// export gametype ; starting begin if multiplayer then
   0: LD_OWVAR 4
   4: IFFALSE 18
// gametype = mp_game_type else
   6: LD_ADDR_EXP 1
  10: PUSH
  11: LD_OWVAR 6
  15: ST_TO_ADDR
  16: GO 26
// gametype = 25 ;
  18: LD_ADDR_EXP 1
  22: PUSH
  23: LD_INT 25
  25: ST_TO_ADDR
// case gametype of 15 :
  26: LD_EXP 1
  30: PUSH
  31: LD_INT 15
  33: DOUBLE
  34: EQUAL
  35: IFTRUE 39
  37: GO 55
  39: POP
// begin enable ( 15 ) ;
  40: LD_INT 15
  42: ENABLE_MARKED
// disable ( 25 ) ;
  43: LD_INT 25
  45: DISABLE_MARKED
// disable ( 35 ) ;
  46: LD_INT 35
  48: DISABLE_MARKED
// starting_sheherezad ;
  49: CALL 3956 0 0
// end ; 25 :
  53: GO 110
  55: LD_INT 25
  57: DOUBLE
  58: EQUAL
  59: IFTRUE 63
  61: GO 79
  63: POP
// begin enable ( 25 ) ;
  64: LD_INT 25
  66: ENABLE_MARKED
// disable ( 15 ) ;
  67: LD_INT 15
  69: DISABLE_MARKED
// disable ( 35 ) ;
  70: LD_INT 35
  72: DISABLE_MARKED
// starting_vehicles ;
  73: CALL 7333 0 0
// end ; 35 , 36 :
  77: GO 110
  79: LD_INT 35
  81: DOUBLE
  82: EQUAL
  83: IFTRUE 93
  85: LD_INT 36
  87: DOUBLE
  88: EQUAL
  89: IFTRUE 93
  91: GO 109
  93: POP
// begin enable ( 35 ) ;
  94: LD_INT 35
  96: ENABLE_MARKED
// disable ( 15 ) ;
  97: LD_INT 15
  99: DISABLE_MARKED
// disable ( 25 ) ;
 100: LD_INT 25
 102: DISABLE_MARKED
// starting_hunt ;
 103: CALL 12363 0 0
// end ; end ;
 107: GO 110
 109: POP
// end ; end_of_file
 110: END
// export def_sheherezade_speed , def_sheherezade_stamina , def_sheherezade_skills , def_number_of_sheikhs , def_sheikhs_level , def_number_of_soldiers , def_soldiers_level , def_charges_allowed , def_amount_of_apemen , def_apemen_level , def_apemen_abilities , def_number_of_mastodons , def_number_of_tigers , def_time_to_prepare , def_flags ; export shzd_speed , shzd_stamina , shzd_skills , nsh , sh_skills , nsol , sol_skills , nstart_ape , ape_respawning , ape_skills , nmast1 , nmast2 , nmast3 , ntig , tig_respawning , prep_time , flags ; export coordinates , sheherezades , lastunit ; export Side_Count , Team_Count , Player_Side , Player_Team , Side_Teams , Teams ; export Side_Positions , Side_Nations , Side_Names , Team_Names , Team_Game ; function read_multiplayer_and_game_parameters ; var i ; begin
 111: LD_INT 0
 113: PPUSH
 114: PPUSH
// if MultiPlayer then
 115: LD_OWVAR 4
 119: IFFALSE 183
// begin Player_Side = mp_player_side ;
 121: LD_ADDR_EXP 39
 125: PUSH
 126: LD_OWVAR 7
 130: ST_TO_ADDR
// Player_Team = mp_player_team ;
 131: LD_ADDR_EXP 40
 135: PUSH
 136: LD_OWVAR 8
 140: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
 141: LD_ADDR_EXP 43
 145: PUSH
 146: LD_OWVAR 17
 150: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
 151: LD_ADDR_EXP 41
 155: PUSH
 156: LD_OWVAR 15
 160: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
 161: LD_ADDR_EXP 44
 165: PUSH
 166: LD_OWVAR 16
 170: ST_TO_ADDR
// Teams = mp_teams ;
 171: LD_ADDR_EXP 42
 175: PUSH
 176: LD_OWVAR 12
 180: ST_TO_ADDR
// end else
 181: GO 323
// begin Player_Side = 1 ;
 183: LD_ADDR_EXP 39
 187: PUSH
 188: LD_INT 1
 190: ST_TO_ADDR
// Player_Team = 0 ;
 191: LD_ADDR_EXP 40
 195: PUSH
 196: LD_INT 0
 198: ST_TO_ADDR
// Side_Positions = [ 1 , 2 , 3 , 4 , 5 , 0 , 0 , 0 ] ;
 199: LD_ADDR_EXP 43
 203: PUSH
 204: LD_INT 1
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 4
 215: PUSH
 216: LD_INT 5
 218: PUSH
 219: LD_INT 0
 221: PUSH
 222: LD_INT 0
 224: PUSH
 225: LD_INT 0
 227: PUSH
 228: EMPTY
 229: LIST
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 238: LD_ADDR_EXP 41
 242: PUSH
 243: LD_INT 0
 245: PUSH
 246: LD_INT 0
 248: PUSH
 249: LD_INT 0
 251: PUSH
 252: LD_INT 0
 254: PUSH
 255: LD_INT 0
 257: PUSH
 258: LD_INT 0
 260: PUSH
 261: LD_INT 0
 263: PUSH
 264: LD_INT 0
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// Side_Nations = [ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ] ;
 277: LD_ADDR_EXP 44
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 2
 287: PUSH
 288: LD_INT 2
 290: PUSH
 291: LD_INT 2
 293: PUSH
 294: LD_INT 2
 296: PUSH
 297: LD_INT 2
 299: PUSH
 300: LD_INT 2
 302: PUSH
 303: LD_INT 2
 305: PUSH
 306: EMPTY
 307: LIST
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: LIST
 313: LIST
 314: LIST
 315: ST_TO_ADDR
// Teams = [ ] ;
 316: LD_ADDR_EXP 42
 320: PUSH
 321: EMPTY
 322: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
 323: LD_ADDR_EXP 37
 327: PUSH
 328: LD_EXP 43
 332: PUSH
 333: LD_INT 0
 335: PUSH
 336: EMPTY
 337: LIST
 338: DIFF
 339: PUSH
 340: LD_INT 0
 342: PLUS
 343: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
 344: LD_ADDR_EXP 38
 348: PUSH
 349: LD_EXP 41
 353: PUSH
 354: LD_INT 0
 356: PUSH
 357: EMPTY
 358: LIST
 359: DIFF
 360: PUSH
 361: LD_INT 0
 363: PLUS
 364: ST_TO_ADDR
// if MultiPlayer then
 365: LD_OWVAR 4
 369: IFFALSE 568
// begin def_sheherezade_speed = GetMultiplayerSetting ( 0 ) ;
 371: LD_ADDR_EXP 2
 375: PUSH
 376: LD_INT 0
 378: PPUSH
 379: CALL_OW 426
 383: ST_TO_ADDR
// def_sheherezade_stamina = GetMultiplayerSetting ( 1 ) ;
 384: LD_ADDR_EXP 3
 388: PUSH
 389: LD_INT 1
 391: PPUSH
 392: CALL_OW 426
 396: ST_TO_ADDR
// def_sheherezade_skills = GetMultiplayerSetting ( 2 ) ;
 397: LD_ADDR_EXP 4
 401: PUSH
 402: LD_INT 2
 404: PPUSH
 405: CALL_OW 426
 409: ST_TO_ADDR
// def_number_of_sheikhs = GetMultiplayerSetting ( 3 ) ;
 410: LD_ADDR_EXP 5
 414: PUSH
 415: LD_INT 3
 417: PPUSH
 418: CALL_OW 426
 422: ST_TO_ADDR
// def_sheikhs_level = GetMultiplayerSetting ( 4 ) ;
 423: LD_ADDR_EXP 6
 427: PUSH
 428: LD_INT 4
 430: PPUSH
 431: CALL_OW 426
 435: ST_TO_ADDR
// def_number_of_soldiers = GetMultiplayerSetting ( 5 ) ;
 436: LD_ADDR_EXP 7
 440: PUSH
 441: LD_INT 5
 443: PPUSH
 444: CALL_OW 426
 448: ST_TO_ADDR
// def_soldiers_level = GetMultiplayerSetting ( 6 ) ;
 449: LD_ADDR_EXP 8
 453: PUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 426
 461: ST_TO_ADDR
// def_charges_allowed = GetMultiplayerSetting ( 7 ) ;
 462: LD_ADDR_EXP 9
 466: PUSH
 467: LD_INT 7
 469: PPUSH
 470: CALL_OW 426
 474: ST_TO_ADDR
// def_amount_of_apemen = GetMultiplayerSetting ( 8 ) ;
 475: LD_ADDR_EXP 10
 479: PUSH
 480: LD_INT 8
 482: PPUSH
 483: CALL_OW 426
 487: ST_TO_ADDR
// def_apemen_level = GetMultiplayerSetting ( 9 ) ;
 488: LD_ADDR_EXP 11
 492: PUSH
 493: LD_INT 9
 495: PPUSH
 496: CALL_OW 426
 500: ST_TO_ADDR
// def_apemen_abilities = GetMultiplayerSetting ( 10 ) ;
 501: LD_ADDR_EXP 12
 505: PUSH
 506: LD_INT 10
 508: PPUSH
 509: CALL_OW 426
 513: ST_TO_ADDR
// def_number_of_mastodons = GetMultiplayerSetting ( 11 ) ;
 514: LD_ADDR_EXP 13
 518: PUSH
 519: LD_INT 11
 521: PPUSH
 522: CALL_OW 426
 526: ST_TO_ADDR
// def_number_of_tigers = GetMultiplayerSetting ( 12 ) ;
 527: LD_ADDR_EXP 14
 531: PUSH
 532: LD_INT 12
 534: PPUSH
 535: CALL_OW 426
 539: ST_TO_ADDR
// def_time_to_prepare = GetMultiplayerSetting ( 13 ) ;
 540: LD_ADDR_EXP 15
 544: PUSH
 545: LD_INT 13
 547: PPUSH
 548: CALL_OW 426
 552: ST_TO_ADDR
// def_flags = GetMultiplayerSetting ( 14 ) ;
 553: LD_ADDR_EXP 16
 557: PUSH
 558: LD_INT 14
 560: PPUSH
 561: CALL_OW 426
 565: ST_TO_ADDR
// end else
 566: GO 696
// begin randomize ;
 568: CALL_OW 10
// randomizeAll ;
 572: CALL_OW 11
// def_sheherezade_speed = 1 ;
 576: LD_ADDR_EXP 2
 580: PUSH
 581: LD_INT 1
 583: ST_TO_ADDR
// def_sheherezade_stamina = 1 ;
 584: LD_ADDR_EXP 3
 588: PUSH
 589: LD_INT 1
 591: ST_TO_ADDR
// def_sheherezade_skills = 2 ;
 592: LD_ADDR_EXP 4
 596: PUSH
 597: LD_INT 2
 599: ST_TO_ADDR
// def_number_of_sheikhs = 3 ;
 600: LD_ADDR_EXP 5
 604: PUSH
 605: LD_INT 3
 607: ST_TO_ADDR
// def_sheikhs_level = 2 ;
 608: LD_ADDR_EXP 6
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// def_number_of_soldiers = 3 ;
 616: LD_ADDR_EXP 7
 620: PUSH
 621: LD_INT 3
 623: ST_TO_ADDR
// def_soldiers_level = 1 ;
 624: LD_ADDR_EXP 8
 628: PUSH
 629: LD_INT 1
 631: ST_TO_ADDR
// def_charges_allowed = 3 ;
 632: LD_ADDR_EXP 9
 636: PUSH
 637: LD_INT 3
 639: ST_TO_ADDR
// def_amount_of_apemen = 2 ;
 640: LD_ADDR_EXP 10
 644: PUSH
 645: LD_INT 2
 647: ST_TO_ADDR
// def_apemen_level = 1 ;
 648: LD_ADDR_EXP 11
 652: PUSH
 653: LD_INT 1
 655: ST_TO_ADDR
// def_apemen_abilities = 1 ;
 656: LD_ADDR_EXP 12
 660: PUSH
 661: LD_INT 1
 663: ST_TO_ADDR
// def_number_of_mastodons = 2 ;
 664: LD_ADDR_EXP 13
 668: PUSH
 669: LD_INT 2
 671: ST_TO_ADDR
// def_number_of_tigers = 2 ;
 672: LD_ADDR_EXP 14
 676: PUSH
 677: LD_INT 2
 679: ST_TO_ADDR
// def_time_to_prepare = 2 ;
 680: LD_ADDR_EXP 15
 684: PUSH
 685: LD_INT 2
 687: ST_TO_ADDR
// def_flags = 2 ;
 688: LD_ADDR_EXP 16
 692: PUSH
 693: LD_INT 2
 695: ST_TO_ADDR
// end ; shzd_speed = [ 9 , 12 , 15 ] [ def_sheherezade_speed + 1 ] ;
 696: LD_ADDR_EXP 17
 700: PUSH
 701: LD_INT 9
 703: PUSH
 704: LD_INT 12
 706: PUSH
 707: LD_INT 15
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_EXP 2
 719: PUSH
 720: LD_INT 1
 722: PLUS
 723: ARRAY
 724: ST_TO_ADDR
// shzd_stamina = [ 6 , 10 , 15 ] [ def_sheherezade_stamina + 1 ] ;
 725: LD_ADDR_EXP 18
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 10
 735: PUSH
 736: LD_INT 15
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: PUSH
 744: LD_EXP 3
 748: PUSH
 749: LD_INT 1
 751: PLUS
 752: ARRAY
 753: ST_TO_ADDR
// shzd_skills = [ [ 1 , 0 , 0 , 3 ] , [ 2 , 0 , 0 , 5 ] , [ 3 , 0 , 0 , 7 ] ] [ def_sheherezade_skills + 1 ] ;
 754: LD_ADDR_EXP 19
 758: PUSH
 759: LD_INT 1
 761: PUSH
 762: LD_INT 0
 764: PUSH
 765: LD_INT 0
 767: PUSH
 768: LD_INT 3
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 2
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: LD_INT 5
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 0
 800: PUSH
 801: LD_INT 0
 803: PUSH
 804: LD_INT 7
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: LIST
 817: PUSH
 818: LD_EXP 4
 822: PUSH
 823: LD_INT 1
 825: PLUS
 826: ARRAY
 827: ST_TO_ADDR
// nsh = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_sheikhs + 1 ] ;
 828: LD_ADDR_EXP 20
 832: PUSH
 833: LD_INT 0
 835: PUSH
 836: LD_INT 1
 838: PUSH
 839: LD_INT 2
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 4
 847: PUSH
 848: LD_INT 5
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PUSH
 859: LD_EXP 5
 863: PUSH
 864: LD_INT 1
 866: PLUS
 867: ARRAY
 868: ST_TO_ADDR
// sh_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_sheikhs_level + 1 ] ;
 869: LD_ADDR_EXP 21
 873: PUSH
 874: LD_INT 2
 876: PUSH
 877: LD_INT 1
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 1
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: PUSH
 892: LD_INT 4
 894: PUSH
 895: LD_INT 2
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 2
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: PUSH
 910: LD_INT 6
 912: PUSH
 913: LD_INT 3
 915: PUSH
 916: LD_INT 3
 918: PUSH
 919: LD_INT 3
 921: PUSH
 922: EMPTY
 923: LIST
 924: LIST
 925: LIST
 926: LIST
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: LD_EXP 6
 937: PUSH
 938: LD_INT 1
 940: PLUS
 941: ARRAY
 942: ST_TO_ADDR
// nsol = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_soldiers + 1 ] ;
 943: LD_ADDR_EXP 22
 947: PUSH
 948: LD_INT 0
 950: PUSH
 951: LD_INT 1
 953: PUSH
 954: LD_INT 2
 956: PUSH
 957: LD_INT 3
 959: PUSH
 960: LD_INT 4
 962: PUSH
 963: LD_INT 5
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: LIST
 973: PUSH
 974: LD_EXP 7
 978: PUSH
 979: LD_INT 1
 981: PLUS
 982: ARRAY
 983: ST_TO_ADDR
// sol_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_soldiers_level + 1 ] ;
 984: LD_ADDR_EXP 23
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: LD_INT 1
 994: PUSH
 995: LD_INT 1
 997: PUSH
 998: LD_INT 1
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: LIST
1005: LIST
1006: PUSH
1007: LD_INT 4
1009: PUSH
1010: LD_INT 2
1012: PUSH
1013: LD_INT 2
1015: PUSH
1016: LD_INT 2
1018: PUSH
1019: EMPTY
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: PUSH
1025: LD_INT 6
1027: PUSH
1028: LD_INT 3
1030: PUSH
1031: LD_INT 3
1033: PUSH
1034: LD_INT 3
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PUSH
1043: EMPTY
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: LD_EXP 8
1052: PUSH
1053: LD_INT 1
1055: PLUS
1056: ARRAY
1057: ST_TO_ADDR
// nstart_ape = [ 0 , 2 , 4 , 6 , 8 ] [ def_amount_of_apemen + 1 ] ;
1058: LD_ADDR_EXP 24
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 4
1071: PUSH
1072: LD_INT 6
1074: PUSH
1075: LD_INT 8
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PUSH
1085: LD_EXP 10
1089: PUSH
1090: LD_INT 1
1092: PLUS
1093: ARRAY
1094: ST_TO_ADDR
// ape_respawning = [ 0 , 4 4$00 , 2 2$00 , 1 1$00 , 0 0$30 ] [ def_amount_of_apemen + 1 ] ;
1095: LD_ADDR_EXP 25
1099: PUSH
1100: LD_INT 0
1102: PUSH
1103: LD_INT 8400
1105: PUSH
1106: LD_INT 4200
1108: PUSH
1109: LD_INT 2100
1111: PUSH
1112: LD_INT 1050
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_EXP 10
1126: PUSH
1127: LD_INT 1
1129: PLUS
1130: ARRAY
1131: ST_TO_ADDR
// ape_skills = [ [ 1 , 0 , 0 , 0 ] , [ 3 , 0 , 0 , 0 ] , [ 5 , 0 , 0 , 0 ] ] [ def_apemen_level + 1 ] ;
1132: LD_ADDR_EXP 26
1136: PUSH
1137: LD_INT 1
1139: PUSH
1140: LD_INT 0
1142: PUSH
1143: LD_INT 0
1145: PUSH
1146: LD_INT 0
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 0
1160: PUSH
1161: LD_INT 0
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 0
1178: PUSH
1179: LD_INT 0
1181: PUSH
1182: LD_INT 0
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: LIST
1195: PUSH
1196: LD_EXP 11
1200: PUSH
1201: LD_INT 1
1203: PLUS
1204: ARRAY
1205: ST_TO_ADDR
// nmast1 = [ 0 , 2 , 4 , 6 ] [ def_number_of_mastodons + 1 ] ;
1206: LD_ADDR_EXP 27
1210: PUSH
1211: LD_INT 0
1213: PUSH
1214: LD_INT 2
1216: PUSH
1217: LD_INT 4
1219: PUSH
1220: LD_INT 6
1222: PUSH
1223: EMPTY
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: PUSH
1229: LD_EXP 13
1233: PUSH
1234: LD_INT 1
1236: PLUS
1237: ARRAY
1238: ST_TO_ADDR
// nmast2 = [ 0 , 1 , 2 , 3 ] [ def_number_of_mastodons + 1 ] ;
1239: LD_ADDR_EXP 28
1243: PUSH
1244: LD_INT 0
1246: PUSH
1247: LD_INT 1
1249: PUSH
1250: LD_INT 2
1252: PUSH
1253: LD_INT 3
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: PUSH
1262: LD_EXP 13
1266: PUSH
1267: LD_INT 1
1269: PLUS
1270: ARRAY
1271: ST_TO_ADDR
// nmast3 = [ 0 , 15 , 30 , 45 ] [ def_number_of_mastodons + 1 ] ;
1272: LD_ADDR_EXP 29
1276: PUSH
1277: LD_INT 0
1279: PUSH
1280: LD_INT 15
1282: PUSH
1283: LD_INT 30
1285: PUSH
1286: LD_INT 45
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_EXP 13
1299: PUSH
1300: LD_INT 1
1302: PLUS
1303: ARRAY
1304: ST_TO_ADDR
// ntig = [ 0 , 1 , 3 , 5 ] [ def_number_of_tigers + 1 ] ;
1305: LD_ADDR_EXP 30
1309: PUSH
1310: LD_INT 0
1312: PUSH
1313: LD_INT 1
1315: PUSH
1316: LD_INT 3
1318: PUSH
1319: LD_INT 5
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: PUSH
1328: LD_EXP 14
1332: PUSH
1333: LD_INT 1
1335: PLUS
1336: ARRAY
1337: ST_TO_ADDR
// tig_respawning = [ 0 , 8 8$00 , 4 4$00 , 2 2$00 ] [ def_number_of_tigers + 1 ] ;
1338: LD_ADDR_EXP 31
1342: PUSH
1343: LD_INT 0
1345: PUSH
1346: LD_INT 16800
1348: PUSH
1349: LD_INT 8400
1351: PUSH
1352: LD_INT 4200
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: PUSH
1361: LD_EXP 14
1365: PUSH
1366: LD_INT 1
1368: PLUS
1369: ARRAY
1370: ST_TO_ADDR
// prep_time = [ 0 , 0 0$20 , 0 0$40 , 1 1$20 ] [ def_time_to_prepare + 1 ] ;
1371: LD_ADDR_EXP 32
1375: PUSH
1376: LD_INT 0
1378: PUSH
1379: LD_INT 700
1381: PUSH
1382: LD_INT 1400
1384: PUSH
1385: LD_INT 2800
1387: PUSH
1388: EMPTY
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: PUSH
1394: LD_EXP 15
1398: PUSH
1399: LD_INT 1
1401: PLUS
1402: ARRAY
1403: ST_TO_ADDR
// flags = [ 0 , 25 , 50 , 75 ] [ def_flags + 1 ] ;
1404: LD_ADDR_EXP 33
1408: PUSH
1409: LD_INT 0
1411: PUSH
1412: LD_INT 25
1414: PUSH
1415: LD_INT 50
1417: PUSH
1418: LD_INT 75
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: PUSH
1427: LD_EXP 16
1431: PUSH
1432: LD_INT 1
1434: PLUS
1435: ARRAY
1436: ST_TO_ADDR
// if def_charges_allowed in [ 1 , 3 ] then
1437: LD_EXP 9
1441: PUSH
1442: LD_INT 1
1444: PUSH
1445: LD_INT 3
1447: PUSH
1448: EMPTY
1449: LIST
1450: LIST
1451: IN
1452: IFFALSE 1489
// for i := 1 to 8 do
1454: LD_ADDR_VAR 0 2
1458: PUSH
1459: DOUBLE
1460: LD_INT 1
1462: DEC
1463: ST_TO_ADDR
1464: LD_INT 8
1466: PUSH
1467: FOR_TO
1468: IFFALSE 1487
// SetTech ( tech_RemCharge , i , state_researched ) ;
1470: LD_INT 18
1472: PPUSH
1473: LD_VAR 0 2
1477: PPUSH
1478: LD_INT 2
1480: PPUSH
1481: CALL_OW 322
1485: GO 1467
1487: POP
1488: POP
// if def_charges_allowed in [ 1 , 3 ] then
1489: LD_EXP 9
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 3
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: IN
1504: IFFALSE 1541
// for i := 1 to 8 do
1506: LD_ADDR_VAR 0 2
1510: PUSH
1511: DOUBLE
1512: LD_INT 1
1514: DEC
1515: ST_TO_ADDR
1516: LD_INT 8
1518: PUSH
1519: FOR_TO
1520: IFFALSE 1539
// SetTech ( tech_Explos , i , state_researched ) ;
1522: LD_INT 42
1524: PPUSH
1525: LD_VAR 0 2
1529: PPUSH
1530: LD_INT 2
1532: PPUSH
1533: CALL_OW 322
1537: GO 1519
1539: POP
1540: POP
// for i := 1 to 8 do
1541: LD_ADDR_VAR 0 2
1545: PUSH
1546: DOUBLE
1547: LD_INT 1
1549: DEC
1550: ST_TO_ADDR
1551: LD_INT 8
1553: PUSH
1554: FOR_TO
1555: IFFALSE 1589
// begin SetTech ( tech_ApeLang , i , state_disabled ) ;
1557: LD_INT 1
1559: PPUSH
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 0
1567: PPUSH
1568: CALL_OW 322
// SetTech ( tech_SibContam , i , state_disabled ) ;
1572: LD_INT 26
1574: PPUSH
1575: LD_VAR 0 2
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL_OW 322
// end ;
1587: GO 1554
1589: POP
1590: POP
// end ;
1591: LD_VAR 0 1
1595: RET
// function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
1596: LD_INT 0
1598: PPUSH
1599: PPUSH
1600: PPUSH
1601: PPUSH
1602: PPUSH
1603: PPUSH
1604: PPUSH
1605: PPUSH
// best = 0 ;
1606: LD_ADDR_VAR 0 2
1610: PUSH
1611: LD_INT 0
1613: ST_TO_ADDR
// for n = 1 to 400 do
1614: LD_ADDR_VAR 0 8
1618: PUSH
1619: DOUBLE
1620: LD_INT 1
1622: DEC
1623: ST_TO_ADDR
1624: LD_INT 400
1626: PUSH
1627: FOR_TO
1628: IFFALSE 1924
// begin c = [ ] ;
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: EMPTY
1636: ST_TO_ADDR
// for i = 1 to side_count do
1637: LD_ADDR_VAR 0 6
1641: PUSH
1642: DOUBLE
1643: LD_INT 1
1645: DEC
1646: ST_TO_ADDR
1647: LD_EXP 37
1651: PUSH
1652: FOR_TO
1653: IFFALSE 1682
// c := c ^ [ RandHexArea ( arstart , false ) ] ;
1655: LD_ADDR_VAR 0 3
1659: PUSH
1660: LD_VAR 0 3
1664: PUSH
1665: LD_INT 7
1667: PPUSH
1668: LD_INT 0
1670: PPUSH
1671: CALL_OW 16
1675: PUSH
1676: EMPTY
1677: LIST
1678: ADD
1679: ST_TO_ADDR
1680: GO 1652
1682: POP
1683: POP
// minv = 10000 ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_INT 10000
1691: ST_TO_ADDR
// for i = 1 to side_count do
1692: LD_ADDR_VAR 0 6
1696: PUSH
1697: DOUBLE
1698: LD_INT 1
1700: DEC
1701: ST_TO_ADDR
1702: LD_EXP 37
1706: PUSH
1707: FOR_TO
1708: IFFALSE 1888
// for j = 1 to side_count do
1710: LD_ADDR_VAR 0 7
1714: PUSH
1715: DOUBLE
1716: LD_INT 1
1718: DEC
1719: ST_TO_ADDR
1720: LD_EXP 37
1724: PUSH
1725: FOR_TO
1726: IFFALSE 1884
// if i <> j then
1728: LD_VAR 0 6
1732: PUSH
1733: LD_VAR 0 7
1737: NONEQUAL
1738: IFFALSE 1882
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
1740: LD_VAR 0 3
1744: PUSH
1745: LD_VAR 0 6
1749: ARRAY
1750: PUSH
1751: LD_INT 1
1753: ARRAY
1754: PPUSH
1755: LD_VAR 0 3
1759: PUSH
1760: LD_VAR 0 6
1764: ARRAY
1765: PUSH
1766: LD_INT 2
1768: ARRAY
1769: PPUSH
1770: LD_VAR 0 3
1774: PUSH
1775: LD_VAR 0 7
1779: ARRAY
1780: PUSH
1781: LD_INT 1
1783: ARRAY
1784: PPUSH
1785: LD_VAR 0 3
1789: PUSH
1790: LD_VAR 0 7
1794: ARRAY
1795: PUSH
1796: LD_INT 2
1798: ARRAY
1799: PPUSH
1800: CALL_OW 298
1804: PUSH
1805: LD_VAR 0 5
1809: LESS
1810: IFFALSE 1882
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
1812: LD_ADDR_VAR 0 5
1816: PUSH
1817: LD_VAR 0 3
1821: PUSH
1822: LD_VAR 0 6
1826: ARRAY
1827: PUSH
1828: LD_INT 1
1830: ARRAY
1831: PPUSH
1832: LD_VAR 0 3
1836: PUSH
1837: LD_VAR 0 6
1841: ARRAY
1842: PUSH
1843: LD_INT 2
1845: ARRAY
1846: PPUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_VAR 0 7
1856: ARRAY
1857: PUSH
1858: LD_INT 1
1860: ARRAY
1861: PPUSH
1862: LD_VAR 0 3
1866: PUSH
1867: LD_VAR 0 7
1871: ARRAY
1872: PUSH
1873: LD_INT 2
1875: ARRAY
1876: PPUSH
1877: CALL_OW 298
1881: ST_TO_ADDR
// end ;
1882: GO 1725
1884: POP
1885: POP
1886: GO 1707
1888: POP
1889: POP
// if minv > best then
1890: LD_VAR 0 5
1894: PUSH
1895: LD_VAR 0 2
1899: GREATER
1900: IFFALSE 1922
// begin best := minv ;
1902: LD_ADDR_VAR 0 2
1906: PUSH
1907: LD_VAR 0 5
1911: ST_TO_ADDR
// bestc := c ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 3
1921: ST_TO_ADDR
// end ; end ;
1922: GO 1627
1924: POP
1925: POP
// coordinates := [ ] ;
1926: LD_ADDR_EXP 34
1930: PUSH
1931: EMPTY
1932: ST_TO_ADDR
// for i = 1 to 8 do
1933: LD_ADDR_VAR 0 6
1937: PUSH
1938: DOUBLE
1939: LD_INT 1
1941: DEC
1942: ST_TO_ADDR
1943: LD_INT 8
1945: PUSH
1946: FOR_TO
1947: IFFALSE 2034
// if side_positions [ i ] = 0 then
1949: LD_EXP 43
1953: PUSH
1954: LD_VAR 0 6
1958: ARRAY
1959: PUSH
1960: LD_INT 0
1962: EQUAL
1963: IFFALSE 1991
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
1965: LD_ADDR_EXP 34
1969: PUSH
1970: LD_EXP 34
1974: PUSH
1975: LD_INT 0
1977: PUSH
1978: LD_INT 0
1980: PUSH
1981: EMPTY
1982: LIST
1983: LIST
1984: PUSH
1985: EMPTY
1986: LIST
1987: ADD
1988: ST_TO_ADDR
1989: GO 2032
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
1991: LD_ADDR_EXP 34
1995: PUSH
1996: LD_EXP 34
2000: PUSH
2001: LD_VAR 0 4
2005: PUSH
2006: LD_INT 1
2008: ARRAY
2009: PUSH
2010: EMPTY
2011: LIST
2012: ADD
2013: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
2014: LD_ADDR_VAR 0 4
2018: PUSH
2019: LD_VAR 0 4
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: CALL_OW 3
2031: ST_TO_ADDR
// end ;
2032: GO 1946
2034: POP
2035: POP
// end ;
2036: LD_VAR 0 1
2040: RET
// function set_attitudes ; var i , j ; begin
2041: LD_INT 0
2043: PPUSH
2044: PPUSH
2045: PPUSH
// if not Team_Game then
2046: LD_EXP 47
2050: NOT
2051: IFFALSE 2147
// begin for i = 1 to 8 do
2053: LD_ADDR_VAR 0 2
2057: PUSH
2058: DOUBLE
2059: LD_INT 1
2061: DEC
2062: ST_TO_ADDR
2063: LD_INT 8
2065: PUSH
2066: FOR_TO
2067: IFFALSE 2145
// for j = 1 to 8 do
2069: LD_ADDR_VAR 0 3
2073: PUSH
2074: DOUBLE
2075: LD_INT 1
2077: DEC
2078: ST_TO_ADDR
2079: LD_INT 8
2081: PUSH
2082: FOR_TO
2083: IFFALSE 2141
// if i <> j then
2085: LD_VAR 0 2
2089: PUSH
2090: LD_VAR 0 3
2094: NONEQUAL
2095: IFFALSE 2119
// SetAttitude ( i , j , att_neutral , true ) else
2097: LD_VAR 0 2
2101: PPUSH
2102: LD_VAR 0 3
2106: PPUSH
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: CALL_OW 80
2117: GO 2139
// SetAttitude ( i , j , att_friend , true ) end ;
2119: LD_VAR 0 2
2123: PPUSH
2124: LD_VAR 0 3
2128: PPUSH
2129: LD_INT 1
2131: PPUSH
2132: LD_INT 1
2134: PPUSH
2135: CALL_OW 80
2139: GO 2082
2141: POP
2142: POP
2143: GO 2066
2145: POP
2146: POP
// end ;
2147: LD_VAR 0 1
2151: RET
// function create_sheherezade ( side ) ; var s ; begin
2152: LD_INT 0
2154: PPUSH
2155: PPUSH
// uc_side := side ;
2156: LD_ADDR_OWVAR 20
2160: PUSH
2161: LD_VAR 0 1
2165: ST_TO_ADDR
// uc_nation := nation_arabian ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 2
2173: ST_TO_ADDR
// hc_name = Sheherezade ;
2174: LD_ADDR_OWVAR 26
2178: PUSH
2179: LD_STRING Sheherezade
2181: ST_TO_ADDR
// hc_sex = sex_female ;
2182: LD_ADDR_OWVAR 27
2186: PUSH
2187: LD_INT 2
2189: ST_TO_ADDR
// hc_class = class_scientistic ;
2190: LD_ADDR_OWVAR 28
2194: PUSH
2195: LD_INT 4
2197: ST_TO_ADDR
// hc_basic_skills = shzd_skills ;
2198: LD_ADDR_OWVAR 30
2202: PUSH
2203: LD_EXP 19
2207: ST_TO_ADDR
// hc_skills = shzd_skills ;
2208: LD_ADDR_OWVAR 31
2212: PUSH
2213: LD_EXP 19
2217: ST_TO_ADDR
// hc_attr = [ shzd_stamina , shzd_speed ] ;
2218: LD_ADDR_OWVAR 29
2222: PUSH
2223: LD_EXP 18
2227: PUSH
2228: LD_EXP 17
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: ST_TO_ADDR
// hc_gallery = multi ;
2237: LD_ADDR_OWVAR 33
2241: PUSH
2242: LD_STRING multi
2244: ST_TO_ADDR
// hc_face_number = 18 ;
2245: LD_ADDR_OWVAR 34
2249: PUSH
2250: LD_INT 18
2252: ST_TO_ADDR
// hc_importance = 105 ;
2253: LD_ADDR_OWVAR 32
2257: PUSH
2258: LD_INT 105
2260: ST_TO_ADDR
// s = CreateHuman ;
2261: LD_ADDR_VAR 0 3
2265: PUSH
2266: CALL_OW 44
2270: ST_TO_ADDR
// PlaceUnitXYR ( s , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 1 , false ) ;
2271: LD_VAR 0 3
2275: PPUSH
2276: LD_EXP 34
2280: PUSH
2281: LD_VAR 0 1
2285: ARRAY
2286: PUSH
2287: LD_INT 1
2289: ARRAY
2290: PPUSH
2291: LD_EXP 34
2295: PUSH
2296: LD_VAR 0 1
2300: ARRAY
2301: PUSH
2302: LD_INT 2
2304: ARRAY
2305: PPUSH
2306: LD_INT 1
2308: PPUSH
2309: LD_INT 0
2311: PPUSH
2312: CALL_OW 50
// sheherezades = Replace ( sheherezades , side , s ) ;
2316: LD_ADDR_EXP 35
2320: PUSH
2321: LD_EXP 35
2325: PPUSH
2326: LD_VAR 0 1
2330: PPUSH
2331: LD_VAR 0 3
2335: PPUSH
2336: CALL_OW 1
2340: ST_TO_ADDR
// end ;
2341: LD_VAR 0 2
2345: RET
// function prepare_sides ; var i ; begin
2346: LD_INT 0
2348: PPUSH
2349: PPUSH
// for i := 1 to 8 do
2350: LD_ADDR_VAR 0 2
2354: PUSH
2355: DOUBLE
2356: LD_INT 1
2358: DEC
2359: ST_TO_ADDR
2360: LD_INT 8
2362: PUSH
2363: FOR_TO
2364: IFFALSE 2389
// if side_positions [ i ] then
2366: LD_EXP 43
2370: PUSH
2371: LD_VAR 0 2
2375: ARRAY
2376: IFFALSE 2387
// create_sheherezade ( i ) ;
2378: LD_VAR 0 2
2382: PPUSH
2383: CALL 2152 0 1
2387: GO 2363
2389: POP
2390: POP
// if prep_time = 0 then
2391: LD_EXP 32
2395: PUSH
2396: LD_INT 0
2398: EQUAL
2399: IFFALSE 2405
// sheherezade_start_the_fight ;
2401: CALL 3720 0 0
// end ;
2405: LD_VAR 0 1
2409: RET
// function prepare_side_to_the_fight ( side , materialization ) ; var x , y , i , sh , sol ; begin
2410: LD_INT 0
2412: PPUSH
2413: PPUSH
2414: PPUSH
2415: PPUSH
2416: PPUSH
2417: PPUSH
// SetTech ( tech_ApeLang , side , state_researched ) ;
2418: LD_INT 1
2420: PPUSH
2421: LD_VAR 0 1
2425: PPUSH
2426: LD_INT 2
2428: PPUSH
2429: CALL_OW 322
// x := GetX ( Sheherezades [ side ] ) ;
2433: LD_ADDR_VAR 0 4
2437: PUSH
2438: LD_EXP 35
2442: PUSH
2443: LD_VAR 0 1
2447: ARRAY
2448: PPUSH
2449: CALL_OW 250
2453: ST_TO_ADDR
// y := GetY ( Sheherezades [ side ] ) ;
2454: LD_ADDR_VAR 0 5
2458: PUSH
2459: LD_EXP 35
2463: PUSH
2464: LD_VAR 0 1
2468: ARRAY
2469: PPUSH
2470: CALL_OW 251
2474: ST_TO_ADDR
// coordinates := Replace ( coordinates , side , [ x , y ] ) ;
2475: LD_ADDR_EXP 34
2479: PUSH
2480: LD_EXP 34
2484: PPUSH
2485: LD_VAR 0 1
2489: PPUSH
2490: LD_VAR 0 4
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PPUSH
2504: CALL_OW 1
2508: ST_TO_ADDR
// if flags then
2509: LD_EXP 33
2513: IFFALSE 2592
// begin SetBattleFlag ( side , x , y , [ [ bfo_defend_bonus_human , flags ] , [ bfo_defend_bonus_vehicle , flags ] , [ bfo_defend_bonus_building , flags ] , [ bfo_height , flags + 25 ] ] ) ;
2515: LD_VAR 0 1
2519: PPUSH
2520: LD_VAR 0 4
2524: PPUSH
2525: LD_VAR 0 5
2529: PPUSH
2530: LD_INT 1
2532: PUSH
2533: LD_EXP 33
2537: PUSH
2538: EMPTY
2539: LIST
2540: LIST
2541: PUSH
2542: LD_INT 2
2544: PUSH
2545: LD_EXP 33
2549: PUSH
2550: EMPTY
2551: LIST
2552: LIST
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: LD_EXP 33
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: PUSH
2566: LD_INT 20
2568: PUSH
2569: LD_EXP 33
2573: PUSH
2574: LD_INT 25
2576: PLUS
2577: PUSH
2578: EMPTY
2579: LIST
2580: LIST
2581: PUSH
2582: EMPTY
2583: LIST
2584: LIST
2585: LIST
2586: LIST
2587: PPUSH
2588: CALL_OW 418
// end ; uc_side := side ;
2592: LD_ADDR_OWVAR 20
2596: PUSH
2597: LD_VAR 0 1
2601: ST_TO_ADDR
// uc_nation := nation_arabian ;
2602: LD_ADDR_OWVAR 21
2606: PUSH
2607: LD_INT 2
2609: ST_TO_ADDR
// hc_name :=  ;
2610: LD_ADDR_OWVAR 26
2614: PUSH
2615: LD_STRING 
2617: ST_TO_ADDR
// hc_class := class_desert_warior ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 11
2625: ST_TO_ADDR
// hc_sex := sex_male ;
2626: LD_ADDR_OWVAR 27
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_basic_skills := sh_skills ;
2634: LD_ADDR_OWVAR 30
2638: PUSH
2639: LD_EXP 21
2643: ST_TO_ADDR
// hc_skills := sh_skills ;
2644: LD_ADDR_OWVAR 31
2648: PUSH
2649: LD_EXP 21
2653: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2654: LD_ADDR_OWVAR 29
2658: PUSH
2659: LD_INT 10
2661: PUSH
2662: LD_INT 10
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: ST_TO_ADDR
// hc_importance := 0 ;
2669: LD_ADDR_OWVAR 32
2673: PUSH
2674: LD_INT 0
2676: ST_TO_ADDR
// hc_gallery :=  ;
2677: LD_ADDR_OWVAR 33
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// for i := 1 to nsol do
2685: LD_ADDR_VAR 0 6
2689: PUSH
2690: DOUBLE
2691: LD_INT 1
2693: DEC
2694: ST_TO_ADDR
2695: LD_EXP 22
2699: PUSH
2700: FOR_TO
2701: IFFALSE 2742
// begin sh := CreateHuman ;
2703: LD_ADDR_VAR 0 7
2707: PUSH
2708: CALL_OW 44
2712: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2713: LD_VAR 0 7
2717: PPUSH
2718: LD_VAR 0 4
2722: PPUSH
2723: LD_VAR 0 5
2727: PPUSH
2728: LD_INT 5
2730: PPUSH
2731: LD_VAR 0 2
2735: PPUSH
2736: CALL_OW 50
// end ;
2740: GO 2700
2742: POP
2743: POP
// hc_name :=  ;
2744: LD_ADDR_OWVAR 26
2748: PUSH
2749: LD_STRING 
2751: ST_TO_ADDR
// hc_class := class_soldier ;
2752: LD_ADDR_OWVAR 28
2756: PUSH
2757: LD_INT 1
2759: ST_TO_ADDR
// hc_sex := sex_male ;
2760: LD_ADDR_OWVAR 27
2764: PUSH
2765: LD_INT 1
2767: ST_TO_ADDR
// hc_basic_skills := sol_skills ;
2768: LD_ADDR_OWVAR 30
2772: PUSH
2773: LD_EXP 23
2777: ST_TO_ADDR
// hc_skills := sol_skills ;
2778: LD_ADDR_OWVAR 31
2782: PUSH
2783: LD_EXP 23
2787: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2788: LD_ADDR_OWVAR 29
2792: PUSH
2793: LD_INT 10
2795: PUSH
2796: LD_INT 10
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: ST_TO_ADDR
// hc_importance := 0 ;
2803: LD_ADDR_OWVAR 32
2807: PUSH
2808: LD_INT 0
2810: ST_TO_ADDR
// hc_gallery :=  ;
2811: LD_ADDR_OWVAR 33
2815: PUSH
2816: LD_STRING 
2818: ST_TO_ADDR
// for i := 1 to nsh do
2819: LD_ADDR_VAR 0 6
2823: PUSH
2824: DOUBLE
2825: LD_INT 1
2827: DEC
2828: ST_TO_ADDR
2829: LD_EXP 20
2833: PUSH
2834: FOR_TO
2835: IFFALSE 2876
// begin sh := CreateHuman ;
2837: LD_ADDR_VAR 0 7
2841: PUSH
2842: CALL_OW 44
2846: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2847: LD_VAR 0 7
2851: PPUSH
2852: LD_VAR 0 4
2856: PPUSH
2857: LD_VAR 0 5
2861: PPUSH
2862: LD_INT 5
2864: PPUSH
2865: LD_VAR 0 2
2869: PPUSH
2870: CALL_OW 50
// end ;
2874: GO 2834
2876: POP
2877: POP
// end ;
2878: LD_VAR 0 3
2882: RET
// function find_hidden_hex ( ar ) ; var i , j , seen ; begin
2883: LD_INT 0
2885: PPUSH
2886: PPUSH
2887: PPUSH
2888: PPUSH
// for i := 1 to 100 do
2889: LD_ADDR_VAR 0 3
2893: PUSH
2894: DOUBLE
2895: LD_INT 1
2897: DEC
2898: ST_TO_ADDR
2899: LD_INT 100
2901: PUSH
2902: FOR_TO
2903: IFFALSE 3026
// begin repeat result := RandHexArea ( ar , false ) ;
2905: LD_ADDR_VAR 0 2
2909: PUSH
2910: LD_VAR 0 1
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 16
2922: ST_TO_ADDR
// until not HexInfo ( result [ 1 ] , result [ 2 ] ) ;
2923: LD_VAR 0 2
2927: PUSH
2928: LD_INT 1
2930: ARRAY
2931: PPUSH
2932: LD_VAR 0 2
2936: PUSH
2937: LD_INT 2
2939: ARRAY
2940: PPUSH
2941: CALL_OW 428
2945: NOT
2946: IFFALSE 2905
// seen := false ;
2948: LD_ADDR_VAR 0 5
2952: PUSH
2953: LD_INT 0
2955: ST_TO_ADDR
// for j := 1 to 8 do
2956: LD_ADDR_VAR 0 4
2960: PUSH
2961: DOUBLE
2962: LD_INT 1
2964: DEC
2965: ST_TO_ADDR
2966: LD_INT 8
2968: PUSH
2969: FOR_TO
2970: IFFALSE 3011
// if SeeXY ( j , result [ 1 ] , result [ 2 ] ) then
2972: LD_VAR 0 4
2976: PPUSH
2977: LD_VAR 0 2
2981: PUSH
2982: LD_INT 1
2984: ARRAY
2985: PPUSH
2986: LD_VAR 0 2
2990: PUSH
2991: LD_INT 2
2993: ARRAY
2994: PPUSH
2995: CALL_OW 293
2999: IFFALSE 3009
// seen := true ;
3001: LD_ADDR_VAR 0 5
3005: PUSH
3006: LD_INT 1
3008: ST_TO_ADDR
3009: GO 2969
3011: POP
3012: POP
// if not seen then
3013: LD_VAR 0 5
3017: NOT
3018: IFFALSE 3024
// exit ;
3020: POP
3021: POP
3022: GO 3036
// end ;
3024: GO 2902
3026: POP
3027: POP
// result := 0 ;
3028: LD_ADDR_VAR 0 2
3032: PUSH
3033: LD_INT 0
3035: ST_TO_ADDR
// end ;
3036: LD_VAR 0 2
3040: RET
// function create_ape ; var coord , i ; begin
3041: LD_INT 0
3043: PPUSH
3044: PPUSH
3045: PPUSH
// if lastunit >= 1999 then
3046: LD_EXP 36
3050: PUSH
3051: LD_INT 1999
3053: GREATEREQUAL
3054: IFFALSE 3058
// exit ;
3056: GO 3225
// uc_nation := nation_nature ;
3058: LD_ADDR_OWVAR 21
3062: PUSH
3063: LD_INT 0
3065: ST_TO_ADDR
// uc_side := 0 ;
3066: LD_ADDR_OWVAR 20
3070: PUSH
3071: LD_INT 0
3073: ST_TO_ADDR
// hc_name :=  ;
3074: LD_ADDR_OWVAR 26
3078: PUSH
3079: LD_STRING 
3081: ST_TO_ADDR
// hc_class := class_apeman ;
3082: LD_ADDR_OWVAR 28
3086: PUSH
3087: LD_INT 12
3089: ST_TO_ADDR
// hc_sex := 1 ;
3090: LD_ADDR_OWVAR 27
3094: PUSH
3095: LD_INT 1
3097: ST_TO_ADDR
// hc_basic_skills := ape_skills ;
3098: LD_ADDR_OWVAR 30
3102: PUSH
3103: LD_EXP 26
3107: ST_TO_ADDR
// hc_skills := ape_skills ;
3108: LD_ADDR_OWVAR 31
3112: PUSH
3113: LD_EXP 26
3117: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3118: LD_ADDR_OWVAR 29
3122: PUSH
3123: LD_INT 12
3125: PUSH
3126: LD_INT 12
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: ST_TO_ADDR
// hc_importance := 0 ;
3133: LD_ADDR_OWVAR 32
3137: PUSH
3138: LD_INT 0
3140: ST_TO_ADDR
// hc_gallery :=  ;
3141: LD_ADDR_OWVAR 33
3145: PUSH
3146: LD_STRING 
3148: ST_TO_ADDR
// hc_agressivity := Rand ( - 15 , 15 ) ;
3149: LD_ADDR_OWVAR 35
3153: PUSH
3154: LD_INT 15
3156: NEG
3157: PPUSH
3158: LD_INT 15
3160: PPUSH
3161: CALL_OW 12
3165: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3166: LD_ADDR_VAR 0 2
3170: PUSH
3171: LD_INT 7
3173: PPUSH
3174: CALL 2883 0 1
3178: ST_TO_ADDR
// if coord then
3179: LD_VAR 0 2
3183: IFFALSE 3225
// begin lastunit := CreateHuman ;
3185: LD_ADDR_EXP 36
3189: PUSH
3190: CALL_OW 44
3194: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3195: LD_EXP 36
3199: PPUSH
3200: LD_VAR 0 2
3204: PUSH
3205: LD_INT 1
3207: ARRAY
3208: PPUSH
3209: LD_VAR 0 2
3213: PUSH
3214: LD_INT 2
3216: ARRAY
3217: PPUSH
3218: LD_INT 0
3220: PPUSH
3221: CALL_OW 48
// end ; end ;
3225: LD_VAR 0 1
3229: RET
// function prepare_apes ; var i ; begin
3230: LD_INT 0
3232: PPUSH
3233: PPUSH
// for i := 1 to side_count * nstart_ape do
3234: LD_ADDR_VAR 0 2
3238: PUSH
3239: DOUBLE
3240: LD_INT 1
3242: DEC
3243: ST_TO_ADDR
3244: LD_EXP 37
3248: PUSH
3249: LD_EXP 24
3253: MUL
3254: PUSH
3255: FOR_TO
3256: IFFALSE 3264
// begin create_ape ;
3258: CALL 3041 0 0
// end ;
3262: GO 3255
3264: POP
3265: POP
// end ;
3266: LD_VAR 0 1
3270: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3271: LD_OWVAR 1
3275: PUSH
3276: LD_EXP 32
3280: GREATER
3281: IFFALSE 3365
3283: GO 3285
3285: DISABLE
3286: LD_INT 0
3288: PPUSH
// begin if not ape_respawning then
3289: LD_EXP 25
3293: NOT
3294: IFFALSE 3298
// exit ;
3296: GO 3365
// delay := ape_respawning div side_count ;
3298: LD_ADDR_VAR 0 1
3302: PUSH
3303: LD_EXP 25
3307: PUSH
3308: LD_EXP 37
3312: DIV
3313: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3314: LD_VAR 0 1
3318: PUSH
3319: LD_INT 50
3321: PPUSH
3322: LD_INT 150
3324: PPUSH
3325: CALL_OW 12
3329: MUL
3330: PUSH
3331: LD_INT 100
3333: DIV
3334: PPUSH
3335: CALL_OW 67
// delay := delay * 110 div 100 ;
3339: LD_ADDR_VAR 0 1
3343: PUSH
3344: LD_VAR 0 1
3348: PUSH
3349: LD_INT 110
3351: MUL
3352: PUSH
3353: LD_INT 100
3355: DIV
3356: ST_TO_ADDR
// create_ape ;
3357: CALL 3041 0 0
// until false ;
3361: LD_INT 0
3363: IFFALSE 3314
// end ;
3365: PPOPN 1
3367: END
// function create_tiger ; var coord , i ; begin
3368: LD_INT 0
3370: PPUSH
3371: PPUSH
3372: PPUSH
// if lastunit >= 1999 then
3373: LD_EXP 36
3377: PUSH
3378: LD_INT 1999
3380: GREATEREQUAL
3381: IFFALSE 3385
// exit ;
3383: GO 3577
// uc_nation := nation_nature ;
3385: LD_ADDR_OWVAR 21
3389: PUSH
3390: LD_INT 0
3392: ST_TO_ADDR
// uc_side := 0 ;
3393: LD_ADDR_OWVAR 20
3397: PUSH
3398: LD_INT 0
3400: ST_TO_ADDR
// hc_name :=  ;
3401: LD_ADDR_OWVAR 26
3405: PUSH
3406: LD_STRING 
3408: ST_TO_ADDR
// hc_class := class_tiger ;
3409: LD_ADDR_OWVAR 28
3413: PUSH
3414: LD_INT 14
3416: ST_TO_ADDR
// hc_sex := 1 ;
3417: LD_ADDR_OWVAR 27
3421: PUSH
3422: LD_INT 1
3424: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 2 , 2 ] ;
3425: LD_ADDR_OWVAR 30
3429: PUSH
3430: LD_INT 2
3432: PUSH
3433: LD_INT 2
3435: PUSH
3436: LD_INT 2
3438: PUSH
3439: LD_INT 2
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// hc_skills := [ 2 , 2 , 2 , 2 ] ;
3448: LD_ADDR_OWVAR 31
3452: PUSH
3453: LD_INT 2
3455: PUSH
3456: LD_INT 2
3458: PUSH
3459: LD_INT 2
3461: PUSH
3462: LD_INT 2
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: LIST
3469: LIST
3470: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3471: LD_ADDR_OWVAR 29
3475: PUSH
3476: LD_INT 12
3478: PUSH
3479: LD_INT 12
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: ST_TO_ADDR
// hc_importance := 0 ;
3486: LD_ADDR_OWVAR 32
3490: PUSH
3491: LD_INT 0
3493: ST_TO_ADDR
// hc_gallery :=  ;
3494: LD_ADDR_OWVAR 33
3498: PUSH
3499: LD_STRING 
3501: ST_TO_ADDR
// hc_agressivity := Rand ( 30 , 50 ) ;
3502: LD_ADDR_OWVAR 35
3506: PUSH
3507: LD_INT 30
3509: PPUSH
3510: LD_INT 50
3512: PPUSH
3513: CALL_OW 12
3517: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3518: LD_ADDR_VAR 0 2
3522: PUSH
3523: LD_INT 7
3525: PPUSH
3526: CALL 2883 0 1
3530: ST_TO_ADDR
// if coord then
3531: LD_VAR 0 2
3535: IFFALSE 3577
// begin lastunit := CreateHuman ;
3537: LD_ADDR_EXP 36
3541: PUSH
3542: CALL_OW 44
3546: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3547: LD_EXP 36
3551: PPUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_INT 1
3559: ARRAY
3560: PPUSH
3561: LD_VAR 0 2
3565: PUSH
3566: LD_INT 2
3568: ARRAY
3569: PPUSH
3570: LD_INT 0
3572: PPUSH
3573: CALL_OW 48
// end ; end ;
3577: LD_VAR 0 1
3581: RET
// function prepare_tigers ; var i ; begin
3582: LD_INT 0
3584: PPUSH
3585: PPUSH
// for i := 1 to side_count * ntig do
3586: LD_ADDR_VAR 0 2
3590: PUSH
3591: DOUBLE
3592: LD_INT 1
3594: DEC
3595: ST_TO_ADDR
3596: LD_EXP 37
3600: PUSH
3601: LD_EXP 30
3605: MUL
3606: PUSH
3607: FOR_TO
3608: IFFALSE 3616
// begin create_tiger ;
3610: CALL 3368 0 0
// end ;
3614: GO 3607
3616: POP
3617: POP
// end ;
3618: LD_VAR 0 1
3622: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3623: LD_OWVAR 1
3627: PUSH
3628: LD_EXP 32
3632: GREATER
3633: IFFALSE 3717
3635: GO 3637
3637: DISABLE
3638: LD_INT 0
3640: PPUSH
// begin if not tig_respawning then
3641: LD_EXP 31
3645: NOT
3646: IFFALSE 3650
// exit ;
3648: GO 3717
// delay := tig_respawning div side_count ;
3650: LD_ADDR_VAR 0 1
3654: PUSH
3655: LD_EXP 31
3659: PUSH
3660: LD_EXP 37
3664: DIV
3665: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3666: LD_VAR 0 1
3670: PUSH
3671: LD_INT 50
3673: PPUSH
3674: LD_INT 150
3676: PPUSH
3677: CALL_OW 12
3681: MUL
3682: PUSH
3683: LD_INT 100
3685: DIV
3686: PPUSH
3687: CALL_OW 67
// delay := delay * 110 div 100 ;
3691: LD_ADDR_VAR 0 1
3695: PUSH
3696: LD_VAR 0 1
3700: PUSH
3701: LD_INT 110
3703: MUL
3704: PUSH
3705: LD_INT 100
3707: DIV
3708: ST_TO_ADDR
// create_tiger ;
3709: CALL 3368 0 0
// until false ;
3713: LD_INT 0
3715: IFFALSE 3666
// end ;
3717: PPOPN 1
3719: END
// export function sheherezade_start_the_fight ; var i ; begin
3720: LD_INT 0
3722: PPUSH
3723: PPUSH
// for i := 1 to 8 do
3724: LD_ADDR_VAR 0 2
3728: PUSH
3729: DOUBLE
3730: LD_INT 1
3732: DEC
3733: ST_TO_ADDR
3734: LD_INT 8
3736: PUSH
3737: FOR_TO
3738: IFFALSE 3772
// if side_positions [ i ] then
3740: LD_EXP 43
3744: PUSH
3745: LD_VAR 0 2
3749: ARRAY
3750: IFFALSE 3770
// prepare_side_to_the_fight ( i , prep_time > 0 ) ;
3752: LD_VAR 0 2
3756: PPUSH
3757: LD_EXP 32
3761: PUSH
3762: LD_INT 0
3764: GREATER
3765: PPUSH
3766: CALL 2410 0 2
3770: GO 3737
3772: POP
3773: POP
// end ;
3774: LD_VAR 0 1
3778: RET
// function create_mastodon ; var coord , i ; begin
3779: LD_INT 0
3781: PPUSH
3782: PPUSH
3783: PPUSH
// if lastunit >= 1999 then
3784: LD_EXP 36
3788: PUSH
3789: LD_INT 1999
3791: GREATEREQUAL
3792: IFFALSE 3796
// exit ;
3794: GO 3882
// uc_nation := nation_nature ;
3796: LD_ADDR_OWVAR 21
3800: PUSH
3801: LD_INT 0
3803: ST_TO_ADDR
// uc_side := 0 ;
3804: LD_ADDR_OWVAR 20
3808: PUSH
3809: LD_INT 0
3811: ST_TO_ADDR
// vc_chassis := 31 ;
3812: LD_ADDR_OWVAR 37
3816: PUSH
3817: LD_INT 31
3819: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3820: LD_ADDR_VAR 0 2
3824: PUSH
3825: LD_INT 7
3827: PPUSH
3828: CALL 2883 0 1
3832: ST_TO_ADDR
// if coord then
3833: LD_VAR 0 2
3837: IFFALSE 3882
// begin lastunit := CreateVehicle ;
3839: LD_ADDR_EXP 36
3843: PUSH
3844: CALL_OW 45
3848: ST_TO_ADDR
// PlaceUnitXYR ( lastunit , coord [ 1 ] , coord [ 2 ] , 3 , false ) ;
3849: LD_EXP 36
3853: PPUSH
3854: LD_VAR 0 2
3858: PUSH
3859: LD_INT 1
3861: ARRAY
3862: PPUSH
3863: LD_VAR 0 2
3867: PUSH
3868: LD_INT 2
3870: ARRAY
3871: PPUSH
3872: LD_INT 3
3874: PPUSH
3875: LD_INT 0
3877: PPUSH
3878: CALL_OW 50
// end ; end ;
3882: LD_VAR 0 1
3886: RET
// function prepare_mastodons ; var i ; begin
3887: LD_INT 0
3889: PPUSH
3890: PPUSH
// for i := 1 to nmast1 + side_count * nmast2 + side_count * nsh * nmast3 div 100 do
3891: LD_ADDR_VAR 0 2
3895: PUSH
3896: DOUBLE
3897: LD_INT 1
3899: DEC
3900: ST_TO_ADDR
3901: LD_EXP 27
3905: PUSH
3906: LD_EXP 37
3910: PUSH
3911: LD_EXP 28
3915: MUL
3916: PLUS
3917: PUSH
3918: LD_EXP 37
3922: PUSH
3923: LD_EXP 20
3927: MUL
3928: PUSH
3929: LD_EXP 29
3933: MUL
3934: PUSH
3935: LD_INT 100
3937: DIV
3938: PLUS
3939: PUSH
3940: FOR_TO
3941: IFFALSE 3949
// begin create_mastodon ;
3943: CALL 3779 0 0
// end ;
3947: GO 3940
3949: POP
3950: POP
// end ;
3951: LD_VAR 0 1
3955: RET
// export function starting_sheherezad ; begin
3956: LD_INT 0
3958: PPUSH
// mp_selectmsg := true ;
3959: LD_ADDR_OWVAR 13
3963: PUSH
3964: LD_INT 1
3966: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
3967: CALL 111 0 0
// prepare_map_coordinates ;
3971: CALL 1596 0 0
// set_attitudes ;
3975: CALL 2041 0 0
// prepare_sides ;
3979: CALL 2346 0 0
// prepare_apes ;
3983: CALL 3230 0 0
// prepare_tigers ;
3987: CALL 3582 0 0
// prepare_mastodons ;
3991: CALL 3887 0 0
// your_side := Player_Side ;
3995: LD_ADDR_OWVAR 2
3999: PUSH
4000: LD_EXP 39
4004: ST_TO_ADDR
// ResetFog ;
4005: CALL_OW 335
// music_nat := nation_arabian ;
4009: LD_ADDR_OWVAR 71
4013: PUSH
4014: LD_INT 2
4016: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
4017: LD_EXP 34
4021: PUSH
4022: LD_OWVAR 2
4026: ARRAY
4027: PUSH
4028: LD_INT 1
4030: ARRAY
4031: PPUSH
4032: LD_EXP 34
4036: PUSH
4037: LD_OWVAR 2
4041: ARRAY
4042: PUSH
4043: LD_INT 2
4045: ARRAY
4046: PPUSH
4047: CALL_OW 86
// end ; end_of_file
4051: LD_VAR 0 1
4055: RET
// export def_victory_conditions , def_number_of_people , def_people_respawning , def_vehicles_at_start , def_vehicles_respawning , def_vehicles_nations , def_siberite_rocket , def_vehicles_durability ; export game_time , point_limit , vehresp , vehmax1 , vehmax2 , vehmax , startvehperc , startveh , vehdur , npeop , peopresp , vehnats , sibrock , to_resp ; function read_multiplayer_and_game_parameters ; var i ; begin
4056: LD_INT 0
4058: PPUSH
4059: PPUSH
// if MultiPlayer then
4060: LD_OWVAR 4
4064: IFFALSE 4128
// begin Player_Side = mp_player_side ;
4066: LD_ADDR_EXP 39
4070: PUSH
4071: LD_OWVAR 7
4075: ST_TO_ADDR
// Player_Team = mp_player_team ;
4076: LD_ADDR_EXP 40
4080: PUSH
4081: LD_OWVAR 8
4085: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
4086: LD_ADDR_EXP 43
4090: PUSH
4091: LD_OWVAR 17
4095: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
4096: LD_ADDR_EXP 41
4100: PUSH
4101: LD_OWVAR 15
4105: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
4106: LD_ADDR_EXP 44
4110: PUSH
4111: LD_OWVAR 16
4115: ST_TO_ADDR
// Teams = mp_teams ;
4116: LD_ADDR_EXP 42
4120: PUSH
4121: LD_OWVAR 12
4125: ST_TO_ADDR
// end else
4126: GO 4272
// begin randomize ;
4128: CALL_OW 10
// Player_Side = 1 ;
4132: LD_ADDR_EXP 39
4136: PUSH
4137: LD_INT 1
4139: ST_TO_ADDR
// Player_Team = 0 ;
4140: LD_ADDR_EXP 40
4144: PUSH
4145: LD_INT 0
4147: ST_TO_ADDR
// Side_Positions = [ 1 , 3 , 6 , 0 , 0 , 0 , 0 , 7 ] ;
4148: LD_ADDR_EXP 43
4152: PUSH
4153: LD_INT 1
4155: PUSH
4156: LD_INT 3
4158: PUSH
4159: LD_INT 6
4161: PUSH
4162: LD_INT 0
4164: PUSH
4165: LD_INT 0
4167: PUSH
4168: LD_INT 0
4170: PUSH
4171: LD_INT 0
4173: PUSH
4174: LD_INT 7
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: LIST
4181: LIST
4182: LIST
4183: LIST
4184: LIST
4185: LIST
4186: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4187: LD_ADDR_EXP 41
4191: PUSH
4192: LD_INT 0
4194: PUSH
4195: LD_INT 0
4197: PUSH
4198: LD_INT 0
4200: PUSH
4201: LD_INT 0
4203: PUSH
4204: LD_INT 0
4206: PUSH
4207: LD_INT 0
4209: PUSH
4210: LD_INT 0
4212: PUSH
4213: LD_INT 0
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: LIST
4220: LIST
4221: LIST
4222: LIST
4223: LIST
4224: LIST
4225: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 2 , 2 , 2 , 2 ] ;
4226: LD_ADDR_EXP 44
4230: PUSH
4231: LD_INT 1
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: LD_INT 1
4239: PUSH
4240: LD_INT 2
4242: PUSH
4243: LD_INT 2
4245: PUSH
4246: LD_INT 2
4248: PUSH
4249: LD_INT 2
4251: PUSH
4252: LD_INT 2
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: ST_TO_ADDR
// Teams = [ ] ;
4265: LD_ADDR_EXP 42
4269: PUSH
4270: EMPTY
4271: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
4272: LD_ADDR_EXP 37
4276: PUSH
4277: LD_EXP 43
4281: PUSH
4282: LD_INT 0
4284: PUSH
4285: EMPTY
4286: LIST
4287: DIFF
4288: PUSH
4289: LD_INT 0
4291: PLUS
4292: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
4293: LD_ADDR_EXP 38
4297: PUSH
4298: LD_EXP 41
4302: PUSH
4303: LD_INT 0
4305: PUSH
4306: EMPTY
4307: LIST
4308: DIFF
4309: PUSH
4310: LD_INT 0
4312: PLUS
4313: ST_TO_ADDR
// if MultiPlayer then
4314: LD_OWVAR 4
4318: IFFALSE 4426
// begin def_victory_conditions = GetMultiplayerSetting ( 0 ) ;
4320: LD_ADDR_EXP 48
4324: PUSH
4325: LD_INT 0
4327: PPUSH
4328: CALL_OW 426
4332: ST_TO_ADDR
// def_number_of_people = GetMultiplayerSetting ( 1 ) ;
4333: LD_ADDR_EXP 49
4337: PUSH
4338: LD_INT 1
4340: PPUSH
4341: CALL_OW 426
4345: ST_TO_ADDR
// def_people_respawning = GetMultiplayerSetting ( 2 ) ;
4346: LD_ADDR_EXP 50
4350: PUSH
4351: LD_INT 2
4353: PPUSH
4354: CALL_OW 426
4358: ST_TO_ADDR
// def_vehicles_at_start = GetMultiplayerSetting ( 3 ) ;
4359: LD_ADDR_EXP 51
4363: PUSH
4364: LD_INT 3
4366: PPUSH
4367: CALL_OW 426
4371: ST_TO_ADDR
// def_vehicles_respawning = GetMultiplayerSetting ( 4 ) ;
4372: LD_ADDR_EXP 52
4376: PUSH
4377: LD_INT 4
4379: PPUSH
4380: CALL_OW 426
4384: ST_TO_ADDR
// def_vehicles_nations = GetMultiplayerSetting ( 5 ) ;
4385: LD_ADDR_EXP 53
4389: PUSH
4390: LD_INT 5
4392: PPUSH
4393: CALL_OW 426
4397: ST_TO_ADDR
// def_siberite_rocket = GetMultiplayerSetting ( 6 ) ;
4398: LD_ADDR_EXP 54
4402: PUSH
4403: LD_INT 6
4405: PPUSH
4406: CALL_OW 426
4410: ST_TO_ADDR
// def_vehicles_durability = GetMultiplayerSetting ( 7 ) ;
4411: LD_ADDR_EXP 55
4415: PUSH
4416: LD_INT 7
4418: PPUSH
4419: CALL_OW 426
4423: ST_TO_ADDR
// end else
4424: GO 4494
// begin randomize ;
4426: CALL_OW 10
// def_victory_conditions = 2 ;
4430: LD_ADDR_EXP 48
4434: PUSH
4435: LD_INT 2
4437: ST_TO_ADDR
// def_number_of_people = 1 ;
4438: LD_ADDR_EXP 49
4442: PUSH
4443: LD_INT 1
4445: ST_TO_ADDR
// def_people_respawning = 1 ;
4446: LD_ADDR_EXP 50
4450: PUSH
4451: LD_INT 1
4453: ST_TO_ADDR
// def_vehicles_at_start = 1 ;
4454: LD_ADDR_EXP 51
4458: PUSH
4459: LD_INT 1
4461: ST_TO_ADDR
// def_vehicles_respawning = 2 ;
4462: LD_ADDR_EXP 52
4466: PUSH
4467: LD_INT 2
4469: ST_TO_ADDR
// def_vehicles_nations = 0 ;
4470: LD_ADDR_EXP 53
4474: PUSH
4475: LD_INT 0
4477: ST_TO_ADDR
// def_siberite_rocket = 1 ;
4478: LD_ADDR_EXP 54
4482: PUSH
4483: LD_INT 1
4485: ST_TO_ADDR
// def_vehicles_durability = 1 ;
4486: LD_ADDR_EXP 55
4490: PUSH
4491: LD_INT 1
4493: ST_TO_ADDR
// end ; game_time = [ 5 5$0 , 10 10$0 , 15 15$0 , 20 20$0 , 30 30$0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ def_victory_conditions + 1 ] ;
4494: LD_ADDR_EXP 56
4498: PUSH
4499: LD_INT 10500
4501: PUSH
4502: LD_INT 21000
4504: PUSH
4505: LD_INT 31500
4507: PUSH
4508: LD_INT 42000
4510: PUSH
4511: LD_INT 63000
4513: PUSH
4514: LD_INT 0
4516: PUSH
4517: LD_INT 0
4519: PUSH
4520: LD_INT 0
4522: PUSH
4523: LD_INT 0
4525: PUSH
4526: LD_INT 0
4528: PUSH
4529: LD_INT 0
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: LIST
4538: LIST
4539: LIST
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: PUSH
4545: LD_EXP 48
4549: PUSH
4550: LD_INT 1
4552: PLUS
4553: ARRAY
4554: ST_TO_ADDR
// point_limit = [ 0 , 0 , 0 , 0 , 0 , 0 , 5 , 10 , 15 , 20 , 30 , 50 ] [ def_victory_conditions + 1 ] ;
4555: LD_ADDR_EXP 57
4559: PUSH
4560: LD_INT 0
4562: PUSH
4563: LD_INT 0
4565: PUSH
4566: LD_INT 0
4568: PUSH
4569: LD_INT 0
4571: PUSH
4572: LD_INT 0
4574: PUSH
4575: LD_INT 0
4577: PUSH
4578: LD_INT 5
4580: PUSH
4581: LD_INT 10
4583: PUSH
4584: LD_INT 15
4586: PUSH
4587: LD_INT 20
4589: PUSH
4590: LD_INT 30
4592: PUSH
4593: LD_INT 50
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: LIST
4605: LIST
4606: LIST
4607: LIST
4608: LIST
4609: PUSH
4610: LD_EXP 48
4614: PUSH
4615: LD_INT 1
4617: PLUS
4618: ARRAY
4619: ST_TO_ADDR
// npeop = [ 4 , 6 , 8 , 10 ] [ def_number_of_people + 1 ] ;
4620: LD_ADDR_EXP 65
4624: PUSH
4625: LD_INT 4
4627: PUSH
4628: LD_INT 6
4630: PUSH
4631: LD_INT 8
4633: PUSH
4634: LD_INT 10
4636: PUSH
4637: EMPTY
4638: LIST
4639: LIST
4640: LIST
4641: LIST
4642: PUSH
4643: LD_EXP 49
4647: PUSH
4648: LD_INT 1
4650: PLUS
4651: ARRAY
4652: ST_TO_ADDR
// peopresp = [ false , [ 0 0$40 , 1 1$20 ] , [ 0 0$20 , 0 0$40 ] , [ 0 0$10 , 0 0$20 ] ] [ def_people_respawning + 1 ] ;
4653: LD_ADDR_EXP 66
4657: PUSH
4658: LD_INT 0
4660: PUSH
4661: LD_INT 1400
4663: PUSH
4664: LD_INT 2800
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: PUSH
4671: LD_INT 700
4673: PUSH
4674: LD_INT 1400
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: PUSH
4681: LD_INT 350
4683: PUSH
4684: LD_INT 700
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: LIST
4695: LIST
4696: PUSH
4697: LD_EXP 50
4701: PUSH
4702: LD_INT 1
4704: PLUS
4705: ARRAY
4706: ST_TO_ADDR
// vehmax1 = [ 3 , 6 , 9 ] [ def_vehicles_respawning + 1 ] ;
4707: LD_ADDR_EXP 59
4711: PUSH
4712: LD_INT 3
4714: PUSH
4715: LD_INT 6
4717: PUSH
4718: LD_INT 9
4720: PUSH
4721: EMPTY
4722: LIST
4723: LIST
4724: LIST
4725: PUSH
4726: LD_EXP 52
4730: PUSH
4731: LD_INT 1
4733: PLUS
4734: ARRAY
4735: ST_TO_ADDR
// vehmax2 = [ 2 , 4 , 6 ] [ def_vehicles_respawning + 1 ] ;
4736: LD_ADDR_EXP 60
4740: PUSH
4741: LD_INT 2
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: LD_INT 6
4749: PUSH
4750: EMPTY
4751: LIST
4752: LIST
4753: LIST
4754: PUSH
4755: LD_EXP 52
4759: PUSH
4760: LD_INT 1
4762: PLUS
4763: ARRAY
4764: ST_TO_ADDR
// vehmax = vehmax1 + side_count * vehmax2 ;
4765: LD_ADDR_EXP 61
4769: PUSH
4770: LD_EXP 59
4774: PUSH
4775: LD_EXP 37
4779: PUSH
4780: LD_EXP 60
4784: MUL
4785: PLUS
4786: ST_TO_ADDR
// vehdur = [ [ 40 , 80 ] , [ 60 , 120 ] , [ 100 , 200 ] ] [ def_vehicles_durability + 1 ] ;
4787: LD_ADDR_EXP 64
4791: PUSH
4792: LD_INT 40
4794: PUSH
4795: LD_INT 80
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: PUSH
4802: LD_INT 60
4804: PUSH
4805: LD_INT 120
4807: PUSH
4808: EMPTY
4809: LIST
4810: LIST
4811: PUSH
4812: LD_INT 100
4814: PUSH
4815: LD_INT 200
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PUSH
4822: EMPTY
4823: LIST
4824: LIST
4825: LIST
4826: PUSH
4827: LD_EXP 55
4831: PUSH
4832: LD_INT 1
4834: PLUS
4835: ARRAY
4836: ST_TO_ADDR
// vehresp = [ [ 0 0$40 , 2 2$00 ] , [ 0 0$20 , 1 1$00 ] , [ 0 0$10 , 0 0$30 ] ] [ def_vehicles_respawning + 1 ] ;
4837: LD_ADDR_EXP 58
4841: PUSH
4842: LD_INT 1400
4844: PUSH
4845: LD_INT 4200
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: LD_INT 700
4854: PUSH
4855: LD_INT 2100
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 350
4864: PUSH
4865: LD_INT 1050
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: LIST
4876: PUSH
4877: LD_EXP 52
4881: PUSH
4882: LD_INT 1
4884: PLUS
4885: ARRAY
4886: ST_TO_ADDR
// startvehperc = [ 0 , 10 , 20 , 40 ] [ def_vehicles_at_start + 1 ] ;
4887: LD_ADDR_EXP 62
4891: PUSH
4892: LD_INT 0
4894: PUSH
4895: LD_INT 10
4897: PUSH
4898: LD_INT 20
4900: PUSH
4901: LD_INT 40
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: LIST
4908: LIST
4909: PUSH
4910: LD_EXP 51
4914: PUSH
4915: LD_INT 1
4917: PLUS
4918: ARRAY
4919: ST_TO_ADDR
// startveh = vehmax * startvehperc div 100 ;
4920: LD_ADDR_EXP 63
4924: PUSH
4925: LD_EXP 61
4929: PUSH
4930: LD_EXP 62
4934: MUL
4935: PUSH
4936: LD_INT 100
4938: DIV
4939: ST_TO_ADDR
// vehnats = [ [ 1 , 2 , 3 ] , [ 1 ] , [ 3 ] , [ 2 ] , [ 1 , 3 ] , [ 3 , 2 ] , [ 2 , 1 ] ] [ def_vehicles_nations + 1 ] ;
4940: LD_ADDR_EXP 67
4944: PUSH
4945: LD_INT 1
4947: PUSH
4948: LD_INT 2
4950: PUSH
4951: LD_INT 3
4953: PUSH
4954: EMPTY
4955: LIST
4956: LIST
4957: LIST
4958: PUSH
4959: LD_INT 1
4961: PUSH
4962: EMPTY
4963: LIST
4964: PUSH
4965: LD_INT 3
4967: PUSH
4968: EMPTY
4969: LIST
4970: PUSH
4971: LD_INT 2
4973: PUSH
4974: EMPTY
4975: LIST
4976: PUSH
4977: LD_INT 1
4979: PUSH
4980: LD_INT 3
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: PUSH
4987: LD_INT 3
4989: PUSH
4990: LD_INT 2
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: PUSH
4997: LD_INT 2
4999: PUSH
5000: LD_INT 1
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: PUSH
5016: LD_EXP 53
5020: PUSH
5021: LD_INT 1
5023: PLUS
5024: ARRAY
5025: ST_TO_ADDR
// sibrock = [ 0 , 3 , 7 ] [ def_siberite_rocket + 1 ] ;
5026: LD_ADDR_EXP 68
5030: PUSH
5031: LD_INT 0
5033: PUSH
5034: LD_INT 3
5036: PUSH
5037: LD_INT 7
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: LIST
5044: PUSH
5045: LD_EXP 54
5049: PUSH
5050: LD_INT 1
5052: PLUS
5053: ARRAY
5054: ST_TO_ADDR
// for i = 1 to 8 do
5055: LD_ADDR_VAR 0 2
5059: PUSH
5060: DOUBLE
5061: LD_INT 1
5063: DEC
5064: ST_TO_ADDR
5065: LD_INT 8
5067: PUSH
5068: FOR_TO
5069: IFFALSE 5101
// if Side_Positions [ i ] then
5071: LD_EXP 43
5075: PUSH
5076: LD_VAR 0 2
5080: ARRAY
5081: IFFALSE 5099
// to_resp := to_resp ^ i ;
5083: LD_ADDR_EXP 69
5087: PUSH
5088: LD_EXP 69
5092: PUSH
5093: LD_VAR 0 2
5097: ADD
5098: ST_TO_ADDR
5099: GO 5068
5101: POP
5102: POP
// end ;
5103: LD_VAR 0 1
5107: RET
// export chassis , weapons , areas_wheeled , areas_tracked ; function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
5108: LD_INT 0
5110: PPUSH
5111: PPUSH
5112: PPUSH
5113: PPUSH
5114: PPUSH
5115: PPUSH
5116: PPUSH
5117: PPUSH
// areas_wheeled = [ aw1 , aw2 , aw3 , aw4 ] ;
5118: LD_ADDR_EXP 72
5122: PUSH
5123: LD_INT 13
5125: PUSH
5126: LD_INT 15
5128: PUSH
5129: LD_INT 17
5131: PUSH
5132: LD_INT 19
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: LIST
5139: LIST
5140: ST_TO_ADDR
// areas_tracked = [ at1 , at2 , at3 , at4 ] ;
5141: LD_ADDR_EXP 73
5145: PUSH
5146: LD_INT 12
5148: PUSH
5149: LD_INT 14
5151: PUSH
5152: LD_INT 16
5154: PUSH
5155: LD_INT 18
5157: PUSH
5158: EMPTY
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: ST_TO_ADDR
// best = 0 ;
5164: LD_ADDR_VAR 0 2
5168: PUSH
5169: LD_INT 0
5171: ST_TO_ADDR
// for n = 1 to 200 do
5172: LD_ADDR_VAR 0 8
5176: PUSH
5177: DOUBLE
5178: LD_INT 1
5180: DEC
5181: ST_TO_ADDR
5182: LD_INT 200
5184: PUSH
5185: FOR_TO
5186: IFFALSE 5482
// begin c = [ ] ;
5188: LD_ADDR_VAR 0 3
5192: PUSH
5193: EMPTY
5194: ST_TO_ADDR
// for i = 1 to side_count do
5195: LD_ADDR_VAR 0 6
5199: PUSH
5200: DOUBLE
5201: LD_INT 1
5203: DEC
5204: ST_TO_ADDR
5205: LD_EXP 37
5209: PUSH
5210: FOR_TO
5211: IFFALSE 5240
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
5213: LD_ADDR_VAR 0 3
5217: PUSH
5218: LD_VAR 0 3
5222: PUSH
5223: LD_INT 21
5225: PPUSH
5226: LD_INT 0
5228: PPUSH
5229: CALL_OW 16
5233: PUSH
5234: EMPTY
5235: LIST
5236: ADD
5237: ST_TO_ADDR
5238: GO 5210
5240: POP
5241: POP
// minv = 10000 ;
5242: LD_ADDR_VAR 0 5
5246: PUSH
5247: LD_INT 10000
5249: ST_TO_ADDR
// for i = 1 to side_count do
5250: LD_ADDR_VAR 0 6
5254: PUSH
5255: DOUBLE
5256: LD_INT 1
5258: DEC
5259: ST_TO_ADDR
5260: LD_EXP 37
5264: PUSH
5265: FOR_TO
5266: IFFALSE 5446
// for j = 1 to side_count do
5268: LD_ADDR_VAR 0 7
5272: PUSH
5273: DOUBLE
5274: LD_INT 1
5276: DEC
5277: ST_TO_ADDR
5278: LD_EXP 37
5282: PUSH
5283: FOR_TO
5284: IFFALSE 5442
// if i <> j then
5286: LD_VAR 0 6
5290: PUSH
5291: LD_VAR 0 7
5295: NONEQUAL
5296: IFFALSE 5440
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
5298: LD_VAR 0 3
5302: PUSH
5303: LD_VAR 0 6
5307: ARRAY
5308: PUSH
5309: LD_INT 1
5311: ARRAY
5312: PPUSH
5313: LD_VAR 0 3
5317: PUSH
5318: LD_VAR 0 6
5322: ARRAY
5323: PUSH
5324: LD_INT 2
5326: ARRAY
5327: PPUSH
5328: LD_VAR 0 3
5332: PUSH
5333: LD_VAR 0 7
5337: ARRAY
5338: PUSH
5339: LD_INT 1
5341: ARRAY
5342: PPUSH
5343: LD_VAR 0 3
5347: PUSH
5348: LD_VAR 0 7
5352: ARRAY
5353: PUSH
5354: LD_INT 2
5356: ARRAY
5357: PPUSH
5358: CALL_OW 298
5362: PUSH
5363: LD_VAR 0 5
5367: LESS
5368: IFFALSE 5440
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
5370: LD_ADDR_VAR 0 5
5374: PUSH
5375: LD_VAR 0 3
5379: PUSH
5380: LD_VAR 0 6
5384: ARRAY
5385: PUSH
5386: LD_INT 1
5388: ARRAY
5389: PPUSH
5390: LD_VAR 0 3
5394: PUSH
5395: LD_VAR 0 6
5399: ARRAY
5400: PUSH
5401: LD_INT 2
5403: ARRAY
5404: PPUSH
5405: LD_VAR 0 3
5409: PUSH
5410: LD_VAR 0 7
5414: ARRAY
5415: PUSH
5416: LD_INT 1
5418: ARRAY
5419: PPUSH
5420: LD_VAR 0 3
5424: PUSH
5425: LD_VAR 0 7
5429: ARRAY
5430: PUSH
5431: LD_INT 2
5433: ARRAY
5434: PPUSH
5435: CALL_OW 298
5439: ST_TO_ADDR
// end ;
5440: GO 5283
5442: POP
5443: POP
5444: GO 5265
5446: POP
5447: POP
// if minv > best then
5448: LD_VAR 0 5
5452: PUSH
5453: LD_VAR 0 2
5457: GREATER
5458: IFFALSE 5480
// begin best := minv ;
5460: LD_ADDR_VAR 0 2
5464: PUSH
5465: LD_VAR 0 5
5469: ST_TO_ADDR
// bestc := c ;
5470: LD_ADDR_VAR 0 4
5474: PUSH
5475: LD_VAR 0 3
5479: ST_TO_ADDR
// end ; end ;
5480: GO 5185
5482: POP
5483: POP
// coordinates := [ ] ;
5484: LD_ADDR_EXP 34
5488: PUSH
5489: EMPTY
5490: ST_TO_ADDR
// for i = 1 to 8 do
5491: LD_ADDR_VAR 0 6
5495: PUSH
5496: DOUBLE
5497: LD_INT 1
5499: DEC
5500: ST_TO_ADDR
5501: LD_INT 8
5503: PUSH
5504: FOR_TO
5505: IFFALSE 5592
// if side_positions [ i ] = 0 then
5507: LD_EXP 43
5511: PUSH
5512: LD_VAR 0 6
5516: ARRAY
5517: PUSH
5518: LD_INT 0
5520: EQUAL
5521: IFFALSE 5549
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
5523: LD_ADDR_EXP 34
5527: PUSH
5528: LD_EXP 34
5532: PUSH
5533: LD_INT 0
5535: PUSH
5536: LD_INT 0
5538: PUSH
5539: EMPTY
5540: LIST
5541: LIST
5542: PUSH
5543: EMPTY
5544: LIST
5545: ADD
5546: ST_TO_ADDR
5547: GO 5590
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
5549: LD_ADDR_EXP 34
5553: PUSH
5554: LD_EXP 34
5558: PUSH
5559: LD_VAR 0 4
5563: PUSH
5564: LD_INT 1
5566: ARRAY
5567: PUSH
5568: EMPTY
5569: LIST
5570: ADD
5571: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
5572: LD_ADDR_VAR 0 4
5576: PUSH
5577: LD_VAR 0 4
5581: PPUSH
5582: LD_INT 1
5584: PPUSH
5585: CALL_OW 3
5589: ST_TO_ADDR
// end ;
5590: GO 5504
5592: POP
5593: POP
// end ;
5594: LD_VAR 0 1
5598: RET
// function prepare_constants ; begin
5599: LD_INT 0
5601: PPUSH
// chassis = [ [ [ [ us_light_wheeled ] , [ ] ] , [ [ us_medium_wheeled ] , [ us_medium_tracked ] ] , [ [ ] , [ us_heavy_tracked , us_morphling ] ] ] , [ [ [ ar_light_trike , ar_hovercraft ] , [ ] ] , [ [ ar_medium_trike ] , [ ar_half_tracked ] ] , [ [ ] , [ ] ] ] , [ [ [ ] , [ ] ] , [ [ ru_medium_wheeled ] , [ ru_medium_tracked ] ] , [ [ ru_heavy_wheeled ] , [ ru_heavy_tracked ] ] ] ] ;
5602: LD_ADDR_EXP 70
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: EMPTY
5611: LIST
5612: PUSH
5613: EMPTY
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PUSH
5619: LD_INT 2
5621: PUSH
5622: EMPTY
5623: LIST
5624: PUSH
5625: LD_INT 3
5627: PUSH
5628: EMPTY
5629: LIST
5630: PUSH
5631: EMPTY
5632: LIST
5633: LIST
5634: PUSH
5635: EMPTY
5636: PUSH
5637: LD_INT 4
5639: PUSH
5640: LD_INT 5
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 12
5658: PUSH
5659: LD_INT 11
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: EMPTY
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: PUSH
5672: LD_INT 13
5674: PUSH
5675: EMPTY
5676: LIST
5677: PUSH
5678: LD_INT 14
5680: PUSH
5681: EMPTY
5682: LIST
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: PUSH
5688: EMPTY
5689: PUSH
5690: EMPTY
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: PUSH
5701: EMPTY
5702: PUSH
5703: EMPTY
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: PUSH
5709: LD_INT 21
5711: PUSH
5712: EMPTY
5713: LIST
5714: PUSH
5715: LD_INT 22
5717: PUSH
5718: EMPTY
5719: LIST
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: PUSH
5725: LD_INT 23
5727: PUSH
5728: EMPTY
5729: LIST
5730: PUSH
5731: LD_INT 24
5733: PUSH
5734: EMPTY
5735: LIST
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: LIST
5750: ST_TO_ADDR
// weapons = [ [ [ us_machine_gun , 1 , 100 ] , [ us_light_gun , 1 , 100 ] , [ us_radar , 1 , 100 ] , [ us_gatling_gun , 2 , 100 ] , [ us_double_gun , 2 , 100 ] , [ us_rocket_launcher , 2 , 100 ] , [ us_laser , 2 , 100 ] , [ us_heavy_gun , 3 , 100 ] , [ us_bulldozer , 3 , 100 ] , [ us_double_laser , 3 , 100 ] ] , [ [ ar_multimissile_ballista , 1 , 100 ] , [ ar_double_machine_gun , 1 , 100 ] , [ ar_light_gun , 1 , 100 ] , [ ar_radar , 1 , 100 ] , [ ar_gatling_gun , 2 , 100 ] , [ ar_gun , 2 , 100 ] , [ ar_rocket_launcher , 2 , 100 ] , [ ar_selfpropelled_bomb , 2 , 100 ] , [ ar_flame_thrower , 2 , 100 ] ] , [ [ ru_heavy_machine_gun , 2 , 100 ] , [ ru_gatling_gun , 2 , 100 ] , [ ru_gun , 2 , 100 ] , [ ru_rocket_launcher , 2 , 100 ] , [ ru_heavy_gun , 3 , 100 ] , [ ru_rocket , 3 , 100 ] , [ ru_bulldozer , 3 , 100 ] ] ] ;
5751: LD_ADDR_EXP 71
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 1
5761: PUSH
5762: LD_INT 100
5764: PUSH
5765: EMPTY
5766: LIST
5767: LIST
5768: LIST
5769: PUSH
5770: LD_INT 3
5772: PUSH
5773: LD_INT 1
5775: PUSH
5776: LD_INT 100
5778: PUSH
5779: EMPTY
5780: LIST
5781: LIST
5782: LIST
5783: PUSH
5784: LD_INT 11
5786: PUSH
5787: LD_INT 1
5789: PUSH
5790: LD_INT 100
5792: PUSH
5793: EMPTY
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 4
5800: PUSH
5801: LD_INT 2
5803: PUSH
5804: LD_INT 100
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: LIST
5811: PUSH
5812: LD_INT 5
5814: PUSH
5815: LD_INT 2
5817: PUSH
5818: LD_INT 100
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: LIST
5825: PUSH
5826: LD_INT 7
5828: PUSH
5829: LD_INT 2
5831: PUSH
5832: LD_INT 100
5834: PUSH
5835: EMPTY
5836: LIST
5837: LIST
5838: LIST
5839: PUSH
5840: LD_INT 9
5842: PUSH
5843: LD_INT 2
5845: PUSH
5846: LD_INT 100
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: LIST
5853: PUSH
5854: LD_INT 6
5856: PUSH
5857: LD_INT 3
5859: PUSH
5860: LD_INT 100
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 14
5870: PUSH
5871: LD_INT 3
5873: PUSH
5874: LD_INT 100
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: LIST
5881: PUSH
5882: LD_INT 10
5884: PUSH
5885: LD_INT 3
5887: PUSH
5888: LD_INT 100
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: LIST
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: PUSH
5908: LD_INT 22
5910: PUSH
5911: LD_INT 1
5913: PUSH
5914: LD_INT 100
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: PUSH
5922: LD_INT 24
5924: PUSH
5925: LD_INT 1
5927: PUSH
5928: LD_INT 100
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: LIST
5935: PUSH
5936: LD_INT 23
5938: PUSH
5939: LD_INT 1
5941: PUSH
5942: LD_INT 100
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: LIST
5949: PUSH
5950: LD_INT 30
5952: PUSH
5953: LD_INT 1
5955: PUSH
5956: LD_INT 100
5958: PUSH
5959: EMPTY
5960: LIST
5961: LIST
5962: LIST
5963: PUSH
5964: LD_INT 25
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 100
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: PUSH
5978: LD_INT 27
5980: PUSH
5981: LD_INT 2
5983: PUSH
5984: LD_INT 100
5986: PUSH
5987: EMPTY
5988: LIST
5989: LIST
5990: LIST
5991: PUSH
5992: LD_INT 28
5994: PUSH
5995: LD_INT 2
5997: PUSH
5998: LD_INT 100
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: LIST
6005: PUSH
6006: LD_INT 29
6008: PUSH
6009: LD_INT 2
6011: PUSH
6012: LD_INT 100
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: LIST
6019: PUSH
6020: LD_INT 26
6022: PUSH
6023: LD_INT 2
6025: PUSH
6026: LD_INT 100
6028: PUSH
6029: EMPTY
6030: LIST
6031: LIST
6032: LIST
6033: PUSH
6034: EMPTY
6035: LIST
6036: LIST
6037: LIST
6038: LIST
6039: LIST
6040: LIST
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_INT 42
6047: PUSH
6048: LD_INT 2
6050: PUSH
6051: LD_INT 100
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: LD_INT 43
6061: PUSH
6062: LD_INT 2
6064: PUSH
6065: LD_INT 100
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: LIST
6072: PUSH
6073: LD_INT 44
6075: PUSH
6076: LD_INT 2
6078: PUSH
6079: LD_INT 100
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: LIST
6086: PUSH
6087: LD_INT 45
6089: PUSH
6090: LD_INT 2
6092: PUSH
6093: LD_INT 100
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: PUSH
6101: LD_INT 46
6103: PUSH
6104: LD_INT 3
6106: PUSH
6107: LD_INT 100
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 47
6117: PUSH
6118: LD_INT 3
6120: PUSH
6121: LD_INT 100
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: LIST
6128: PUSH
6129: LD_INT 53
6131: PUSH
6132: LD_INT 3
6134: PUSH
6135: LD_INT 100
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: LIST
6147: LIST
6148: LIST
6149: LIST
6150: LIST
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: LIST
6156: ST_TO_ADDR
// end ;
6157: LD_VAR 0 1
6161: RET
// var is_tracked ; function random_vehicle ( sibrockprob ) ; var nat , wpset , suma , tmp , i , weap , wwght , wght , chs , trck ; begin
6162: LD_INT 0
6164: PPUSH
6165: PPUSH
6166: PPUSH
6167: PPUSH
6168: PPUSH
6169: PPUSH
6170: PPUSH
6171: PPUSH
6172: PPUSH
6173: PPUSH
6174: PPUSH
// nat := vehnats [ rand ( 1 , vehnats ) ] ;
6175: LD_ADDR_VAR 0 3
6179: PUSH
6180: LD_EXP 67
6184: PUSH
6185: LD_INT 1
6187: PPUSH
6188: LD_EXP 67
6192: PPUSH
6193: CALL_OW 12
6197: ARRAY
6198: ST_TO_ADDR
// if ( nat in [ nation_russian , nation_american ] ) and ( Rand ( 1 , 1000 ) <= sibrockprob ) then
6199: LD_VAR 0 3
6203: PUSH
6204: LD_INT 3
6206: PUSH
6207: LD_INT 1
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: IN
6214: PUSH
6215: LD_INT 1
6217: PPUSH
6218: LD_INT 1000
6220: PPUSH
6221: CALL_OW 12
6225: PUSH
6226: LD_VAR 0 1
6230: LESSEQUAL
6231: AND
6232: IFFALSE 6288
// begin wght := 3 ;
6234: LD_ADDR_VAR 0 10
6238: PUSH
6239: LD_INT 3
6241: ST_TO_ADDR
// case nat of nation_russian :
6242: LD_VAR 0 3
6246: PUSH
6247: LD_INT 3
6249: DOUBLE
6250: EQUAL
6251: IFTRUE 6255
6253: GO 6266
6255: POP
// weap := ru_siberium_rocket ; nation_american :
6256: LD_ADDR_VAR 0 8
6260: PUSH
6261: LD_INT 48
6263: ST_TO_ADDR
6264: GO 6286
6266: LD_INT 1
6268: DOUBLE
6269: EQUAL
6270: IFTRUE 6274
6272: GO 6285
6274: POP
// weap := us_siberium_rocket ; end ;
6275: LD_ADDR_VAR 0 8
6279: PUSH
6280: LD_INT 8
6282: ST_TO_ADDR
6283: GO 6286
6285: POP
// end else
6286: GO 6490
// begin wpset := weapons [ nat ] ;
6288: LD_ADDR_VAR 0 4
6292: PUSH
6293: LD_EXP 71
6297: PUSH
6298: LD_VAR 0 3
6302: ARRAY
6303: ST_TO_ADDR
// suma := 0 ;
6304: LD_ADDR_VAR 0 5
6308: PUSH
6309: LD_INT 0
6311: ST_TO_ADDR
// for i := 1 to wpset do
6312: LD_ADDR_VAR 0 7
6316: PUSH
6317: DOUBLE
6318: LD_INT 1
6320: DEC
6321: ST_TO_ADDR
6322: LD_VAR 0 4
6326: PUSH
6327: FOR_TO
6328: IFFALSE 6358
// suma := suma + wpset [ i ] [ 3 ] ;
6330: LD_ADDR_VAR 0 5
6334: PUSH
6335: LD_VAR 0 5
6339: PUSH
6340: LD_VAR 0 4
6344: PUSH
6345: LD_VAR 0 7
6349: ARRAY
6350: PUSH
6351: LD_INT 3
6353: ARRAY
6354: PLUS
6355: ST_TO_ADDR
6356: GO 6327
6358: POP
6359: POP
// tmp := rand ( 1 , suma ) ;
6360: LD_ADDR_VAR 0 6
6364: PUSH
6365: LD_INT 1
6367: PPUSH
6368: LD_VAR 0 5
6372: PPUSH
6373: CALL_OW 12
6377: ST_TO_ADDR
// i := 1 ;
6378: LD_ADDR_VAR 0 7
6382: PUSH
6383: LD_INT 1
6385: ST_TO_ADDR
// while wpset [ i ] [ 3 ] < tmp do
6386: LD_VAR 0 4
6390: PUSH
6391: LD_VAR 0 7
6395: ARRAY
6396: PUSH
6397: LD_INT 3
6399: ARRAY
6400: PUSH
6401: LD_VAR 0 6
6405: LESS
6406: IFFALSE 6450
// begin tmp := tmp - wpset [ i ] [ 3 ] ;
6408: LD_ADDR_VAR 0 6
6412: PUSH
6413: LD_VAR 0 6
6417: PUSH
6418: LD_VAR 0 4
6422: PUSH
6423: LD_VAR 0 7
6427: ARRAY
6428: PUSH
6429: LD_INT 3
6431: ARRAY
6432: MINUS
6433: ST_TO_ADDR
// i := i + 1 ;
6434: LD_ADDR_VAR 0 7
6438: PUSH
6439: LD_VAR 0 7
6443: PUSH
6444: LD_INT 1
6446: PLUS
6447: ST_TO_ADDR
// end ;
6448: GO 6386
// weap := wpset [ i ] [ 1 ] ;
6450: LD_ADDR_VAR 0 8
6454: PUSH
6455: LD_VAR 0 4
6459: PUSH
6460: LD_VAR 0 7
6464: ARRAY
6465: PUSH
6466: LD_INT 1
6468: ARRAY
6469: ST_TO_ADDR
// wwght := wpset [ i ] [ 2 ] ;
6470: LD_ADDR_VAR 0 9
6474: PUSH
6475: LD_VAR 0 4
6479: PUSH
6480: LD_VAR 0 7
6484: ARRAY
6485: PUSH
6486: LD_INT 2
6488: ARRAY
6489: ST_TO_ADDR
// end ; repeat trck := Rand ( 1 , 2 ) ;
6490: LD_ADDR_VAR 0 12
6494: PUSH
6495: LD_INT 1
6497: PPUSH
6498: LD_INT 2
6500: PPUSH
6501: CALL_OW 12
6505: ST_TO_ADDR
// case wwght of 3 :
6506: LD_VAR 0 9
6510: PUSH
6511: LD_INT 3
6513: DOUBLE
6514: EQUAL
6515: IFTRUE 6519
6517: GO 6530
6519: POP
// wght := 3 ; 2 :
6520: LD_ADDR_VAR 0 10
6524: PUSH
6525: LD_INT 3
6527: ST_TO_ADDR
6528: GO 6647
6530: LD_INT 2
6532: DOUBLE
6533: EQUAL
6534: IFTRUE 6538
6536: GO 6575
6538: POP
// if Rand ( 1 , 100 ) <= 80 then
6539: LD_INT 1
6541: PPUSH
6542: LD_INT 100
6544: PPUSH
6545: CALL_OW 12
6549: PUSH
6550: LD_INT 80
6552: LESSEQUAL
6553: IFFALSE 6565
// wght := 2 else
6555: LD_ADDR_VAR 0 10
6559: PUSH
6560: LD_INT 2
6562: ST_TO_ADDR
6563: GO 6573
// wght := 3 ; 1 :
6565: LD_ADDR_VAR 0 10
6569: PUSH
6570: LD_INT 3
6572: ST_TO_ADDR
6573: GO 6647
6575: LD_INT 1
6577: DOUBLE
6578: EQUAL
6579: IFTRUE 6583
6581: GO 6646
6583: POP
// if Rand ( 1 , 100 ) <= 80 then
6584: LD_INT 1
6586: PPUSH
6587: LD_INT 100
6589: PPUSH
6590: CALL_OW 12
6594: PUSH
6595: LD_INT 80
6597: LESSEQUAL
6598: IFFALSE 6610
// wght := 1 else
6600: LD_ADDR_VAR 0 10
6604: PUSH
6605: LD_INT 1
6607: ST_TO_ADDR
6608: GO 6644
// if Rand ( 1 , 100 ) <= 80 then
6610: LD_INT 1
6612: PPUSH
6613: LD_INT 100
6615: PPUSH
6616: CALL_OW 12
6620: PUSH
6621: LD_INT 80
6623: LESSEQUAL
6624: IFFALSE 6636
// wght := 2 else
6626: LD_ADDR_VAR 0 10
6630: PUSH
6631: LD_INT 2
6633: ST_TO_ADDR
6634: GO 6644
// wght := 3 ; end ;
6636: LD_ADDR_VAR 0 10
6640: PUSH
6641: LD_INT 3
6643: ST_TO_ADDR
6644: GO 6647
6646: POP
// if chassis [ nat ] [ wght ] [ trck ] then
6647: LD_EXP 70
6651: PUSH
6652: LD_VAR 0 3
6656: ARRAY
6657: PUSH
6658: LD_VAR 0 10
6662: ARRAY
6663: PUSH
6664: LD_VAR 0 12
6668: ARRAY
6669: IFFALSE 6733
// chs := chassis [ nat ] [ wght ] [ trck ] [ Rand ( 1 , chassis [ nat ] [ wght ] [ trck ] ) ] else
6671: LD_ADDR_VAR 0 11
6675: PUSH
6676: LD_EXP 70
6680: PUSH
6681: LD_VAR 0 3
6685: ARRAY
6686: PUSH
6687: LD_VAR 0 10
6691: ARRAY
6692: PUSH
6693: LD_VAR 0 12
6697: ARRAY
6698: PUSH
6699: LD_INT 1
6701: PPUSH
6702: LD_EXP 70
6706: PUSH
6707: LD_VAR 0 3
6711: ARRAY
6712: PUSH
6713: LD_VAR 0 10
6717: ARRAY
6718: PUSH
6719: LD_VAR 0 12
6723: ARRAY
6724: PPUSH
6725: CALL_OW 12
6729: ARRAY
6730: ST_TO_ADDR
6731: GO 6741
// chs := 0 ;
6733: LD_ADDR_VAR 0 11
6737: PUSH
6738: LD_INT 0
6740: ST_TO_ADDR
// until chs ;
6741: LD_VAR 0 11
6745: IFFALSE 6490
// uc_side := 0 ;
6747: LD_ADDR_OWVAR 20
6751: PUSH
6752: LD_INT 0
6754: ST_TO_ADDR
// uc_nation := nat ;
6755: LD_ADDR_OWVAR 21
6759: PUSH
6760: LD_VAR 0 3
6764: ST_TO_ADDR
// uc_direction := rand ( 0 , 5 ) ;
6765: LD_ADDR_OWVAR 24
6769: PUSH
6770: LD_INT 0
6772: PPUSH
6773: LD_INT 5
6775: PPUSH
6776: CALL_OW 12
6780: ST_TO_ADDR
// vc_chassis := chs ;
6781: LD_ADDR_OWVAR 37
6785: PUSH
6786: LD_VAR 0 11
6790: ST_TO_ADDR
// vc_weapon := weap ;
6791: LD_ADDR_OWVAR 40
6795: PUSH
6796: LD_VAR 0 8
6800: ST_TO_ADDR
// vc_control := control_manual ;
6801: LD_ADDR_OWVAR 38
6805: PUSH
6806: LD_INT 1
6808: ST_TO_ADDR
// case wght of 1 :
6809: LD_VAR 0 10
6813: PUSH
6814: LD_INT 1
6816: DOUBLE
6817: EQUAL
6818: IFTRUE 6822
6820: GO 6833
6822: POP
// vc_engine := engine_solar ; 2 , 3 :
6823: LD_ADDR_OWVAR 39
6827: PUSH
6828: LD_INT 2
6830: ST_TO_ADDR
6831: GO 6859
6833: LD_INT 2
6835: DOUBLE
6836: EQUAL
6837: IFTRUE 6847
6839: LD_INT 3
6841: DOUBLE
6842: EQUAL
6843: IFTRUE 6847
6845: GO 6858
6847: POP
// vc_engine := engine_siberite ; end ;
6848: LD_ADDR_OWVAR 39
6852: PUSH
6853: LD_INT 3
6855: ST_TO_ADDR
6856: GO 6859
6858: POP
// is_tracked := trck = 2 ;
6859: LD_ADDR_LOC 1
6863: PUSH
6864: LD_VAR 0 12
6868: PUSH
6869: LD_INT 2
6871: EQUAL
6872: ST_TO_ADDR
// end ;
6873: LD_VAR 0 2
6877: RET
// export function vehicles_create_vehicle ( atstart ) ; var v , ar ; begin
6878: LD_INT 0
6880: PPUSH
6881: PPUSH
6882: PPUSH
// if atstart then
6883: LD_VAR 0 1
6887: IFFALSE 6898
// random_vehicle ( 0 ) else
6889: LD_INT 0
6891: PPUSH
6892: CALL 6162 0 1
6896: GO 6907
// random_vehicle ( sibrock ) ;
6898: LD_EXP 68
6902: PPUSH
6903: CALL 6162 0 1
// v := CreateVehicle ;
6907: LD_ADDR_VAR 0 3
6911: PUSH
6912: CALL_OW 45
6916: ST_TO_ADDR
// if is_tracked then
6917: LD_LOC 1
6921: IFFALSE 6949
// ar := areas_tracked [ Rand ( 1 , areas_tracked ) ] else
6923: LD_ADDR_VAR 0 4
6927: PUSH
6928: LD_EXP 73
6932: PUSH
6933: LD_INT 1
6935: PPUSH
6936: LD_EXP 73
6940: PPUSH
6941: CALL_OW 12
6945: ARRAY
6946: ST_TO_ADDR
6947: GO 6973
// ar := areas_wheeled [ Rand ( 1 , areas_wheeled ) ] ;
6949: LD_ADDR_VAR 0 4
6953: PUSH
6954: LD_EXP 72
6958: PUSH
6959: LD_INT 1
6961: PPUSH
6962: LD_EXP 72
6966: PPUSH
6967: CALL_OW 12
6971: ARRAY
6972: ST_TO_ADDR
// PlaceUnitArea ( v , ar , not atstart ) ;
6973: LD_VAR 0 3
6977: PPUSH
6978: LD_VAR 0 4
6982: PPUSH
6983: LD_VAR 0 1
6987: NOT
6988: PPUSH
6989: CALL_OW 49
// end ;
6993: LD_VAR 0 2
6997: RET
// function prepare_vehicles ; var i ; begin
6998: LD_INT 0
7000: PPUSH
7001: PPUSH
// for i := 1 to startveh do
7002: LD_ADDR_VAR 0 2
7006: PUSH
7007: DOUBLE
7008: LD_INT 1
7010: DEC
7011: ST_TO_ADDR
7012: LD_EXP 63
7016: PUSH
7017: FOR_TO
7018: IFFALSE 7029
// begin vehicles_create_vehicle ( true ) ;
7020: LD_INT 1
7022: PPUSH
7023: CALL 6878 0 1
// end ;
7027: GO 7017
7029: POP
7030: POP
// end ;
7031: LD_VAR 0 1
7035: RET
// function set_attitudes ; var i , j ; begin
7036: LD_INT 0
7038: PPUSH
7039: PPUSH
7040: PPUSH
// if not Team_Game then
7041: LD_EXP 47
7045: NOT
7046: IFFALSE 7142
// begin for i = 1 to 8 do
7048: LD_ADDR_VAR 0 2
7052: PUSH
7053: DOUBLE
7054: LD_INT 1
7056: DEC
7057: ST_TO_ADDR
7058: LD_INT 8
7060: PUSH
7061: FOR_TO
7062: IFFALSE 7140
// for j = 1 to 8 do
7064: LD_ADDR_VAR 0 3
7068: PUSH
7069: DOUBLE
7070: LD_INT 1
7072: DEC
7073: ST_TO_ADDR
7074: LD_INT 8
7076: PUSH
7077: FOR_TO
7078: IFFALSE 7136
// if i <> j then
7080: LD_VAR 0 2
7084: PUSH
7085: LD_VAR 0 3
7089: NONEQUAL
7090: IFFALSE 7114
// SetAttitude ( i , j , att_neutral , true ) else
7092: LD_VAR 0 2
7096: PPUSH
7097: LD_VAR 0 3
7101: PPUSH
7102: LD_INT 0
7104: PPUSH
7105: LD_INT 1
7107: PPUSH
7108: CALL_OW 80
7112: GO 7134
// SetAttitude ( i , j , att_friend , true ) end ;
7114: LD_VAR 0 2
7118: PPUSH
7119: LD_VAR 0 3
7123: PPUSH
7124: LD_INT 1
7126: PPUSH
7127: LD_INT 1
7129: PPUSH
7130: CALL_OW 80
7134: GO 7077
7136: POP
7137: POP
7138: GO 7061
7140: POP
7141: POP
// end ;
7142: LD_VAR 0 1
7146: RET
// function prepare_side ( side ) ; var i ; begin
7147: LD_INT 0
7149: PPUSH
7150: PPUSH
// for i := 1 to npeop do
7151: LD_ADDR_VAR 0 3
7155: PUSH
7156: DOUBLE
7157: LD_INT 1
7159: DEC
7160: ST_TO_ADDR
7161: LD_EXP 65
7165: PUSH
7166: FOR_TO
7167: IFFALSE 7276
// begin uc_side := side ;
7169: LD_ADDR_OWVAR 20
7173: PUSH
7174: LD_VAR 0 1
7178: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
7179: LD_ADDR_OWVAR 21
7183: PUSH
7184: LD_EXP 44
7188: PUSH
7189: LD_VAR 0 1
7193: ARRAY
7194: ST_TO_ADDR
// hc_name :=  ;
7195: LD_ADDR_OWVAR 26
7199: PUSH
7200: LD_STRING 
7202: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
7203: LD_INT 0
7205: PPUSH
7206: LD_INT 4
7208: PPUSH
7209: CALL_OW 383
// hc_importance := 0 ;
7213: LD_ADDR_OWVAR 32
7217: PUSH
7218: LD_INT 0
7220: ST_TO_ADDR
// hc_gallery :=  ;
7221: LD_ADDR_OWVAR 33
7225: PUSH
7226: LD_STRING 
7228: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 4 , false ) ;
7229: CALL_OW 44
7233: PPUSH
7234: LD_EXP 34
7238: PUSH
7239: LD_VAR 0 1
7243: ARRAY
7244: PUSH
7245: LD_INT 1
7247: ARRAY
7248: PPUSH
7249: LD_EXP 34
7253: PUSH
7254: LD_VAR 0 1
7258: ARRAY
7259: PUSH
7260: LD_INT 2
7262: ARRAY
7263: PPUSH
7264: LD_INT 4
7266: PPUSH
7267: LD_INT 0
7269: PPUSH
7270: CALL_OW 50
// end ;
7274: GO 7166
7276: POP
7277: POP
// end ;
7278: LD_VAR 0 2
7282: RET
// function prepare_sides ; var i ; begin
7283: LD_INT 0
7285: PPUSH
7286: PPUSH
// for i := 1 to 8 do
7287: LD_ADDR_VAR 0 2
7291: PUSH
7292: DOUBLE
7293: LD_INT 1
7295: DEC
7296: ST_TO_ADDR
7297: LD_INT 8
7299: PUSH
7300: FOR_TO
7301: IFFALSE 7326
// if side_positions [ i ] then
7303: LD_EXP 43
7307: PUSH
7308: LD_VAR 0 2
7312: ARRAY
7313: IFFALSE 7324
// prepare_side ( i ) ;
7315: LD_VAR 0 2
7319: PPUSH
7320: CALL 7147 0 1
7324: GO 7300
7326: POP
7327: POP
// end ;
7328: LD_VAR 0 1
7332: RET
// export function starting_vehicles ; begin
7333: LD_INT 0
7335: PPUSH
// mp_with_score := true ;
7336: LD_ADDR_OWVAR 14
7340: PUSH
7341: LD_INT 1
7343: ST_TO_ADDR
// mp_selectmsg := true ;
7344: LD_ADDR_OWVAR 13
7348: PUSH
7349: LD_INT 1
7351: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
7352: CALL 4056 0 0
// prepare_map_coordinates ;
7356: CALL 5108 0 0
// prepare_constants ;
7360: CALL 5599 0 0
// set_attitudes ;
7364: CALL 7036 0 0
// prepare_sides ;
7368: CALL 7283 0 0
// prepare_vehicles ;
7372: CALL 6998 0 0
// SetAreaMapShow ( exitarea , 1 ) ;
7376: LD_INT 20
7378: PPUSH
7379: LD_INT 1
7381: PPUSH
7382: CALL_OW 424
// your_side := Player_Side ;
7386: LD_ADDR_OWVAR 2
7390: PUSH
7391: LD_EXP 39
7395: ST_TO_ADDR
// ResetFog ;
7396: CALL_OW 335
// music_nat := Side_Nations [ your_side ] ;
7400: LD_ADDR_OWVAR 71
7404: PUSH
7405: LD_EXP 44
7409: PUSH
7410: LD_OWVAR 2
7414: ARRAY
7415: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
7416: LD_EXP 34
7420: PUSH
7421: LD_OWVAR 2
7425: ARRAY
7426: PUSH
7427: LD_INT 1
7429: ARRAY
7430: PPUSH
7431: LD_EXP 34
7435: PUSH
7436: LD_OWVAR 2
7440: ARRAY
7441: PUSH
7442: LD_INT 2
7444: ARRAY
7445: PPUSH
7446: CALL_OW 86
// end ; end_of_file
7450: LD_VAR 0 1
7454: RET
// every 0 0$0.5 + 2 marked 15 do var t , red ;
7455: GO 7457
7457: DISABLE
7458: LD_INT 0
7460: PPUSH
7461: PPUSH
// begin if not prep_time then
7462: LD_EXP 32
7466: NOT
7467: IFFALSE 7471
// exit ;
7469: GO 7593
// if tick >= prep_time then
7471: LD_OWVAR 1
7475: PUSH
7476: LD_EXP 32
7480: GREATEREQUAL
7481: IFFALSE 7496
// begin display_strings = [ ] ;
7483: LD_ADDR_OWVAR 47
7487: PUSH
7488: EMPTY
7489: ST_TO_ADDR
// sheherezade_start_the_fight ;
7490: CALL 3720 0 0
// end else
7494: GO 7593
// begin t = prep_time - tick ;
7496: LD_ADDR_VAR 0 1
7500: PUSH
7501: LD_EXP 32
7505: PUSH
7506: LD_OWVAR 1
7510: MINUS
7511: ST_TO_ADDR
// if t <= 0 0$5.5 then
7512: LD_VAR 0 1
7516: PUSH
7517: LD_INT 192
7519: LESSEQUAL
7520: IFFALSE 7542
// red := t mod 0 0$1 < 0 0$0.5 else
7522: LD_ADDR_VAR 0 2
7526: PUSH
7527: LD_VAR 0 1
7531: PUSH
7532: LD_INT 35
7534: MOD
7535: PUSH
7536: LD_INT 18
7538: LESS
7539: ST_TO_ADDR
7540: GO 7550
// red := false ;
7542: LD_ADDR_VAR 0 2
7546: PUSH
7547: LD_INT 0
7549: ST_TO_ADDR
// if red then
7550: LD_VAR 0 2
7554: IFFALSE 7575
// display_strings = [ #Sheherezade-Time2 , t ] else
7556: LD_ADDR_OWVAR 47
7560: PUSH
7561: LD_STRING #Sheherezade-Time2
7563: PUSH
7564: LD_VAR 0 1
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: ST_TO_ADDR
7573: GO 7592
// display_strings = [ #Sheherezade-Time1 , t ] ;
7575: LD_ADDR_OWVAR 47
7579: PUSH
7580: LD_STRING #Sheherezade-Time1
7582: PUSH
7583: LD_VAR 0 1
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: ST_TO_ADDR
// enable ;
7592: ENABLE
// end ; end ;
7593: PPOPN 2
7595: END
// every 4 marked 15 do
7596: GO 7598
7598: DISABLE
// begin if tick < prep_time then
7599: LD_OWVAR 1
7603: PUSH
7604: LD_EXP 32
7608: LESS
7609: IFFALSE 7624
// begin SetLives ( all_units , 1000 ) ;
7611: LD_OWVAR 3
7615: PPUSH
7616: LD_INT 1000
7618: PPUSH
7619: CALL_OW 234
// enable ;
7623: ENABLE
// end ; end ; end_of_file
7624: END
// on ApemanTamed ( ape , sci ) do begin if gametype = 15 then
7625: LD_EXP 1
7629: PUSH
7630: LD_INT 15
7632: EQUAL
7633: IFFALSE 7657
// begin if not def_apemen_abilities then
7635: LD_EXP 12
7639: NOT
7640: IFFALSE 7645
// disable else
7642: DISABLE
7643: GO 7657
// begin SetClass ( ape , class_apeman_soldier ) ;
7645: LD_VAR 0 1
7649: PPUSH
7650: LD_INT 15
7652: PPUSH
7653: CALL_OW 336
// end ; end ; end ;
7657: PPOPN 2
7659: END
// on UnitGoesToRed ( un ) do var killer , victim , near ;
7660: LD_INT 0
7662: PPUSH
7663: PPUSH
7664: PPUSH
// begin if gametype = 15 then
7665: LD_EXP 1
7669: PUSH
7670: LD_INT 15
7672: EQUAL
7673: IFFALSE 7898
// if un in sheherezades then
7675: LD_VAR 0 1
7679: PUSH
7680: LD_EXP 35
7684: IN
7685: IFFALSE 7898
// begin victim := GetSide ( un ) ;
7687: LD_ADDR_VAR 0 3
7691: PUSH
7692: LD_VAR 0 1
7696: PPUSH
7697: CALL_OW 255
7701: ST_TO_ADDR
// near := NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , victim ] , f_not , [ f_side , 0 ] ] ) , un ) ;
7702: LD_ADDR_VAR 0 4
7706: PUSH
7707: LD_INT 3
7709: PUSH
7710: LD_INT 22
7712: PUSH
7713: LD_VAR 0 3
7717: PUSH
7718: EMPTY
7719: LIST
7720: LIST
7721: PUSH
7722: LD_INT 3
7724: PUSH
7725: LD_INT 22
7727: PUSH
7728: LD_INT 0
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: LIST
7739: LIST
7740: PPUSH
7741: CALL_OW 69
7745: PPUSH
7746: LD_VAR 0 1
7750: PPUSH
7751: CALL_OW 74
7755: ST_TO_ADDR
// killer := GetSide ( near ) ;
7756: LD_ADDR_VAR 0 2
7760: PUSH
7761: LD_VAR 0 4
7765: PPUSH
7766: CALL_OW 255
7770: ST_TO_ADDR
// if your_side and ( your_side = victim ) then
7771: LD_OWVAR 2
7775: PUSH
7776: LD_OWVAR 2
7780: PUSH
7781: LD_VAR 0 3
7785: EQUAL
7786: AND
7787: IFFALSE 7816
// begin wait ( 0 0$3 ) ;
7789: LD_INT 105
7791: PPUSH
7792: CALL_OW 67
// if not multiplayer then
7796: LD_OWVAR 4
7800: NOT
7801: IFFALSE 7812
// msg ( You Lost ) else
7803: LD_STRING You Lost
7805: PPUSH
7806: CALL_OW 100
7810: GO 7816
// YouLostInMultiplayer ;
7812: CALL_OW 107
// end ; sheherezades := Replace ( sheherezades , victim , 0 ) ;
7816: LD_ADDR_EXP 35
7820: PUSH
7821: LD_EXP 35
7825: PPUSH
7826: LD_VAR 0 3
7830: PPUSH
7831: LD_INT 0
7833: PPUSH
7834: CALL_OW 1
7838: ST_TO_ADDR
// SetSide ( FilterAllUnits ( [ f_side , victim ] ) , killer ) ;
7839: LD_INT 22
7841: PUSH
7842: LD_VAR 0 3
7846: PUSH
7847: EMPTY
7848: LIST
7849: LIST
7850: PPUSH
7851: CALL_OW 69
7855: PPUSH
7856: LD_VAR 0 2
7860: PPUSH
7861: CALL_OW 235
// ComStop ( FilterAllUnits ( [ f_side , killer ] ) ) ;
7865: LD_INT 22
7867: PUSH
7868: LD_VAR 0 2
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: PPUSH
7877: CALL_OW 69
7881: PPUSH
7882: CALL_OW 141
// SetLives ( un , 0 ) ;
7886: LD_VAR 0 1
7890: PPUSH
7891: LD_INT 0
7893: PPUSH
7894: CALL_OW 234
// end ; end ;
7898: PPOPN 4
7900: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if gametype = 25 then
7901: LD_EXP 1
7905: PUSH
7906: LD_INT 25
7908: EQUAL
7909: IFFALSE 8018
// begin if origside = 0 then
7911: LD_VAR 0 3
7915: PUSH
7916: LD_INT 0
7918: EQUAL
7919: IFFALSE 7971
// begin SetTag ( vehnew , Rand ( vehdur [ 1 ] , vehdur [ 2 ] ) ) ;
7921: LD_VAR 0 1
7925: PPUSH
7926: LD_EXP 64
7930: PUSH
7931: LD_INT 1
7933: ARRAY
7934: PPUSH
7935: LD_EXP 64
7939: PUSH
7940: LD_INT 2
7942: ARRAY
7943: PPUSH
7944: CALL_OW 12
7948: PPUSH
7949: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
7953: LD_ADDR_EXP 90
7957: PUSH
7958: LD_EXP 90
7962: PUSH
7963: LD_VAR 0 1
7967: ADD
7968: ST_TO_ADDR
// end else
7969: GO 8018
// begin SetUnitDisplayNumber ( vehnew , 0 ) ;
7971: LD_VAR 0 1
7975: PPUSH
7976: LD_INT 0
7978: PPUSH
7979: CALL_OW 505
// SetTag ( vehnew , GetTag ( vehold ) ) ;
7983: LD_VAR 0 1
7987: PPUSH
7988: LD_VAR 0 2
7992: PPUSH
7993: CALL_OW 110
7997: PPUSH
7998: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
8002: LD_ADDR_EXP 90
8006: PUSH
8007: LD_EXP 90
8011: PUSH
8012: LD_VAR 0 1
8016: ADD
8017: ST_TO_ADDR
// end ; end end ; end_of_file
8018: PPOPN 4
8020: END
// every 0 0$1 marked 25 do var i , ends , best ;
8021: GO 8023
8023: DISABLE
8024: LD_INT 0
8026: PPUSH
8027: PPUSH
8028: PPUSH
// begin ends := false ;
8029: LD_ADDR_VAR 0 2
8033: PUSH
8034: LD_INT 0
8036: ST_TO_ADDR
// best := 0 ;
8037: LD_ADDR_VAR 0 3
8041: PUSH
8042: LD_INT 0
8044: ST_TO_ADDR
// for i := 1 to 8 do
8045: LD_ADDR_VAR 0 1
8049: PUSH
8050: DOUBLE
8051: LD_INT 1
8053: DEC
8054: ST_TO_ADDR
8055: LD_INT 8
8057: PUSH
8058: FOR_TO
8059: IFFALSE 8095
// if GetMultiScore ( i ) > best then
8061: LD_VAR 0 1
8065: PPUSH
8066: CALL_OW 507
8070: PUSH
8071: LD_VAR 0 3
8075: GREATER
8076: IFFALSE 8093
// best := GetMultiScore ( i ) ;
8078: LD_ADDR_VAR 0 3
8082: PUSH
8083: LD_VAR 0 1
8087: PPUSH
8088: CALL_OW 507
8092: ST_TO_ADDR
8093: GO 8058
8095: POP
8096: POP
// if point_limit then
8097: LD_EXP 57
8101: IFFALSE 8123
// if best > point_limit then
8103: LD_VAR 0 3
8107: PUSH
8108: LD_EXP 57
8112: GREATER
8113: IFFALSE 8123
// ends := true ;
8115: LD_ADDR_VAR 0 2
8119: PUSH
8120: LD_INT 1
8122: ST_TO_ADDR
// if game_time then
8123: LD_EXP 56
8127: IFFALSE 8149
// if game_time <= tick then
8129: LD_EXP 56
8133: PUSH
8134: LD_OWVAR 1
8138: LESSEQUAL
8139: IFFALSE 8149
// ends := true ;
8141: LD_ADDR_VAR 0 2
8145: PUSH
8146: LD_INT 1
8148: ST_TO_ADDR
// if ends then
8149: LD_VAR 0 2
8153: IFFALSE 8198
// begin if GetMultiScore ( your_side ) = best then
8155: LD_OWVAR 2
8159: PPUSH
8160: CALL_OW 507
8164: PUSH
8165: LD_VAR 0 3
8169: EQUAL
8170: IFFALSE 8185
// begin wait ( 0 0$1 ) ;
8172: LD_INT 35
8174: PPUSH
8175: CALL_OW 67
// YouWinInMultiplayer ;
8179: CALL_OW 106
// end else
8183: GO 8196
// begin wait ( 0 0$1 ) ;
8185: LD_INT 35
8187: PPUSH
8188: CALL_OW 67
// YouLostInMultiplayer ;
8192: CALL_OW 107
// end ; end else
8196: GO 8199
// enable ;
8198: ENABLE
// end ;
8199: PPOPN 3
8201: END
// every 0 0$3 marked 15 do var win , i ;
8202: GO 8204
8204: DISABLE
8205: LD_INT 0
8207: PPUSH
8208: PPUSH
// begin win := true ;
8209: LD_ADDR_VAR 0 1
8213: PUSH
8214: LD_INT 1
8216: ST_TO_ADDR
// for i = 1 to Side_Positions do
8217: LD_ADDR_VAR 0 2
8221: PUSH
8222: DOUBLE
8223: LD_INT 1
8225: DEC
8226: ST_TO_ADDR
8227: LD_EXP 43
8231: PUSH
8232: FOR_TO
8233: IFFALSE 8297
// if Side_Positions [ i ] and ( i <> your_side ) and MultiplayerSideAlive ( i ) then
8235: LD_EXP 43
8239: PUSH
8240: LD_VAR 0 2
8244: ARRAY
8245: PUSH
8246: LD_VAR 0 2
8250: PUSH
8251: LD_OWVAR 2
8255: NONEQUAL
8256: AND
8257: PUSH
8258: LD_VAR 0 2
8262: PPUSH
8263: CALL_OW 108
8267: AND
8268: IFFALSE 8295
// if not AlliedSides ( i , your_side ) then
8270: LD_VAR 0 2
8274: PPUSH
8275: LD_OWVAR 2
8279: PPUSH
8280: CALL 8322 0 2
8284: NOT
8285: IFFALSE 8295
// win := false ;
8287: LD_ADDR_VAR 0 1
8291: PUSH
8292: LD_INT 0
8294: ST_TO_ADDR
8295: GO 8232
8297: POP
8298: POP
// if win then
8299: LD_VAR 0 1
8303: IFFALSE 8318
// begin wait ( 0 0$3 ) ;
8305: LD_INT 105
8307: PPUSH
8308: CALL_OW 67
// YouWinInMultiplayer ;
8312: CALL_OW 106
// exit ;
8316: GO 8319
// end ; enable ;
8318: ENABLE
// end ;
8319: PPOPN 2
8321: END
// function AlliedSides ( i , j ) ; var vysledek ; begin
8322: LD_INT 0
8324: PPUSH
8325: PPUSH
// vysledek := false ;
8326: LD_ADDR_VAR 0 4
8330: PUSH
8331: LD_INT 0
8333: ST_TO_ADDR
// if ( GetAttitude ( i , j ) = att_friend ) and ( GetAttitude ( j , i ) = att_friend ) and GetAlliedVictory ( i ) and GetAlliedVictory ( j ) then
8334: LD_VAR 0 1
8338: PPUSH
8339: LD_VAR 0 2
8343: PPUSH
8344: CALL_OW 81
8348: PUSH
8349: LD_INT 1
8351: EQUAL
8352: PUSH
8353: LD_VAR 0 2
8357: PPUSH
8358: LD_VAR 0 1
8362: PPUSH
8363: CALL_OW 81
8367: PUSH
8368: LD_INT 1
8370: EQUAL
8371: AND
8372: PUSH
8373: LD_VAR 0 1
8377: PPUSH
8378: CALL_OW 83
8382: AND
8383: PUSH
8384: LD_VAR 0 2
8388: PPUSH
8389: CALL_OW 83
8393: AND
8394: IFFALSE 8404
// vysledek := true ;
8396: LD_ADDR_VAR 0 4
8400: PUSH
8401: LD_INT 1
8403: ST_TO_ADDR
// result := vysledek ;
8404: LD_ADDR_VAR 0 3
8408: PUSH
8409: LD_VAR 0 4
8413: ST_TO_ADDR
// end ; end_of_file
8414: LD_VAR 0 3
8418: RET
// export def_hunters , def_hunt_size , def_hunt_balance , def_hunt_limit , def_doctors ; export one_hunter , hunt_limit , size_of_ape_team , size_of_hunt_team , doctors_in_team , hunter_level , ape_level , ape_stamina , to_be_alone , people , scorestring ; function read_multiplayer_and_game_parameters ; var i , p1 , p2 ; begin
8419: LD_INT 0
8421: PPUSH
8422: PPUSH
8423: PPUSH
8424: PPUSH
// if MultiPlayer then
8425: LD_OWVAR 4
8429: IFFALSE 8493
// begin Player_Side = mp_player_side ;
8431: LD_ADDR_EXP 39
8435: PUSH
8436: LD_OWVAR 7
8440: ST_TO_ADDR
// Player_Team = mp_player_team ;
8441: LD_ADDR_EXP 40
8445: PUSH
8446: LD_OWVAR 8
8450: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
8451: LD_ADDR_EXP 43
8455: PUSH
8456: LD_OWVAR 17
8460: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
8461: LD_ADDR_EXP 41
8465: PUSH
8466: LD_OWVAR 15
8470: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
8471: LD_ADDR_EXP 44
8475: PUSH
8476: LD_OWVAR 16
8480: ST_TO_ADDR
// Teams = mp_teams ;
8481: LD_ADDR_EXP 42
8485: PUSH
8486: LD_OWVAR 12
8490: ST_TO_ADDR
// end else
8491: GO 8637
// begin randomize ;
8493: CALL_OW 10
// Player_Side = 1 ;
8497: LD_ADDR_EXP 39
8501: PUSH
8502: LD_INT 1
8504: ST_TO_ADDR
// Player_Team = 0 ;
8505: LD_ADDR_EXP 40
8509: PUSH
8510: LD_INT 0
8512: ST_TO_ADDR
// Side_Positions = [ 1 , 3 , 6 , 0 , 0 , 0 , 0 , 7 ] ;
8513: LD_ADDR_EXP 43
8517: PUSH
8518: LD_INT 1
8520: PUSH
8521: LD_INT 3
8523: PUSH
8524: LD_INT 6
8526: PUSH
8527: LD_INT 0
8529: PUSH
8530: LD_INT 0
8532: PUSH
8533: LD_INT 0
8535: PUSH
8536: LD_INT 0
8538: PUSH
8539: LD_INT 7
8541: PUSH
8542: EMPTY
8543: LIST
8544: LIST
8545: LIST
8546: LIST
8547: LIST
8548: LIST
8549: LIST
8550: LIST
8551: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
8552: LD_ADDR_EXP 41
8556: PUSH
8557: LD_INT 0
8559: PUSH
8560: LD_INT 0
8562: PUSH
8563: LD_INT 0
8565: PUSH
8566: LD_INT 0
8568: PUSH
8569: LD_INT 0
8571: PUSH
8572: LD_INT 0
8574: PUSH
8575: LD_INT 0
8577: PUSH
8578: LD_INT 0
8580: PUSH
8581: EMPTY
8582: LIST
8583: LIST
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 2 , 2 , 2 , 2 ] ;
8591: LD_ADDR_EXP 44
8595: PUSH
8596: LD_INT 1
8598: PUSH
8599: LD_INT 3
8601: PUSH
8602: LD_INT 1
8604: PUSH
8605: LD_INT 2
8607: PUSH
8608: LD_INT 2
8610: PUSH
8611: LD_INT 2
8613: PUSH
8614: LD_INT 2
8616: PUSH
8617: LD_INT 2
8619: PUSH
8620: EMPTY
8621: LIST
8622: LIST
8623: LIST
8624: LIST
8625: LIST
8626: LIST
8627: LIST
8628: LIST
8629: ST_TO_ADDR
// Teams = [ ] ;
8630: LD_ADDR_EXP 42
8634: PUSH
8635: EMPTY
8636: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
8637: LD_ADDR_EXP 37
8641: PUSH
8642: LD_EXP 43
8646: PUSH
8647: LD_INT 0
8649: PUSH
8650: EMPTY
8651: LIST
8652: DIFF
8653: PUSH
8654: LD_INT 0
8656: PLUS
8657: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
8658: LD_ADDR_EXP 38
8662: PUSH
8663: LD_EXP 41
8667: PUSH
8668: LD_INT 0
8670: PUSH
8671: EMPTY
8672: LIST
8673: DIFF
8674: PUSH
8675: LD_INT 0
8677: PLUS
8678: ST_TO_ADDR
// if MultiPlayer then
8679: LD_OWVAR 4
8683: IFFALSE 8739
// begin def_hunt_size = GetMultiplayerSetting ( 1 ) ;
8685: LD_ADDR_EXP 75
8689: PUSH
8690: LD_INT 1
8692: PPUSH
8693: CALL_OW 426
8697: ST_TO_ADDR
// def_hunt_balance = GetMultiplayerSetting ( 2 ) ;
8698: LD_ADDR_EXP 76
8702: PUSH
8703: LD_INT 2
8705: PPUSH
8706: CALL_OW 426
8710: ST_TO_ADDR
// def_hunt_limit = GetMultiplayerSetting ( 3 ) ;
8711: LD_ADDR_EXP 77
8715: PUSH
8716: LD_INT 3
8718: PPUSH
8719: CALL_OW 426
8723: ST_TO_ADDR
// def_doctors = GetMultiplayerSetting ( 4 ) ;
8724: LD_ADDR_EXP 78
8728: PUSH
8729: LD_INT 4
8731: PPUSH
8732: CALL_OW 426
8736: ST_TO_ADDR
// end else
8737: GO 8775
// begin randomize ;
8739: CALL_OW 10
// def_hunt_size = 1 ;
8743: LD_ADDR_EXP 75
8747: PUSH
8748: LD_INT 1
8750: ST_TO_ADDR
// def_hunt_balance = 1 ;
8751: LD_ADDR_EXP 76
8755: PUSH
8756: LD_INT 1
8758: ST_TO_ADDR
// def_hunt_limit = 1 ;
8759: LD_ADDR_EXP 77
8763: PUSH
8764: LD_INT 1
8766: ST_TO_ADDR
// def_doctors = 1 ;
8767: LD_ADDR_EXP 78
8771: PUSH
8772: LD_INT 1
8774: ST_TO_ADDR
// end ; one_hunter = gametype = 36 ;
8775: LD_ADDR_EXP 79
8779: PUSH
8780: LD_EXP 1
8784: PUSH
8785: LD_INT 36
8787: EQUAL
8788: ST_TO_ADDR
// if one_hunter then
8789: LD_EXP 79
8793: IFFALSE 9066
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
8795: LD_ADDR_EXP 80
8799: PUSH
8800: LD_INT 4200
8802: PUSH
8803: LD_INT 6300
8805: PUSH
8806: LD_INT 8400
8808: PUSH
8809: LD_INT 10500
8811: PUSH
8812: EMPTY
8813: LIST
8814: LIST
8815: LIST
8816: LIST
8817: PUSH
8818: LD_EXP 77
8822: PUSH
8823: LD_INT 1
8825: PLUS
8826: ARRAY
8827: ST_TO_ADDR
// p1 = [ 6 , 10 , 12 ] [ def_hunt_size + 1 ] ;
8828: LD_ADDR_VAR 0 3
8832: PUSH
8833: LD_INT 6
8835: PUSH
8836: LD_INT 10
8838: PUSH
8839: LD_INT 12
8841: PUSH
8842: EMPTY
8843: LIST
8844: LIST
8845: LIST
8846: PUSH
8847: LD_EXP 75
8851: PUSH
8852: LD_INT 1
8854: PLUS
8855: ARRAY
8856: ST_TO_ADDR
// p2 = [ 2 , 4 , 6 ] [ def_hunt_size + 1 ] ;
8857: LD_ADDR_VAR 0 4
8861: PUSH
8862: LD_INT 2
8864: PUSH
8865: LD_INT 4
8867: PUSH
8868: LD_INT 6
8870: PUSH
8871: EMPTY
8872: LIST
8873: LIST
8874: LIST
8875: PUSH
8876: LD_EXP 75
8880: PUSH
8881: LD_INT 1
8883: PLUS
8884: ARRAY
8885: ST_TO_ADDR
// size_of_ape_team = p1 div side_count + p2 ;
8886: LD_ADDR_EXP 81
8890: PUSH
8891: LD_VAR 0 3
8895: PUSH
8896: LD_EXP 37
8900: DIV
8901: PUSH
8902: LD_VAR 0 4
8906: PLUS
8907: ST_TO_ADDR
// size_of_hunt_team = size_of_ape_team * ( side_count - 1 ) ;
8908: LD_ADDR_EXP 82
8912: PUSH
8913: LD_EXP 81
8917: PUSH
8918: LD_EXP 37
8922: PUSH
8923: LD_INT 1
8925: MINUS
8926: MUL
8927: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
8928: LD_ADDR_EXP 83
8932: PUSH
8933: LD_INT 0
8935: PUSH
8936: LD_EXP 82
8940: PUSH
8941: LD_INT 5
8943: PLUS
8944: PUSH
8945: LD_INT 6
8947: DIV
8948: PUSH
8949: LD_EXP 82
8953: PUSH
8954: LD_INT 3
8956: PLUS
8957: PUSH
8958: LD_INT 4
8960: DIV
8961: PUSH
8962: EMPTY
8963: LIST
8964: LIST
8965: LIST
8966: PUSH
8967: LD_EXP 78
8971: PUSH
8972: LD_INT 1
8974: PLUS
8975: ARRAY
8976: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
8977: LD_ADDR_EXP 84
8981: PUSH
8982: LD_INT 5
8984: PUSH
8985: LD_INT 3
8987: PUSH
8988: LD_INT 1
8990: PUSH
8991: EMPTY
8992: LIST
8993: LIST
8994: LIST
8995: PUSH
8996: LD_EXP 76
9000: PUSH
9001: LD_INT 1
9003: PLUS
9004: ARRAY
9005: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9006: LD_ADDR_EXP 85
9010: PUSH
9011: LD_INT 1
9013: PUSH
9014: LD_INT 2
9016: PUSH
9017: LD_INT 3
9019: PUSH
9020: EMPTY
9021: LIST
9022: LIST
9023: LIST
9024: PUSH
9025: LD_EXP 76
9029: PUSH
9030: LD_INT 1
9032: PLUS
9033: ARRAY
9034: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9035: LD_ADDR_EXP 86
9039: PUSH
9040: LD_INT 6
9042: PUSH
9043: LD_INT 10
9045: PUSH
9046: LD_INT 13
9048: PUSH
9049: EMPTY
9050: LIST
9051: LIST
9052: LIST
9053: PUSH
9054: LD_EXP 76
9058: PUSH
9059: LD_INT 1
9061: PLUS
9062: ARRAY
9063: ST_TO_ADDR
// end else
9064: GO 9345
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
9066: LD_ADDR_EXP 80
9070: PUSH
9071: LD_INT 4200
9073: PUSH
9074: LD_INT 6300
9076: PUSH
9077: LD_INT 8400
9079: PUSH
9080: LD_INT 10500
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: LIST
9087: LIST
9088: PUSH
9089: LD_EXP 77
9093: PUSH
9094: LD_INT 1
9096: PLUS
9097: ARRAY
9098: ST_TO_ADDR
// p1 = [ 10 , 15 , 20 ] [ def_hunt_size + 1 ] ;
9099: LD_ADDR_VAR 0 3
9103: PUSH
9104: LD_INT 10
9106: PUSH
9107: LD_INT 15
9109: PUSH
9110: LD_INT 20
9112: PUSH
9113: EMPTY
9114: LIST
9115: LIST
9116: LIST
9117: PUSH
9118: LD_EXP 75
9122: PUSH
9123: LD_INT 1
9125: PLUS
9126: ARRAY
9127: ST_TO_ADDR
// p2 = [ 3 , 5 , 7 ] [ def_hunt_size + 1 ] ;
9128: LD_ADDR_VAR 0 4
9132: PUSH
9133: LD_INT 3
9135: PUSH
9136: LD_INT 5
9138: PUSH
9139: LD_INT 7
9141: PUSH
9142: EMPTY
9143: LIST
9144: LIST
9145: LIST
9146: PUSH
9147: LD_EXP 75
9151: PUSH
9152: LD_INT 1
9154: PLUS
9155: ARRAY
9156: ST_TO_ADDR
// size_of_hunt_team = p1 div side_count + p2 ;
9157: LD_ADDR_EXP 82
9161: PUSH
9162: LD_VAR 0 3
9166: PUSH
9167: LD_EXP 37
9171: DIV
9172: PUSH
9173: LD_VAR 0 4
9177: PLUS
9178: ST_TO_ADDR
// size_of_ape_team = ( size_of_hunt_team + size_of_hunt_team * ( side_count - 1 ) ) div 2 ;
9179: LD_ADDR_EXP 81
9183: PUSH
9184: LD_EXP 82
9188: PUSH
9189: LD_EXP 82
9193: PUSH
9194: LD_EXP 37
9198: PUSH
9199: LD_INT 1
9201: MINUS
9202: MUL
9203: PLUS
9204: PUSH
9205: LD_INT 2
9207: DIV
9208: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
9209: LD_ADDR_EXP 83
9213: PUSH
9214: LD_INT 0
9216: PUSH
9217: LD_EXP 82
9221: PUSH
9222: LD_INT 5
9224: PLUS
9225: PUSH
9226: LD_INT 6
9228: DIV
9229: PUSH
9230: LD_EXP 82
9234: PUSH
9235: LD_INT 3
9237: PLUS
9238: PUSH
9239: LD_INT 4
9241: DIV
9242: PUSH
9243: EMPTY
9244: LIST
9245: LIST
9246: LIST
9247: PUSH
9248: LD_EXP 78
9252: PUSH
9253: LD_INT 1
9255: PLUS
9256: ARRAY
9257: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
9258: LD_ADDR_EXP 84
9262: PUSH
9263: LD_INT 5
9265: PUSH
9266: LD_INT 3
9268: PUSH
9269: LD_INT 1
9271: PUSH
9272: EMPTY
9273: LIST
9274: LIST
9275: LIST
9276: PUSH
9277: LD_EXP 76
9281: PUSH
9282: LD_INT 1
9284: PLUS
9285: ARRAY
9286: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9287: LD_ADDR_EXP 85
9291: PUSH
9292: LD_INT 1
9294: PUSH
9295: LD_INT 2
9297: PUSH
9298: LD_INT 3
9300: PUSH
9301: EMPTY
9302: LIST
9303: LIST
9304: LIST
9305: PUSH
9306: LD_EXP 76
9310: PUSH
9311: LD_INT 1
9313: PLUS
9314: ARRAY
9315: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9316: LD_ADDR_EXP 86
9320: PUSH
9321: LD_INT 6
9323: PUSH
9324: LD_INT 10
9326: PUSH
9327: LD_INT 13
9329: PUSH
9330: EMPTY
9331: LIST
9332: LIST
9333: LIST
9334: PUSH
9335: LD_EXP 76
9339: PUSH
9340: LD_INT 1
9342: PLUS
9343: ARRAY
9344: ST_TO_ADDR
// end ; for i = 1 to 8 do
9345: LD_ADDR_VAR 0 2
9349: PUSH
9350: DOUBLE
9351: LD_INT 1
9353: DEC
9354: ST_TO_ADDR
9355: LD_INT 8
9357: PUSH
9358: FOR_TO
9359: IFFALSE 9391
// if Side_Positions [ i ] then
9361: LD_EXP 43
9365: PUSH
9366: LD_VAR 0 2
9370: ARRAY
9371: IFFALSE 9389
// to_be_alone := to_be_alone ^ i ;
9373: LD_ADDR_EXP 87
9377: PUSH
9378: LD_EXP 87
9382: PUSH
9383: LD_VAR 0 2
9387: ADD
9388: ST_TO_ADDR
9389: GO 9358
9391: POP
9392: POP
// end ;
9393: LD_VAR 0 1
9397: RET
// function prepare_hunter_team ( side ) ; var i , team ; begin
9398: LD_INT 0
9400: PPUSH
9401: PPUSH
9402: PPUSH
// team := [ ] ;
9403: LD_ADDR_VAR 0 4
9407: PUSH
9408: EMPTY
9409: ST_TO_ADDR
// for i := 1 to size_of_hunt_team do
9410: LD_ADDR_VAR 0 3
9414: PUSH
9415: DOUBLE
9416: LD_INT 1
9418: DEC
9419: ST_TO_ADDR
9420: LD_EXP 82
9424: PUSH
9425: FOR_TO
9426: IFFALSE 9543
// begin uc_nation := side_nations [ side ] ;
9428: LD_ADDR_OWVAR 21
9432: PUSH
9433: LD_EXP 44
9437: PUSH
9438: LD_VAR 0 1
9442: ARRAY
9443: ST_TO_ADDR
// uc_side := side ;
9444: LD_ADDR_OWVAR 20
9448: PUSH
9449: LD_VAR 0 1
9453: ST_TO_ADDR
// hc_name :=  ;
9454: LD_ADDR_OWVAR 26
9458: PUSH
9459: LD_STRING 
9461: ST_TO_ADDR
// if i > size_of_hunt_team - doctors_in_team then
9462: LD_VAR 0 3
9466: PUSH
9467: LD_EXP 82
9471: PUSH
9472: LD_EXP 83
9476: MINUS
9477: GREATER
9478: IFFALSE 9494
// PrepareScientist ( 0 , hunter_level ) else
9480: LD_INT 0
9482: PPUSH
9483: LD_EXP 84
9487: PPUSH
9488: CALL_OW 384
9492: GO 9506
// PrepareSoldier ( 0 , hunter_level ) ;
9494: LD_INT 0
9496: PPUSH
9497: LD_EXP 84
9501: PPUSH
9502: CALL_OW 381
// hc_gallery :=  ;
9506: LD_ADDR_OWVAR 33
9510: PUSH
9511: LD_STRING 
9513: ST_TO_ADDR
// hc_importance := 0 ;
9514: LD_ADDR_OWVAR 32
9518: PUSH
9519: LD_INT 0
9521: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9522: LD_ADDR_VAR 0 4
9526: PUSH
9527: LD_VAR 0 4
9531: PUSH
9532: CALL_OW 44
9536: PUSH
9537: EMPTY
9538: LIST
9539: ADD
9540: ST_TO_ADDR
// end ;
9541: GO 9425
9543: POP
9544: POP
// people := Replace ( people , side , team ) ;
9545: LD_ADDR_EXP 88
9549: PUSH
9550: LD_EXP 88
9554: PPUSH
9555: LD_VAR 0 1
9559: PPUSH
9560: LD_VAR 0 4
9564: PPUSH
9565: CALL_OW 1
9569: ST_TO_ADDR
// end ;
9570: LD_VAR 0 2
9574: RET
// function prepare_ape_team ( side ) ; var i , team ; begin
9575: LD_INT 0
9577: PPUSH
9578: PPUSH
9579: PPUSH
// team := [ ] ;
9580: LD_ADDR_VAR 0 4
9584: PUSH
9585: EMPTY
9586: ST_TO_ADDR
// for i := 1 to size_of_ape_team do
9587: LD_ADDR_VAR 0 3
9591: PUSH
9592: DOUBLE
9593: LD_INT 1
9595: DEC
9596: ST_TO_ADDR
9597: LD_EXP 81
9601: PUSH
9602: FOR_TO
9603: IFFALSE 9726
// begin uc_nation := nation_nature ;
9605: LD_ADDR_OWVAR 21
9609: PUSH
9610: LD_INT 0
9612: ST_TO_ADDR
// uc_side := side ;
9613: LD_ADDR_OWVAR 20
9617: PUSH
9618: LD_VAR 0 1
9622: ST_TO_ADDR
// hc_name :=  ;
9623: LD_ADDR_OWVAR 26
9627: PUSH
9628: LD_STRING 
9630: ST_TO_ADDR
// hc_attr := [ ape_stamina , 14 ] ;
9631: LD_ADDR_OWVAR 29
9635: PUSH
9636: LD_EXP 86
9640: PUSH
9641: LD_INT 14
9643: PUSH
9644: EMPTY
9645: LIST
9646: LIST
9647: ST_TO_ADDR
// hc_skills := [ ape_level , 0 , 0 , 0 ] ;
9648: LD_ADDR_OWVAR 31
9652: PUSH
9653: LD_EXP 85
9657: PUSH
9658: LD_INT 0
9660: PUSH
9661: LD_INT 0
9663: PUSH
9664: LD_INT 0
9666: PUSH
9667: EMPTY
9668: LIST
9669: LIST
9670: LIST
9671: LIST
9672: ST_TO_ADDR
// hc_sex := sex_male ;
9673: LD_ADDR_OWVAR 27
9677: PUSH
9678: LD_INT 1
9680: ST_TO_ADDR
// hc_class := class_apeman ;
9681: LD_ADDR_OWVAR 28
9685: PUSH
9686: LD_INT 12
9688: ST_TO_ADDR
// hc_gallery :=  ;
9689: LD_ADDR_OWVAR 33
9693: PUSH
9694: LD_STRING 
9696: ST_TO_ADDR
// hc_importance := 0 ;
9697: LD_ADDR_OWVAR 32
9701: PUSH
9702: LD_INT 0
9704: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9705: LD_ADDR_VAR 0 4
9709: PUSH
9710: LD_VAR 0 4
9714: PUSH
9715: CALL_OW 44
9719: PUSH
9720: EMPTY
9721: LIST
9722: ADD
9723: ST_TO_ADDR
// end ;
9724: GO 9602
9726: POP
9727: POP
// people := Replace ( people , side , team ) ;
9728: LD_ADDR_EXP 88
9732: PUSH
9733: LD_EXP 88
9737: PPUSH
9738: LD_VAR 0 1
9742: PPUSH
9743: LD_VAR 0 4
9747: PPUSH
9748: CALL_OW 1
9752: ST_TO_ADDR
// end ;
9753: LD_VAR 0 2
9757: RET
// function display_score ( alone , t ) ; begin
9758: LD_INT 0
9760: PPUSH
// display_strings := scorestring ^  ;
9761: LD_ADDR_OWVAR 47
9765: PUSH
9766: LD_EXP 89
9770: PUSH
9771: LD_STRING 
9773: ADD
9774: ST_TO_ADDR
// if alone then
9775: LD_VAR 0 1
9779: IFFALSE 9859
// if one_hunter then
9781: LD_EXP 79
9785: IFFALSE 9824
// display_strings := display_strings ^ [ #Hunt-prepare2 , alone , alone , t ] else
9787: LD_ADDR_OWVAR 47
9791: PUSH
9792: LD_OWVAR 47
9796: PUSH
9797: LD_STRING #Hunt-prepare2
9799: PUSH
9800: LD_VAR 0 1
9804: PUSH
9805: LD_VAR 0 1
9809: PUSH
9810: LD_VAR 0 2
9814: PUSH
9815: EMPTY
9816: LIST
9817: LIST
9818: LIST
9819: LIST
9820: ADD
9821: ST_TO_ADDR
9822: GO 9859
// display_strings := display_strings ^ [ #Hunt-prepare1 , alone , alone , t ] ;
9824: LD_ADDR_OWVAR 47
9828: PUSH
9829: LD_OWVAR 47
9833: PUSH
9834: LD_STRING #Hunt-prepare1
9836: PUSH
9837: LD_VAR 0 1
9841: PUSH
9842: LD_VAR 0 1
9846: PUSH
9847: LD_VAR 0 2
9851: PUSH
9852: EMPTY
9853: LIST
9854: LIST
9855: LIST
9856: LIST
9857: ADD
9858: ST_TO_ADDR
// end ;
9859: LD_VAR 0 3
9863: RET
// function set_attitudes ( alone ) ; var i , j ; begin
9864: LD_INT 0
9866: PPUSH
9867: PPUSH
9868: PPUSH
// for i := 1 to 8 do
9869: LD_ADDR_VAR 0 3
9873: PUSH
9874: DOUBLE
9875: LD_INT 1
9877: DEC
9878: ST_TO_ADDR
9879: LD_INT 8
9881: PUSH
9882: FOR_TO
9883: IFFALSE 9973
// for j := 1 to 8 do
9885: LD_ADDR_VAR 0 4
9889: PUSH
9890: DOUBLE
9891: LD_INT 1
9893: DEC
9894: ST_TO_ADDR
9895: LD_INT 8
9897: PUSH
9898: FOR_TO
9899: IFFALSE 9969
// if ( i = alone ) = ( j = alone ) then
9901: LD_VAR 0 3
9905: PUSH
9906: LD_VAR 0 1
9910: EQUAL
9911: PUSH
9912: LD_VAR 0 4
9916: PUSH
9917: LD_VAR 0 1
9921: EQUAL
9922: EQUAL
9923: IFFALSE 9947
// SetAttitude ( i , j , att_friend , true ) else
9925: LD_VAR 0 3
9929: PPUSH
9930: LD_VAR 0 4
9934: PPUSH
9935: LD_INT 1
9937: PPUSH
9938: LD_INT 1
9940: PPUSH
9941: CALL_OW 80
9945: GO 9967
// SetAttitude ( i , j , att_enemy , true ) ;
9947: LD_VAR 0 3
9951: PPUSH
9952: LD_VAR 0 4
9956: PPUSH
9957: LD_INT 2
9959: PPUSH
9960: LD_INT 1
9962: PPUSH
9963: CALL_OW 80
9967: GO 9898
9969: POP
9970: POP
9971: GO 9882
9973: POP
9974: POP
// end ;
9975: LD_VAR 0 2
9979: RET
// function set_technologies ( alone ) ; var i ; begin
9980: LD_INT 0
9982: PPUSH
9983: PPUSH
// for i := 1 to 8 do
9984: LD_ADDR_VAR 0 3
9988: PUSH
9989: DOUBLE
9990: LD_INT 1
9992: DEC
9993: ST_TO_ADDR
9994: LD_INT 8
9996: PUSH
9997: FOR_TO
9998: IFFALSE 10187
// begin if ( alone = i ) = one_hunter then
10000: LD_VAR 0 1
10004: PUSH
10005: LD_VAR 0 3
10009: EQUAL
10010: PUSH
10011: LD_EXP 79
10015: EQUAL
10016: IFFALSE 10080
// begin SetTech ( tech_Opto1 , i , state_disabled ) ;
10018: LD_INT 60
10020: PPUSH
10021: LD_VAR 0 3
10025: PPUSH
10026: LD_INT 0
10028: PPUSH
10029: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_disabled ) ;
10033: LD_INT 61
10035: PPUSH
10036: LD_VAR 0 3
10040: PPUSH
10041: LD_INT 0
10043: PPUSH
10044: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_disabled ) ;
10048: LD_INT 62
10050: PPUSH
10051: LD_VAR 0 3
10055: PPUSH
10056: LD_INT 0
10058: PPUSH
10059: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_disabled ) ;
10063: LD_INT 5
10065: PPUSH
10066: LD_VAR 0 3
10070: PPUSH
10071: LD_INT 0
10073: PPUSH
10074: CALL_OW 322
// end else
10078: GO 10140
// begin SetTech ( tech_Opto1 , i , state_researched ) ;
10080: LD_INT 60
10082: PPUSH
10083: LD_VAR 0 3
10087: PPUSH
10088: LD_INT 2
10090: PPUSH
10091: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_researched ) ;
10095: LD_INT 61
10097: PPUSH
10098: LD_VAR 0 3
10102: PPUSH
10103: LD_INT 2
10105: PPUSH
10106: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_researched ) ;
10110: LD_INT 62
10112: PPUSH
10113: LD_VAR 0 3
10117: PPUSH
10118: LD_INT 2
10120: PPUSH
10121: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_researched ) ;
10125: LD_INT 5
10127: PPUSH
10128: LD_VAR 0 3
10132: PPUSH
10133: LD_INT 2
10135: PPUSH
10136: CALL_OW 322
// end ; SetTech ( tech_Weap1 , i , state_disabled ) ;
10140: LD_INT 51
10142: PPUSH
10143: LD_VAR 0 3
10147: PPUSH
10148: LD_INT 0
10150: PPUSH
10151: CALL_OW 322
// SetTech ( tech_Weap2 , i , state_disabled ) ;
10155: LD_INT 52
10157: PPUSH
10158: LD_VAR 0 3
10162: PPUSH
10163: LD_INT 0
10165: PPUSH
10166: CALL_OW 322
// SetTech ( tech_Weap3 , i , state_disabled ) ;
10170: LD_INT 53
10172: PPUSH
10173: LD_VAR 0 3
10177: PPUSH
10178: LD_INT 0
10180: PPUSH
10181: CALL_OW 322
// end ;
10185: GO 9997
10187: POP
10188: POP
// end ;
10189: LD_VAR 0 2
10193: RET
// function prepare_map_coordinates_more_hunters ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10194: LD_INT 0
10196: PPUSH
10197: PPUSH
10198: PPUSH
10199: PPUSH
10200: PPUSH
10201: PPUSH
10202: PPUSH
10203: PPUSH
// best = 0 ;
10204: LD_ADDR_VAR 0 3
10208: PUSH
10209: LD_INT 0
10211: ST_TO_ADDR
// for n = 1 to 40 do
10212: LD_ADDR_VAR 0 9
10216: PUSH
10217: DOUBLE
10218: LD_INT 1
10220: DEC
10221: ST_TO_ADDR
10222: LD_INT 40
10224: PUSH
10225: FOR_TO
10226: IFFALSE 10534
// begin c = [ ] ;
10228: LD_ADDR_VAR 0 4
10232: PUSH
10233: EMPTY
10234: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10235: LD_ADDR_VAR 0 7
10239: PUSH
10240: DOUBLE
10241: LD_INT 1
10243: DEC
10244: ST_TO_ADDR
10245: LD_EXP 37
10249: PUSH
10250: LD_INT 1
10252: MINUS
10253: PUSH
10254: FOR_TO
10255: IFFALSE 10284
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
10257: LD_ADDR_VAR 0 4
10261: PUSH
10262: LD_VAR 0 4
10266: PUSH
10267: LD_INT 21
10269: PPUSH
10270: LD_INT 0
10272: PPUSH
10273: CALL_OW 16
10277: PUSH
10278: EMPTY
10279: LIST
10280: ADD
10281: ST_TO_ADDR
10282: GO 10254
10284: POP
10285: POP
// minv = 10000 ;
10286: LD_ADDR_VAR 0 6
10290: PUSH
10291: LD_INT 10000
10293: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10294: LD_ADDR_VAR 0 7
10298: PUSH
10299: DOUBLE
10300: LD_INT 1
10302: DEC
10303: ST_TO_ADDR
10304: LD_EXP 37
10308: PUSH
10309: LD_INT 1
10311: MINUS
10312: PUSH
10313: FOR_TO
10314: IFFALSE 10498
// for j = 1 to side_count - 1 do
10316: LD_ADDR_VAR 0 8
10320: PUSH
10321: DOUBLE
10322: LD_INT 1
10324: DEC
10325: ST_TO_ADDR
10326: LD_EXP 37
10330: PUSH
10331: LD_INT 1
10333: MINUS
10334: PUSH
10335: FOR_TO
10336: IFFALSE 10494
// if i <> j then
10338: LD_VAR 0 7
10342: PUSH
10343: LD_VAR 0 8
10347: NONEQUAL
10348: IFFALSE 10492
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10350: LD_VAR 0 4
10354: PUSH
10355: LD_VAR 0 7
10359: ARRAY
10360: PUSH
10361: LD_INT 1
10363: ARRAY
10364: PPUSH
10365: LD_VAR 0 4
10369: PUSH
10370: LD_VAR 0 7
10374: ARRAY
10375: PUSH
10376: LD_INT 2
10378: ARRAY
10379: PPUSH
10380: LD_VAR 0 4
10384: PUSH
10385: LD_VAR 0 8
10389: ARRAY
10390: PUSH
10391: LD_INT 1
10393: ARRAY
10394: PPUSH
10395: LD_VAR 0 4
10399: PUSH
10400: LD_VAR 0 8
10404: ARRAY
10405: PUSH
10406: LD_INT 2
10408: ARRAY
10409: PPUSH
10410: CALL_OW 298
10414: PUSH
10415: LD_VAR 0 6
10419: LESS
10420: IFFALSE 10492
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10422: LD_ADDR_VAR 0 6
10426: PUSH
10427: LD_VAR 0 4
10431: PUSH
10432: LD_VAR 0 7
10436: ARRAY
10437: PUSH
10438: LD_INT 1
10440: ARRAY
10441: PPUSH
10442: LD_VAR 0 4
10446: PUSH
10447: LD_VAR 0 7
10451: ARRAY
10452: PUSH
10453: LD_INT 2
10455: ARRAY
10456: PPUSH
10457: LD_VAR 0 4
10461: PUSH
10462: LD_VAR 0 8
10466: ARRAY
10467: PUSH
10468: LD_INT 1
10470: ARRAY
10471: PPUSH
10472: LD_VAR 0 4
10476: PUSH
10477: LD_VAR 0 8
10481: ARRAY
10482: PUSH
10483: LD_INT 2
10485: ARRAY
10486: PPUSH
10487: CALL_OW 298
10491: ST_TO_ADDR
// end ;
10492: GO 10335
10494: POP
10495: POP
10496: GO 10313
10498: POP
10499: POP
// if minv > best then
10500: LD_VAR 0 6
10504: PUSH
10505: LD_VAR 0 3
10509: GREATER
10510: IFFALSE 10532
// begin best := minv ;
10512: LD_ADDR_VAR 0 3
10516: PUSH
10517: LD_VAR 0 6
10521: ST_TO_ADDR
// bestc := c ;
10522: LD_ADDR_VAR 0 5
10526: PUSH
10527: LD_VAR 0 4
10531: ST_TO_ADDR
// end ; end ;
10532: GO 10225
10534: POP
10535: POP
// coordinates := [ ] ;
10536: LD_ADDR_EXP 34
10540: PUSH
10541: EMPTY
10542: ST_TO_ADDR
// for i = 1 to 8 do
10543: LD_ADDR_VAR 0 7
10547: PUSH
10548: DOUBLE
10549: LD_INT 1
10551: DEC
10552: ST_TO_ADDR
10553: LD_INT 8
10555: PUSH
10556: FOR_TO
10557: IFFALSE 10682
// if i = alone then
10559: LD_VAR 0 7
10563: PUSH
10564: LD_VAR 0 1
10568: EQUAL
10569: IFFALSE 10597
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
10571: LD_ADDR_EXP 34
10575: PUSH
10576: LD_EXP 34
10580: PUSH
10581: LD_INT 81
10583: PUSH
10584: LD_INT 57
10586: PUSH
10587: EMPTY
10588: LIST
10589: LIST
10590: PUSH
10591: EMPTY
10592: LIST
10593: ADD
10594: ST_TO_ADDR
10595: GO 10680
// if ( side_positions [ i ] = 0 ) then
10597: LD_EXP 43
10601: PUSH
10602: LD_VAR 0 7
10606: ARRAY
10607: PUSH
10608: LD_INT 0
10610: EQUAL
10611: IFFALSE 10639
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
10613: LD_ADDR_EXP 34
10617: PUSH
10618: LD_EXP 34
10622: PUSH
10623: LD_INT 0
10625: PUSH
10626: LD_INT 0
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: EMPTY
10634: LIST
10635: ADD
10636: ST_TO_ADDR
10637: GO 10680
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
10639: LD_ADDR_EXP 34
10643: PUSH
10644: LD_EXP 34
10648: PUSH
10649: LD_VAR 0 5
10653: PUSH
10654: LD_INT 1
10656: ARRAY
10657: PUSH
10658: EMPTY
10659: LIST
10660: ADD
10661: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
10662: LD_ADDR_VAR 0 5
10666: PUSH
10667: LD_VAR 0 5
10671: PPUSH
10672: LD_INT 1
10674: PPUSH
10675: CALL_OW 3
10679: ST_TO_ADDR
// end ;
10680: GO 10556
10682: POP
10683: POP
// end ;
10684: LD_VAR 0 2
10688: RET
// function prepare_map_coordinates_one_hunter ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10689: LD_INT 0
10691: PPUSH
10692: PPUSH
10693: PPUSH
10694: PPUSH
10695: PPUSH
10696: PPUSH
10697: PPUSH
10698: PPUSH
// best = 0 ;
10699: LD_ADDR_VAR 0 3
10703: PUSH
10704: LD_INT 0
10706: ST_TO_ADDR
// for n = 1 to 40 do
10707: LD_ADDR_VAR 0 9
10711: PUSH
10712: DOUBLE
10713: LD_INT 1
10715: DEC
10716: ST_TO_ADDR
10717: LD_INT 40
10719: PUSH
10720: FOR_TO
10721: IFFALSE 11029
// begin c = [ ] ;
10723: LD_ADDR_VAR 0 4
10727: PUSH
10728: EMPTY
10729: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10730: LD_ADDR_VAR 0 7
10734: PUSH
10735: DOUBLE
10736: LD_INT 1
10738: DEC
10739: ST_TO_ADDR
10740: LD_EXP 37
10744: PUSH
10745: LD_INT 1
10747: MINUS
10748: PUSH
10749: FOR_TO
10750: IFFALSE 10779
// c := c ^ [ RandHexArea ( arapestart , false ) ] ;
10752: LD_ADDR_VAR 0 4
10756: PUSH
10757: LD_VAR 0 4
10761: PUSH
10762: LD_INT 22
10764: PPUSH
10765: LD_INT 0
10767: PPUSH
10768: CALL_OW 16
10772: PUSH
10773: EMPTY
10774: LIST
10775: ADD
10776: ST_TO_ADDR
10777: GO 10749
10779: POP
10780: POP
// minv = 10000 ;
10781: LD_ADDR_VAR 0 6
10785: PUSH
10786: LD_INT 10000
10788: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10789: LD_ADDR_VAR 0 7
10793: PUSH
10794: DOUBLE
10795: LD_INT 1
10797: DEC
10798: ST_TO_ADDR
10799: LD_EXP 37
10803: PUSH
10804: LD_INT 1
10806: MINUS
10807: PUSH
10808: FOR_TO
10809: IFFALSE 10993
// for j = 1 to side_count - 1 do
10811: LD_ADDR_VAR 0 8
10815: PUSH
10816: DOUBLE
10817: LD_INT 1
10819: DEC
10820: ST_TO_ADDR
10821: LD_EXP 37
10825: PUSH
10826: LD_INT 1
10828: MINUS
10829: PUSH
10830: FOR_TO
10831: IFFALSE 10989
// if i <> j then
10833: LD_VAR 0 7
10837: PUSH
10838: LD_VAR 0 8
10842: NONEQUAL
10843: IFFALSE 10987
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10845: LD_VAR 0 4
10849: PUSH
10850: LD_VAR 0 7
10854: ARRAY
10855: PUSH
10856: LD_INT 1
10858: ARRAY
10859: PPUSH
10860: LD_VAR 0 4
10864: PUSH
10865: LD_VAR 0 7
10869: ARRAY
10870: PUSH
10871: LD_INT 2
10873: ARRAY
10874: PPUSH
10875: LD_VAR 0 4
10879: PUSH
10880: LD_VAR 0 8
10884: ARRAY
10885: PUSH
10886: LD_INT 1
10888: ARRAY
10889: PPUSH
10890: LD_VAR 0 4
10894: PUSH
10895: LD_VAR 0 8
10899: ARRAY
10900: PUSH
10901: LD_INT 2
10903: ARRAY
10904: PPUSH
10905: CALL_OW 298
10909: PUSH
10910: LD_VAR 0 6
10914: LESS
10915: IFFALSE 10987
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10917: LD_ADDR_VAR 0 6
10921: PUSH
10922: LD_VAR 0 4
10926: PUSH
10927: LD_VAR 0 7
10931: ARRAY
10932: PUSH
10933: LD_INT 1
10935: ARRAY
10936: PPUSH
10937: LD_VAR 0 4
10941: PUSH
10942: LD_VAR 0 7
10946: ARRAY
10947: PUSH
10948: LD_INT 2
10950: ARRAY
10951: PPUSH
10952: LD_VAR 0 4
10956: PUSH
10957: LD_VAR 0 8
10961: ARRAY
10962: PUSH
10963: LD_INT 1
10965: ARRAY
10966: PPUSH
10967: LD_VAR 0 4
10971: PUSH
10972: LD_VAR 0 8
10976: ARRAY
10977: PUSH
10978: LD_INT 2
10980: ARRAY
10981: PPUSH
10982: CALL_OW 298
10986: ST_TO_ADDR
// end ;
10987: GO 10830
10989: POP
10990: POP
10991: GO 10808
10993: POP
10994: POP
// if minv > best then
10995: LD_VAR 0 6
10999: PUSH
11000: LD_VAR 0 3
11004: GREATER
11005: IFFALSE 11027
// begin best := minv ;
11007: LD_ADDR_VAR 0 3
11011: PUSH
11012: LD_VAR 0 6
11016: ST_TO_ADDR
// bestc := c ;
11017: LD_ADDR_VAR 0 5
11021: PUSH
11022: LD_VAR 0 4
11026: ST_TO_ADDR
// end ; end ;
11027: GO 10720
11029: POP
11030: POP
// coordinates := [ ] ;
11031: LD_ADDR_EXP 34
11035: PUSH
11036: EMPTY
11037: ST_TO_ADDR
// for i = 1 to 8 do
11038: LD_ADDR_VAR 0 7
11042: PUSH
11043: DOUBLE
11044: LD_INT 1
11046: DEC
11047: ST_TO_ADDR
11048: LD_INT 8
11050: PUSH
11051: FOR_TO
11052: IFFALSE 11177
// if i = alone then
11054: LD_VAR 0 7
11058: PUSH
11059: LD_VAR 0 1
11063: EQUAL
11064: IFFALSE 11092
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
11066: LD_ADDR_EXP 34
11070: PUSH
11071: LD_EXP 34
11075: PUSH
11076: LD_INT 81
11078: PUSH
11079: LD_INT 57
11081: PUSH
11082: EMPTY
11083: LIST
11084: LIST
11085: PUSH
11086: EMPTY
11087: LIST
11088: ADD
11089: ST_TO_ADDR
11090: GO 11175
// if ( side_positions [ i ] = 0 ) then
11092: LD_EXP 43
11096: PUSH
11097: LD_VAR 0 7
11101: ARRAY
11102: PUSH
11103: LD_INT 0
11105: EQUAL
11106: IFFALSE 11134
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
11108: LD_ADDR_EXP 34
11112: PUSH
11113: LD_EXP 34
11117: PUSH
11118: LD_INT 0
11120: PUSH
11121: LD_INT 0
11123: PUSH
11124: EMPTY
11125: LIST
11126: LIST
11127: PUSH
11128: EMPTY
11129: LIST
11130: ADD
11131: ST_TO_ADDR
11132: GO 11175
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
11134: LD_ADDR_EXP 34
11138: PUSH
11139: LD_EXP 34
11143: PUSH
11144: LD_VAR 0 5
11148: PUSH
11149: LD_INT 1
11151: ARRAY
11152: PUSH
11153: EMPTY
11154: LIST
11155: ADD
11156: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
11157: LD_ADDR_VAR 0 5
11161: PUSH
11162: LD_VAR 0 5
11166: PPUSH
11167: LD_INT 1
11169: PPUSH
11170: CALL_OW 3
11174: ST_TO_ADDR
// end ;
11175: GO 11051
11177: POP
11178: POP
// end ;
11179: LD_VAR 0 2
11183: RET
// function prepare_game ( alone ) ; var i , t ; begin
11184: LD_INT 0
11186: PPUSH
11187: PPUSH
11188: PPUSH
// ResetFog ;
11189: CALL_OW 335
// for i := 1 to 8 do
11193: LD_ADDR_VAR 0 3
11197: PUSH
11198: DOUBLE
11199: LD_INT 1
11201: DEC
11202: ST_TO_ADDR
11203: LD_INT 8
11205: PUSH
11206: FOR_TO
11207: IFFALSE 11261
// if Side_Positions [ i ] then
11209: LD_EXP 43
11213: PUSH
11214: LD_VAR 0 3
11218: ARRAY
11219: IFFALSE 11259
// if i = alone then
11221: LD_VAR 0 3
11225: PUSH
11226: LD_VAR 0 1
11230: EQUAL
11231: IFFALSE 11247
// ChangeSideFog ( i , 1 ) else
11233: LD_VAR 0 3
11237: PPUSH
11238: LD_INT 1
11240: PPUSH
11241: CALL_OW 343
11245: GO 11259
// ChangeSideFog ( i , 2 ) ;
11247: LD_VAR 0 3
11251: PPUSH
11252: LD_INT 2
11254: PPUSH
11255: CALL_OW 343
11259: GO 11206
11261: POP
11262: POP
// set_attitudes ( alone ) ;
11263: LD_VAR 0 1
11267: PPUSH
11268: CALL 9864 0 1
// set_technologies ( alone ) ;
11272: LD_VAR 0 1
11276: PPUSH
11277: CALL 9980 0 1
// display_score ( alone , 0 0$8 ) ;
11281: LD_VAR 0 1
11285: PPUSH
11286: LD_INT 280
11288: PPUSH
11289: CALL 9758 0 2
// for i := 1 to 8 do
11293: LD_ADDR_VAR 0 3
11297: PUSH
11298: DOUBLE
11299: LD_INT 1
11301: DEC
11302: ST_TO_ADDR
11303: LD_INT 8
11305: PUSH
11306: FOR_TO
11307: IFFALSE 11361
// if Side_Positions [ i ] then
11309: LD_EXP 43
11313: PUSH
11314: LD_VAR 0 3
11318: ARRAY
11319: IFFALSE 11359
// if ( i = alone ) = ( one_hunter ) then
11321: LD_VAR 0 3
11325: PUSH
11326: LD_VAR 0 1
11330: EQUAL
11331: PUSH
11332: LD_EXP 79
11336: EQUAL
11337: IFFALSE 11350
// prepare_hunter_team ( i ) else
11339: LD_VAR 0 3
11343: PPUSH
11344: CALL 9398 0 1
11348: GO 11359
// prepare_ape_team ( i ) ;
11350: LD_VAR 0 3
11354: PPUSH
11355: CALL 9575 0 1
11359: GO 11306
11361: POP
11362: POP
// t := 8 ;
11363: LD_ADDR_VAR 0 4
11367: PUSH
11368: LD_INT 8
11370: ST_TO_ADDR
// repeat t := t - 1 ;
11371: LD_ADDR_VAR 0 4
11375: PUSH
11376: LD_VAR 0 4
11380: PUSH
11381: LD_INT 1
11383: MINUS
11384: ST_TO_ADDR
// display_score ( alone , t * 0 0$1 ) ;
11385: LD_VAR 0 1
11389: PPUSH
11390: LD_VAR 0 4
11394: PUSH
11395: LD_INT 35
11397: MUL
11398: PPUSH
11399: CALL 9758 0 2
// wait ( 0 0$1 ) ;
11403: LD_INT 35
11405: PPUSH
11406: CALL_OW 67
// until t = 0 ;
11410: LD_VAR 0 4
11414: PUSH
11415: LD_INT 0
11417: EQUAL
11418: IFFALSE 11371
// end ;
11420: LD_VAR 0 2
11424: RET
// function run_game ( alone ) ; var i , un , ape , time , alive , dead , aktsc ; begin
11425: LD_INT 0
11427: PPUSH
11428: PPUSH
11429: PPUSH
11430: PPUSH
11431: PPUSH
11432: PPUSH
11433: PPUSH
11434: PPUSH
// if ( your_side = alone ) <> one_hunter then
11435: LD_OWVAR 2
11439: PUSH
11440: LD_VAR 0 1
11444: EQUAL
11445: PUSH
11446: LD_EXP 79
11450: NONEQUAL
11451: IFFALSE 11463
// music_nat := nation_arabian else
11453: LD_ADDR_OWVAR 71
11457: PUSH
11458: LD_INT 2
11460: ST_TO_ADDR
11461: GO 11479
// music_nat := Side_Nations [ your_side ] ;
11463: LD_ADDR_OWVAR 71
11467: PUSH
11468: LD_EXP 44
11472: PUSH
11473: LD_OWVAR 2
11477: ARRAY
11478: ST_TO_ADDR
// if one_hunter then
11479: LD_EXP 79
11483: IFFALSE 11648
// begin prepare_map_coordinates_one_hunter ( alone ) ;
11485: LD_VAR 0 1
11489: PPUSH
11490: CALL 10689 0 1
// for i := 1 to 8 do
11494: LD_ADDR_VAR 0 3
11498: PUSH
11499: DOUBLE
11500: LD_INT 1
11502: DEC
11503: ST_TO_ADDR
11504: LD_INT 8
11506: PUSH
11507: FOR_TO
11508: IFFALSE 11644
// if side_positions [ i ] then
11510: LD_EXP 43
11514: PUSH
11515: LD_VAR 0 3
11519: ARRAY
11520: IFFALSE 11642
// if i = alone then
11522: LD_VAR 0 3
11526: PUSH
11527: LD_VAR 0 1
11531: EQUAL
11532: IFFALSE 11574
// for un in people [ i ] do
11534: LD_ADDR_VAR 0 4
11538: PUSH
11539: LD_EXP 88
11543: PUSH
11544: LD_VAR 0 3
11548: ARRAY
11549: PUSH
11550: FOR_IN
11551: IFFALSE 11570
// PlaceUnitArea ( un , arstartveh , false ) else
11553: LD_VAR 0 4
11557: PPUSH
11558: LD_INT 21
11560: PPUSH
11561: LD_INT 0
11563: PPUSH
11564: CALL_OW 49
11568: GO 11550
11570: POP
11571: POP
11572: GO 11642
// for un in people [ i ] do
11574: LD_ADDR_VAR 0 4
11578: PUSH
11579: LD_EXP 88
11583: PUSH
11584: LD_VAR 0 3
11588: ARRAY
11589: PUSH
11590: FOR_IN
11591: IFFALSE 11640
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 15 , false ) ;
11593: LD_VAR 0 4
11597: PPUSH
11598: LD_EXP 34
11602: PUSH
11603: LD_VAR 0 3
11607: ARRAY
11608: PUSH
11609: LD_INT 1
11611: ARRAY
11612: PPUSH
11613: LD_EXP 34
11617: PUSH
11618: LD_VAR 0 3
11622: ARRAY
11623: PUSH
11624: LD_INT 2
11626: ARRAY
11627: PPUSH
11628: LD_INT 15
11630: PPUSH
11631: LD_INT 0
11633: PPUSH
11634: CALL_OW 50
11638: GO 11590
11640: POP
11641: POP
11642: GO 11507
11644: POP
11645: POP
// end else
11646: GO 11809
// begin prepare_map_coordinates_more_hunters ( alone ) ;
11648: LD_VAR 0 1
11652: PPUSH
11653: CALL 10194 0 1
// for i := 1 to 8 do
11657: LD_ADDR_VAR 0 3
11661: PUSH
11662: DOUBLE
11663: LD_INT 1
11665: DEC
11666: ST_TO_ADDR
11667: LD_INT 8
11669: PUSH
11670: FOR_TO
11671: IFFALSE 11807
// if side_positions [ i ] then
11673: LD_EXP 43
11677: PUSH
11678: LD_VAR 0 3
11682: ARRAY
11683: IFFALSE 11805
// if i = alone then
11685: LD_VAR 0 3
11689: PUSH
11690: LD_VAR 0 1
11694: EQUAL
11695: IFFALSE 11737
// for un in people [ i ] do
11697: LD_ADDR_VAR 0 4
11701: PUSH
11702: LD_EXP 88
11706: PUSH
11707: LD_VAR 0 3
11711: ARRAY
11712: PUSH
11713: FOR_IN
11714: IFFALSE 11733
// PlaceUnitArea ( un , arapes , false ) else
11716: LD_VAR 0 4
11720: PPUSH
11721: LD_INT 23
11723: PPUSH
11724: LD_INT 0
11726: PPUSH
11727: CALL_OW 49
11731: GO 11713
11733: POP
11734: POP
11735: GO 11805
// for un in people [ i ] do
11737: LD_ADDR_VAR 0 4
11741: PUSH
11742: LD_EXP 88
11746: PUSH
11747: LD_VAR 0 3
11751: ARRAY
11752: PUSH
11753: FOR_IN
11754: IFFALSE 11803
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 4 , false ) ;
11756: LD_VAR 0 4
11760: PPUSH
11761: LD_EXP 34
11765: PUSH
11766: LD_VAR 0 3
11770: ARRAY
11771: PUSH
11772: LD_INT 1
11774: ARRAY
11775: PPUSH
11776: LD_EXP 34
11780: PUSH
11781: LD_VAR 0 3
11785: ARRAY
11786: PUSH
11787: LD_INT 2
11789: ARRAY
11790: PPUSH
11791: LD_INT 4
11793: PPUSH
11794: LD_INT 0
11796: PPUSH
11797: CALL_OW 50
11801: GO 11753
11803: POP
11804: POP
11805: GO 11670
11807: POP
11808: POP
// end ; CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
11809: LD_EXP 34
11813: PUSH
11814: LD_OWVAR 2
11818: ARRAY
11819: PUSH
11820: LD_INT 1
11822: ARRAY
11823: PPUSH
11824: LD_EXP 34
11828: PUSH
11829: LD_OWVAR 2
11833: ARRAY
11834: PUSH
11835: LD_INT 2
11837: ARRAY
11838: PPUSH
11839: CALL_OW 86
// display_score ( 0 , 0 ) ;
11843: LD_INT 0
11845: PPUSH
11846: LD_INT 0
11848: PPUSH
11849: CALL 9758 0 2
// time := hunt_limit div 0 0$1 ;
11853: LD_ADDR_VAR 0 6
11857: PUSH
11858: LD_EXP 80
11862: PUSH
11863: LD_INT 35
11865: DIV
11866: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11867: LD_INT 35
11869: PPUSH
11870: CALL_OW 67
// ape := FilterAllUnits ( [ f_class , class_apeman ] ) + 0 ;
11874: LD_ADDR_VAR 0 5
11878: PUSH
11879: LD_INT 25
11881: PUSH
11882: LD_INT 12
11884: PUSH
11885: EMPTY
11886: LIST
11887: LIST
11888: PPUSH
11889: CALL_OW 69
11893: PUSH
11894: LD_INT 0
11896: PLUS
11897: ST_TO_ADDR
// time := time - 1 ;
11898: LD_ADDR_VAR 0 6
11902: PUSH
11903: LD_VAR 0 6
11907: PUSH
11908: LD_INT 1
11910: MINUS
11911: ST_TO_ADDR
// display_strings := [ #Hunt-Apes , alone , ape , #Hunt-Limit , alone , time * 0 0$1 ] ;
11912: LD_ADDR_OWVAR 47
11916: PUSH
11917: LD_STRING #Hunt-Apes
11919: PUSH
11920: LD_VAR 0 1
11924: PUSH
11925: LD_VAR 0 5
11929: PUSH
11930: LD_STRING #Hunt-Limit
11932: PUSH
11933: LD_VAR 0 1
11937: PUSH
11938: LD_VAR 0 6
11942: PUSH
11943: LD_INT 35
11945: MUL
11946: PUSH
11947: EMPTY
11948: LIST
11949: LIST
11950: LIST
11951: LIST
11952: LIST
11953: LIST
11954: ST_TO_ADDR
// until ( ape = 0 ) or ( time = 0 ) ;
11955: LD_VAR 0 5
11959: PUSH
11960: LD_INT 0
11962: EQUAL
11963: PUSH
11964: LD_VAR 0 6
11968: PUSH
11969: LD_INT 0
11971: EQUAL
11972: OR
11973: IFFALSE 11867
// alive := FilterAllUnits ( [ f_or , [ f_class , class_soldier ] , [ f_class , class_scientistic ] ] ) + 0 ;
11975: LD_ADDR_VAR 0 7
11979: PUSH
11980: LD_INT 2
11982: PUSH
11983: LD_INT 25
11985: PUSH
11986: LD_INT 1
11988: PUSH
11989: EMPTY
11990: LIST
11991: LIST
11992: PUSH
11993: LD_INT 25
11995: PUSH
11996: LD_INT 4
11998: PUSH
11999: EMPTY
12000: LIST
12001: LIST
12002: PUSH
12003: EMPTY
12004: LIST
12005: LIST
12006: LIST
12007: PPUSH
12008: CALL_OW 69
12012: PUSH
12013: LD_INT 0
12015: PLUS
12016: ST_TO_ADDR
// if one_hunter then
12017: LD_EXP 79
12021: IFFALSE 12172
// begin dead := size_of_hunt_team - alive ;
12023: LD_ADDR_VAR 0 8
12027: PUSH
12028: LD_EXP 82
12032: PUSH
12033: LD_VAR 0 7
12037: MINUS
12038: ST_TO_ADDR
// ape := size_of_ape_team * ( side_count - 1 ) - ape ;
12039: LD_ADDR_VAR 0 5
12043: PUSH
12044: LD_EXP 81
12048: PUSH
12049: LD_EXP 37
12053: PUSH
12054: LD_INT 1
12056: MINUS
12057: MUL
12058: PUSH
12059: LD_VAR 0 5
12063: MINUS
12064: ST_TO_ADDR
// aktsc := time + ape * 30 - dead * 20 ;
12065: LD_ADDR_VAR 0 9
12069: PUSH
12070: LD_VAR 0 6
12074: PUSH
12075: LD_VAR 0 5
12079: PUSH
12080: LD_INT 30
12082: MUL
12083: PLUS
12084: PUSH
12085: LD_VAR 0 8
12089: PUSH
12090: LD_INT 20
12092: MUL
12093: MINUS
12094: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score2 , alone , alone , time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12095: LD_ADDR_EXP 89
12099: PUSH
12100: LD_EXP 89
12104: PUSH
12105: LD_STRING #Hunt-score2
12107: PUSH
12108: LD_VAR 0 1
12112: PUSH
12113: LD_VAR 0 1
12117: PUSH
12118: LD_VAR 0 6
12122: PUSH
12123: LD_INT 35
12125: MUL
12126: PUSH
12127: LD_VAR 0 5
12131: PUSH
12132: LD_VAR 0 8
12136: PUSH
12137: LD_INT 0
12139: PUSH
12140: LD_VAR 0 9
12144: PUSH
12145: EMPTY
12146: LIST
12147: LIST
12148: LIST
12149: LIST
12150: LIST
12151: LIST
12152: LIST
12153: LIST
12154: ADD
12155: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12156: LD_VAR 0 1
12160: PPUSH
12161: LD_VAR 0 9
12165: PPUSH
12166: CALL_OW 506
// end else
12170: GO 12319
// begin dead := size_of_hunt_team * ( side_count - 1 ) - alive ;
12172: LD_ADDR_VAR 0 8
12176: PUSH
12177: LD_EXP 82
12181: PUSH
12182: LD_EXP 37
12186: PUSH
12187: LD_INT 1
12189: MINUS
12190: MUL
12191: PUSH
12192: LD_VAR 0 7
12196: MINUS
12197: ST_TO_ADDR
// aktsc := hunt_limit div 0 0$1 - time + ape * 30 + dead * 20 ;
12198: LD_ADDR_VAR 0 9
12202: PUSH
12203: LD_EXP 80
12207: PUSH
12208: LD_INT 35
12210: DIV
12211: PUSH
12212: LD_VAR 0 6
12216: MINUS
12217: PUSH
12218: LD_VAR 0 5
12222: PUSH
12223: LD_INT 30
12225: MUL
12226: PLUS
12227: PUSH
12228: LD_VAR 0 8
12232: PUSH
12233: LD_INT 20
12235: MUL
12236: PLUS
12237: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score1 , alone , alone , hunt_limit - time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12238: LD_ADDR_EXP 89
12242: PUSH
12243: LD_EXP 89
12247: PUSH
12248: LD_STRING #Hunt-score1
12250: PUSH
12251: LD_VAR 0 1
12255: PUSH
12256: LD_VAR 0 1
12260: PUSH
12261: LD_EXP 80
12265: PUSH
12266: LD_VAR 0 6
12270: PUSH
12271: LD_INT 35
12273: MUL
12274: MINUS
12275: PUSH
12276: LD_VAR 0 5
12280: PUSH
12281: LD_VAR 0 8
12285: PUSH
12286: LD_INT 0
12288: PUSH
12289: LD_VAR 0 9
12293: PUSH
12294: EMPTY
12295: LIST
12296: LIST
12297: LIST
12298: LIST
12299: LIST
12300: LIST
12301: LIST
12302: LIST
12303: ADD
12304: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12305: LD_VAR 0 1
12309: PPUSH
12310: LD_VAR 0 9
12314: PPUSH
12315: CALL_OW 506
// end ; end ;
12319: LD_VAR 0 2
12323: RET
// function close_game ( alone ) ; var un ; begin
12324: LD_INT 0
12326: PPUSH
12327: PPUSH
// for un in all_units do
12328: LD_ADDR_VAR 0 3
12332: PUSH
12333: LD_OWVAR 3
12337: PUSH
12338: FOR_IN
12339: IFFALSE 12352
// DestroyUnit ( un ) ;
12341: LD_VAR 0 3
12345: PPUSH
12346: CALL_OW 65
12350: GO 12338
12352: POP
12353: POP
// ResetFog ;
12354: CALL_OW 335
// end ;
12358: LD_VAR 0 2
12362: RET
// export function starting_hunt ; var alone , win , i ; begin
12363: LD_INT 0
12365: PPUSH
12366: PPUSH
12367: PPUSH
12368: PPUSH
// mp_selectmsg := true ;
12369: LD_ADDR_OWVAR 13
12373: PUSH
12374: LD_INT 1
12376: ST_TO_ADDR
// mp_with_score := true ;
12377: LD_ADDR_OWVAR 14
12381: PUSH
12382: LD_INT 1
12384: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
12385: CALL 8419 0 0
// your_side := Player_Side ;
12389: LD_ADDR_OWVAR 2
12393: PUSH
12394: LD_EXP 39
12398: ST_TO_ADDR
// while to_be_alone do
12399: LD_EXP 87
12403: IFFALSE 12474
// begin alone := to_be_alone [ Rand ( 1 , to_be_alone ) ] ;
12405: LD_ADDR_VAR 0 2
12409: PUSH
12410: LD_EXP 87
12414: PUSH
12415: LD_INT 1
12417: PPUSH
12418: LD_EXP 87
12422: PPUSH
12423: CALL_OW 12
12427: ARRAY
12428: ST_TO_ADDR
// to_be_alone := to_be_alone diff alone ;
12429: LD_ADDR_EXP 87
12433: PUSH
12434: LD_EXP 87
12438: PUSH
12439: LD_VAR 0 2
12443: DIFF
12444: ST_TO_ADDR
// prepare_game ( alone ) ;
12445: LD_VAR 0 2
12449: PPUSH
12450: CALL 11184 0 1
// run_game ( alone ) ;
12454: LD_VAR 0 2
12458: PPUSH
12459: CALL 11425 0 1
// close_game ( alone ) ;
12463: LD_VAR 0 2
12467: PPUSH
12468: CALL 12324 0 1
// end ;
12472: GO 12399
// display_score ( 0 , 0 ) ;
12474: LD_INT 0
12476: PPUSH
12477: LD_INT 0
12479: PPUSH
12480: CALL 9758 0 2
// wait ( 0 0$5 ) ;
12484: LD_INT 175
12486: PPUSH
12487: CALL_OW 67
// win := true ;
12491: LD_ADDR_VAR 0 3
12495: PUSH
12496: LD_INT 1
12498: ST_TO_ADDR
// for i := 1 to 8 do
12499: LD_ADDR_VAR 0 4
12503: PUSH
12504: DOUBLE
12505: LD_INT 1
12507: DEC
12508: ST_TO_ADDR
12509: LD_INT 8
12511: PUSH
12512: FOR_TO
12513: IFFALSE 12547
// if GetMultiScore ( i ) > GetMultiScore ( your_side ) then
12515: LD_VAR 0 4
12519: PPUSH
12520: CALL_OW 507
12524: PUSH
12525: LD_OWVAR 2
12529: PPUSH
12530: CALL_OW 507
12534: GREATER
12535: IFFALSE 12545
// win := false ;
12537: LD_ADDR_VAR 0 3
12541: PUSH
12542: LD_INT 0
12544: ST_TO_ADDR
12545: GO 12512
12547: POP
12548: POP
// if win then
12549: LD_VAR 0 3
12553: IFFALSE 12561
// YouWinInMultiplayer else
12555: CALL_OW 106
12559: GO 12565
// YouLostInMultiplayer ;
12561: CALL_OW 107
// end ; end_of_file
12565: LD_VAR 0 1
12569: RET
// export to_be_countdowned ; every 0 0$0.2 trigger to_be_countdowned marked 25 do var who , timer ;
12570: LD_EXP 90
12574: IFFALSE 12745
12576: GO 12578
12578: DISABLE
12579: LD_INT 0
12581: PPUSH
12582: PPUSH
// begin enable ;
12583: ENABLE
// who := to_be_countdowned [ 1 ] ;
12584: LD_ADDR_VAR 0 1
12588: PUSH
12589: LD_EXP 90
12593: PUSH
12594: LD_INT 1
12596: ARRAY
12597: ST_TO_ADDR
// to_be_countdowned := Delete ( to_be_countdowned , 1 ) ;
12598: LD_ADDR_EXP 90
12602: PUSH
12603: LD_EXP 90
12607: PPUSH
12608: LD_INT 1
12610: PPUSH
12611: CALL_OW 3
12615: ST_TO_ADDR
// repeat timer := GetTag ( who ) ;
12616: LD_ADDR_VAR 0 2
12620: PUSH
12621: LD_VAR 0 1
12625: PPUSH
12626: CALL_OW 110
12630: ST_TO_ADDR
// if GetSide ( who ) = your_side then
12631: LD_VAR 0 1
12635: PPUSH
12636: CALL_OW 255
12640: PUSH
12641: LD_OWVAR 2
12645: EQUAL
12646: IFFALSE 12662
// SetUnitDisplayNumber ( who , timer ) ;
12648: LD_VAR 0 1
12652: PPUSH
12653: LD_VAR 0 2
12657: PPUSH
12658: CALL_OW 505
// timer := timer - 1 ;
12662: LD_ADDR_VAR 0 2
12666: PUSH
12667: LD_VAR 0 2
12671: PUSH
12672: LD_INT 1
12674: MINUS
12675: ST_TO_ADDR
// SetTag ( who , timer ) ;
12676: LD_VAR 0 1
12680: PPUSH
12681: LD_VAR 0 2
12685: PPUSH
12686: CALL_OW 109
// wait ( 0 0$1 ) ;
12690: LD_INT 35
12692: PPUSH
12693: CALL_OW 67
// until not IsLive ( who ) or not GetTag ( who ) ;
12697: LD_VAR 0 1
12701: PPUSH
12702: CALL_OW 300
12706: NOT
12707: PUSH
12708: LD_VAR 0 1
12712: PPUSH
12713: CALL_OW 110
12717: NOT
12718: OR
12719: IFFALSE 12616
// if not GetTag ( who ) then
12721: LD_VAR 0 1
12725: PPUSH
12726: CALL_OW 110
12730: NOT
12731: IFFALSE 12745
// SetLives ( who , 0 ) ;
12733: LD_VAR 0 1
12737: PPUSH
12738: LD_INT 0
12740: PPUSH
12741: CALL_OW 234
// end ;
12745: PPOPN 2
12747: END
// every 0 0$0.5 + 0 0$0.05 marked 25 do var un , veh ;
12748: GO 12750
12750: DISABLE
12751: LD_INT 0
12753: PPUSH
12754: PPUSH
// begin veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , f_not , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12755: LD_ADDR_VAR 0 2
12759: PUSH
12760: LD_INT 20
12762: PPUSH
12763: LD_INT 21
12765: PUSH
12766: LD_INT 2
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PUSH
12773: LD_INT 3
12775: PUSH
12776: LD_INT 58
12778: PUSH
12779: EMPTY
12780: LIST
12781: PUSH
12782: LD_INT 3
12784: PUSH
12785: LD_INT 22
12787: PUSH
12788: LD_INT 0
12790: PUSH
12791: EMPTY
12792: LIST
12793: LIST
12794: PUSH
12795: EMPTY
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: PPUSH
12802: CALL_OW 70
12806: ST_TO_ADDR
// for un in veh do
12807: LD_ADDR_VAR 0 1
12811: PUSH
12812: LD_VAR 0 2
12816: PUSH
12817: FOR_IN
12818: IFFALSE 12831
// ComExitVehicle ( veh ) ;
12820: LD_VAR 0 2
12824: PPUSH
12825: CALL_OW 121
12829: GO 12817
12831: POP
12832: POP
// veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12833: LD_ADDR_VAR 0 2
12837: PUSH
12838: LD_INT 20
12840: PPUSH
12841: LD_INT 21
12843: PUSH
12844: LD_INT 2
12846: PUSH
12847: EMPTY
12848: LIST
12849: LIST
12850: PUSH
12851: LD_INT 58
12853: PUSH
12854: EMPTY
12855: LIST
12856: PUSH
12857: LD_INT 3
12859: PUSH
12860: LD_INT 22
12862: PUSH
12863: LD_INT 0
12865: PUSH
12866: EMPTY
12867: LIST
12868: LIST
12869: PUSH
12870: EMPTY
12871: LIST
12872: LIST
12873: LIST
12874: LIST
12875: PPUSH
12876: CALL_OW 70
12880: ST_TO_ADDR
// for un in veh do
12881: LD_ADDR_VAR 0 1
12885: PUSH
12886: LD_VAR 0 2
12890: PUSH
12891: FOR_IN
12892: IFFALSE 12947
// begin SetMultiScore ( GetSide ( un ) , GetMultiScore ( GetSide ( un ) ) + 1 ) ;
12894: LD_VAR 0 1
12898: PPUSH
12899: CALL_OW 255
12903: PPUSH
12904: LD_VAR 0 1
12908: PPUSH
12909: CALL_OW 255
12913: PPUSH
12914: CALL_OW 507
12918: PUSH
12919: LD_INT 1
12921: PLUS
12922: PPUSH
12923: CALL_OW 506
// RemoveUnit ( un ) ;
12927: LD_VAR 0 1
12931: PPUSH
12932: CALL_OW 64
// DestroyUnit ( un ) ;
12936: LD_VAR 0 1
12940: PPUSH
12941: CALL_OW 65
// end ;
12945: GO 12891
12947: POP
12948: POP
// enable ;
12949: ENABLE
// end ;
12950: PPOPN 2
12952: END
// every 0 0$1 + 0 0$0.1 marked 25 do var i , best , nbest , lastbest , s , first , n ;
12953: GO 12955
12955: DISABLE
12956: LD_INT 0
12958: PPUSH
12959: PPUSH
12960: PPUSH
12961: PPUSH
12962: PPUSH
12963: PPUSH
12964: PPUSH
// begin lastbest := 99999 ;
12965: LD_ADDR_VAR 0 4
12969: PUSH
12970: LD_INT 99999
12972: ST_TO_ADDR
// s := [ ] ;
12973: LD_ADDR_VAR 0 5
12977: PUSH
12978: EMPTY
12979: ST_TO_ADDR
// n := 1 ;
12980: LD_ADDR_VAR 0 7
12984: PUSH
12985: LD_INT 1
12987: ST_TO_ADDR
// repeat best := - 99999 ;
12988: LD_ADDR_VAR 0 2
12992: PUSH
12993: LD_INT 99999
12995: NEG
12996: ST_TO_ADDR
// nbest := 0 ;
12997: LD_ADDR_VAR 0 3
13001: PUSH
13002: LD_INT 0
13004: ST_TO_ADDR
// for i := 1 to 8 do
13005: LD_ADDR_VAR 0 1
13009: PUSH
13010: DOUBLE
13011: LD_INT 1
13013: DEC
13014: ST_TO_ADDR
13015: LD_INT 8
13017: PUSH
13018: FOR_TO
13019: IFFALSE 13125
// if Side_Positions [ i ] then
13021: LD_EXP 43
13025: PUSH
13026: LD_VAR 0 1
13030: ARRAY
13031: IFFALSE 13123
// begin if ( GetMultiScore ( i ) > best ) and ( GetMultiScore ( i ) < lastbest ) then
13033: LD_VAR 0 1
13037: PPUSH
13038: CALL_OW 507
13042: PUSH
13043: LD_VAR 0 2
13047: GREATER
13048: PUSH
13049: LD_VAR 0 1
13053: PPUSH
13054: CALL_OW 507
13058: PUSH
13059: LD_VAR 0 4
13063: LESS
13064: AND
13065: IFFALSE 13092
// begin best := GetMultiScore ( i ) ;
13067: LD_ADDR_VAR 0 2
13071: PUSH
13072: LD_VAR 0 1
13076: PPUSH
13077: CALL_OW 507
13081: ST_TO_ADDR
// nbest := 1 ;
13082: LD_ADDR_VAR 0 3
13086: PUSH
13087: LD_INT 1
13089: ST_TO_ADDR
// end else
13090: GO 13123
// if GetMultiScore ( i ) = best then
13092: LD_VAR 0 1
13096: PPUSH
13097: CALL_OW 507
13101: PUSH
13102: LD_VAR 0 2
13106: EQUAL
13107: IFFALSE 13123
// begin nbest := nbest + 1 ;
13109: LD_ADDR_VAR 0 3
13113: PUSH
13114: LD_VAR 0 3
13118: PUSH
13119: LD_INT 1
13121: PLUS
13122: ST_TO_ADDR
// end ; end ;
13123: GO 13018
13125: POP
13126: POP
// first := true ;
13127: LD_ADDR_VAR 0 6
13131: PUSH
13132: LD_INT 1
13134: ST_TO_ADDR
// if nbest > 0 then
13135: LD_VAR 0 3
13139: PUSH
13140: LD_INT 0
13142: GREATER
13143: IFFALSE 13316
// for i := 1 to 8 do
13145: LD_ADDR_VAR 0 1
13149: PUSH
13150: DOUBLE
13151: LD_INT 1
13153: DEC
13154: ST_TO_ADDR
13155: LD_INT 8
13157: PUSH
13158: FOR_TO
13159: IFFALSE 13314
// if Side_Positions [ i ] then
13161: LD_EXP 43
13165: PUSH
13166: LD_VAR 0 1
13170: ARRAY
13171: IFFALSE 13312
// if GetMultiScore ( i ) = best then
13173: LD_VAR 0 1
13177: PPUSH
13178: CALL_OW 507
13182: PUSH
13183: LD_VAR 0 2
13187: EQUAL
13188: IFFALSE 13312
// if nbest = 1 then
13190: LD_VAR 0 3
13194: PUSH
13195: LD_INT 1
13197: EQUAL
13198: IFFALSE 13249
// s := s ^ [ #Multi-score , n , i , i , i , best ] else
13200: LD_ADDR_VAR 0 5
13204: PUSH
13205: LD_VAR 0 5
13209: PUSH
13210: LD_STRING #Multi-score
13212: PUSH
13213: LD_VAR 0 7
13217: PUSH
13218: LD_VAR 0 1
13222: PUSH
13223: LD_VAR 0 1
13227: PUSH
13228: LD_VAR 0 1
13232: PUSH
13233: LD_VAR 0 2
13237: PUSH
13238: EMPTY
13239: LIST
13240: LIST
13241: LIST
13242: LIST
13243: LIST
13244: LIST
13245: ADD
13246: ST_TO_ADDR
13247: GO 13312
// s := s ^ [ #Multi-score-range , n , n + nbest - 1 , i , i , i , best ] ;
13249: LD_ADDR_VAR 0 5
13253: PUSH
13254: LD_VAR 0 5
13258: PUSH
13259: LD_STRING #Multi-score-range
13261: PUSH
13262: LD_VAR 0 7
13266: PUSH
13267: LD_VAR 0 7
13271: PUSH
13272: LD_VAR 0 3
13276: PLUS
13277: PUSH
13278: LD_INT 1
13280: MINUS
13281: PUSH
13282: LD_VAR 0 1
13286: PUSH
13287: LD_VAR 0 1
13291: PUSH
13292: LD_VAR 0 1
13296: PUSH
13297: LD_VAR 0 2
13301: PUSH
13302: EMPTY
13303: LIST
13304: LIST
13305: LIST
13306: LIST
13307: LIST
13308: LIST
13309: LIST
13310: ADD
13311: ST_TO_ADDR
13312: GO 13158
13314: POP
13315: POP
// n := n + nbest ;
13316: LD_ADDR_VAR 0 7
13320: PUSH
13321: LD_VAR 0 7
13325: PUSH
13326: LD_VAR 0 3
13330: PLUS
13331: ST_TO_ADDR
// lastbest := best ;
13332: LD_ADDR_VAR 0 4
13336: PUSH
13337: LD_VAR 0 2
13341: ST_TO_ADDR
// until nbest = 0 ;
13342: LD_VAR 0 3
13346: PUSH
13347: LD_INT 0
13349: EQUAL
13350: IFFALSE 12988
// if game_time then
13352: LD_EXP 56
13356: IFFALSE 13391
// s := [ #Hunt-Limit , 0 , game_time - tick ] ^ s ;
13358: LD_ADDR_VAR 0 5
13362: PUSH
13363: LD_STRING #Hunt-Limit
13365: PUSH
13366: LD_INT 0
13368: PUSH
13369: LD_EXP 56
13373: PUSH
13374: LD_OWVAR 1
13378: MINUS
13379: PUSH
13380: EMPTY
13381: LIST
13382: LIST
13383: LIST
13384: PUSH
13385: LD_VAR 0 5
13389: ADD
13390: ST_TO_ADDR
// display_strings := s ;
13391: LD_ADDR_OWVAR 47
13395: PUSH
13396: LD_VAR 0 5
13400: ST_TO_ADDR
// enable ;
13401: ENABLE
// end ;
13402: PPOPN 7
13404: END
// every 0 0$1 marked 25 do var veh ;
13405: GO 13407
13407: DISABLE
13408: LD_INT 0
13410: PPUSH
// begin repeat repeat veh := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
13411: LD_ADDR_VAR 0 1
13415: PUSH
13416: LD_INT 21
13418: PUSH
13419: LD_INT 2
13421: PUSH
13422: EMPTY
13423: LIST
13424: LIST
13425: PPUSH
13426: CALL_OW 69
13430: ST_TO_ADDR
// wait ( 0 0$3 ) ;
13431: LD_INT 105
13433: PPUSH
13434: CALL_OW 67
// until veh < vehmax ;
13438: LD_VAR 0 1
13442: PUSH
13443: LD_EXP 61
13447: LESS
13448: IFFALSE 13411
// wait ( Rand ( vehresp [ 1 ] div side_count , vehresp [ 2 ] div side_count ) ) ;
13450: LD_EXP 58
13454: PUSH
13455: LD_INT 1
13457: ARRAY
13458: PUSH
13459: LD_EXP 37
13463: DIV
13464: PPUSH
13465: LD_EXP 58
13469: PUSH
13470: LD_INT 2
13472: ARRAY
13473: PUSH
13474: LD_EXP 37
13478: DIV
13479: PPUSH
13480: CALL_OW 12
13484: PPUSH
13485: CALL_OW 67
// vehicles_create_vehicle ( false ) ;
13489: LD_INT 0
13491: PPUSH
13492: CALL 6878 0 1
// until false ;
13496: LD_INT 0
13498: IFFALSE 13411
// end ;
13500: PPOPN 1
13502: END
// every 3 marked 25 do var side , peop ;
13503: GO 13505
13505: DISABLE
13506: LD_INT 0
13508: PPUSH
13509: PPUSH
// begin if not to_resp then
13510: LD_EXP 69
13514: NOT
13515: IFFALSE 13519
// exit ;
13517: GO 13720
// enable ;
13519: ENABLE
// side := to_resp [ 1 ] ;
13520: LD_ADDR_VAR 0 1
13524: PUSH
13525: LD_EXP 69
13529: PUSH
13530: LD_INT 1
13532: ARRAY
13533: ST_TO_ADDR
// to_resp := Delete ( to_resp , 1 ) ;
13534: LD_ADDR_EXP 69
13538: PUSH
13539: LD_EXP 69
13543: PPUSH
13544: LD_INT 1
13546: PPUSH
13547: CALL_OW 3
13551: ST_TO_ADDR
// repeat repeat peop := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_side , side ] , [ f_ok ] ] ) ;
13552: LD_ADDR_VAR 0 2
13556: PUSH
13557: LD_INT 21
13559: PUSH
13560: LD_INT 1
13562: PUSH
13563: EMPTY
13564: LIST
13565: LIST
13566: PUSH
13567: LD_INT 22
13569: PUSH
13570: LD_VAR 0 1
13574: PUSH
13575: EMPTY
13576: LIST
13577: LIST
13578: PUSH
13579: LD_INT 50
13581: PUSH
13582: EMPTY
13583: LIST
13584: PUSH
13585: EMPTY
13586: LIST
13587: LIST
13588: LIST
13589: PPUSH
13590: CALL_OW 69
13594: ST_TO_ADDR
// wait ( 0 0$5 ) ;
13595: LD_INT 175
13597: PPUSH
13598: CALL_OW 67
// until peop < npeop ;
13602: LD_VAR 0 2
13606: PUSH
13607: LD_EXP 65
13611: LESS
13612: IFFALSE 13552
// wait ( Rand ( peopresp [ 1 ] , peopresp [ 2 ] ) ) ;
13614: LD_EXP 66
13618: PUSH
13619: LD_INT 1
13621: ARRAY
13622: PPUSH
13623: LD_EXP 66
13627: PUSH
13628: LD_INT 2
13630: ARRAY
13631: PPUSH
13632: CALL_OW 12
13636: PPUSH
13637: CALL_OW 67
// uc_side := side ;
13641: LD_ADDR_OWVAR 20
13645: PUSH
13646: LD_VAR 0 1
13650: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
13651: LD_ADDR_OWVAR 21
13655: PUSH
13656: LD_EXP 44
13660: PUSH
13661: LD_VAR 0 1
13665: ARRAY
13666: ST_TO_ADDR
// hc_name :=  ;
13667: LD_ADDR_OWVAR 26
13671: PUSH
13672: LD_STRING 
13674: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
13675: LD_INT 0
13677: PPUSH
13678: LD_INT 4
13680: PPUSH
13681: CALL_OW 383
// hc_importance := 0 ;
13685: LD_ADDR_OWVAR 32
13689: PUSH
13690: LD_INT 0
13692: ST_TO_ADDR
// hc_gallery :=  ;
13693: LD_ADDR_OWVAR 33
13697: PUSH
13698: LD_STRING 
13700: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , arstartveh , true ) ;
13701: CALL_OW 44
13705: PPUSH
13706: LD_INT 21
13708: PPUSH
13709: LD_INT 1
13711: PPUSH
13712: CALL_OW 49
// until false ;
13716: LD_INT 0
13718: IFFALSE 13552
// end ;
13720: PPOPN 2
13722: END
// on siberiterocketexploded ( un , x , y ) do SA_OnSiberiteRocketExploded ( un , x , y , Your_Side ) ; end_of_file
13723: LD_VAR 0 1
13727: PPUSH
13728: LD_VAR 0 2
13732: PPUSH
13733: LD_VAR 0 3
13737: PPUSH
13738: LD_OWVAR 2
13742: PPUSH
13743: CALL 14700 0 4
13747: PPOPN 3
13749: END
// every 10 do
13750: GO 13752
13752: DISABLE
// begin if not multiplayer then
13753: LD_OWVAR 4
13757: NOT
13758: IFFALSE 13762
// exit ;
13760: GO 13819
// if ( tick >= 100 ) then
13762: LD_OWVAR 1
13766: PUSH
13767: LD_INT 100
13769: GREATEREQUAL
13770: IFFALSE 13790
// if tick mod 20 = 0 then
13772: LD_OWVAR 1
13776: PUSH
13777: LD_INT 20
13779: MOD
13780: PUSH
13781: LD_INT 0
13783: EQUAL
13784: IFFALSE 13790
// MultiplayerCRC ;
13786: CALL_OW 361
// if ( tick >= 100 ) then
13790: LD_OWVAR 1
13794: PUSH
13795: LD_INT 100
13797: GREATEREQUAL
13798: IFFALSE 13818
// if tick mod 30 = 0 then
13800: LD_OWVAR 1
13804: PUSH
13805: LD_INT 30
13807: MOD
13808: PUSH
13809: LD_INT 0
13811: EQUAL
13812: IFFALSE 13818
// DebugLogAll ;
13814: CALL_OW 360
// enable ;
13818: ENABLE
// end ; end_of_file
13819: END
// export Side_Comps ; export nonCombat , siberite_rocket ; every 1 do
13820: GO 13822
13822: DISABLE
// begin if GetMultiplayerSetting ( 49 ) or iseditor then
13823: LD_INT 49
13825: PPUSH
13826: CALL_OW 426
13830: PUSH
13831: LD_OWVAR 84
13835: OR
13836: IFFALSE 13845
// fogoff ( true ) ;
13838: LD_INT 1
13840: PPUSH
13841: CALL_OW 344
// disable ( 125 ) ;
13845: LD_INT 125
13847: DISABLE_MARKED
// Start_VehicleAI ;
13848: CALL 13853 0 0
// end ;
13852: END
// function Start_VehicleAI ; var i , k ; begin
13853: LD_INT 0
13855: PPUSH
13856: PPUSH
13857: PPUSH
// if multiplayer then
13858: LD_OWVAR 4
13862: IFFALSE 13876
// Side_Comps = mp_sides_comps else
13864: LD_ADDR_EXP 91
13868: PUSH
13869: CALL 14018 0 0
13873: ST_TO_ADDR
13874: GO 13915
// side_comps = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ;
13876: LD_ADDR_EXP 91
13880: PUSH
13881: LD_INT 1
13883: PUSH
13884: LD_INT 1
13886: PUSH
13887: LD_INT 1
13889: PUSH
13890: LD_INT 1
13892: PUSH
13893: LD_INT 1
13895: PUSH
13896: LD_INT 1
13898: PUSH
13899: LD_INT 1
13901: PUSH
13902: LD_INT 1
13904: PUSH
13905: EMPTY
13906: LIST
13907: LIST
13908: LIST
13909: LIST
13910: LIST
13911: LIST
13912: LIST
13913: LIST
13914: ST_TO_ADDR
// k = false ;
13915: LD_ADDR_VAR 0 3
13919: PUSH
13920: LD_INT 0
13922: ST_TO_ADDR
// for i in side_comps do
13923: LD_ADDR_VAR 0 2
13927: PUSH
13928: LD_EXP 91
13932: PUSH
13933: FOR_IN
13934: IFFALSE 13952
// if i then
13936: LD_VAR 0 2
13940: IFFALSE 13950
// k = true ;
13942: LD_ADDR_VAR 0 3
13946: PUSH
13947: LD_INT 1
13949: ST_TO_ADDR
13950: GO 13933
13952: POP
13953: POP
// nonCombat = [ us_radar , us_bulldozer , us_siberium_rocket_remainder , ar_radar , ar_selfpropelled_bomb , ru_bulldozer , ru_siberium_rocket_remainder ] ;
13954: LD_ADDR_EXP 92
13958: PUSH
13959: LD_INT 11
13961: PUSH
13962: LD_INT 14
13964: PUSH
13965: LD_INT 15
13967: PUSH
13968: LD_INT 30
13970: PUSH
13971: LD_INT 29
13973: PUSH
13974: LD_INT 53
13976: PUSH
13977: LD_INT 55
13979: PUSH
13980: EMPTY
13981: LIST
13982: LIST
13983: LIST
13984: LIST
13985: LIST
13986: LIST
13987: LIST
13988: ST_TO_ADDR
// Siberite_Rocket = [ us_siberium_rocket , ru_siberium_rocket ] ;
13989: LD_ADDR_EXP 93
13993: PUSH
13994: LD_INT 8
13996: PUSH
13997: LD_INT 48
13999: PUSH
14000: EMPTY
14001: LIST
14002: LIST
14003: ST_TO_ADDR
// if k then
14004: LD_VAR 0 3
14008: IFFALSE 14013
// enable ( 125 ) ;
14010: LD_INT 125
14012: ENABLE_MARKED
// end ;
14013: LD_VAR 0 1
14017: RET
// function mp_sides_comps ; var c , i ; begin
14018: LD_INT 0
14020: PPUSH
14021: PPUSH
14022: PPUSH
// c = [ ] ;
14023: LD_ADDR_VAR 0 2
14027: PUSH
14028: EMPTY
14029: ST_TO_ADDR
// for i = 1 to 8 do
14030: LD_ADDR_VAR 0 3
14034: PUSH
14035: DOUBLE
14036: LD_INT 1
14038: DEC
14039: ST_TO_ADDR
14040: LD_INT 8
14042: PUSH
14043: FOR_TO
14044: IFFALSE 14069
// c = c ^ Multiplayer_GetPlayerIsComp ( i ) ;
14046: LD_ADDR_VAR 0 2
14050: PUSH
14051: LD_VAR 0 2
14055: PUSH
14056: LD_VAR 0 3
14060: PPUSH
14061: CALL_OW 532
14065: ADD
14066: ST_TO_ADDR
14067: GO 14043
14069: POP
14070: POP
// result = c ;
14071: LD_ADDR_VAR 0 1
14075: PUSH
14076: LD_VAR 0 2
14080: ST_TO_ADDR
// end ;
14081: LD_VAR 0 1
14085: RET
// every 0 0$1 marked 125 do var units , u , veh , k , c , i , hex ;
14086: GO 14088
14088: DISABLE
14089: LD_INT 0
14091: PPUSH
14092: PPUSH
14093: PPUSH
14094: PPUSH
14095: PPUSH
14096: PPUSH
14097: PPUSH
// begin units = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_human ] ] ) ;
14098: LD_ADDR_VAR 0 1
14102: PUSH
14103: LD_INT 52
14105: PUSH
14106: EMPTY
14107: LIST
14108: PUSH
14109: LD_INT 50
14111: PUSH
14112: EMPTY
14113: LIST
14114: PUSH
14115: LD_INT 21
14117: PUSH
14118: LD_INT 1
14120: PUSH
14121: EMPTY
14122: LIST
14123: LIST
14124: PUSH
14125: EMPTY
14126: LIST
14127: LIST
14128: LIST
14129: PPUSH
14130: CALL_OW 69
14134: ST_TO_ADDR
// k = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
14135: LD_ADDR_VAR 0 4
14139: PUSH
14140: LD_INT 52
14142: PUSH
14143: EMPTY
14144: LIST
14145: PUSH
14146: LD_INT 50
14148: PUSH
14149: EMPTY
14150: LIST
14151: PUSH
14152: LD_INT 21
14154: PUSH
14155: LD_INT 2
14157: PUSH
14158: EMPTY
14159: LIST
14160: LIST
14161: PUSH
14162: LD_INT 58
14164: PUSH
14165: EMPTY
14166: LIST
14167: PUSH
14168: EMPTY
14169: LIST
14170: LIST
14171: LIST
14172: LIST
14173: PPUSH
14174: CALL_OW 69
14178: ST_TO_ADDR
// for u in units do
14179: LD_ADDR_VAR 0 2
14183: PUSH
14184: LD_VAR 0 1
14188: PUSH
14189: FOR_IN
14190: IFFALSE 14261
// if getSide ( u ) = 0 then
14192: LD_VAR 0 2
14196: PPUSH
14197: CALL_OW 255
14201: PUSH
14202: LD_INT 0
14204: EQUAL
14205: IFFALSE 14225
// units = units diff u else
14207: LD_ADDR_VAR 0 1
14211: PUSH
14212: LD_VAR 0 1
14216: PUSH
14217: LD_VAR 0 2
14221: DIFF
14222: ST_TO_ADDR
14223: GO 14259
// if not Side_Comps [ getSide ( u ) ] then
14225: LD_EXP 91
14229: PUSH
14230: LD_VAR 0 2
14234: PPUSH
14235: CALL_OW 255
14239: ARRAY
14240: NOT
14241: IFFALSE 14259
// units = units diff u ;
14243: LD_ADDR_VAR 0 1
14247: PUSH
14248: LD_VAR 0 1
14252: PUSH
14253: LD_VAR 0 2
14257: DIFF
14258: ST_TO_ADDR
14259: GO 14189
14261: POP
14262: POP
// for u in units do
14263: LD_ADDR_VAR 0 2
14267: PUSH
14268: LD_VAR 0 1
14272: PUSH
14273: FOR_IN
14274: IFFALSE 14694
// begin if isinunit ( u ) then
14276: LD_VAR 0 2
14280: PPUSH
14281: CALL_OW 310
14285: IFFALSE 14502
// begin veh = isinunit ( u ) ;
14287: LD_ADDR_VAR 0 3
14291: PUSH
14292: LD_VAR 0 2
14296: PPUSH
14297: CALL_OW 310
14301: ST_TO_ADDR
// if not HasTask ( veh ) then
14302: LD_VAR 0 3
14306: PPUSH
14307: CALL_OW 314
14311: NOT
14312: IFFALSE 14500
// begin if getWeapon ( veh ) in nonCombat then
14314: LD_VAR 0 3
14318: PPUSH
14319: CALL_OW 264
14323: PUSH
14324: LD_EXP 92
14328: IN
14329: IFFALSE 14345
// comMoveToArea ( veh , exitarea ) else
14331: LD_VAR 0 3
14335: PPUSH
14336: LD_INT 20
14338: PPUSH
14339: CALL_OW 113
14343: GO 14500
// if getWeapon ( veh ) in Siberite_Rocket then
14345: LD_VAR 0 3
14349: PPUSH
14350: CALL_OW 264
14354: PUSH
14355: LD_EXP 93
14359: IN
14360: IFFALSE 14416
// begin hex = RandHex ( false ) ;
14362: LD_ADDR_VAR 0 7
14366: PUSH
14367: LD_INT 0
14369: PPUSH
14370: CALL_OW 15
14374: ST_TO_ADDR
// ComAttackPlace ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14375: LD_VAR 0 3
14379: PPUSH
14380: LD_VAR 0 7
14384: PUSH
14385: LD_INT 1
14387: ARRAY
14388: PPUSH
14389: LD_VAR 0 7
14393: PUSH
14394: LD_INT 2
14396: ARRAY
14397: PPUSH
14398: CALL_OW 116
// AddComMoveToArea ( veh , exitarea ) ;
14402: LD_VAR 0 3
14406: PPUSH
14407: LD_INT 20
14409: PPUSH
14410: CALL_OW 173
// end else
14414: GO 14500
// if getLives ( veh ) <= hranice_zraneni then
14416: LD_VAR 0 3
14420: PPUSH
14421: CALL_OW 256
14425: PUSH
14426: LD_INT 500
14428: LESSEQUAL
14429: IFFALSE 14445
// comMoveToArea ( veh , exitarea ) else
14431: LD_VAR 0 3
14435: PPUSH
14436: LD_INT 20
14438: PPUSH
14439: CALL_OW 113
14443: GO 14500
// begin hex = RandHexArea ( exitarea , false ) ;
14445: LD_ADDR_VAR 0 7
14449: PUSH
14450: LD_INT 20
14452: PPUSH
14453: LD_INT 0
14455: PPUSH
14456: CALL_OW 16
14460: ST_TO_ADDR
// comAgressiveMove ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14461: LD_VAR 0 3
14465: PPUSH
14466: LD_VAR 0 7
14470: PUSH
14471: LD_INT 1
14473: ARRAY
14474: PPUSH
14475: LD_VAR 0 7
14479: PUSH
14480: LD_INT 2
14482: ARRAY
14483: PPUSH
14484: CALL_OW 114
// AddComMoveToArea ( veh , exitarea ) ;
14488: LD_VAR 0 3
14492: PPUSH
14493: LD_INT 20
14495: PPUSH
14496: CALL_OW 173
// end ; end ; end else
14500: GO 14685
// begin if not HasTask ( u ) then
14502: LD_VAR 0 2
14506: PPUSH
14507: CALL_OW 314
14511: NOT
14512: IFFALSE 14556
// begin hex = RandHex ( false ) ;
14514: LD_ADDR_VAR 0 7
14518: PUSH
14519: LD_INT 0
14521: PPUSH
14522: CALL_OW 15
14526: ST_TO_ADDR
// ComMoveXY ( u , hex [ 1 ] , hex [ 2 ] ) ;
14527: LD_VAR 0 2
14531: PPUSH
14532: LD_VAR 0 7
14536: PUSH
14537: LD_INT 1
14539: ARRAY
14540: PPUSH
14541: LD_VAR 0 7
14545: PUSH
14546: LD_INT 2
14548: ARRAY
14549: PPUSH
14550: CALL_OW 111
// end else
14554: GO 14685
// begin c = [ ] ;
14556: LD_ADDR_VAR 0 5
14560: PUSH
14561: EMPTY
14562: ST_TO_ADDR
// for i in k do
14563: LD_ADDR_VAR 0 6
14567: PUSH
14568: LD_VAR 0 4
14572: PUSH
14573: FOR_IN
14574: IFFALSE 14615
// if See ( getSide ( u ) , i ) then
14576: LD_VAR 0 2
14580: PPUSH
14581: CALL_OW 255
14585: PPUSH
14586: LD_VAR 0 6
14590: PPUSH
14591: CALL_OW 292
14595: IFFALSE 14613
// c = c ^ i ;
14597: LD_ADDR_VAR 0 5
14601: PUSH
14602: LD_VAR 0 5
14606: PUSH
14607: LD_VAR 0 6
14611: ADD
14612: ST_TO_ADDR
14613: GO 14573
14615: POP
14616: POP
// if c + 0 > 0 then
14617: LD_VAR 0 5
14621: PUSH
14622: LD_INT 0
14624: PLUS
14625: PUSH
14626: LD_INT 0
14628: GREATER
14629: IFFALSE 14685
// begin c = NearestUnitToUnit ( c , u ) ;
14631: LD_ADDR_VAR 0 5
14635: PUSH
14636: LD_VAR 0 5
14640: PPUSH
14641: LD_VAR 0 2
14645: PPUSH
14646: CALL_OW 74
14650: ST_TO_ADDR
// if GetDistUnits ( u , c ) < 10 then
14651: LD_VAR 0 2
14655: PPUSH
14656: LD_VAR 0 5
14660: PPUSH
14661: CALL_OW 296
14665: PUSH
14666: LD_INT 10
14668: LESS
14669: IFFALSE 14685
// comEnterUnit ( u , c ) ;
14671: LD_VAR 0 2
14675: PPUSH
14676: LD_VAR 0 5
14680: PPUSH
14681: CALL_OW 120
// end ; end ; end ; wait ( 1 ) ;
14685: LD_INT 1
14687: PPUSH
14688: CALL_OW 67
// end ;
14692: GO 14273
14694: POP
14695: POP
// enable ;
14696: ENABLE
// end ; end_of_file
14697: PPOPN 7
14699: END
// export function SA_OnSiberiteRocketExploded ( siberite_rocket_vehicle , target_x , target_y , requestSide ) ; begin
14700: LD_INT 0
14702: PPUSH
// if GetSide ( siberite_rocket_vehicle ) = requestSide then
14703: LD_VAR 0 1
14707: PPUSH
14708: CALL_OW 255
14712: PUSH
14713: LD_VAR 0 4
14717: EQUAL
14718: IFFALSE 14737
// begin SetAchievement ( ACH_RAD ) ;
14720: LD_STRING ACH_RAD
14722: PPUSH
14723: CALL_OW 543
// SetAchievementEx ( ACH_NL , 1 ) ;
14727: LD_STRING ACH_NL
14729: PPUSH
14730: LD_INT 1
14732: PPUSH
14733: CALL_OW 564
// end end ;
14737: LD_VAR 0 5
14741: RET
// export function SA_Win ( side ) ; begin
14742: LD_INT 0
14744: PPUSH
// case side of 1 :
14745: LD_VAR 0 1
14749: PUSH
14750: LD_INT 1
14752: DOUBLE
14753: EQUAL
14754: IFTRUE 14758
14756: GO 14771
14758: POP
// SetAchievementEx ( ACH_AH , 1 ) ; 2 :
14759: LD_STRING ACH_AH
14761: PPUSH
14762: LD_INT 1
14764: PPUSH
14765: CALL_OW 564
14769: GO 14934
14771: LD_INT 2
14773: DOUBLE
14774: EQUAL
14775: IFTRUE 14779
14777: GO 14792
14779: POP
// SetAchievementEx ( ACH_E , 1 ) ; 3 :
14780: LD_STRING ACH_E
14782: PPUSH
14783: LD_INT 1
14785: PPUSH
14786: CALL_OW 564
14790: GO 14934
14792: LD_INT 3
14794: DOUBLE
14795: EQUAL
14796: IFTRUE 14800
14798: GO 14813
14800: POP
// SetAchievementEx ( ACH_OOL , 1 ) ; [ 1 , 2 ] :
14801: LD_STRING ACH_OOL
14803: PPUSH
14804: LD_INT 1
14806: PPUSH
14807: CALL_OW 564
14811: GO 14934
14813: LD_INT 1
14815: PUSH
14816: LD_INT 2
14818: PUSH
14819: EMPTY
14820: LIST
14821: LIST
14822: DOUBLE
14823: EQUAL
14824: IFTRUE 14828
14826: GO 14853
14828: POP
// begin SetAchievementEx ( ACH_AH , 0.5 ) ;
14829: LD_STRING ACH_AH
14831: PPUSH
14832: LD_REAL  5.00000000000000E-0001
14835: PPUSH
14836: CALL_OW 564
// SetAchievementEx ( ACH_E , 0.5 ) ;
14840: LD_STRING ACH_E
14842: PPUSH
14843: LD_REAL  5.00000000000000E-0001
14846: PPUSH
14847: CALL_OW 564
// end ; [ 2 , 3 ] :
14851: GO 14934
14853: LD_INT 2
14855: PUSH
14856: LD_INT 3
14858: PUSH
14859: EMPTY
14860: LIST
14861: LIST
14862: DOUBLE
14863: EQUAL
14864: IFTRUE 14868
14866: GO 14893
14868: POP
// begin SetAchievementEx ( ACH_OOL , 0.5 ) ;
14869: LD_STRING ACH_OOL
14871: PPUSH
14872: LD_REAL  5.00000000000000E-0001
14875: PPUSH
14876: CALL_OW 564
// SetAchievementEx ( ACH_E , 0.5 ) ;
14880: LD_STRING ACH_E
14882: PPUSH
14883: LD_REAL  5.00000000000000E-0001
14886: PPUSH
14887: CALL_OW 564
// end ; [ 3 , 1 ] :
14891: GO 14934
14893: LD_INT 3
14895: PUSH
14896: LD_INT 1
14898: PUSH
14899: EMPTY
14900: LIST
14901: LIST
14902: DOUBLE
14903: EQUAL
14904: IFTRUE 14908
14906: GO 14933
14908: POP
// begin SetAchievementEx ( ACH_AH , 0.5 ) ;
14909: LD_STRING ACH_AH
14911: PPUSH
14912: LD_REAL  5.00000000000000E-0001
14915: PPUSH
14916: CALL_OW 564
// SetAchievementEx ( ACH_OOL , 0.5 ) ;
14920: LD_STRING ACH_OOL
14922: PPUSH
14923: LD_REAL  5.00000000000000E-0001
14926: PPUSH
14927: CALL_OW 564
// end ; end ;
14931: GO 14934
14933: POP
// end ;
14934: LD_VAR 0 2
14938: RET
