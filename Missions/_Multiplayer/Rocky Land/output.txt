// export gametype ; starting begin if multiplayer then
   0: LD_OWVAR 4
   4: IFFALSE 18
// gametype = mp_game_type else
   6: LD_ADDR_EXP 1
  10: PUSH
  11: LD_OWVAR 6
  15: ST_TO_ADDR
  16: GO 26
// gametype = 25 ;
  18: LD_ADDR_EXP 1
  22: PUSH
  23: LD_INT 25
  25: ST_TO_ADDR
// case gametype of 15 :
  26: LD_EXP 1
  30: PUSH
  31: LD_INT 15
  33: DOUBLE
  34: EQUAL
  35: IFTRUE 39
  37: GO 55
  39: POP
// begin enable ( 15 ) ;
  40: LD_INT 15
  42: ENABLE_MARKED
// disable ( 25 ) ;
  43: LD_INT 25
  45: DISABLE_MARKED
// disable ( 35 ) ;
  46: LD_INT 35
  48: DISABLE_MARKED
// starting_sheherezad ;
  49: CALL 3956 0 0
// end ; 25 :
  53: GO 110
  55: LD_INT 25
  57: DOUBLE
  58: EQUAL
  59: IFTRUE 63
  61: GO 79
  63: POP
// begin enable ( 25 ) ;
  64: LD_INT 25
  66: ENABLE_MARKED
// disable ( 15 ) ;
  67: LD_INT 15
  69: DISABLE_MARKED
// disable ( 35 ) ;
  70: LD_INT 35
  72: DISABLE_MARKED
// starting_vehicles ;
  73: CALL 7336 0 0
// end ; 35 , 36 :
  77: GO 110
  79: LD_INT 35
  81: DOUBLE
  82: EQUAL
  83: IFTRUE 93
  85: LD_INT 36
  87: DOUBLE
  88: EQUAL
  89: IFTRUE 93
  91: GO 109
  93: POP
// begin enable ( 35 ) ;
  94: LD_INT 35
  96: ENABLE_MARKED
// disable ( 15 ) ;
  97: LD_INT 15
  99: DISABLE_MARKED
// disable ( 25 ) ;
 100: LD_INT 25
 102: DISABLE_MARKED
// starting_hunt ;
 103: CALL 12380 0 0
// end ; end ;
 107: GO 110
 109: POP
// end ; end_of_file
 110: END
// export def_sheherezade_speed , def_sheherezade_stamina , def_sheherezade_skills , def_number_of_sheikhs , def_sheikhs_level , def_number_of_soldiers , def_soldiers_level , def_charges_allowed , def_amount_of_apemen , def_apemen_level , def_apemen_abilities , def_number_of_mastodons , def_number_of_tigers , def_time_to_prepare , def_flags ; export shzd_speed , shzd_stamina , shzd_skills , nsh , sh_skills , nsol , sol_skills , nstart_ape , ape_respawning , ape_skills , nmast1 , nmast2 , nmast3 , ntig , tig_respawning , prep_time , flags ; export coordinates , sheherezades , lastunit ; export Side_Count , Team_Count , Player_Side , Player_Team , Side_Teams , Teams ; export Side_Positions , Side_Nations , Side_Names , Team_Names , Team_Game ; function read_multiplayer_and_game_parameters ; var i ; begin
 111: LD_INT 0
 113: PPUSH
 114: PPUSH
// if MultiPlayer then
 115: LD_OWVAR 4
 119: IFFALSE 183
// begin Player_Side = mp_player_side ;
 121: LD_ADDR_EXP 39
 125: PUSH
 126: LD_OWVAR 7
 130: ST_TO_ADDR
// Player_Team = mp_player_team ;
 131: LD_ADDR_EXP 40
 135: PUSH
 136: LD_OWVAR 8
 140: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
 141: LD_ADDR_EXP 43
 145: PUSH
 146: LD_OWVAR 17
 150: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
 151: LD_ADDR_EXP 41
 155: PUSH
 156: LD_OWVAR 15
 160: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
 161: LD_ADDR_EXP 44
 165: PUSH
 166: LD_OWVAR 16
 170: ST_TO_ADDR
// Teams = mp_teams ;
 171: LD_ADDR_EXP 42
 175: PUSH
 176: LD_OWVAR 12
 180: ST_TO_ADDR
// end else
 181: GO 323
// begin Player_Side = 1 ;
 183: LD_ADDR_EXP 39
 187: PUSH
 188: LD_INT 1
 190: ST_TO_ADDR
// Player_Team = 0 ;
 191: LD_ADDR_EXP 40
 195: PUSH
 196: LD_INT 0
 198: ST_TO_ADDR
// Side_Positions = [ 1 , 2 , 3 , 4 , 5 , 0 , 0 , 0 ] ;
 199: LD_ADDR_EXP 43
 203: PUSH
 204: LD_INT 1
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 4
 215: PUSH
 216: LD_INT 5
 218: PUSH
 219: LD_INT 0
 221: PUSH
 222: LD_INT 0
 224: PUSH
 225: LD_INT 0
 227: PUSH
 228: EMPTY
 229: LIST
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 238: LD_ADDR_EXP 41
 242: PUSH
 243: LD_INT 0
 245: PUSH
 246: LD_INT 0
 248: PUSH
 249: LD_INT 0
 251: PUSH
 252: LD_INT 0
 254: PUSH
 255: LD_INT 0
 257: PUSH
 258: LD_INT 0
 260: PUSH
 261: LD_INT 0
 263: PUSH
 264: LD_INT 0
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// Side_Nations = [ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ] ;
 277: LD_ADDR_EXP 44
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 2
 287: PUSH
 288: LD_INT 2
 290: PUSH
 291: LD_INT 2
 293: PUSH
 294: LD_INT 2
 296: PUSH
 297: LD_INT 2
 299: PUSH
 300: LD_INT 2
 302: PUSH
 303: LD_INT 2
 305: PUSH
 306: EMPTY
 307: LIST
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: LIST
 313: LIST
 314: LIST
 315: ST_TO_ADDR
// Teams = [ ] ;
 316: LD_ADDR_EXP 42
 320: PUSH
 321: EMPTY
 322: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
 323: LD_ADDR_EXP 37
 327: PUSH
 328: LD_EXP 43
 332: PUSH
 333: LD_INT 0
 335: PUSH
 336: EMPTY
 337: LIST
 338: DIFF
 339: PUSH
 340: LD_INT 0
 342: PLUS
 343: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
 344: LD_ADDR_EXP 38
 348: PUSH
 349: LD_EXP 41
 353: PUSH
 354: LD_INT 0
 356: PUSH
 357: EMPTY
 358: LIST
 359: DIFF
 360: PUSH
 361: LD_INT 0
 363: PLUS
 364: ST_TO_ADDR
// if MultiPlayer then
 365: LD_OWVAR 4
 369: IFFALSE 568
// begin def_sheherezade_speed = GetMultiplayerSetting ( 0 ) ;
 371: LD_ADDR_EXP 2
 375: PUSH
 376: LD_INT 0
 378: PPUSH
 379: CALL_OW 426
 383: ST_TO_ADDR
// def_sheherezade_stamina = GetMultiplayerSetting ( 1 ) ;
 384: LD_ADDR_EXP 3
 388: PUSH
 389: LD_INT 1
 391: PPUSH
 392: CALL_OW 426
 396: ST_TO_ADDR
// def_sheherezade_skills = GetMultiplayerSetting ( 2 ) ;
 397: LD_ADDR_EXP 4
 401: PUSH
 402: LD_INT 2
 404: PPUSH
 405: CALL_OW 426
 409: ST_TO_ADDR
// def_number_of_sheikhs = GetMultiplayerSetting ( 3 ) ;
 410: LD_ADDR_EXP 5
 414: PUSH
 415: LD_INT 3
 417: PPUSH
 418: CALL_OW 426
 422: ST_TO_ADDR
// def_sheikhs_level = GetMultiplayerSetting ( 4 ) ;
 423: LD_ADDR_EXP 6
 427: PUSH
 428: LD_INT 4
 430: PPUSH
 431: CALL_OW 426
 435: ST_TO_ADDR
// def_number_of_soldiers = GetMultiplayerSetting ( 5 ) ;
 436: LD_ADDR_EXP 7
 440: PUSH
 441: LD_INT 5
 443: PPUSH
 444: CALL_OW 426
 448: ST_TO_ADDR
// def_soldiers_level = GetMultiplayerSetting ( 6 ) ;
 449: LD_ADDR_EXP 8
 453: PUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 426
 461: ST_TO_ADDR
// def_charges_allowed = GetMultiplayerSetting ( 7 ) ;
 462: LD_ADDR_EXP 9
 466: PUSH
 467: LD_INT 7
 469: PPUSH
 470: CALL_OW 426
 474: ST_TO_ADDR
// def_amount_of_apemen = GetMultiplayerSetting ( 8 ) ;
 475: LD_ADDR_EXP 10
 479: PUSH
 480: LD_INT 8
 482: PPUSH
 483: CALL_OW 426
 487: ST_TO_ADDR
// def_apemen_level = GetMultiplayerSetting ( 9 ) ;
 488: LD_ADDR_EXP 11
 492: PUSH
 493: LD_INT 9
 495: PPUSH
 496: CALL_OW 426
 500: ST_TO_ADDR
// def_apemen_abilities = GetMultiplayerSetting ( 10 ) ;
 501: LD_ADDR_EXP 12
 505: PUSH
 506: LD_INT 10
 508: PPUSH
 509: CALL_OW 426
 513: ST_TO_ADDR
// def_number_of_mastodons = GetMultiplayerSetting ( 11 ) ;
 514: LD_ADDR_EXP 13
 518: PUSH
 519: LD_INT 11
 521: PPUSH
 522: CALL_OW 426
 526: ST_TO_ADDR
// def_number_of_tigers = GetMultiplayerSetting ( 12 ) ;
 527: LD_ADDR_EXP 14
 531: PUSH
 532: LD_INT 12
 534: PPUSH
 535: CALL_OW 426
 539: ST_TO_ADDR
// def_time_to_prepare = GetMultiplayerSetting ( 13 ) ;
 540: LD_ADDR_EXP 15
 544: PUSH
 545: LD_INT 13
 547: PPUSH
 548: CALL_OW 426
 552: ST_TO_ADDR
// def_flags = GetMultiplayerSetting ( 14 ) ;
 553: LD_ADDR_EXP 16
 557: PUSH
 558: LD_INT 14
 560: PPUSH
 561: CALL_OW 426
 565: ST_TO_ADDR
// end else
 566: GO 696
// begin randomize ;
 568: CALL_OW 10
// randomizeAll ;
 572: CALL_OW 11
// def_sheherezade_speed = 1 ;
 576: LD_ADDR_EXP 2
 580: PUSH
 581: LD_INT 1
 583: ST_TO_ADDR
// def_sheherezade_stamina = 1 ;
 584: LD_ADDR_EXP 3
 588: PUSH
 589: LD_INT 1
 591: ST_TO_ADDR
// def_sheherezade_skills = 2 ;
 592: LD_ADDR_EXP 4
 596: PUSH
 597: LD_INT 2
 599: ST_TO_ADDR
// def_number_of_sheikhs = 3 ;
 600: LD_ADDR_EXP 5
 604: PUSH
 605: LD_INT 3
 607: ST_TO_ADDR
// def_sheikhs_level = 2 ;
 608: LD_ADDR_EXP 6
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// def_number_of_soldiers = 3 ;
 616: LD_ADDR_EXP 7
 620: PUSH
 621: LD_INT 3
 623: ST_TO_ADDR
// def_soldiers_level = 1 ;
 624: LD_ADDR_EXP 8
 628: PUSH
 629: LD_INT 1
 631: ST_TO_ADDR
// def_charges_allowed = 3 ;
 632: LD_ADDR_EXP 9
 636: PUSH
 637: LD_INT 3
 639: ST_TO_ADDR
// def_amount_of_apemen = 2 ;
 640: LD_ADDR_EXP 10
 644: PUSH
 645: LD_INT 2
 647: ST_TO_ADDR
// def_apemen_level = 1 ;
 648: LD_ADDR_EXP 11
 652: PUSH
 653: LD_INT 1
 655: ST_TO_ADDR
// def_apemen_abilities = 1 ;
 656: LD_ADDR_EXP 12
 660: PUSH
 661: LD_INT 1
 663: ST_TO_ADDR
// def_number_of_mastodons = 2 ;
 664: LD_ADDR_EXP 13
 668: PUSH
 669: LD_INT 2
 671: ST_TO_ADDR
// def_number_of_tigers = 2 ;
 672: LD_ADDR_EXP 14
 676: PUSH
 677: LD_INT 2
 679: ST_TO_ADDR
// def_time_to_prepare = 2 ;
 680: LD_ADDR_EXP 15
 684: PUSH
 685: LD_INT 2
 687: ST_TO_ADDR
// def_flags = 2 ;
 688: LD_ADDR_EXP 16
 692: PUSH
 693: LD_INT 2
 695: ST_TO_ADDR
// end ; shzd_speed = [ 9 , 12 , 15 ] [ def_sheherezade_speed + 1 ] ;
 696: LD_ADDR_EXP 17
 700: PUSH
 701: LD_INT 9
 703: PUSH
 704: LD_INT 12
 706: PUSH
 707: LD_INT 15
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_EXP 2
 719: PUSH
 720: LD_INT 1
 722: PLUS
 723: ARRAY
 724: ST_TO_ADDR
// shzd_stamina = [ 6 , 10 , 15 ] [ def_sheherezade_stamina + 1 ] ;
 725: LD_ADDR_EXP 18
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 10
 735: PUSH
 736: LD_INT 15
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: PUSH
 744: LD_EXP 3
 748: PUSH
 749: LD_INT 1
 751: PLUS
 752: ARRAY
 753: ST_TO_ADDR
// shzd_skills = [ [ 1 , 0 , 0 , 3 ] , [ 2 , 0 , 0 , 5 ] , [ 3 , 0 , 0 , 7 ] ] [ def_sheherezade_skills + 1 ] ;
 754: LD_ADDR_EXP 19
 758: PUSH
 759: LD_INT 1
 761: PUSH
 762: LD_INT 0
 764: PUSH
 765: LD_INT 0
 767: PUSH
 768: LD_INT 3
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 2
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: LD_INT 5
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 0
 800: PUSH
 801: LD_INT 0
 803: PUSH
 804: LD_INT 7
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: LIST
 817: PUSH
 818: LD_EXP 4
 822: PUSH
 823: LD_INT 1
 825: PLUS
 826: ARRAY
 827: ST_TO_ADDR
// nsh = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_sheikhs + 1 ] ;
 828: LD_ADDR_EXP 20
 832: PUSH
 833: LD_INT 0
 835: PUSH
 836: LD_INT 1
 838: PUSH
 839: LD_INT 2
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 4
 847: PUSH
 848: LD_INT 5
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PUSH
 859: LD_EXP 5
 863: PUSH
 864: LD_INT 1
 866: PLUS
 867: ARRAY
 868: ST_TO_ADDR
// sh_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_sheikhs_level + 1 ] ;
 869: LD_ADDR_EXP 21
 873: PUSH
 874: LD_INT 2
 876: PUSH
 877: LD_INT 1
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 1
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: PUSH
 892: LD_INT 4
 894: PUSH
 895: LD_INT 2
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 2
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: PUSH
 910: LD_INT 6
 912: PUSH
 913: LD_INT 3
 915: PUSH
 916: LD_INT 3
 918: PUSH
 919: LD_INT 3
 921: PUSH
 922: EMPTY
 923: LIST
 924: LIST
 925: LIST
 926: LIST
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: LD_EXP 6
 937: PUSH
 938: LD_INT 1
 940: PLUS
 941: ARRAY
 942: ST_TO_ADDR
// nsol = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_soldiers + 1 ] ;
 943: LD_ADDR_EXP 22
 947: PUSH
 948: LD_INT 0
 950: PUSH
 951: LD_INT 1
 953: PUSH
 954: LD_INT 2
 956: PUSH
 957: LD_INT 3
 959: PUSH
 960: LD_INT 4
 962: PUSH
 963: LD_INT 5
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: LIST
 973: PUSH
 974: LD_EXP 7
 978: PUSH
 979: LD_INT 1
 981: PLUS
 982: ARRAY
 983: ST_TO_ADDR
// sol_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_soldiers_level + 1 ] ;
 984: LD_ADDR_EXP 23
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: LD_INT 1
 994: PUSH
 995: LD_INT 1
 997: PUSH
 998: LD_INT 1
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: LIST
1005: LIST
1006: PUSH
1007: LD_INT 4
1009: PUSH
1010: LD_INT 2
1012: PUSH
1013: LD_INT 2
1015: PUSH
1016: LD_INT 2
1018: PUSH
1019: EMPTY
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: PUSH
1025: LD_INT 6
1027: PUSH
1028: LD_INT 3
1030: PUSH
1031: LD_INT 3
1033: PUSH
1034: LD_INT 3
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PUSH
1043: EMPTY
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: LD_EXP 8
1052: PUSH
1053: LD_INT 1
1055: PLUS
1056: ARRAY
1057: ST_TO_ADDR
// nstart_ape = [ 0 , 2 , 4 , 6 , 8 ] [ def_amount_of_apemen + 1 ] ;
1058: LD_ADDR_EXP 24
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 4
1071: PUSH
1072: LD_INT 6
1074: PUSH
1075: LD_INT 8
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PUSH
1085: LD_EXP 10
1089: PUSH
1090: LD_INT 1
1092: PLUS
1093: ARRAY
1094: ST_TO_ADDR
// ape_respawning = [ 0 , 4 4$00 , 2 2$00 , 1 1$00 , 0 0$30 ] [ def_amount_of_apemen + 1 ] ;
1095: LD_ADDR_EXP 25
1099: PUSH
1100: LD_INT 0
1102: PUSH
1103: LD_INT 8400
1105: PUSH
1106: LD_INT 4200
1108: PUSH
1109: LD_INT 2100
1111: PUSH
1112: LD_INT 1050
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_EXP 10
1126: PUSH
1127: LD_INT 1
1129: PLUS
1130: ARRAY
1131: ST_TO_ADDR
// ape_skills = [ [ 1 , 0 , 0 , 0 ] , [ 3 , 0 , 0 , 0 ] , [ 5 , 0 , 0 , 0 ] ] [ def_apemen_level + 1 ] ;
1132: LD_ADDR_EXP 26
1136: PUSH
1137: LD_INT 1
1139: PUSH
1140: LD_INT 0
1142: PUSH
1143: LD_INT 0
1145: PUSH
1146: LD_INT 0
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 0
1160: PUSH
1161: LD_INT 0
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 0
1178: PUSH
1179: LD_INT 0
1181: PUSH
1182: LD_INT 0
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: LIST
1195: PUSH
1196: LD_EXP 11
1200: PUSH
1201: LD_INT 1
1203: PLUS
1204: ARRAY
1205: ST_TO_ADDR
// nmast1 = [ 0 , 2 , 4 , 6 ] [ def_number_of_mastodons + 1 ] ;
1206: LD_ADDR_EXP 27
1210: PUSH
1211: LD_INT 0
1213: PUSH
1214: LD_INT 2
1216: PUSH
1217: LD_INT 4
1219: PUSH
1220: LD_INT 6
1222: PUSH
1223: EMPTY
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: PUSH
1229: LD_EXP 13
1233: PUSH
1234: LD_INT 1
1236: PLUS
1237: ARRAY
1238: ST_TO_ADDR
// nmast2 = [ 0 , 1 , 2 , 3 ] [ def_number_of_mastodons + 1 ] ;
1239: LD_ADDR_EXP 28
1243: PUSH
1244: LD_INT 0
1246: PUSH
1247: LD_INT 1
1249: PUSH
1250: LD_INT 2
1252: PUSH
1253: LD_INT 3
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: PUSH
1262: LD_EXP 13
1266: PUSH
1267: LD_INT 1
1269: PLUS
1270: ARRAY
1271: ST_TO_ADDR
// nmast3 = [ 0 , 15 , 30 , 45 ] [ def_number_of_mastodons + 1 ] ;
1272: LD_ADDR_EXP 29
1276: PUSH
1277: LD_INT 0
1279: PUSH
1280: LD_INT 15
1282: PUSH
1283: LD_INT 30
1285: PUSH
1286: LD_INT 45
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_EXP 13
1299: PUSH
1300: LD_INT 1
1302: PLUS
1303: ARRAY
1304: ST_TO_ADDR
// ntig = [ 0 , 1 , 3 , 5 ] [ def_number_of_tigers + 1 ] ;
1305: LD_ADDR_EXP 30
1309: PUSH
1310: LD_INT 0
1312: PUSH
1313: LD_INT 1
1315: PUSH
1316: LD_INT 3
1318: PUSH
1319: LD_INT 5
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: PUSH
1328: LD_EXP 14
1332: PUSH
1333: LD_INT 1
1335: PLUS
1336: ARRAY
1337: ST_TO_ADDR
// tig_respawning = [ 0 , 8 8$00 , 4 4$00 , 2 2$00 ] [ def_number_of_tigers + 1 ] ;
1338: LD_ADDR_EXP 31
1342: PUSH
1343: LD_INT 0
1345: PUSH
1346: LD_INT 16800
1348: PUSH
1349: LD_INT 8400
1351: PUSH
1352: LD_INT 4200
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: PUSH
1361: LD_EXP 14
1365: PUSH
1366: LD_INT 1
1368: PLUS
1369: ARRAY
1370: ST_TO_ADDR
// prep_time = [ 0 , 0 0$20 , 0 0$40 , 1 1$20 ] [ def_time_to_prepare + 1 ] ;
1371: LD_ADDR_EXP 32
1375: PUSH
1376: LD_INT 0
1378: PUSH
1379: LD_INT 700
1381: PUSH
1382: LD_INT 1400
1384: PUSH
1385: LD_INT 2800
1387: PUSH
1388: EMPTY
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: PUSH
1394: LD_EXP 15
1398: PUSH
1399: LD_INT 1
1401: PLUS
1402: ARRAY
1403: ST_TO_ADDR
// flags = [ 0 , 25 , 50 , 75 ] [ def_flags + 1 ] ;
1404: LD_ADDR_EXP 33
1408: PUSH
1409: LD_INT 0
1411: PUSH
1412: LD_INT 25
1414: PUSH
1415: LD_INT 50
1417: PUSH
1418: LD_INT 75
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: PUSH
1427: LD_EXP 16
1431: PUSH
1432: LD_INT 1
1434: PLUS
1435: ARRAY
1436: ST_TO_ADDR
// if def_charges_allowed in [ 1 , 3 ] then
1437: LD_EXP 9
1441: PUSH
1442: LD_INT 1
1444: PUSH
1445: LD_INT 3
1447: PUSH
1448: EMPTY
1449: LIST
1450: LIST
1451: IN
1452: IFFALSE 1489
// for i := 1 to 8 do
1454: LD_ADDR_VAR 0 2
1458: PUSH
1459: DOUBLE
1460: LD_INT 1
1462: DEC
1463: ST_TO_ADDR
1464: LD_INT 8
1466: PUSH
1467: FOR_TO
1468: IFFALSE 1487
// SetTech ( tech_RemCharge , i , state_researched ) ;
1470: LD_INT 18
1472: PPUSH
1473: LD_VAR 0 2
1477: PPUSH
1478: LD_INT 2
1480: PPUSH
1481: CALL_OW 322
1485: GO 1467
1487: POP
1488: POP
// if def_charges_allowed in [ 1 , 3 ] then
1489: LD_EXP 9
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 3
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: IN
1504: IFFALSE 1541
// for i := 1 to 8 do
1506: LD_ADDR_VAR 0 2
1510: PUSH
1511: DOUBLE
1512: LD_INT 1
1514: DEC
1515: ST_TO_ADDR
1516: LD_INT 8
1518: PUSH
1519: FOR_TO
1520: IFFALSE 1539
// SetTech ( tech_Explos , i , state_researched ) ;
1522: LD_INT 42
1524: PPUSH
1525: LD_VAR 0 2
1529: PPUSH
1530: LD_INT 2
1532: PPUSH
1533: CALL_OW 322
1537: GO 1519
1539: POP
1540: POP
// for i := 1 to 8 do
1541: LD_ADDR_VAR 0 2
1545: PUSH
1546: DOUBLE
1547: LD_INT 1
1549: DEC
1550: ST_TO_ADDR
1551: LD_INT 8
1553: PUSH
1554: FOR_TO
1555: IFFALSE 1589
// begin SetTech ( tech_ApeLang , i , state_disabled ) ;
1557: LD_INT 1
1559: PPUSH
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 0
1567: PPUSH
1568: CALL_OW 322
// SetTech ( tech_SibContam , i , state_disabled ) ;
1572: LD_INT 26
1574: PPUSH
1575: LD_VAR 0 2
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL_OW 322
// end ;
1587: GO 1554
1589: POP
1590: POP
// end ;
1591: LD_VAR 0 1
1595: RET
// function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
1596: LD_INT 0
1598: PPUSH
1599: PPUSH
1600: PPUSH
1601: PPUSH
1602: PPUSH
1603: PPUSH
1604: PPUSH
1605: PPUSH
// best = 0 ;
1606: LD_ADDR_VAR 0 2
1610: PUSH
1611: LD_INT 0
1613: ST_TO_ADDR
// for n = 1 to 400 do
1614: LD_ADDR_VAR 0 8
1618: PUSH
1619: DOUBLE
1620: LD_INT 1
1622: DEC
1623: ST_TO_ADDR
1624: LD_INT 400
1626: PUSH
1627: FOR_TO
1628: IFFALSE 1924
// begin c = [ ] ;
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: EMPTY
1636: ST_TO_ADDR
// for i = 1 to side_count do
1637: LD_ADDR_VAR 0 6
1641: PUSH
1642: DOUBLE
1643: LD_INT 1
1645: DEC
1646: ST_TO_ADDR
1647: LD_EXP 37
1651: PUSH
1652: FOR_TO
1653: IFFALSE 1682
// c := c ^ [ RandHexArea ( arstart , false ) ] ;
1655: LD_ADDR_VAR 0 3
1659: PUSH
1660: LD_VAR 0 3
1664: PUSH
1665: LD_INT 7
1667: PPUSH
1668: LD_INT 0
1670: PPUSH
1671: CALL_OW 16
1675: PUSH
1676: EMPTY
1677: LIST
1678: ADD
1679: ST_TO_ADDR
1680: GO 1652
1682: POP
1683: POP
// minv = 10000 ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_INT 10000
1691: ST_TO_ADDR
// for i = 1 to side_count do
1692: LD_ADDR_VAR 0 6
1696: PUSH
1697: DOUBLE
1698: LD_INT 1
1700: DEC
1701: ST_TO_ADDR
1702: LD_EXP 37
1706: PUSH
1707: FOR_TO
1708: IFFALSE 1888
// for j = 1 to side_count do
1710: LD_ADDR_VAR 0 7
1714: PUSH
1715: DOUBLE
1716: LD_INT 1
1718: DEC
1719: ST_TO_ADDR
1720: LD_EXP 37
1724: PUSH
1725: FOR_TO
1726: IFFALSE 1884
// if i <> j then
1728: LD_VAR 0 6
1732: PUSH
1733: LD_VAR 0 7
1737: NONEQUAL
1738: IFFALSE 1882
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
1740: LD_VAR 0 3
1744: PUSH
1745: LD_VAR 0 6
1749: ARRAY
1750: PUSH
1751: LD_INT 1
1753: ARRAY
1754: PPUSH
1755: LD_VAR 0 3
1759: PUSH
1760: LD_VAR 0 6
1764: ARRAY
1765: PUSH
1766: LD_INT 2
1768: ARRAY
1769: PPUSH
1770: LD_VAR 0 3
1774: PUSH
1775: LD_VAR 0 7
1779: ARRAY
1780: PUSH
1781: LD_INT 1
1783: ARRAY
1784: PPUSH
1785: LD_VAR 0 3
1789: PUSH
1790: LD_VAR 0 7
1794: ARRAY
1795: PUSH
1796: LD_INT 2
1798: ARRAY
1799: PPUSH
1800: CALL_OW 298
1804: PUSH
1805: LD_VAR 0 5
1809: LESS
1810: IFFALSE 1882
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
1812: LD_ADDR_VAR 0 5
1816: PUSH
1817: LD_VAR 0 3
1821: PUSH
1822: LD_VAR 0 6
1826: ARRAY
1827: PUSH
1828: LD_INT 1
1830: ARRAY
1831: PPUSH
1832: LD_VAR 0 3
1836: PUSH
1837: LD_VAR 0 6
1841: ARRAY
1842: PUSH
1843: LD_INT 2
1845: ARRAY
1846: PPUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_VAR 0 7
1856: ARRAY
1857: PUSH
1858: LD_INT 1
1860: ARRAY
1861: PPUSH
1862: LD_VAR 0 3
1866: PUSH
1867: LD_VAR 0 7
1871: ARRAY
1872: PUSH
1873: LD_INT 2
1875: ARRAY
1876: PPUSH
1877: CALL_OW 298
1881: ST_TO_ADDR
// end ;
1882: GO 1725
1884: POP
1885: POP
1886: GO 1707
1888: POP
1889: POP
// if minv > best then
1890: LD_VAR 0 5
1894: PUSH
1895: LD_VAR 0 2
1899: GREATER
1900: IFFALSE 1922
// begin best := minv ;
1902: LD_ADDR_VAR 0 2
1906: PUSH
1907: LD_VAR 0 5
1911: ST_TO_ADDR
// bestc := c ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 3
1921: ST_TO_ADDR
// end ; end ;
1922: GO 1627
1924: POP
1925: POP
// coordinates := [ ] ;
1926: LD_ADDR_EXP 34
1930: PUSH
1931: EMPTY
1932: ST_TO_ADDR
// for i = 1 to 8 do
1933: LD_ADDR_VAR 0 6
1937: PUSH
1938: DOUBLE
1939: LD_INT 1
1941: DEC
1942: ST_TO_ADDR
1943: LD_INT 8
1945: PUSH
1946: FOR_TO
1947: IFFALSE 2034
// if side_positions [ i ] = 0 then
1949: LD_EXP 43
1953: PUSH
1954: LD_VAR 0 6
1958: ARRAY
1959: PUSH
1960: LD_INT 0
1962: EQUAL
1963: IFFALSE 1991
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
1965: LD_ADDR_EXP 34
1969: PUSH
1970: LD_EXP 34
1974: PUSH
1975: LD_INT 0
1977: PUSH
1978: LD_INT 0
1980: PUSH
1981: EMPTY
1982: LIST
1983: LIST
1984: PUSH
1985: EMPTY
1986: LIST
1987: ADD
1988: ST_TO_ADDR
1989: GO 2032
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
1991: LD_ADDR_EXP 34
1995: PUSH
1996: LD_EXP 34
2000: PUSH
2001: LD_VAR 0 4
2005: PUSH
2006: LD_INT 1
2008: ARRAY
2009: PUSH
2010: EMPTY
2011: LIST
2012: ADD
2013: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
2014: LD_ADDR_VAR 0 4
2018: PUSH
2019: LD_VAR 0 4
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: CALL_OW 3
2031: ST_TO_ADDR
// end ;
2032: GO 1946
2034: POP
2035: POP
// end ;
2036: LD_VAR 0 1
2040: RET
// function set_attitudes ; var i , j ; begin
2041: LD_INT 0
2043: PPUSH
2044: PPUSH
2045: PPUSH
// if not Team_Game then
2046: LD_EXP 47
2050: NOT
2051: IFFALSE 2147
// begin for i = 1 to 8 do
2053: LD_ADDR_VAR 0 2
2057: PUSH
2058: DOUBLE
2059: LD_INT 1
2061: DEC
2062: ST_TO_ADDR
2063: LD_INT 8
2065: PUSH
2066: FOR_TO
2067: IFFALSE 2145
// for j = 1 to 8 do
2069: LD_ADDR_VAR 0 3
2073: PUSH
2074: DOUBLE
2075: LD_INT 1
2077: DEC
2078: ST_TO_ADDR
2079: LD_INT 8
2081: PUSH
2082: FOR_TO
2083: IFFALSE 2141
// if i <> j then
2085: LD_VAR 0 2
2089: PUSH
2090: LD_VAR 0 3
2094: NONEQUAL
2095: IFFALSE 2119
// SetAttitude ( i , j , att_neutral , true ) else
2097: LD_VAR 0 2
2101: PPUSH
2102: LD_VAR 0 3
2106: PPUSH
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: CALL_OW 80
2117: GO 2139
// SetAttitude ( i , j , att_friend , true ) end ;
2119: LD_VAR 0 2
2123: PPUSH
2124: LD_VAR 0 3
2128: PPUSH
2129: LD_INT 1
2131: PPUSH
2132: LD_INT 1
2134: PPUSH
2135: CALL_OW 80
2139: GO 2082
2141: POP
2142: POP
2143: GO 2066
2145: POP
2146: POP
// end ;
2147: LD_VAR 0 1
2151: RET
// function create_sheherezade ( side ) ; var s ; begin
2152: LD_INT 0
2154: PPUSH
2155: PPUSH
// uc_side := side ;
2156: LD_ADDR_OWVAR 20
2160: PUSH
2161: LD_VAR 0 1
2165: ST_TO_ADDR
// uc_nation := nation_arabian ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 2
2173: ST_TO_ADDR
// hc_name = Sheherezade ;
2174: LD_ADDR_OWVAR 26
2178: PUSH
2179: LD_STRING Sheherezade
2181: ST_TO_ADDR
// hc_sex = sex_female ;
2182: LD_ADDR_OWVAR 27
2186: PUSH
2187: LD_INT 2
2189: ST_TO_ADDR
// hc_class = class_scientistic ;
2190: LD_ADDR_OWVAR 28
2194: PUSH
2195: LD_INT 4
2197: ST_TO_ADDR
// hc_basic_skills = shzd_skills ;
2198: LD_ADDR_OWVAR 30
2202: PUSH
2203: LD_EXP 19
2207: ST_TO_ADDR
// hc_skills = shzd_skills ;
2208: LD_ADDR_OWVAR 31
2212: PUSH
2213: LD_EXP 19
2217: ST_TO_ADDR
// hc_attr = [ shzd_stamina , shzd_speed ] ;
2218: LD_ADDR_OWVAR 29
2222: PUSH
2223: LD_EXP 18
2227: PUSH
2228: LD_EXP 17
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: ST_TO_ADDR
// hc_gallery = multi ;
2237: LD_ADDR_OWVAR 33
2241: PUSH
2242: LD_STRING multi
2244: ST_TO_ADDR
// hc_face_number = 18 ;
2245: LD_ADDR_OWVAR 34
2249: PUSH
2250: LD_INT 18
2252: ST_TO_ADDR
// hc_importance = 105 ;
2253: LD_ADDR_OWVAR 32
2257: PUSH
2258: LD_INT 105
2260: ST_TO_ADDR
// s = CreateHuman ;
2261: LD_ADDR_VAR 0 3
2265: PUSH
2266: CALL_OW 44
2270: ST_TO_ADDR
// PlaceUnitXYR ( s , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 1 , false ) ;
2271: LD_VAR 0 3
2275: PPUSH
2276: LD_EXP 34
2280: PUSH
2281: LD_VAR 0 1
2285: ARRAY
2286: PUSH
2287: LD_INT 1
2289: ARRAY
2290: PPUSH
2291: LD_EXP 34
2295: PUSH
2296: LD_VAR 0 1
2300: ARRAY
2301: PUSH
2302: LD_INT 2
2304: ARRAY
2305: PPUSH
2306: LD_INT 1
2308: PPUSH
2309: LD_INT 0
2311: PPUSH
2312: CALL_OW 50
// sheherezades = Replace ( sheherezades , side , s ) ;
2316: LD_ADDR_EXP 35
2320: PUSH
2321: LD_EXP 35
2325: PPUSH
2326: LD_VAR 0 1
2330: PPUSH
2331: LD_VAR 0 3
2335: PPUSH
2336: CALL_OW 1
2340: ST_TO_ADDR
// end ;
2341: LD_VAR 0 2
2345: RET
// function prepare_sides ; var i ; begin
2346: LD_INT 0
2348: PPUSH
2349: PPUSH
// for i := 1 to 8 do
2350: LD_ADDR_VAR 0 2
2354: PUSH
2355: DOUBLE
2356: LD_INT 1
2358: DEC
2359: ST_TO_ADDR
2360: LD_INT 8
2362: PUSH
2363: FOR_TO
2364: IFFALSE 2389
// if side_positions [ i ] then
2366: LD_EXP 43
2370: PUSH
2371: LD_VAR 0 2
2375: ARRAY
2376: IFFALSE 2387
// create_sheherezade ( i ) ;
2378: LD_VAR 0 2
2382: PPUSH
2383: CALL 2152 0 1
2387: GO 2363
2389: POP
2390: POP
// if prep_time = 0 then
2391: LD_EXP 32
2395: PUSH
2396: LD_INT 0
2398: EQUAL
2399: IFFALSE 2405
// sheherezade_start_the_fight ;
2401: CALL 3720 0 0
// end ;
2405: LD_VAR 0 1
2409: RET
// function prepare_side_to_the_fight ( side , materialization ) ; var x , y , i , sh , sol ; begin
2410: LD_INT 0
2412: PPUSH
2413: PPUSH
2414: PPUSH
2415: PPUSH
2416: PPUSH
2417: PPUSH
// SetTech ( tech_ApeLang , side , state_researched ) ;
2418: LD_INT 1
2420: PPUSH
2421: LD_VAR 0 1
2425: PPUSH
2426: LD_INT 2
2428: PPUSH
2429: CALL_OW 322
// x := GetX ( Sheherezades [ side ] ) ;
2433: LD_ADDR_VAR 0 4
2437: PUSH
2438: LD_EXP 35
2442: PUSH
2443: LD_VAR 0 1
2447: ARRAY
2448: PPUSH
2449: CALL_OW 250
2453: ST_TO_ADDR
// y := GetY ( Sheherezades [ side ] ) ;
2454: LD_ADDR_VAR 0 5
2458: PUSH
2459: LD_EXP 35
2463: PUSH
2464: LD_VAR 0 1
2468: ARRAY
2469: PPUSH
2470: CALL_OW 251
2474: ST_TO_ADDR
// coordinates := Replace ( coordinates , side , [ x , y ] ) ;
2475: LD_ADDR_EXP 34
2479: PUSH
2480: LD_EXP 34
2484: PPUSH
2485: LD_VAR 0 1
2489: PPUSH
2490: LD_VAR 0 4
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PPUSH
2504: CALL_OW 1
2508: ST_TO_ADDR
// if flags then
2509: LD_EXP 33
2513: IFFALSE 2592
// begin SetBattleFlag ( side , x , y , [ [ bfo_defend_bonus_human , flags ] , [ bfo_defend_bonus_vehicle , flags ] , [ bfo_defend_bonus_building , flags ] , [ bfo_height , flags + 25 ] ] ) ;
2515: LD_VAR 0 1
2519: PPUSH
2520: LD_VAR 0 4
2524: PPUSH
2525: LD_VAR 0 5
2529: PPUSH
2530: LD_INT 1
2532: PUSH
2533: LD_EXP 33
2537: PUSH
2538: EMPTY
2539: LIST
2540: LIST
2541: PUSH
2542: LD_INT 2
2544: PUSH
2545: LD_EXP 33
2549: PUSH
2550: EMPTY
2551: LIST
2552: LIST
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: LD_EXP 33
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: PUSH
2566: LD_INT 20
2568: PUSH
2569: LD_EXP 33
2573: PUSH
2574: LD_INT 25
2576: PLUS
2577: PUSH
2578: EMPTY
2579: LIST
2580: LIST
2581: PUSH
2582: EMPTY
2583: LIST
2584: LIST
2585: LIST
2586: LIST
2587: PPUSH
2588: CALL_OW 418
// end ; uc_side := side ;
2592: LD_ADDR_OWVAR 20
2596: PUSH
2597: LD_VAR 0 1
2601: ST_TO_ADDR
// uc_nation := nation_arabian ;
2602: LD_ADDR_OWVAR 21
2606: PUSH
2607: LD_INT 2
2609: ST_TO_ADDR
// hc_name :=  ;
2610: LD_ADDR_OWVAR 26
2614: PUSH
2615: LD_STRING 
2617: ST_TO_ADDR
// hc_class := class_desert_warior ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 11
2625: ST_TO_ADDR
// hc_sex := sex_male ;
2626: LD_ADDR_OWVAR 27
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_basic_skills := sh_skills ;
2634: LD_ADDR_OWVAR 30
2638: PUSH
2639: LD_EXP 21
2643: ST_TO_ADDR
// hc_skills := sh_skills ;
2644: LD_ADDR_OWVAR 31
2648: PUSH
2649: LD_EXP 21
2653: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2654: LD_ADDR_OWVAR 29
2658: PUSH
2659: LD_INT 10
2661: PUSH
2662: LD_INT 10
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: ST_TO_ADDR
// hc_importance := 0 ;
2669: LD_ADDR_OWVAR 32
2673: PUSH
2674: LD_INT 0
2676: ST_TO_ADDR
// hc_gallery :=  ;
2677: LD_ADDR_OWVAR 33
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// for i := 1 to nsol do
2685: LD_ADDR_VAR 0 6
2689: PUSH
2690: DOUBLE
2691: LD_INT 1
2693: DEC
2694: ST_TO_ADDR
2695: LD_EXP 22
2699: PUSH
2700: FOR_TO
2701: IFFALSE 2742
// begin sh := CreateHuman ;
2703: LD_ADDR_VAR 0 7
2707: PUSH
2708: CALL_OW 44
2712: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2713: LD_VAR 0 7
2717: PPUSH
2718: LD_VAR 0 4
2722: PPUSH
2723: LD_VAR 0 5
2727: PPUSH
2728: LD_INT 5
2730: PPUSH
2731: LD_VAR 0 2
2735: PPUSH
2736: CALL_OW 50
// end ;
2740: GO 2700
2742: POP
2743: POP
// hc_name :=  ;
2744: LD_ADDR_OWVAR 26
2748: PUSH
2749: LD_STRING 
2751: ST_TO_ADDR
// hc_class := class_soldier ;
2752: LD_ADDR_OWVAR 28
2756: PUSH
2757: LD_INT 1
2759: ST_TO_ADDR
// hc_sex := sex_male ;
2760: LD_ADDR_OWVAR 27
2764: PUSH
2765: LD_INT 1
2767: ST_TO_ADDR
// hc_basic_skills := sol_skills ;
2768: LD_ADDR_OWVAR 30
2772: PUSH
2773: LD_EXP 23
2777: ST_TO_ADDR
// hc_skills := sol_skills ;
2778: LD_ADDR_OWVAR 31
2782: PUSH
2783: LD_EXP 23
2787: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2788: LD_ADDR_OWVAR 29
2792: PUSH
2793: LD_INT 10
2795: PUSH
2796: LD_INT 10
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: ST_TO_ADDR
// hc_importance := 0 ;
2803: LD_ADDR_OWVAR 32
2807: PUSH
2808: LD_INT 0
2810: ST_TO_ADDR
// hc_gallery :=  ;
2811: LD_ADDR_OWVAR 33
2815: PUSH
2816: LD_STRING 
2818: ST_TO_ADDR
// for i := 1 to nsh do
2819: LD_ADDR_VAR 0 6
2823: PUSH
2824: DOUBLE
2825: LD_INT 1
2827: DEC
2828: ST_TO_ADDR
2829: LD_EXP 20
2833: PUSH
2834: FOR_TO
2835: IFFALSE 2876
// begin sh := CreateHuman ;
2837: LD_ADDR_VAR 0 7
2841: PUSH
2842: CALL_OW 44
2846: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2847: LD_VAR 0 7
2851: PPUSH
2852: LD_VAR 0 4
2856: PPUSH
2857: LD_VAR 0 5
2861: PPUSH
2862: LD_INT 5
2864: PPUSH
2865: LD_VAR 0 2
2869: PPUSH
2870: CALL_OW 50
// end ;
2874: GO 2834
2876: POP
2877: POP
// end ;
2878: LD_VAR 0 3
2882: RET
// function find_hidden_hex ( ar ) ; var i , j , seen ; begin
2883: LD_INT 0
2885: PPUSH
2886: PPUSH
2887: PPUSH
2888: PPUSH
// for i := 1 to 100 do
2889: LD_ADDR_VAR 0 3
2893: PUSH
2894: DOUBLE
2895: LD_INT 1
2897: DEC
2898: ST_TO_ADDR
2899: LD_INT 100
2901: PUSH
2902: FOR_TO
2903: IFFALSE 3026
// begin repeat result := RandHexArea ( ar , false ) ;
2905: LD_ADDR_VAR 0 2
2909: PUSH
2910: LD_VAR 0 1
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 16
2922: ST_TO_ADDR
// until not HexInfo ( result [ 1 ] , result [ 2 ] ) ;
2923: LD_VAR 0 2
2927: PUSH
2928: LD_INT 1
2930: ARRAY
2931: PPUSH
2932: LD_VAR 0 2
2936: PUSH
2937: LD_INT 2
2939: ARRAY
2940: PPUSH
2941: CALL_OW 428
2945: NOT
2946: IFFALSE 2905
// seen := false ;
2948: LD_ADDR_VAR 0 5
2952: PUSH
2953: LD_INT 0
2955: ST_TO_ADDR
// for j := 1 to 8 do
2956: LD_ADDR_VAR 0 4
2960: PUSH
2961: DOUBLE
2962: LD_INT 1
2964: DEC
2965: ST_TO_ADDR
2966: LD_INT 8
2968: PUSH
2969: FOR_TO
2970: IFFALSE 3011
// if SeeXY ( j , result [ 1 ] , result [ 2 ] ) then
2972: LD_VAR 0 4
2976: PPUSH
2977: LD_VAR 0 2
2981: PUSH
2982: LD_INT 1
2984: ARRAY
2985: PPUSH
2986: LD_VAR 0 2
2990: PUSH
2991: LD_INT 2
2993: ARRAY
2994: PPUSH
2995: CALL_OW 293
2999: IFFALSE 3009
// seen := true ;
3001: LD_ADDR_VAR 0 5
3005: PUSH
3006: LD_INT 1
3008: ST_TO_ADDR
3009: GO 2969
3011: POP
3012: POP
// if not seen then
3013: LD_VAR 0 5
3017: NOT
3018: IFFALSE 3024
// exit ;
3020: POP
3021: POP
3022: GO 3036
// end ;
3024: GO 2902
3026: POP
3027: POP
// result := 0 ;
3028: LD_ADDR_VAR 0 2
3032: PUSH
3033: LD_INT 0
3035: ST_TO_ADDR
// end ;
3036: LD_VAR 0 2
3040: RET
// function create_ape ; var coord , i ; begin
3041: LD_INT 0
3043: PPUSH
3044: PPUSH
3045: PPUSH
// if lastunit >= 1999 then
3046: LD_EXP 36
3050: PUSH
3051: LD_INT 1999
3053: GREATEREQUAL
3054: IFFALSE 3058
// exit ;
3056: GO 3225
// uc_nation := nation_nature ;
3058: LD_ADDR_OWVAR 21
3062: PUSH
3063: LD_INT 0
3065: ST_TO_ADDR
// uc_side := 0 ;
3066: LD_ADDR_OWVAR 20
3070: PUSH
3071: LD_INT 0
3073: ST_TO_ADDR
// hc_name :=  ;
3074: LD_ADDR_OWVAR 26
3078: PUSH
3079: LD_STRING 
3081: ST_TO_ADDR
// hc_class := class_apeman ;
3082: LD_ADDR_OWVAR 28
3086: PUSH
3087: LD_INT 12
3089: ST_TO_ADDR
// hc_sex := 1 ;
3090: LD_ADDR_OWVAR 27
3094: PUSH
3095: LD_INT 1
3097: ST_TO_ADDR
// hc_basic_skills := ape_skills ;
3098: LD_ADDR_OWVAR 30
3102: PUSH
3103: LD_EXP 26
3107: ST_TO_ADDR
// hc_skills := ape_skills ;
3108: LD_ADDR_OWVAR 31
3112: PUSH
3113: LD_EXP 26
3117: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3118: LD_ADDR_OWVAR 29
3122: PUSH
3123: LD_INT 12
3125: PUSH
3126: LD_INT 12
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: ST_TO_ADDR
// hc_importance := 0 ;
3133: LD_ADDR_OWVAR 32
3137: PUSH
3138: LD_INT 0
3140: ST_TO_ADDR
// hc_gallery :=  ;
3141: LD_ADDR_OWVAR 33
3145: PUSH
3146: LD_STRING 
3148: ST_TO_ADDR
// hc_agressivity := Rand ( - 15 , 15 ) ;
3149: LD_ADDR_OWVAR 35
3153: PUSH
3154: LD_INT 15
3156: NEG
3157: PPUSH
3158: LD_INT 15
3160: PPUSH
3161: CALL_OW 12
3165: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3166: LD_ADDR_VAR 0 2
3170: PUSH
3171: LD_INT 7
3173: PPUSH
3174: CALL 2883 0 1
3178: ST_TO_ADDR
// if coord then
3179: LD_VAR 0 2
3183: IFFALSE 3225
// begin lastunit := CreateHuman ;
3185: LD_ADDR_EXP 36
3189: PUSH
3190: CALL_OW 44
3194: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3195: LD_EXP 36
3199: PPUSH
3200: LD_VAR 0 2
3204: PUSH
3205: LD_INT 1
3207: ARRAY
3208: PPUSH
3209: LD_VAR 0 2
3213: PUSH
3214: LD_INT 2
3216: ARRAY
3217: PPUSH
3218: LD_INT 0
3220: PPUSH
3221: CALL_OW 48
// end ; end ;
3225: LD_VAR 0 1
3229: RET
// function prepare_apes ; var i ; begin
3230: LD_INT 0
3232: PPUSH
3233: PPUSH
// for i := 1 to side_count * nstart_ape do
3234: LD_ADDR_VAR 0 2
3238: PUSH
3239: DOUBLE
3240: LD_INT 1
3242: DEC
3243: ST_TO_ADDR
3244: LD_EXP 37
3248: PUSH
3249: LD_EXP 24
3253: MUL
3254: PUSH
3255: FOR_TO
3256: IFFALSE 3264
// begin create_ape ;
3258: CALL 3041 0 0
// end ;
3262: GO 3255
3264: POP
3265: POP
// end ;
3266: LD_VAR 0 1
3270: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3271: LD_OWVAR 1
3275: PUSH
3276: LD_EXP 32
3280: GREATER
3281: IFFALSE 3365
3283: GO 3285
3285: DISABLE
3286: LD_INT 0
3288: PPUSH
// begin if not ape_respawning then
3289: LD_EXP 25
3293: NOT
3294: IFFALSE 3298
// exit ;
3296: GO 3365
// delay := ape_respawning div side_count ;
3298: LD_ADDR_VAR 0 1
3302: PUSH
3303: LD_EXP 25
3307: PUSH
3308: LD_EXP 37
3312: DIV
3313: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3314: LD_VAR 0 1
3318: PUSH
3319: LD_INT 50
3321: PPUSH
3322: LD_INT 150
3324: PPUSH
3325: CALL_OW 12
3329: MUL
3330: PUSH
3331: LD_INT 100
3333: DIV
3334: PPUSH
3335: CALL_OW 67
// delay := delay * 110 div 100 ;
3339: LD_ADDR_VAR 0 1
3343: PUSH
3344: LD_VAR 0 1
3348: PUSH
3349: LD_INT 110
3351: MUL
3352: PUSH
3353: LD_INT 100
3355: DIV
3356: ST_TO_ADDR
// create_ape ;
3357: CALL 3041 0 0
// until false ;
3361: LD_INT 0
3363: IFFALSE 3314
// end ;
3365: PPOPN 1
3367: END
// function create_tiger ; var coord , i ; begin
3368: LD_INT 0
3370: PPUSH
3371: PPUSH
3372: PPUSH
// if lastunit >= 1999 then
3373: LD_EXP 36
3377: PUSH
3378: LD_INT 1999
3380: GREATEREQUAL
3381: IFFALSE 3385
// exit ;
3383: GO 3577
// uc_nation := nation_nature ;
3385: LD_ADDR_OWVAR 21
3389: PUSH
3390: LD_INT 0
3392: ST_TO_ADDR
// uc_side := 0 ;
3393: LD_ADDR_OWVAR 20
3397: PUSH
3398: LD_INT 0
3400: ST_TO_ADDR
// hc_name :=  ;
3401: LD_ADDR_OWVAR 26
3405: PUSH
3406: LD_STRING 
3408: ST_TO_ADDR
// hc_class := class_tiger ;
3409: LD_ADDR_OWVAR 28
3413: PUSH
3414: LD_INT 14
3416: ST_TO_ADDR
// hc_sex := 1 ;
3417: LD_ADDR_OWVAR 27
3421: PUSH
3422: LD_INT 1
3424: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 2 , 2 ] ;
3425: LD_ADDR_OWVAR 30
3429: PUSH
3430: LD_INT 2
3432: PUSH
3433: LD_INT 2
3435: PUSH
3436: LD_INT 2
3438: PUSH
3439: LD_INT 2
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// hc_skills := [ 2 , 2 , 2 , 2 ] ;
3448: LD_ADDR_OWVAR 31
3452: PUSH
3453: LD_INT 2
3455: PUSH
3456: LD_INT 2
3458: PUSH
3459: LD_INT 2
3461: PUSH
3462: LD_INT 2
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: LIST
3469: LIST
3470: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3471: LD_ADDR_OWVAR 29
3475: PUSH
3476: LD_INT 12
3478: PUSH
3479: LD_INT 12
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: ST_TO_ADDR
// hc_importance := 0 ;
3486: LD_ADDR_OWVAR 32
3490: PUSH
3491: LD_INT 0
3493: ST_TO_ADDR
// hc_gallery :=  ;
3494: LD_ADDR_OWVAR 33
3498: PUSH
3499: LD_STRING 
3501: ST_TO_ADDR
// hc_agressivity := Rand ( 30 , 50 ) ;
3502: LD_ADDR_OWVAR 35
3506: PUSH
3507: LD_INT 30
3509: PPUSH
3510: LD_INT 50
3512: PPUSH
3513: CALL_OW 12
3517: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3518: LD_ADDR_VAR 0 2
3522: PUSH
3523: LD_INT 7
3525: PPUSH
3526: CALL 2883 0 1
3530: ST_TO_ADDR
// if coord then
3531: LD_VAR 0 2
3535: IFFALSE 3577
// begin lastunit := CreateHuman ;
3537: LD_ADDR_EXP 36
3541: PUSH
3542: CALL_OW 44
3546: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3547: LD_EXP 36
3551: PPUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_INT 1
3559: ARRAY
3560: PPUSH
3561: LD_VAR 0 2
3565: PUSH
3566: LD_INT 2
3568: ARRAY
3569: PPUSH
3570: LD_INT 0
3572: PPUSH
3573: CALL_OW 48
// end ; end ;
3577: LD_VAR 0 1
3581: RET
// function prepare_tigers ; var i ; begin
3582: LD_INT 0
3584: PPUSH
3585: PPUSH
// for i := 1 to side_count * ntig do
3586: LD_ADDR_VAR 0 2
3590: PUSH
3591: DOUBLE
3592: LD_INT 1
3594: DEC
3595: ST_TO_ADDR
3596: LD_EXP 37
3600: PUSH
3601: LD_EXP 30
3605: MUL
3606: PUSH
3607: FOR_TO
3608: IFFALSE 3616
// begin create_tiger ;
3610: CALL 3368 0 0
// end ;
3614: GO 3607
3616: POP
3617: POP
// end ;
3618: LD_VAR 0 1
3622: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3623: LD_OWVAR 1
3627: PUSH
3628: LD_EXP 32
3632: GREATER
3633: IFFALSE 3717
3635: GO 3637
3637: DISABLE
3638: LD_INT 0
3640: PPUSH
// begin if not tig_respawning then
3641: LD_EXP 31
3645: NOT
3646: IFFALSE 3650
// exit ;
3648: GO 3717
// delay := tig_respawning div side_count ;
3650: LD_ADDR_VAR 0 1
3654: PUSH
3655: LD_EXP 31
3659: PUSH
3660: LD_EXP 37
3664: DIV
3665: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3666: LD_VAR 0 1
3670: PUSH
3671: LD_INT 50
3673: PPUSH
3674: LD_INT 150
3676: PPUSH
3677: CALL_OW 12
3681: MUL
3682: PUSH
3683: LD_INT 100
3685: DIV
3686: PPUSH
3687: CALL_OW 67
// delay := delay * 110 div 100 ;
3691: LD_ADDR_VAR 0 1
3695: PUSH
3696: LD_VAR 0 1
3700: PUSH
3701: LD_INT 110
3703: MUL
3704: PUSH
3705: LD_INT 100
3707: DIV
3708: ST_TO_ADDR
// create_tiger ;
3709: CALL 3368 0 0
// until false ;
3713: LD_INT 0
3715: IFFALSE 3666
// end ;
3717: PPOPN 1
3719: END
// export function sheherezade_start_the_fight ; var i ; begin
3720: LD_INT 0
3722: PPUSH
3723: PPUSH
// for i := 1 to 8 do
3724: LD_ADDR_VAR 0 2
3728: PUSH
3729: DOUBLE
3730: LD_INT 1
3732: DEC
3733: ST_TO_ADDR
3734: LD_INT 8
3736: PUSH
3737: FOR_TO
3738: IFFALSE 3772
// if side_positions [ i ] then
3740: LD_EXP 43
3744: PUSH
3745: LD_VAR 0 2
3749: ARRAY
3750: IFFALSE 3770
// prepare_side_to_the_fight ( i , prep_time > 0 ) ;
3752: LD_VAR 0 2
3756: PPUSH
3757: LD_EXP 32
3761: PUSH
3762: LD_INT 0
3764: GREATER
3765: PPUSH
3766: CALL 2410 0 2
3770: GO 3737
3772: POP
3773: POP
// end ;
3774: LD_VAR 0 1
3778: RET
// function create_mastodon ; var coord , i ; begin
3779: LD_INT 0
3781: PPUSH
3782: PPUSH
3783: PPUSH
// if lastunit >= 1999 then
3784: LD_EXP 36
3788: PUSH
3789: LD_INT 1999
3791: GREATEREQUAL
3792: IFFALSE 3796
// exit ;
3794: GO 3882
// uc_nation := nation_nature ;
3796: LD_ADDR_OWVAR 21
3800: PUSH
3801: LD_INT 0
3803: ST_TO_ADDR
// uc_side := 0 ;
3804: LD_ADDR_OWVAR 20
3808: PUSH
3809: LD_INT 0
3811: ST_TO_ADDR
// vc_chassis := 31 ;
3812: LD_ADDR_OWVAR 37
3816: PUSH
3817: LD_INT 31
3819: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3820: LD_ADDR_VAR 0 2
3824: PUSH
3825: LD_INT 7
3827: PPUSH
3828: CALL 2883 0 1
3832: ST_TO_ADDR
// if coord then
3833: LD_VAR 0 2
3837: IFFALSE 3882
// begin lastunit := CreateVehicle ;
3839: LD_ADDR_EXP 36
3843: PUSH
3844: CALL_OW 45
3848: ST_TO_ADDR
// PlaceUnitXYR ( lastunit , coord [ 1 ] , coord [ 2 ] , 3 , false ) ;
3849: LD_EXP 36
3853: PPUSH
3854: LD_VAR 0 2
3858: PUSH
3859: LD_INT 1
3861: ARRAY
3862: PPUSH
3863: LD_VAR 0 2
3867: PUSH
3868: LD_INT 2
3870: ARRAY
3871: PPUSH
3872: LD_INT 3
3874: PPUSH
3875: LD_INT 0
3877: PPUSH
3878: CALL_OW 50
// end ; end ;
3882: LD_VAR 0 1
3886: RET
// function prepare_mastodons ; var i ; begin
3887: LD_INT 0
3889: PPUSH
3890: PPUSH
// for i := 1 to nmast1 + side_count * nmast2 + side_count * nsh * nmast3 div 100 do
3891: LD_ADDR_VAR 0 2
3895: PUSH
3896: DOUBLE
3897: LD_INT 1
3899: DEC
3900: ST_TO_ADDR
3901: LD_EXP 27
3905: PUSH
3906: LD_EXP 37
3910: PUSH
3911: LD_EXP 28
3915: MUL
3916: PLUS
3917: PUSH
3918: LD_EXP 37
3922: PUSH
3923: LD_EXP 20
3927: MUL
3928: PUSH
3929: LD_EXP 29
3933: MUL
3934: PUSH
3935: LD_INT 100
3937: DIV
3938: PLUS
3939: PUSH
3940: FOR_TO
3941: IFFALSE 3949
// begin create_mastodon ;
3943: CALL 3779 0 0
// end ;
3947: GO 3940
3949: POP
3950: POP
// end ;
3951: LD_VAR 0 1
3955: RET
// export function starting_sheherezad ; begin
3956: LD_INT 0
3958: PPUSH
// mp_selectmsg := true ;
3959: LD_ADDR_OWVAR 13
3963: PUSH
3964: LD_INT 1
3966: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
3967: CALL 111 0 0
// prepare_map_coordinates ;
3971: CALL 1596 0 0
// set_attitudes ;
3975: CALL 2041 0 0
// prepare_sides ;
3979: CALL 2346 0 0
// prepare_apes ;
3983: CALL 3230 0 0
// prepare_tigers ;
3987: CALL 3582 0 0
// prepare_mastodons ;
3991: CALL 3887 0 0
// your_side := Player_Side ;
3995: LD_ADDR_OWVAR 2
3999: PUSH
4000: LD_EXP 39
4004: ST_TO_ADDR
// ResetFog ;
4005: CALL_OW 335
// AnimateTrees ( true ) ;
4009: LD_INT 1
4011: PPUSH
4012: CALL_OW 573
// music_nat := nation_arabian ;
4016: LD_ADDR_OWVAR 71
4020: PUSH
4021: LD_INT 2
4023: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
4024: LD_EXP 34
4028: PUSH
4029: LD_OWVAR 2
4033: ARRAY
4034: PUSH
4035: LD_INT 1
4037: ARRAY
4038: PPUSH
4039: LD_EXP 34
4043: PUSH
4044: LD_OWVAR 2
4048: ARRAY
4049: PUSH
4050: LD_INT 2
4052: ARRAY
4053: PPUSH
4054: CALL_OW 86
// end ; end_of_file
4058: LD_VAR 0 1
4062: RET
// export def_victory_conditions , def_number_of_people , def_people_respawning , def_vehicles_at_start , def_vehicles_respawning , def_vehicles_nations , def_siberite_rocket , def_vehicles_durability ; export game_time , point_limit , vehresp , vehmax1 , vehmax2 , vehmax , startvehperc , startveh , vehdur , npeop , peopresp , vehnats , sibrock , to_resp ; function read_multiplayer_and_game_parameters ; var i ; begin
4063: LD_INT 0
4065: PPUSH
4066: PPUSH
// if MultiPlayer then
4067: LD_OWVAR 4
4071: IFFALSE 4135
// begin Player_Side = mp_player_side ;
4073: LD_ADDR_EXP 39
4077: PUSH
4078: LD_OWVAR 7
4082: ST_TO_ADDR
// Player_Team = mp_player_team ;
4083: LD_ADDR_EXP 40
4087: PUSH
4088: LD_OWVAR 8
4092: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
4093: LD_ADDR_EXP 43
4097: PUSH
4098: LD_OWVAR 17
4102: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
4103: LD_ADDR_EXP 41
4107: PUSH
4108: LD_OWVAR 15
4112: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
4113: LD_ADDR_EXP 44
4117: PUSH
4118: LD_OWVAR 16
4122: ST_TO_ADDR
// Teams = mp_teams ;
4123: LD_ADDR_EXP 42
4127: PUSH
4128: LD_OWVAR 12
4132: ST_TO_ADDR
// end else
4133: GO 4279
// begin randomize ;
4135: CALL_OW 10
// Player_Side = 1 ;
4139: LD_ADDR_EXP 39
4143: PUSH
4144: LD_INT 1
4146: ST_TO_ADDR
// Player_Team = 0 ;
4147: LD_ADDR_EXP 40
4151: PUSH
4152: LD_INT 0
4154: ST_TO_ADDR
// Side_Positions = [ 1 , 3 , 6 , 0 , 0 , 0 , 0 , 7 ] ;
4155: LD_ADDR_EXP 43
4159: PUSH
4160: LD_INT 1
4162: PUSH
4163: LD_INT 3
4165: PUSH
4166: LD_INT 6
4168: PUSH
4169: LD_INT 0
4171: PUSH
4172: LD_INT 0
4174: PUSH
4175: LD_INT 0
4177: PUSH
4178: LD_INT 0
4180: PUSH
4181: LD_INT 7
4183: PUSH
4184: EMPTY
4185: LIST
4186: LIST
4187: LIST
4188: LIST
4189: LIST
4190: LIST
4191: LIST
4192: LIST
4193: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4194: LD_ADDR_EXP 41
4198: PUSH
4199: LD_INT 0
4201: PUSH
4202: LD_INT 0
4204: PUSH
4205: LD_INT 0
4207: PUSH
4208: LD_INT 0
4210: PUSH
4211: LD_INT 0
4213: PUSH
4214: LD_INT 0
4216: PUSH
4217: LD_INT 0
4219: PUSH
4220: LD_INT 0
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: LIST
4227: LIST
4228: LIST
4229: LIST
4230: LIST
4231: LIST
4232: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 2 , 2 , 2 , 2 ] ;
4233: LD_ADDR_EXP 44
4237: PUSH
4238: LD_INT 1
4240: PUSH
4241: LD_INT 3
4243: PUSH
4244: LD_INT 1
4246: PUSH
4247: LD_INT 2
4249: PUSH
4250: LD_INT 2
4252: PUSH
4253: LD_INT 2
4255: PUSH
4256: LD_INT 2
4258: PUSH
4259: LD_INT 2
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: ST_TO_ADDR
// Teams = [ ] ;
4272: LD_ADDR_EXP 42
4276: PUSH
4277: EMPTY
4278: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
4279: LD_ADDR_EXP 37
4283: PUSH
4284: LD_EXP 43
4288: PUSH
4289: LD_INT 0
4291: PUSH
4292: EMPTY
4293: LIST
4294: DIFF
4295: PUSH
4296: LD_INT 0
4298: PLUS
4299: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
4300: LD_ADDR_EXP 38
4304: PUSH
4305: LD_EXP 41
4309: PUSH
4310: LD_INT 0
4312: PUSH
4313: EMPTY
4314: LIST
4315: DIFF
4316: PUSH
4317: LD_INT 0
4319: PLUS
4320: ST_TO_ADDR
// if MultiPlayer then
4321: LD_OWVAR 4
4325: IFFALSE 4433
// begin def_victory_conditions = GetMultiplayerSetting ( 0 ) ;
4327: LD_ADDR_EXP 48
4331: PUSH
4332: LD_INT 0
4334: PPUSH
4335: CALL_OW 426
4339: ST_TO_ADDR
// def_number_of_people = GetMultiplayerSetting ( 1 ) ;
4340: LD_ADDR_EXP 49
4344: PUSH
4345: LD_INT 1
4347: PPUSH
4348: CALL_OW 426
4352: ST_TO_ADDR
// def_people_respawning = GetMultiplayerSetting ( 2 ) ;
4353: LD_ADDR_EXP 50
4357: PUSH
4358: LD_INT 2
4360: PPUSH
4361: CALL_OW 426
4365: ST_TO_ADDR
// def_vehicles_at_start = GetMultiplayerSetting ( 3 ) ;
4366: LD_ADDR_EXP 51
4370: PUSH
4371: LD_INT 3
4373: PPUSH
4374: CALL_OW 426
4378: ST_TO_ADDR
// def_vehicles_respawning = GetMultiplayerSetting ( 4 ) ;
4379: LD_ADDR_EXP 52
4383: PUSH
4384: LD_INT 4
4386: PPUSH
4387: CALL_OW 426
4391: ST_TO_ADDR
// def_vehicles_nations = GetMultiplayerSetting ( 5 ) ;
4392: LD_ADDR_EXP 53
4396: PUSH
4397: LD_INT 5
4399: PPUSH
4400: CALL_OW 426
4404: ST_TO_ADDR
// def_siberite_rocket = GetMultiplayerSetting ( 6 ) ;
4405: LD_ADDR_EXP 54
4409: PUSH
4410: LD_INT 6
4412: PPUSH
4413: CALL_OW 426
4417: ST_TO_ADDR
// def_vehicles_durability = GetMultiplayerSetting ( 7 ) ;
4418: LD_ADDR_EXP 55
4422: PUSH
4423: LD_INT 7
4425: PPUSH
4426: CALL_OW 426
4430: ST_TO_ADDR
// end else
4431: GO 4501
// begin randomize ;
4433: CALL_OW 10
// def_victory_conditions = 2 ;
4437: LD_ADDR_EXP 48
4441: PUSH
4442: LD_INT 2
4444: ST_TO_ADDR
// def_number_of_people = 1 ;
4445: LD_ADDR_EXP 49
4449: PUSH
4450: LD_INT 1
4452: ST_TO_ADDR
// def_people_respawning = 1 ;
4453: LD_ADDR_EXP 50
4457: PUSH
4458: LD_INT 1
4460: ST_TO_ADDR
// def_vehicles_at_start = 1 ;
4461: LD_ADDR_EXP 51
4465: PUSH
4466: LD_INT 1
4468: ST_TO_ADDR
// def_vehicles_respawning = 2 ;
4469: LD_ADDR_EXP 52
4473: PUSH
4474: LD_INT 2
4476: ST_TO_ADDR
// def_vehicles_nations = 0 ;
4477: LD_ADDR_EXP 53
4481: PUSH
4482: LD_INT 0
4484: ST_TO_ADDR
// def_siberite_rocket = 1 ;
4485: LD_ADDR_EXP 54
4489: PUSH
4490: LD_INT 1
4492: ST_TO_ADDR
// def_vehicles_durability = 1 ;
4493: LD_ADDR_EXP 55
4497: PUSH
4498: LD_INT 1
4500: ST_TO_ADDR
// end ; game_time = [ 5 5$0 , 10 10$0 , 15 15$0 , 20 20$0 , 30 30$0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ def_victory_conditions + 1 ] ;
4501: LD_ADDR_EXP 56
4505: PUSH
4506: LD_INT 10500
4508: PUSH
4509: LD_INT 21000
4511: PUSH
4512: LD_INT 31500
4514: PUSH
4515: LD_INT 42000
4517: PUSH
4518: LD_INT 63000
4520: PUSH
4521: LD_INT 0
4523: PUSH
4524: LD_INT 0
4526: PUSH
4527: LD_INT 0
4529: PUSH
4530: LD_INT 0
4532: PUSH
4533: LD_INT 0
4535: PUSH
4536: LD_INT 0
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: PUSH
4552: LD_EXP 48
4556: PUSH
4557: LD_INT 1
4559: PLUS
4560: ARRAY
4561: ST_TO_ADDR
// point_limit = [ 0 , 0 , 0 , 0 , 0 , 5 , 10 , 15 , 20 , 30 , 50 ] [ def_victory_conditions + 1 ] ;
4562: LD_ADDR_EXP 57
4566: PUSH
4567: LD_INT 0
4569: PUSH
4570: LD_INT 0
4572: PUSH
4573: LD_INT 0
4575: PUSH
4576: LD_INT 0
4578: PUSH
4579: LD_INT 0
4581: PUSH
4582: LD_INT 5
4584: PUSH
4585: LD_INT 10
4587: PUSH
4588: LD_INT 15
4590: PUSH
4591: LD_INT 20
4593: PUSH
4594: LD_INT 30
4596: PUSH
4597: LD_INT 50
4599: PUSH
4600: EMPTY
4601: LIST
4602: LIST
4603: LIST
4604: LIST
4605: LIST
4606: LIST
4607: LIST
4608: LIST
4609: LIST
4610: LIST
4611: LIST
4612: PUSH
4613: LD_EXP 48
4617: PUSH
4618: LD_INT 1
4620: PLUS
4621: ARRAY
4622: ST_TO_ADDR
// npeop = [ 4 , 6 , 8 , 10 ] [ def_number_of_people + 1 ] ;
4623: LD_ADDR_EXP 65
4627: PUSH
4628: LD_INT 4
4630: PUSH
4631: LD_INT 6
4633: PUSH
4634: LD_INT 8
4636: PUSH
4637: LD_INT 10
4639: PUSH
4640: EMPTY
4641: LIST
4642: LIST
4643: LIST
4644: LIST
4645: PUSH
4646: LD_EXP 49
4650: PUSH
4651: LD_INT 1
4653: PLUS
4654: ARRAY
4655: ST_TO_ADDR
// peopresp = [ false , [ 0 0$40 , 1 1$20 ] , [ 0 0$20 , 0 0$40 ] , [ 0 0$10 , 0 0$20 ] ] [ def_people_respawning + 1 ] ;
4656: LD_ADDR_EXP 66
4660: PUSH
4661: LD_INT 0
4663: PUSH
4664: LD_INT 1400
4666: PUSH
4667: LD_INT 2800
4669: PUSH
4670: EMPTY
4671: LIST
4672: LIST
4673: PUSH
4674: LD_INT 700
4676: PUSH
4677: LD_INT 1400
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: PUSH
4684: LD_INT 350
4686: PUSH
4687: LD_INT 700
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: LIST
4698: LIST
4699: PUSH
4700: LD_EXP 50
4704: PUSH
4705: LD_INT 1
4707: PLUS
4708: ARRAY
4709: ST_TO_ADDR
// vehmax1 = [ 3 , 6 , 9 ] [ def_vehicles_respawning + 1 ] ;
4710: LD_ADDR_EXP 59
4714: PUSH
4715: LD_INT 3
4717: PUSH
4718: LD_INT 6
4720: PUSH
4721: LD_INT 9
4723: PUSH
4724: EMPTY
4725: LIST
4726: LIST
4727: LIST
4728: PUSH
4729: LD_EXP 52
4733: PUSH
4734: LD_INT 1
4736: PLUS
4737: ARRAY
4738: ST_TO_ADDR
// vehmax2 = [ 2 , 4 , 6 ] [ def_vehicles_respawning + 1 ] ;
4739: LD_ADDR_EXP 60
4743: PUSH
4744: LD_INT 2
4746: PUSH
4747: LD_INT 4
4749: PUSH
4750: LD_INT 6
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: LIST
4757: PUSH
4758: LD_EXP 52
4762: PUSH
4763: LD_INT 1
4765: PLUS
4766: ARRAY
4767: ST_TO_ADDR
// vehmax = vehmax1 + side_count * vehmax2 ;
4768: LD_ADDR_EXP 61
4772: PUSH
4773: LD_EXP 59
4777: PUSH
4778: LD_EXP 37
4782: PUSH
4783: LD_EXP 60
4787: MUL
4788: PLUS
4789: ST_TO_ADDR
// vehdur = [ [ 40 , 80 ] , [ 60 , 120 ] , [ 100 , 200 ] ] [ def_vehicles_durability + 1 ] ;
4790: LD_ADDR_EXP 64
4794: PUSH
4795: LD_INT 40
4797: PUSH
4798: LD_INT 80
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PUSH
4805: LD_INT 60
4807: PUSH
4808: LD_INT 120
4810: PUSH
4811: EMPTY
4812: LIST
4813: LIST
4814: PUSH
4815: LD_INT 100
4817: PUSH
4818: LD_INT 200
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: LIST
4829: PUSH
4830: LD_EXP 55
4834: PUSH
4835: LD_INT 1
4837: PLUS
4838: ARRAY
4839: ST_TO_ADDR
// vehresp = [ [ 0 0$40 , 2 2$00 ] , [ 0 0$20 , 1 1$00 ] , [ 0 0$10 , 0 0$30 ] ] [ def_vehicles_respawning + 1 ] ;
4840: LD_ADDR_EXP 58
4844: PUSH
4845: LD_INT 1400
4847: PUSH
4848: LD_INT 4200
4850: PUSH
4851: EMPTY
4852: LIST
4853: LIST
4854: PUSH
4855: LD_INT 700
4857: PUSH
4858: LD_INT 2100
4860: PUSH
4861: EMPTY
4862: LIST
4863: LIST
4864: PUSH
4865: LD_INT 350
4867: PUSH
4868: LD_INT 1050
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: LIST
4879: PUSH
4880: LD_EXP 52
4884: PUSH
4885: LD_INT 1
4887: PLUS
4888: ARRAY
4889: ST_TO_ADDR
// startvehperc = [ 0 , 10 , 20 , 40 ] [ def_vehicles_at_start + 1 ] ;
4890: LD_ADDR_EXP 62
4894: PUSH
4895: LD_INT 0
4897: PUSH
4898: LD_INT 10
4900: PUSH
4901: LD_INT 20
4903: PUSH
4904: LD_INT 40
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: LIST
4911: LIST
4912: PUSH
4913: LD_EXP 51
4917: PUSH
4918: LD_INT 1
4920: PLUS
4921: ARRAY
4922: ST_TO_ADDR
// startveh = vehmax * startvehperc div 100 ;
4923: LD_ADDR_EXP 63
4927: PUSH
4928: LD_EXP 61
4932: PUSH
4933: LD_EXP 62
4937: MUL
4938: PUSH
4939: LD_INT 100
4941: DIV
4942: ST_TO_ADDR
// vehnats = [ [ 1 , 2 , 3 ] , [ 1 ] , [ 3 ] , [ 2 ] , [ 1 , 3 ] , [ 3 , 2 ] , [ 2 , 1 ] ] [ def_vehicles_nations + 1 ] ;
4943: LD_ADDR_EXP 67
4947: PUSH
4948: LD_INT 1
4950: PUSH
4951: LD_INT 2
4953: PUSH
4954: LD_INT 3
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: LIST
4961: PUSH
4962: LD_INT 1
4964: PUSH
4965: EMPTY
4966: LIST
4967: PUSH
4968: LD_INT 3
4970: PUSH
4971: EMPTY
4972: LIST
4973: PUSH
4974: LD_INT 2
4976: PUSH
4977: EMPTY
4978: LIST
4979: PUSH
4980: LD_INT 1
4982: PUSH
4983: LD_INT 3
4985: PUSH
4986: EMPTY
4987: LIST
4988: LIST
4989: PUSH
4990: LD_INT 3
4992: PUSH
4993: LD_INT 2
4995: PUSH
4996: EMPTY
4997: LIST
4998: LIST
4999: PUSH
5000: LD_INT 2
5002: PUSH
5003: LD_INT 1
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: PUSH
5019: LD_EXP 53
5023: PUSH
5024: LD_INT 1
5026: PLUS
5027: ARRAY
5028: ST_TO_ADDR
// sibrock = [ 0 , 3 , 7 ] [ def_siberite_rocket + 1 ] ;
5029: LD_ADDR_EXP 68
5033: PUSH
5034: LD_INT 0
5036: PUSH
5037: LD_INT 3
5039: PUSH
5040: LD_INT 7
5042: PUSH
5043: EMPTY
5044: LIST
5045: LIST
5046: LIST
5047: PUSH
5048: LD_EXP 54
5052: PUSH
5053: LD_INT 1
5055: PLUS
5056: ARRAY
5057: ST_TO_ADDR
// for i = 1 to 8 do
5058: LD_ADDR_VAR 0 2
5062: PUSH
5063: DOUBLE
5064: LD_INT 1
5066: DEC
5067: ST_TO_ADDR
5068: LD_INT 8
5070: PUSH
5071: FOR_TO
5072: IFFALSE 5104
// if Side_Positions [ i ] then
5074: LD_EXP 43
5078: PUSH
5079: LD_VAR 0 2
5083: ARRAY
5084: IFFALSE 5102
// to_resp := to_resp ^ i ;
5086: LD_ADDR_EXP 69
5090: PUSH
5091: LD_EXP 69
5095: PUSH
5096: LD_VAR 0 2
5100: ADD
5101: ST_TO_ADDR
5102: GO 5071
5104: POP
5105: POP
// end ;
5106: LD_VAR 0 1
5110: RET
// export chassis , weapons , areas_wheeled , areas_tracked ; function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
5111: LD_INT 0
5113: PPUSH
5114: PPUSH
5115: PPUSH
5116: PPUSH
5117: PPUSH
5118: PPUSH
5119: PPUSH
5120: PPUSH
// areas_wheeled = [ aw1 , aw2 , aw3 , aw4 ] ;
5121: LD_ADDR_EXP 72
5125: PUSH
5126: LD_INT 13
5128: PUSH
5129: LD_INT 15
5131: PUSH
5132: LD_INT 17
5134: PUSH
5135: LD_INT 19
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: LIST
5143: ST_TO_ADDR
// areas_tracked = [ at1 , at2 , at3 , at4 ] ;
5144: LD_ADDR_EXP 73
5148: PUSH
5149: LD_INT 12
5151: PUSH
5152: LD_INT 14
5154: PUSH
5155: LD_INT 16
5157: PUSH
5158: LD_INT 18
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: ST_TO_ADDR
// best = 0 ;
5167: LD_ADDR_VAR 0 2
5171: PUSH
5172: LD_INT 0
5174: ST_TO_ADDR
// for n = 1 to 200 do
5175: LD_ADDR_VAR 0 8
5179: PUSH
5180: DOUBLE
5181: LD_INT 1
5183: DEC
5184: ST_TO_ADDR
5185: LD_INT 200
5187: PUSH
5188: FOR_TO
5189: IFFALSE 5485
// begin c = [ ] ;
5191: LD_ADDR_VAR 0 3
5195: PUSH
5196: EMPTY
5197: ST_TO_ADDR
// for i = 1 to side_count do
5198: LD_ADDR_VAR 0 6
5202: PUSH
5203: DOUBLE
5204: LD_INT 1
5206: DEC
5207: ST_TO_ADDR
5208: LD_EXP 37
5212: PUSH
5213: FOR_TO
5214: IFFALSE 5243
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
5216: LD_ADDR_VAR 0 3
5220: PUSH
5221: LD_VAR 0 3
5225: PUSH
5226: LD_INT 21
5228: PPUSH
5229: LD_INT 0
5231: PPUSH
5232: CALL_OW 16
5236: PUSH
5237: EMPTY
5238: LIST
5239: ADD
5240: ST_TO_ADDR
5241: GO 5213
5243: POP
5244: POP
// minv = 10000 ;
5245: LD_ADDR_VAR 0 5
5249: PUSH
5250: LD_INT 10000
5252: ST_TO_ADDR
// for i = 1 to side_count do
5253: LD_ADDR_VAR 0 6
5257: PUSH
5258: DOUBLE
5259: LD_INT 1
5261: DEC
5262: ST_TO_ADDR
5263: LD_EXP 37
5267: PUSH
5268: FOR_TO
5269: IFFALSE 5449
// for j = 1 to side_count do
5271: LD_ADDR_VAR 0 7
5275: PUSH
5276: DOUBLE
5277: LD_INT 1
5279: DEC
5280: ST_TO_ADDR
5281: LD_EXP 37
5285: PUSH
5286: FOR_TO
5287: IFFALSE 5445
// if i <> j then
5289: LD_VAR 0 6
5293: PUSH
5294: LD_VAR 0 7
5298: NONEQUAL
5299: IFFALSE 5443
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
5301: LD_VAR 0 3
5305: PUSH
5306: LD_VAR 0 6
5310: ARRAY
5311: PUSH
5312: LD_INT 1
5314: ARRAY
5315: PPUSH
5316: LD_VAR 0 3
5320: PUSH
5321: LD_VAR 0 6
5325: ARRAY
5326: PUSH
5327: LD_INT 2
5329: ARRAY
5330: PPUSH
5331: LD_VAR 0 3
5335: PUSH
5336: LD_VAR 0 7
5340: ARRAY
5341: PUSH
5342: LD_INT 1
5344: ARRAY
5345: PPUSH
5346: LD_VAR 0 3
5350: PUSH
5351: LD_VAR 0 7
5355: ARRAY
5356: PUSH
5357: LD_INT 2
5359: ARRAY
5360: PPUSH
5361: CALL_OW 298
5365: PUSH
5366: LD_VAR 0 5
5370: LESS
5371: IFFALSE 5443
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
5373: LD_ADDR_VAR 0 5
5377: PUSH
5378: LD_VAR 0 3
5382: PUSH
5383: LD_VAR 0 6
5387: ARRAY
5388: PUSH
5389: LD_INT 1
5391: ARRAY
5392: PPUSH
5393: LD_VAR 0 3
5397: PUSH
5398: LD_VAR 0 6
5402: ARRAY
5403: PUSH
5404: LD_INT 2
5406: ARRAY
5407: PPUSH
5408: LD_VAR 0 3
5412: PUSH
5413: LD_VAR 0 7
5417: ARRAY
5418: PUSH
5419: LD_INT 1
5421: ARRAY
5422: PPUSH
5423: LD_VAR 0 3
5427: PUSH
5428: LD_VAR 0 7
5432: ARRAY
5433: PUSH
5434: LD_INT 2
5436: ARRAY
5437: PPUSH
5438: CALL_OW 298
5442: ST_TO_ADDR
// end ;
5443: GO 5286
5445: POP
5446: POP
5447: GO 5268
5449: POP
5450: POP
// if minv > best then
5451: LD_VAR 0 5
5455: PUSH
5456: LD_VAR 0 2
5460: GREATER
5461: IFFALSE 5483
// begin best := minv ;
5463: LD_ADDR_VAR 0 2
5467: PUSH
5468: LD_VAR 0 5
5472: ST_TO_ADDR
// bestc := c ;
5473: LD_ADDR_VAR 0 4
5477: PUSH
5478: LD_VAR 0 3
5482: ST_TO_ADDR
// end ; end ;
5483: GO 5188
5485: POP
5486: POP
// coordinates := [ ] ;
5487: LD_ADDR_EXP 34
5491: PUSH
5492: EMPTY
5493: ST_TO_ADDR
// for i = 1 to 8 do
5494: LD_ADDR_VAR 0 6
5498: PUSH
5499: DOUBLE
5500: LD_INT 1
5502: DEC
5503: ST_TO_ADDR
5504: LD_INT 8
5506: PUSH
5507: FOR_TO
5508: IFFALSE 5595
// if side_positions [ i ] = 0 then
5510: LD_EXP 43
5514: PUSH
5515: LD_VAR 0 6
5519: ARRAY
5520: PUSH
5521: LD_INT 0
5523: EQUAL
5524: IFFALSE 5552
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
5526: LD_ADDR_EXP 34
5530: PUSH
5531: LD_EXP 34
5535: PUSH
5536: LD_INT 0
5538: PUSH
5539: LD_INT 0
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: PUSH
5546: EMPTY
5547: LIST
5548: ADD
5549: ST_TO_ADDR
5550: GO 5593
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
5552: LD_ADDR_EXP 34
5556: PUSH
5557: LD_EXP 34
5561: PUSH
5562: LD_VAR 0 4
5566: PUSH
5567: LD_INT 1
5569: ARRAY
5570: PUSH
5571: EMPTY
5572: LIST
5573: ADD
5574: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
5575: LD_ADDR_VAR 0 4
5579: PUSH
5580: LD_VAR 0 4
5584: PPUSH
5585: LD_INT 1
5587: PPUSH
5588: CALL_OW 3
5592: ST_TO_ADDR
// end ;
5593: GO 5507
5595: POP
5596: POP
// end ;
5597: LD_VAR 0 1
5601: RET
// function prepare_constants ; begin
5602: LD_INT 0
5604: PPUSH
// chassis = [ [ [ [ us_light_wheeled ] , [ ] ] , [ [ us_medium_wheeled ] , [ us_medium_tracked ] ] , [ [ ] , [ us_heavy_tracked , us_morphling ] ] ] , [ [ [ ar_light_trike , ar_hovercraft ] , [ ] ] , [ [ ar_medium_trike ] , [ ar_half_tracked ] ] , [ [ ] , [ ] ] ] , [ [ [ ] , [ ] ] , [ [ ru_medium_wheeled ] , [ ru_medium_tracked ] ] , [ [ ru_heavy_wheeled ] , [ ru_heavy_tracked ] ] ] ] ;
5605: LD_ADDR_EXP 70
5609: PUSH
5610: LD_INT 1
5612: PUSH
5613: EMPTY
5614: LIST
5615: PUSH
5616: EMPTY
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 2
5624: PUSH
5625: EMPTY
5626: LIST
5627: PUSH
5628: LD_INT 3
5630: PUSH
5631: EMPTY
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: PUSH
5638: EMPTY
5639: PUSH
5640: LD_INT 4
5642: PUSH
5643: LD_INT 5
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: LIST
5658: PUSH
5659: LD_INT 12
5661: PUSH
5662: LD_INT 11
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: PUSH
5669: EMPTY
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 13
5677: PUSH
5678: EMPTY
5679: LIST
5680: PUSH
5681: LD_INT 14
5683: PUSH
5684: EMPTY
5685: LIST
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: PUSH
5691: EMPTY
5692: PUSH
5693: EMPTY
5694: PUSH
5695: EMPTY
5696: LIST
5697: LIST
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: EMPTY
5705: PUSH
5706: EMPTY
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PUSH
5712: LD_INT 21
5714: PUSH
5715: EMPTY
5716: LIST
5717: PUSH
5718: LD_INT 22
5720: PUSH
5721: EMPTY
5722: LIST
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: LD_INT 23
5730: PUSH
5731: EMPTY
5732: LIST
5733: PUSH
5734: LD_INT 24
5736: PUSH
5737: EMPTY
5738: LIST
5739: PUSH
5740: EMPTY
5741: LIST
5742: LIST
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: PUSH
5749: EMPTY
5750: LIST
5751: LIST
5752: LIST
5753: ST_TO_ADDR
// weapons = [ [ [ us_machine_gun , 1 , 100 ] , [ us_light_gun , 1 , 100 ] , [ us_radar , 1 , 100 ] , [ us_gatling_gun , 2 , 100 ] , [ us_double_gun , 2 , 100 ] , [ us_rocket_launcher , 2 , 100 ] , [ us_laser , 2 , 100 ] , [ us_heavy_gun , 3 , 100 ] , [ us_bulldozer , 3 , 100 ] , [ us_double_laser , 3 , 100 ] ] , [ [ ar_multimissile_ballista , 1 , 100 ] , [ ar_double_machine_gun , 1 , 100 ] , [ ar_light_gun , 1 , 100 ] , [ ar_radar , 1 , 100 ] , [ ar_gatling_gun , 2 , 100 ] , [ ar_gun , 2 , 100 ] , [ ar_rocket_launcher , 2 , 100 ] , [ ar_selfpropelled_bomb , 2 , 100 ] , [ ar_flame_thrower , 2 , 100 ] ] , [ [ ru_heavy_machine_gun , 2 , 100 ] , [ ru_gatling_gun , 2 , 100 ] , [ ru_gun , 2 , 100 ] , [ ru_rocket_launcher , 2 , 100 ] , [ ru_heavy_gun , 3 , 100 ] , [ ru_rocket , 3 , 100 ] , [ ru_bulldozer , 3 , 100 ] ] ] ;
5754: LD_ADDR_EXP 71
5758: PUSH
5759: LD_INT 2
5761: PUSH
5762: LD_INT 1
5764: PUSH
5765: LD_INT 100
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 3
5775: PUSH
5776: LD_INT 1
5778: PUSH
5779: LD_INT 100
5781: PUSH
5782: EMPTY
5783: LIST
5784: LIST
5785: LIST
5786: PUSH
5787: LD_INT 11
5789: PUSH
5790: LD_INT 1
5792: PUSH
5793: LD_INT 100
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: LIST
5800: PUSH
5801: LD_INT 4
5803: PUSH
5804: LD_INT 2
5806: PUSH
5807: LD_INT 100
5809: PUSH
5810: EMPTY
5811: LIST
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 5
5817: PUSH
5818: LD_INT 2
5820: PUSH
5821: LD_INT 100
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 7
5831: PUSH
5832: LD_INT 2
5834: PUSH
5835: LD_INT 100
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: PUSH
5843: LD_INT 9
5845: PUSH
5846: LD_INT 2
5848: PUSH
5849: LD_INT 100
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: LIST
5856: PUSH
5857: LD_INT 6
5859: PUSH
5860: LD_INT 3
5862: PUSH
5863: LD_INT 100
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: LIST
5870: PUSH
5871: LD_INT 14
5873: PUSH
5874: LD_INT 3
5876: PUSH
5877: LD_INT 100
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 10
5887: PUSH
5888: LD_INT 3
5890: PUSH
5891: LD_INT 100
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: PUSH
5911: LD_INT 22
5913: PUSH
5914: LD_INT 1
5916: PUSH
5917: LD_INT 100
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 24
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 100
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: LIST
5938: PUSH
5939: LD_INT 23
5941: PUSH
5942: LD_INT 1
5944: PUSH
5945: LD_INT 100
5947: PUSH
5948: EMPTY
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 30
5955: PUSH
5956: LD_INT 1
5958: PUSH
5959: LD_INT 100
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: LIST
5966: PUSH
5967: LD_INT 25
5969: PUSH
5970: LD_INT 2
5972: PUSH
5973: LD_INT 100
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: PUSH
5981: LD_INT 27
5983: PUSH
5984: LD_INT 2
5986: PUSH
5987: LD_INT 100
5989: PUSH
5990: EMPTY
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 28
5997: PUSH
5998: LD_INT 2
6000: PUSH
6001: LD_INT 100
6003: PUSH
6004: EMPTY
6005: LIST
6006: LIST
6007: LIST
6008: PUSH
6009: LD_INT 29
6011: PUSH
6012: LD_INT 2
6014: PUSH
6015: LD_INT 100
6017: PUSH
6018: EMPTY
6019: LIST
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 26
6025: PUSH
6026: LD_INT 2
6028: PUSH
6029: LD_INT 100
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: LIST
6036: PUSH
6037: EMPTY
6038: LIST
6039: LIST
6040: LIST
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 42
6050: PUSH
6051: LD_INT 2
6053: PUSH
6054: LD_INT 100
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: LIST
6061: PUSH
6062: LD_INT 43
6064: PUSH
6065: LD_INT 2
6067: PUSH
6068: LD_INT 100
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: PUSH
6076: LD_INT 44
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: LD_INT 100
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: LIST
6089: PUSH
6090: LD_INT 45
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: LD_INT 100
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: LIST
6103: PUSH
6104: LD_INT 46
6106: PUSH
6107: LD_INT 3
6109: PUSH
6110: LD_INT 100
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: PUSH
6118: LD_INT 47
6120: PUSH
6121: LD_INT 3
6123: PUSH
6124: LD_INT 100
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: LIST
6131: PUSH
6132: LD_INT 53
6134: PUSH
6135: LD_INT 3
6137: PUSH
6138: LD_INT 100
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: LIST
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: LIST
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: LIST
6159: ST_TO_ADDR
// end ;
6160: LD_VAR 0 1
6164: RET
// var is_tracked ; function random_vehicle ( sibrockprob ) ; var nat , wpset , suma , tmp , i , weap , wwght , wght , chs , trck ; begin
6165: LD_INT 0
6167: PPUSH
6168: PPUSH
6169: PPUSH
6170: PPUSH
6171: PPUSH
6172: PPUSH
6173: PPUSH
6174: PPUSH
6175: PPUSH
6176: PPUSH
6177: PPUSH
// nat := vehnats [ rand ( 1 , vehnats ) ] ;
6178: LD_ADDR_VAR 0 3
6182: PUSH
6183: LD_EXP 67
6187: PUSH
6188: LD_INT 1
6190: PPUSH
6191: LD_EXP 67
6195: PPUSH
6196: CALL_OW 12
6200: ARRAY
6201: ST_TO_ADDR
// if ( nat in [ nation_russian , nation_american ] ) and ( Rand ( 1 , 1000 ) <= sibrockprob ) then
6202: LD_VAR 0 3
6206: PUSH
6207: LD_INT 3
6209: PUSH
6210: LD_INT 1
6212: PUSH
6213: EMPTY
6214: LIST
6215: LIST
6216: IN
6217: PUSH
6218: LD_INT 1
6220: PPUSH
6221: LD_INT 1000
6223: PPUSH
6224: CALL_OW 12
6228: PUSH
6229: LD_VAR 0 1
6233: LESSEQUAL
6234: AND
6235: IFFALSE 6291
// begin wght := 3 ;
6237: LD_ADDR_VAR 0 10
6241: PUSH
6242: LD_INT 3
6244: ST_TO_ADDR
// case nat of nation_russian :
6245: LD_VAR 0 3
6249: PUSH
6250: LD_INT 3
6252: DOUBLE
6253: EQUAL
6254: IFTRUE 6258
6256: GO 6269
6258: POP
// weap := ru_siberium_rocket ; nation_american :
6259: LD_ADDR_VAR 0 8
6263: PUSH
6264: LD_INT 48
6266: ST_TO_ADDR
6267: GO 6289
6269: LD_INT 1
6271: DOUBLE
6272: EQUAL
6273: IFTRUE 6277
6275: GO 6288
6277: POP
// weap := us_siberium_rocket ; end ;
6278: LD_ADDR_VAR 0 8
6282: PUSH
6283: LD_INT 8
6285: ST_TO_ADDR
6286: GO 6289
6288: POP
// end else
6289: GO 6493
// begin wpset := weapons [ nat ] ;
6291: LD_ADDR_VAR 0 4
6295: PUSH
6296: LD_EXP 71
6300: PUSH
6301: LD_VAR 0 3
6305: ARRAY
6306: ST_TO_ADDR
// suma := 0 ;
6307: LD_ADDR_VAR 0 5
6311: PUSH
6312: LD_INT 0
6314: ST_TO_ADDR
// for i := 1 to wpset do
6315: LD_ADDR_VAR 0 7
6319: PUSH
6320: DOUBLE
6321: LD_INT 1
6323: DEC
6324: ST_TO_ADDR
6325: LD_VAR 0 4
6329: PUSH
6330: FOR_TO
6331: IFFALSE 6361
// suma := suma + wpset [ i ] [ 3 ] ;
6333: LD_ADDR_VAR 0 5
6337: PUSH
6338: LD_VAR 0 5
6342: PUSH
6343: LD_VAR 0 4
6347: PUSH
6348: LD_VAR 0 7
6352: ARRAY
6353: PUSH
6354: LD_INT 3
6356: ARRAY
6357: PLUS
6358: ST_TO_ADDR
6359: GO 6330
6361: POP
6362: POP
// tmp := rand ( 1 , suma ) ;
6363: LD_ADDR_VAR 0 6
6367: PUSH
6368: LD_INT 1
6370: PPUSH
6371: LD_VAR 0 5
6375: PPUSH
6376: CALL_OW 12
6380: ST_TO_ADDR
// i := 1 ;
6381: LD_ADDR_VAR 0 7
6385: PUSH
6386: LD_INT 1
6388: ST_TO_ADDR
// while wpset [ i ] [ 3 ] < tmp do
6389: LD_VAR 0 4
6393: PUSH
6394: LD_VAR 0 7
6398: ARRAY
6399: PUSH
6400: LD_INT 3
6402: ARRAY
6403: PUSH
6404: LD_VAR 0 6
6408: LESS
6409: IFFALSE 6453
// begin tmp := tmp - wpset [ i ] [ 3 ] ;
6411: LD_ADDR_VAR 0 6
6415: PUSH
6416: LD_VAR 0 6
6420: PUSH
6421: LD_VAR 0 4
6425: PUSH
6426: LD_VAR 0 7
6430: ARRAY
6431: PUSH
6432: LD_INT 3
6434: ARRAY
6435: MINUS
6436: ST_TO_ADDR
// i := i + 1 ;
6437: LD_ADDR_VAR 0 7
6441: PUSH
6442: LD_VAR 0 7
6446: PUSH
6447: LD_INT 1
6449: PLUS
6450: ST_TO_ADDR
// end ;
6451: GO 6389
// weap := wpset [ i ] [ 1 ] ;
6453: LD_ADDR_VAR 0 8
6457: PUSH
6458: LD_VAR 0 4
6462: PUSH
6463: LD_VAR 0 7
6467: ARRAY
6468: PUSH
6469: LD_INT 1
6471: ARRAY
6472: ST_TO_ADDR
// wwght := wpset [ i ] [ 2 ] ;
6473: LD_ADDR_VAR 0 9
6477: PUSH
6478: LD_VAR 0 4
6482: PUSH
6483: LD_VAR 0 7
6487: ARRAY
6488: PUSH
6489: LD_INT 2
6491: ARRAY
6492: ST_TO_ADDR
// end ; repeat trck := Rand ( 1 , 2 ) ;
6493: LD_ADDR_VAR 0 12
6497: PUSH
6498: LD_INT 1
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 12
6508: ST_TO_ADDR
// case wwght of 3 :
6509: LD_VAR 0 9
6513: PUSH
6514: LD_INT 3
6516: DOUBLE
6517: EQUAL
6518: IFTRUE 6522
6520: GO 6533
6522: POP
// wght := 3 ; 2 :
6523: LD_ADDR_VAR 0 10
6527: PUSH
6528: LD_INT 3
6530: ST_TO_ADDR
6531: GO 6650
6533: LD_INT 2
6535: DOUBLE
6536: EQUAL
6537: IFTRUE 6541
6539: GO 6578
6541: POP
// if Rand ( 1 , 100 ) <= 80 then
6542: LD_INT 1
6544: PPUSH
6545: LD_INT 100
6547: PPUSH
6548: CALL_OW 12
6552: PUSH
6553: LD_INT 80
6555: LESSEQUAL
6556: IFFALSE 6568
// wght := 2 else
6558: LD_ADDR_VAR 0 10
6562: PUSH
6563: LD_INT 2
6565: ST_TO_ADDR
6566: GO 6576
// wght := 3 ; 1 :
6568: LD_ADDR_VAR 0 10
6572: PUSH
6573: LD_INT 3
6575: ST_TO_ADDR
6576: GO 6650
6578: LD_INT 1
6580: DOUBLE
6581: EQUAL
6582: IFTRUE 6586
6584: GO 6649
6586: POP
// if Rand ( 1 , 100 ) <= 80 then
6587: LD_INT 1
6589: PPUSH
6590: LD_INT 100
6592: PPUSH
6593: CALL_OW 12
6597: PUSH
6598: LD_INT 80
6600: LESSEQUAL
6601: IFFALSE 6613
// wght := 1 else
6603: LD_ADDR_VAR 0 10
6607: PUSH
6608: LD_INT 1
6610: ST_TO_ADDR
6611: GO 6647
// if Rand ( 1 , 100 ) <= 80 then
6613: LD_INT 1
6615: PPUSH
6616: LD_INT 100
6618: PPUSH
6619: CALL_OW 12
6623: PUSH
6624: LD_INT 80
6626: LESSEQUAL
6627: IFFALSE 6639
// wght := 2 else
6629: LD_ADDR_VAR 0 10
6633: PUSH
6634: LD_INT 2
6636: ST_TO_ADDR
6637: GO 6647
// wght := 3 ; end ;
6639: LD_ADDR_VAR 0 10
6643: PUSH
6644: LD_INT 3
6646: ST_TO_ADDR
6647: GO 6650
6649: POP
// if chassis [ nat ] [ wght ] [ trck ] then
6650: LD_EXP 70
6654: PUSH
6655: LD_VAR 0 3
6659: ARRAY
6660: PUSH
6661: LD_VAR 0 10
6665: ARRAY
6666: PUSH
6667: LD_VAR 0 12
6671: ARRAY
6672: IFFALSE 6736
// chs := chassis [ nat ] [ wght ] [ trck ] [ Rand ( 1 , chassis [ nat ] [ wght ] [ trck ] ) ] else
6674: LD_ADDR_VAR 0 11
6678: PUSH
6679: LD_EXP 70
6683: PUSH
6684: LD_VAR 0 3
6688: ARRAY
6689: PUSH
6690: LD_VAR 0 10
6694: ARRAY
6695: PUSH
6696: LD_VAR 0 12
6700: ARRAY
6701: PUSH
6702: LD_INT 1
6704: PPUSH
6705: LD_EXP 70
6709: PUSH
6710: LD_VAR 0 3
6714: ARRAY
6715: PUSH
6716: LD_VAR 0 10
6720: ARRAY
6721: PUSH
6722: LD_VAR 0 12
6726: ARRAY
6727: PPUSH
6728: CALL_OW 12
6732: ARRAY
6733: ST_TO_ADDR
6734: GO 6744
// chs := 0 ;
6736: LD_ADDR_VAR 0 11
6740: PUSH
6741: LD_INT 0
6743: ST_TO_ADDR
// until chs ;
6744: LD_VAR 0 11
6748: IFFALSE 6493
// uc_side := 0 ;
6750: LD_ADDR_OWVAR 20
6754: PUSH
6755: LD_INT 0
6757: ST_TO_ADDR
// uc_nation := nat ;
6758: LD_ADDR_OWVAR 21
6762: PUSH
6763: LD_VAR 0 3
6767: ST_TO_ADDR
// uc_direction := rand ( 0 , 5 ) ;
6768: LD_ADDR_OWVAR 24
6772: PUSH
6773: LD_INT 0
6775: PPUSH
6776: LD_INT 5
6778: PPUSH
6779: CALL_OW 12
6783: ST_TO_ADDR
// vc_chassis := chs ;
6784: LD_ADDR_OWVAR 37
6788: PUSH
6789: LD_VAR 0 11
6793: ST_TO_ADDR
// vc_weapon := weap ;
6794: LD_ADDR_OWVAR 40
6798: PUSH
6799: LD_VAR 0 8
6803: ST_TO_ADDR
// vc_control := control_manual ;
6804: LD_ADDR_OWVAR 38
6808: PUSH
6809: LD_INT 1
6811: ST_TO_ADDR
// case wght of 1 :
6812: LD_VAR 0 10
6816: PUSH
6817: LD_INT 1
6819: DOUBLE
6820: EQUAL
6821: IFTRUE 6825
6823: GO 6836
6825: POP
// vc_engine := engine_solar ; 2 , 3 :
6826: LD_ADDR_OWVAR 39
6830: PUSH
6831: LD_INT 2
6833: ST_TO_ADDR
6834: GO 6862
6836: LD_INT 2
6838: DOUBLE
6839: EQUAL
6840: IFTRUE 6850
6842: LD_INT 3
6844: DOUBLE
6845: EQUAL
6846: IFTRUE 6850
6848: GO 6861
6850: POP
// vc_engine := engine_siberite ; end ;
6851: LD_ADDR_OWVAR 39
6855: PUSH
6856: LD_INT 3
6858: ST_TO_ADDR
6859: GO 6862
6861: POP
// is_tracked := trck = 2 ;
6862: LD_ADDR_LOC 1
6866: PUSH
6867: LD_VAR 0 12
6871: PUSH
6872: LD_INT 2
6874: EQUAL
6875: ST_TO_ADDR
// end ;
6876: LD_VAR 0 2
6880: RET
// export function vehicles_create_vehicle ( atstart ) ; var v , ar ; begin
6881: LD_INT 0
6883: PPUSH
6884: PPUSH
6885: PPUSH
// if atstart then
6886: LD_VAR 0 1
6890: IFFALSE 6901
// random_vehicle ( 0 ) else
6892: LD_INT 0
6894: PPUSH
6895: CALL 6165 0 1
6899: GO 6910
// random_vehicle ( sibrock ) ;
6901: LD_EXP 68
6905: PPUSH
6906: CALL 6165 0 1
// v := CreateVehicle ;
6910: LD_ADDR_VAR 0 3
6914: PUSH
6915: CALL_OW 45
6919: ST_TO_ADDR
// if is_tracked then
6920: LD_LOC 1
6924: IFFALSE 6952
// ar := areas_tracked [ Rand ( 1 , areas_tracked ) ] else
6926: LD_ADDR_VAR 0 4
6930: PUSH
6931: LD_EXP 73
6935: PUSH
6936: LD_INT 1
6938: PPUSH
6939: LD_EXP 73
6943: PPUSH
6944: CALL_OW 12
6948: ARRAY
6949: ST_TO_ADDR
6950: GO 6976
// ar := areas_wheeled [ Rand ( 1 , areas_wheeled ) ] ;
6952: LD_ADDR_VAR 0 4
6956: PUSH
6957: LD_EXP 72
6961: PUSH
6962: LD_INT 1
6964: PPUSH
6965: LD_EXP 72
6969: PPUSH
6970: CALL_OW 12
6974: ARRAY
6975: ST_TO_ADDR
// PlaceUnitArea ( v , ar , not atstart ) ;
6976: LD_VAR 0 3
6980: PPUSH
6981: LD_VAR 0 4
6985: PPUSH
6986: LD_VAR 0 1
6990: NOT
6991: PPUSH
6992: CALL_OW 49
// end ;
6996: LD_VAR 0 2
7000: RET
// function prepare_vehicles ; var i ; begin
7001: LD_INT 0
7003: PPUSH
7004: PPUSH
// for i := 1 to startveh do
7005: LD_ADDR_VAR 0 2
7009: PUSH
7010: DOUBLE
7011: LD_INT 1
7013: DEC
7014: ST_TO_ADDR
7015: LD_EXP 63
7019: PUSH
7020: FOR_TO
7021: IFFALSE 7032
// begin vehicles_create_vehicle ( true ) ;
7023: LD_INT 1
7025: PPUSH
7026: CALL 6881 0 1
// end ;
7030: GO 7020
7032: POP
7033: POP
// end ;
7034: LD_VAR 0 1
7038: RET
// function set_attitudes ; var i , j ; begin
7039: LD_INT 0
7041: PPUSH
7042: PPUSH
7043: PPUSH
// if not Team_Game then
7044: LD_EXP 47
7048: NOT
7049: IFFALSE 7145
// begin for i = 1 to 8 do
7051: LD_ADDR_VAR 0 2
7055: PUSH
7056: DOUBLE
7057: LD_INT 1
7059: DEC
7060: ST_TO_ADDR
7061: LD_INT 8
7063: PUSH
7064: FOR_TO
7065: IFFALSE 7143
// for j = 1 to 8 do
7067: LD_ADDR_VAR 0 3
7071: PUSH
7072: DOUBLE
7073: LD_INT 1
7075: DEC
7076: ST_TO_ADDR
7077: LD_INT 8
7079: PUSH
7080: FOR_TO
7081: IFFALSE 7139
// if i <> j then
7083: LD_VAR 0 2
7087: PUSH
7088: LD_VAR 0 3
7092: NONEQUAL
7093: IFFALSE 7117
// SetAttitude ( i , j , att_neutral , true ) else
7095: LD_VAR 0 2
7099: PPUSH
7100: LD_VAR 0 3
7104: PPUSH
7105: LD_INT 0
7107: PPUSH
7108: LD_INT 1
7110: PPUSH
7111: CALL_OW 80
7115: GO 7137
// SetAttitude ( i , j , att_friend , true ) end ;
7117: LD_VAR 0 2
7121: PPUSH
7122: LD_VAR 0 3
7126: PPUSH
7127: LD_INT 1
7129: PPUSH
7130: LD_INT 1
7132: PPUSH
7133: CALL_OW 80
7137: GO 7080
7139: POP
7140: POP
7141: GO 7064
7143: POP
7144: POP
// end ;
7145: LD_VAR 0 1
7149: RET
// function prepare_side ( side ) ; var i ; begin
7150: LD_INT 0
7152: PPUSH
7153: PPUSH
// for i := 1 to npeop do
7154: LD_ADDR_VAR 0 3
7158: PUSH
7159: DOUBLE
7160: LD_INT 1
7162: DEC
7163: ST_TO_ADDR
7164: LD_EXP 65
7168: PUSH
7169: FOR_TO
7170: IFFALSE 7279
// begin uc_side := side ;
7172: LD_ADDR_OWVAR 20
7176: PUSH
7177: LD_VAR 0 1
7181: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
7182: LD_ADDR_OWVAR 21
7186: PUSH
7187: LD_EXP 44
7191: PUSH
7192: LD_VAR 0 1
7196: ARRAY
7197: ST_TO_ADDR
// hc_name :=  ;
7198: LD_ADDR_OWVAR 26
7202: PUSH
7203: LD_STRING 
7205: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
7206: LD_INT 0
7208: PPUSH
7209: LD_INT 4
7211: PPUSH
7212: CALL_OW 383
// hc_importance := 0 ;
7216: LD_ADDR_OWVAR 32
7220: PUSH
7221: LD_INT 0
7223: ST_TO_ADDR
// hc_gallery :=  ;
7224: LD_ADDR_OWVAR 33
7228: PUSH
7229: LD_STRING 
7231: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 4 , false ) ;
7232: CALL_OW 44
7236: PPUSH
7237: LD_EXP 34
7241: PUSH
7242: LD_VAR 0 1
7246: ARRAY
7247: PUSH
7248: LD_INT 1
7250: ARRAY
7251: PPUSH
7252: LD_EXP 34
7256: PUSH
7257: LD_VAR 0 1
7261: ARRAY
7262: PUSH
7263: LD_INT 2
7265: ARRAY
7266: PPUSH
7267: LD_INT 4
7269: PPUSH
7270: LD_INT 0
7272: PPUSH
7273: CALL_OW 50
// end ;
7277: GO 7169
7279: POP
7280: POP
// end ;
7281: LD_VAR 0 2
7285: RET
// function prepare_sides ; var i ; begin
7286: LD_INT 0
7288: PPUSH
7289: PPUSH
// for i := 1 to 8 do
7290: LD_ADDR_VAR 0 2
7294: PUSH
7295: DOUBLE
7296: LD_INT 1
7298: DEC
7299: ST_TO_ADDR
7300: LD_INT 8
7302: PUSH
7303: FOR_TO
7304: IFFALSE 7329
// if side_positions [ i ] then
7306: LD_EXP 43
7310: PUSH
7311: LD_VAR 0 2
7315: ARRAY
7316: IFFALSE 7327
// prepare_side ( i ) ;
7318: LD_VAR 0 2
7322: PPUSH
7323: CALL 7150 0 1
7327: GO 7303
7329: POP
7330: POP
// end ;
7331: LD_VAR 0 1
7335: RET
// export function starting_vehicles ; begin
7336: LD_INT 0
7338: PPUSH
// mp_with_score := true ;
7339: LD_ADDR_OWVAR 14
7343: PUSH
7344: LD_INT 1
7346: ST_TO_ADDR
// mp_selectmsg := true ;
7347: LD_ADDR_OWVAR 13
7351: PUSH
7352: LD_INT 1
7354: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
7355: CALL 4063 0 0
// prepare_map_coordinates ;
7359: CALL 5111 0 0
// prepare_constants ;
7363: CALL 5602 0 0
// set_attitudes ;
7367: CALL 7039 0 0
// prepare_sides ;
7371: CALL 7286 0 0
// prepare_vehicles ;
7375: CALL 7001 0 0
// SetAreaMapShow ( exitarea , 1 ) ;
7379: LD_INT 20
7381: PPUSH
7382: LD_INT 1
7384: PPUSH
7385: CALL_OW 424
// your_side := Player_Side ;
7389: LD_ADDR_OWVAR 2
7393: PUSH
7394: LD_EXP 39
7398: ST_TO_ADDR
// ResetFog ;
7399: CALL_OW 335
// AnimateTrees ( true ) ;
7403: LD_INT 1
7405: PPUSH
7406: CALL_OW 573
// music_nat := Side_Nations [ your_side ] ;
7410: LD_ADDR_OWVAR 71
7414: PUSH
7415: LD_EXP 44
7419: PUSH
7420: LD_OWVAR 2
7424: ARRAY
7425: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
7426: LD_EXP 34
7430: PUSH
7431: LD_OWVAR 2
7435: ARRAY
7436: PUSH
7437: LD_INT 1
7439: ARRAY
7440: PPUSH
7441: LD_EXP 34
7445: PUSH
7446: LD_OWVAR 2
7450: ARRAY
7451: PUSH
7452: LD_INT 2
7454: ARRAY
7455: PPUSH
7456: CALL_OW 86
// end ; end_of_file
7460: LD_VAR 0 1
7464: RET
// every 0 0$0.5 + 2 marked 15 do var t , red ;
7465: GO 7467
7467: DISABLE
7468: LD_INT 0
7470: PPUSH
7471: PPUSH
// begin if not prep_time then
7472: LD_EXP 32
7476: NOT
7477: IFFALSE 7481
// exit ;
7479: GO 7603
// if tick >= prep_time then
7481: LD_OWVAR 1
7485: PUSH
7486: LD_EXP 32
7490: GREATEREQUAL
7491: IFFALSE 7506
// begin display_strings = [ ] ;
7493: LD_ADDR_OWVAR 47
7497: PUSH
7498: EMPTY
7499: ST_TO_ADDR
// sheherezade_start_the_fight ;
7500: CALL 3720 0 0
// end else
7504: GO 7603
// begin t = prep_time - tick ;
7506: LD_ADDR_VAR 0 1
7510: PUSH
7511: LD_EXP 32
7515: PUSH
7516: LD_OWVAR 1
7520: MINUS
7521: ST_TO_ADDR
// if t <= 0 0$5.5 then
7522: LD_VAR 0 1
7526: PUSH
7527: LD_INT 192
7529: LESSEQUAL
7530: IFFALSE 7552
// red := t mod 0 0$1 < 0 0$0.5 else
7532: LD_ADDR_VAR 0 2
7536: PUSH
7537: LD_VAR 0 1
7541: PUSH
7542: LD_INT 35
7544: MOD
7545: PUSH
7546: LD_INT 18
7548: LESS
7549: ST_TO_ADDR
7550: GO 7560
// red := false ;
7552: LD_ADDR_VAR 0 2
7556: PUSH
7557: LD_INT 0
7559: ST_TO_ADDR
// if red then
7560: LD_VAR 0 2
7564: IFFALSE 7585
// display_strings = [ #Sheherezade-Time2 , t ] else
7566: LD_ADDR_OWVAR 47
7570: PUSH
7571: LD_STRING #Sheherezade-Time2
7573: PUSH
7574: LD_VAR 0 1
7578: PUSH
7579: EMPTY
7580: LIST
7581: LIST
7582: ST_TO_ADDR
7583: GO 7602
// display_strings = [ #Sheherezade-Time1 , t ] ;
7585: LD_ADDR_OWVAR 47
7589: PUSH
7590: LD_STRING #Sheherezade-Time1
7592: PUSH
7593: LD_VAR 0 1
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: ST_TO_ADDR
// enable ;
7602: ENABLE
// end ; end ;
7603: PPOPN 2
7605: END
// every 4 marked 15 do
7606: GO 7608
7608: DISABLE
// begin if tick < prep_time then
7609: LD_OWVAR 1
7613: PUSH
7614: LD_EXP 32
7618: LESS
7619: IFFALSE 7634
// begin SetLives ( all_units , 1000 ) ;
7621: LD_OWVAR 3
7625: PPUSH
7626: LD_INT 1000
7628: PPUSH
7629: CALL_OW 234
// enable ;
7633: ENABLE
// end ; end ; end_of_file
7634: END
// on ApemanTamed ( ape , sci ) do begin if gametype = 15 then
7635: LD_EXP 1
7639: PUSH
7640: LD_INT 15
7642: EQUAL
7643: IFFALSE 7667
// begin if not def_apemen_abilities then
7645: LD_EXP 12
7649: NOT
7650: IFFALSE 7655
// disable else
7652: DISABLE
7653: GO 7667
// begin SetClass ( ape , class_apeman_soldier ) ;
7655: LD_VAR 0 1
7659: PPUSH
7660: LD_INT 15
7662: PPUSH
7663: CALL_OW 336
// end ; end ; end ;
7667: PPOPN 2
7669: END
// on UnitGoesToRed ( un ) do var killer , victim , near ;
7670: LD_INT 0
7672: PPUSH
7673: PPUSH
7674: PPUSH
// begin if gametype = 15 then
7675: LD_EXP 1
7679: PUSH
7680: LD_INT 15
7682: EQUAL
7683: IFFALSE 7908
// if un in sheherezades then
7685: LD_VAR 0 1
7689: PUSH
7690: LD_EXP 35
7694: IN
7695: IFFALSE 7908
// begin victim := GetSide ( un ) ;
7697: LD_ADDR_VAR 0 3
7701: PUSH
7702: LD_VAR 0 1
7706: PPUSH
7707: CALL_OW 255
7711: ST_TO_ADDR
// near := NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , victim ] , f_not , [ f_side , 0 ] ] ) , un ) ;
7712: LD_ADDR_VAR 0 4
7716: PUSH
7717: LD_INT 3
7719: PUSH
7720: LD_INT 22
7722: PUSH
7723: LD_VAR 0 3
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PUSH
7732: LD_INT 3
7734: PUSH
7735: LD_INT 22
7737: PUSH
7738: LD_INT 0
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: PPUSH
7751: CALL_OW 69
7755: PPUSH
7756: LD_VAR 0 1
7760: PPUSH
7761: CALL_OW 74
7765: ST_TO_ADDR
// killer := GetSide ( near ) ;
7766: LD_ADDR_VAR 0 2
7770: PUSH
7771: LD_VAR 0 4
7775: PPUSH
7776: CALL_OW 255
7780: ST_TO_ADDR
// if your_side and ( your_side = victim ) then
7781: LD_OWVAR 2
7785: PUSH
7786: LD_OWVAR 2
7790: PUSH
7791: LD_VAR 0 3
7795: EQUAL
7796: AND
7797: IFFALSE 7826
// begin wait ( 0 0$3 ) ;
7799: LD_INT 105
7801: PPUSH
7802: CALL_OW 67
// if not multiplayer then
7806: LD_OWVAR 4
7810: NOT
7811: IFFALSE 7822
// msg ( You Lost ) else
7813: LD_STRING You Lost
7815: PPUSH
7816: CALL_OW 100
7820: GO 7826
// YouLostInMultiplayer ;
7822: CALL_OW 107
// end ; sheherezades := Replace ( sheherezades , victim , 0 ) ;
7826: LD_ADDR_EXP 35
7830: PUSH
7831: LD_EXP 35
7835: PPUSH
7836: LD_VAR 0 3
7840: PPUSH
7841: LD_INT 0
7843: PPUSH
7844: CALL_OW 1
7848: ST_TO_ADDR
// SetSide ( FilterAllUnits ( [ f_side , victim ] ) , killer ) ;
7849: LD_INT 22
7851: PUSH
7852: LD_VAR 0 3
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: PPUSH
7861: CALL_OW 69
7865: PPUSH
7866: LD_VAR 0 2
7870: PPUSH
7871: CALL_OW 235
// ComStop ( FilterAllUnits ( [ f_side , killer ] ) ) ;
7875: LD_INT 22
7877: PUSH
7878: LD_VAR 0 2
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 69
7891: PPUSH
7892: CALL_OW 141
// SetLives ( un , 0 ) ;
7896: LD_VAR 0 1
7900: PPUSH
7901: LD_INT 0
7903: PPUSH
7904: CALL_OW 234
// end ; end ;
7908: PPOPN 4
7910: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if gametype = 25 then
7911: LD_EXP 1
7915: PUSH
7916: LD_INT 25
7918: EQUAL
7919: IFFALSE 8028
// begin if origside = 0 then
7921: LD_VAR 0 3
7925: PUSH
7926: LD_INT 0
7928: EQUAL
7929: IFFALSE 7981
// begin SetTag ( vehnew , Rand ( vehdur [ 1 ] , vehdur [ 2 ] ) ) ;
7931: LD_VAR 0 1
7935: PPUSH
7936: LD_EXP 64
7940: PUSH
7941: LD_INT 1
7943: ARRAY
7944: PPUSH
7945: LD_EXP 64
7949: PUSH
7950: LD_INT 2
7952: ARRAY
7953: PPUSH
7954: CALL_OW 12
7958: PPUSH
7959: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
7963: LD_ADDR_EXP 90
7967: PUSH
7968: LD_EXP 90
7972: PUSH
7973: LD_VAR 0 1
7977: ADD
7978: ST_TO_ADDR
// end else
7979: GO 8028
// begin SetUnitDisplayNumber ( vehnew , 0 ) ;
7981: LD_VAR 0 1
7985: PPUSH
7986: LD_INT 0
7988: PPUSH
7989: CALL_OW 505
// SetTag ( vehnew , GetTag ( vehold ) ) ;
7993: LD_VAR 0 1
7997: PPUSH
7998: LD_VAR 0 2
8002: PPUSH
8003: CALL_OW 110
8007: PPUSH
8008: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
8012: LD_ADDR_EXP 90
8016: PUSH
8017: LD_EXP 90
8021: PUSH
8022: LD_VAR 0 1
8026: ADD
8027: ST_TO_ADDR
// end ; end end ; end_of_file
8028: PPOPN 4
8030: END
// every 0 0$1 marked 25 do var i , ends , best ;
8031: GO 8033
8033: DISABLE
8034: LD_INT 0
8036: PPUSH
8037: PPUSH
8038: PPUSH
// begin ends := false ;
8039: LD_ADDR_VAR 0 2
8043: PUSH
8044: LD_INT 0
8046: ST_TO_ADDR
// best := 0 ;
8047: LD_ADDR_VAR 0 3
8051: PUSH
8052: LD_INT 0
8054: ST_TO_ADDR
// for i := 1 to 8 do
8055: LD_ADDR_VAR 0 1
8059: PUSH
8060: DOUBLE
8061: LD_INT 1
8063: DEC
8064: ST_TO_ADDR
8065: LD_INT 8
8067: PUSH
8068: FOR_TO
8069: IFFALSE 8105
// if GetMultiScore ( i ) > best then
8071: LD_VAR 0 1
8075: PPUSH
8076: CALL_OW 507
8080: PUSH
8081: LD_VAR 0 3
8085: GREATER
8086: IFFALSE 8103
// best := GetMultiScore ( i ) ;
8088: LD_ADDR_VAR 0 3
8092: PUSH
8093: LD_VAR 0 1
8097: PPUSH
8098: CALL_OW 507
8102: ST_TO_ADDR
8103: GO 8068
8105: POP
8106: POP
// if point_limit then
8107: LD_EXP 57
8111: IFFALSE 8133
// if best > point_limit then
8113: LD_VAR 0 3
8117: PUSH
8118: LD_EXP 57
8122: GREATER
8123: IFFALSE 8133
// ends := true ;
8125: LD_ADDR_VAR 0 2
8129: PUSH
8130: LD_INT 1
8132: ST_TO_ADDR
// if game_time then
8133: LD_EXP 56
8137: IFFALSE 8159
// if game_time <= tick then
8139: LD_EXP 56
8143: PUSH
8144: LD_OWVAR 1
8148: LESSEQUAL
8149: IFFALSE 8159
// ends := true ;
8151: LD_ADDR_VAR 0 2
8155: PUSH
8156: LD_INT 1
8158: ST_TO_ADDR
// if ends then
8159: LD_VAR 0 2
8163: IFFALSE 8208
// begin if GetMultiScore ( your_side ) = best then
8165: LD_OWVAR 2
8169: PPUSH
8170: CALL_OW 507
8174: PUSH
8175: LD_VAR 0 3
8179: EQUAL
8180: IFFALSE 8195
// begin wait ( 0 0$1 ) ;
8182: LD_INT 35
8184: PPUSH
8185: CALL_OW 67
// YouWinInMultiplayer ;
8189: CALL_OW 106
// end else
8193: GO 8206
// begin wait ( 0 0$1 ) ;
8195: LD_INT 35
8197: PPUSH
8198: CALL_OW 67
// YouLostInMultiplayer ;
8202: CALL_OW 107
// end ; end else
8206: GO 8209
// enable ;
8208: ENABLE
// end ;
8209: PPOPN 3
8211: END
// every 0 0$3 marked 15 do var win , i ;
8212: GO 8214
8214: DISABLE
8215: LD_INT 0
8217: PPUSH
8218: PPUSH
// begin win := true ;
8219: LD_ADDR_VAR 0 1
8223: PUSH
8224: LD_INT 1
8226: ST_TO_ADDR
// for i = 1 to Side_Positions do
8227: LD_ADDR_VAR 0 2
8231: PUSH
8232: DOUBLE
8233: LD_INT 1
8235: DEC
8236: ST_TO_ADDR
8237: LD_EXP 43
8241: PUSH
8242: FOR_TO
8243: IFFALSE 8307
// if Side_Positions [ i ] and ( i <> your_side ) and MultiplayerSideAlive ( i ) then
8245: LD_EXP 43
8249: PUSH
8250: LD_VAR 0 2
8254: ARRAY
8255: PUSH
8256: LD_VAR 0 2
8260: PUSH
8261: LD_OWVAR 2
8265: NONEQUAL
8266: AND
8267: PUSH
8268: LD_VAR 0 2
8272: PPUSH
8273: CALL_OW 108
8277: AND
8278: IFFALSE 8305
// if not AlliedSides ( i , your_side ) then
8280: LD_VAR 0 2
8284: PPUSH
8285: LD_OWVAR 2
8289: PPUSH
8290: CALL 8332 0 2
8294: NOT
8295: IFFALSE 8305
// win := false ;
8297: LD_ADDR_VAR 0 1
8301: PUSH
8302: LD_INT 0
8304: ST_TO_ADDR
8305: GO 8242
8307: POP
8308: POP
// if win then
8309: LD_VAR 0 1
8313: IFFALSE 8328
// begin wait ( 0 0$3 ) ;
8315: LD_INT 105
8317: PPUSH
8318: CALL_OW 67
// YouWinInMultiplayer ;
8322: CALL_OW 106
// exit ;
8326: GO 8329
// end ; enable ;
8328: ENABLE
// end ;
8329: PPOPN 2
8331: END
// function AlliedSides ( i , j ) ; var vysledek ; begin
8332: LD_INT 0
8334: PPUSH
8335: PPUSH
// vysledek := false ;
8336: LD_ADDR_VAR 0 4
8340: PUSH
8341: LD_INT 0
8343: ST_TO_ADDR
// if ( GetAttitude ( i , j ) = att_friend ) and ( GetAttitude ( j , i ) = att_friend ) and GetAlliedVictory ( i ) and GetAlliedVictory ( j ) then
8344: LD_VAR 0 1
8348: PPUSH
8349: LD_VAR 0 2
8353: PPUSH
8354: CALL_OW 81
8358: PUSH
8359: LD_INT 1
8361: EQUAL
8362: PUSH
8363: LD_VAR 0 2
8367: PPUSH
8368: LD_VAR 0 1
8372: PPUSH
8373: CALL_OW 81
8377: PUSH
8378: LD_INT 1
8380: EQUAL
8381: AND
8382: PUSH
8383: LD_VAR 0 1
8387: PPUSH
8388: CALL_OW 83
8392: AND
8393: PUSH
8394: LD_VAR 0 2
8398: PPUSH
8399: CALL_OW 83
8403: AND
8404: IFFALSE 8414
// vysledek := true ;
8406: LD_ADDR_VAR 0 4
8410: PUSH
8411: LD_INT 1
8413: ST_TO_ADDR
// result := vysledek ;
8414: LD_ADDR_VAR 0 3
8418: PUSH
8419: LD_VAR 0 4
8423: ST_TO_ADDR
// end ; end_of_file
8424: LD_VAR 0 3
8428: RET
// export def_hunters , def_hunt_size , def_hunt_balance , def_hunt_limit , def_doctors ; export one_hunter , hunt_limit , size_of_ape_team , size_of_hunt_team , doctors_in_team , hunter_level , ape_level , ape_stamina , to_be_alone , people , scorestring ; function read_multiplayer_and_game_parameters ; var i , p1 , p2 ; begin
8429: LD_INT 0
8431: PPUSH
8432: PPUSH
8433: PPUSH
8434: PPUSH
// if MultiPlayer then
8435: LD_OWVAR 4
8439: IFFALSE 8503
// begin Player_Side = mp_player_side ;
8441: LD_ADDR_EXP 39
8445: PUSH
8446: LD_OWVAR 7
8450: ST_TO_ADDR
// Player_Team = mp_player_team ;
8451: LD_ADDR_EXP 40
8455: PUSH
8456: LD_OWVAR 8
8460: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
8461: LD_ADDR_EXP 43
8465: PUSH
8466: LD_OWVAR 17
8470: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
8471: LD_ADDR_EXP 41
8475: PUSH
8476: LD_OWVAR 15
8480: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
8481: LD_ADDR_EXP 44
8485: PUSH
8486: LD_OWVAR 16
8490: ST_TO_ADDR
// Teams = mp_teams ;
8491: LD_ADDR_EXP 42
8495: PUSH
8496: LD_OWVAR 12
8500: ST_TO_ADDR
// end else
8501: GO 8647
// begin randomize ;
8503: CALL_OW 10
// Player_Side = 1 ;
8507: LD_ADDR_EXP 39
8511: PUSH
8512: LD_INT 1
8514: ST_TO_ADDR
// Player_Team = 0 ;
8515: LD_ADDR_EXP 40
8519: PUSH
8520: LD_INT 0
8522: ST_TO_ADDR
// Side_Positions = [ 1 , 3 , 6 , 0 , 0 , 0 , 0 , 7 ] ;
8523: LD_ADDR_EXP 43
8527: PUSH
8528: LD_INT 1
8530: PUSH
8531: LD_INT 3
8533: PUSH
8534: LD_INT 6
8536: PUSH
8537: LD_INT 0
8539: PUSH
8540: LD_INT 0
8542: PUSH
8543: LD_INT 0
8545: PUSH
8546: LD_INT 0
8548: PUSH
8549: LD_INT 7
8551: PUSH
8552: EMPTY
8553: LIST
8554: LIST
8555: LIST
8556: LIST
8557: LIST
8558: LIST
8559: LIST
8560: LIST
8561: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
8562: LD_ADDR_EXP 41
8566: PUSH
8567: LD_INT 0
8569: PUSH
8570: LD_INT 0
8572: PUSH
8573: LD_INT 0
8575: PUSH
8576: LD_INT 0
8578: PUSH
8579: LD_INT 0
8581: PUSH
8582: LD_INT 0
8584: PUSH
8585: LD_INT 0
8587: PUSH
8588: LD_INT 0
8590: PUSH
8591: EMPTY
8592: LIST
8593: LIST
8594: LIST
8595: LIST
8596: LIST
8597: LIST
8598: LIST
8599: LIST
8600: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 2 , 2 , 2 , 2 ] ;
8601: LD_ADDR_EXP 44
8605: PUSH
8606: LD_INT 1
8608: PUSH
8609: LD_INT 3
8611: PUSH
8612: LD_INT 1
8614: PUSH
8615: LD_INT 2
8617: PUSH
8618: LD_INT 2
8620: PUSH
8621: LD_INT 2
8623: PUSH
8624: LD_INT 2
8626: PUSH
8627: LD_INT 2
8629: PUSH
8630: EMPTY
8631: LIST
8632: LIST
8633: LIST
8634: LIST
8635: LIST
8636: LIST
8637: LIST
8638: LIST
8639: ST_TO_ADDR
// Teams = [ ] ;
8640: LD_ADDR_EXP 42
8644: PUSH
8645: EMPTY
8646: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
8647: LD_ADDR_EXP 37
8651: PUSH
8652: LD_EXP 43
8656: PUSH
8657: LD_INT 0
8659: PUSH
8660: EMPTY
8661: LIST
8662: DIFF
8663: PUSH
8664: LD_INT 0
8666: PLUS
8667: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
8668: LD_ADDR_EXP 38
8672: PUSH
8673: LD_EXP 41
8677: PUSH
8678: LD_INT 0
8680: PUSH
8681: EMPTY
8682: LIST
8683: DIFF
8684: PUSH
8685: LD_INT 0
8687: PLUS
8688: ST_TO_ADDR
// if MultiPlayer then
8689: LD_OWVAR 4
8693: IFFALSE 8749
// begin def_hunt_size = GetMultiplayerSetting ( 1 ) ;
8695: LD_ADDR_EXP 75
8699: PUSH
8700: LD_INT 1
8702: PPUSH
8703: CALL_OW 426
8707: ST_TO_ADDR
// def_hunt_balance = GetMultiplayerSetting ( 2 ) ;
8708: LD_ADDR_EXP 76
8712: PUSH
8713: LD_INT 2
8715: PPUSH
8716: CALL_OW 426
8720: ST_TO_ADDR
// def_hunt_limit = GetMultiplayerSetting ( 3 ) ;
8721: LD_ADDR_EXP 77
8725: PUSH
8726: LD_INT 3
8728: PPUSH
8729: CALL_OW 426
8733: ST_TO_ADDR
// def_doctors = GetMultiplayerSetting ( 4 ) ;
8734: LD_ADDR_EXP 78
8738: PUSH
8739: LD_INT 4
8741: PPUSH
8742: CALL_OW 426
8746: ST_TO_ADDR
// end else
8747: GO 8785
// begin randomize ;
8749: CALL_OW 10
// def_hunt_size = 1 ;
8753: LD_ADDR_EXP 75
8757: PUSH
8758: LD_INT 1
8760: ST_TO_ADDR
// def_hunt_balance = 1 ;
8761: LD_ADDR_EXP 76
8765: PUSH
8766: LD_INT 1
8768: ST_TO_ADDR
// def_hunt_limit = 1 ;
8769: LD_ADDR_EXP 77
8773: PUSH
8774: LD_INT 1
8776: ST_TO_ADDR
// def_doctors = 1 ;
8777: LD_ADDR_EXP 78
8781: PUSH
8782: LD_INT 1
8784: ST_TO_ADDR
// end ; one_hunter = gametype = 36 ;
8785: LD_ADDR_EXP 79
8789: PUSH
8790: LD_EXP 1
8794: PUSH
8795: LD_INT 36
8797: EQUAL
8798: ST_TO_ADDR
// if one_hunter then
8799: LD_EXP 79
8803: IFFALSE 9076
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
8805: LD_ADDR_EXP 80
8809: PUSH
8810: LD_INT 4200
8812: PUSH
8813: LD_INT 6300
8815: PUSH
8816: LD_INT 8400
8818: PUSH
8819: LD_INT 10500
8821: PUSH
8822: EMPTY
8823: LIST
8824: LIST
8825: LIST
8826: LIST
8827: PUSH
8828: LD_EXP 77
8832: PUSH
8833: LD_INT 1
8835: PLUS
8836: ARRAY
8837: ST_TO_ADDR
// p1 = [ 6 , 10 , 12 ] [ def_hunt_size + 1 ] ;
8838: LD_ADDR_VAR 0 3
8842: PUSH
8843: LD_INT 6
8845: PUSH
8846: LD_INT 10
8848: PUSH
8849: LD_INT 12
8851: PUSH
8852: EMPTY
8853: LIST
8854: LIST
8855: LIST
8856: PUSH
8857: LD_EXP 75
8861: PUSH
8862: LD_INT 1
8864: PLUS
8865: ARRAY
8866: ST_TO_ADDR
// p2 = [ 2 , 4 , 6 ] [ def_hunt_size + 1 ] ;
8867: LD_ADDR_VAR 0 4
8871: PUSH
8872: LD_INT 2
8874: PUSH
8875: LD_INT 4
8877: PUSH
8878: LD_INT 6
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: PUSH
8886: LD_EXP 75
8890: PUSH
8891: LD_INT 1
8893: PLUS
8894: ARRAY
8895: ST_TO_ADDR
// size_of_ape_team = p1 div side_count + p2 ;
8896: LD_ADDR_EXP 81
8900: PUSH
8901: LD_VAR 0 3
8905: PUSH
8906: LD_EXP 37
8910: DIV
8911: PUSH
8912: LD_VAR 0 4
8916: PLUS
8917: ST_TO_ADDR
// size_of_hunt_team = size_of_ape_team * ( side_count - 1 ) ;
8918: LD_ADDR_EXP 82
8922: PUSH
8923: LD_EXP 81
8927: PUSH
8928: LD_EXP 37
8932: PUSH
8933: LD_INT 1
8935: MINUS
8936: MUL
8937: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
8938: LD_ADDR_EXP 83
8942: PUSH
8943: LD_INT 0
8945: PUSH
8946: LD_EXP 82
8950: PUSH
8951: LD_INT 5
8953: PLUS
8954: PUSH
8955: LD_INT 6
8957: DIV
8958: PUSH
8959: LD_EXP 82
8963: PUSH
8964: LD_INT 3
8966: PLUS
8967: PUSH
8968: LD_INT 4
8970: DIV
8971: PUSH
8972: EMPTY
8973: LIST
8974: LIST
8975: LIST
8976: PUSH
8977: LD_EXP 78
8981: PUSH
8982: LD_INT 1
8984: PLUS
8985: ARRAY
8986: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
8987: LD_ADDR_EXP 84
8991: PUSH
8992: LD_INT 5
8994: PUSH
8995: LD_INT 3
8997: PUSH
8998: LD_INT 1
9000: PUSH
9001: EMPTY
9002: LIST
9003: LIST
9004: LIST
9005: PUSH
9006: LD_EXP 76
9010: PUSH
9011: LD_INT 1
9013: PLUS
9014: ARRAY
9015: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9016: LD_ADDR_EXP 85
9020: PUSH
9021: LD_INT 1
9023: PUSH
9024: LD_INT 2
9026: PUSH
9027: LD_INT 3
9029: PUSH
9030: EMPTY
9031: LIST
9032: LIST
9033: LIST
9034: PUSH
9035: LD_EXP 76
9039: PUSH
9040: LD_INT 1
9042: PLUS
9043: ARRAY
9044: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9045: LD_ADDR_EXP 86
9049: PUSH
9050: LD_INT 6
9052: PUSH
9053: LD_INT 10
9055: PUSH
9056: LD_INT 13
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: LIST
9063: PUSH
9064: LD_EXP 76
9068: PUSH
9069: LD_INT 1
9071: PLUS
9072: ARRAY
9073: ST_TO_ADDR
// end else
9074: GO 9355
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
9076: LD_ADDR_EXP 80
9080: PUSH
9081: LD_INT 4200
9083: PUSH
9084: LD_INT 6300
9086: PUSH
9087: LD_INT 8400
9089: PUSH
9090: LD_INT 10500
9092: PUSH
9093: EMPTY
9094: LIST
9095: LIST
9096: LIST
9097: LIST
9098: PUSH
9099: LD_EXP 77
9103: PUSH
9104: LD_INT 1
9106: PLUS
9107: ARRAY
9108: ST_TO_ADDR
// p1 = [ 10 , 15 , 20 ] [ def_hunt_size + 1 ] ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_INT 10
9116: PUSH
9117: LD_INT 15
9119: PUSH
9120: LD_INT 20
9122: PUSH
9123: EMPTY
9124: LIST
9125: LIST
9126: LIST
9127: PUSH
9128: LD_EXP 75
9132: PUSH
9133: LD_INT 1
9135: PLUS
9136: ARRAY
9137: ST_TO_ADDR
// p2 = [ 3 , 5 , 7 ] [ def_hunt_size + 1 ] ;
9138: LD_ADDR_VAR 0 4
9142: PUSH
9143: LD_INT 3
9145: PUSH
9146: LD_INT 5
9148: PUSH
9149: LD_INT 7
9151: PUSH
9152: EMPTY
9153: LIST
9154: LIST
9155: LIST
9156: PUSH
9157: LD_EXP 75
9161: PUSH
9162: LD_INT 1
9164: PLUS
9165: ARRAY
9166: ST_TO_ADDR
// size_of_hunt_team = p1 div side_count + p2 ;
9167: LD_ADDR_EXP 82
9171: PUSH
9172: LD_VAR 0 3
9176: PUSH
9177: LD_EXP 37
9181: DIV
9182: PUSH
9183: LD_VAR 0 4
9187: PLUS
9188: ST_TO_ADDR
// size_of_ape_team = ( size_of_hunt_team + size_of_hunt_team * ( side_count - 1 ) ) div 2 ;
9189: LD_ADDR_EXP 81
9193: PUSH
9194: LD_EXP 82
9198: PUSH
9199: LD_EXP 82
9203: PUSH
9204: LD_EXP 37
9208: PUSH
9209: LD_INT 1
9211: MINUS
9212: MUL
9213: PLUS
9214: PUSH
9215: LD_INT 2
9217: DIV
9218: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
9219: LD_ADDR_EXP 83
9223: PUSH
9224: LD_INT 0
9226: PUSH
9227: LD_EXP 82
9231: PUSH
9232: LD_INT 5
9234: PLUS
9235: PUSH
9236: LD_INT 6
9238: DIV
9239: PUSH
9240: LD_EXP 82
9244: PUSH
9245: LD_INT 3
9247: PLUS
9248: PUSH
9249: LD_INT 4
9251: DIV
9252: PUSH
9253: EMPTY
9254: LIST
9255: LIST
9256: LIST
9257: PUSH
9258: LD_EXP 78
9262: PUSH
9263: LD_INT 1
9265: PLUS
9266: ARRAY
9267: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
9268: LD_ADDR_EXP 84
9272: PUSH
9273: LD_INT 5
9275: PUSH
9276: LD_INT 3
9278: PUSH
9279: LD_INT 1
9281: PUSH
9282: EMPTY
9283: LIST
9284: LIST
9285: LIST
9286: PUSH
9287: LD_EXP 76
9291: PUSH
9292: LD_INT 1
9294: PLUS
9295: ARRAY
9296: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9297: LD_ADDR_EXP 85
9301: PUSH
9302: LD_INT 1
9304: PUSH
9305: LD_INT 2
9307: PUSH
9308: LD_INT 3
9310: PUSH
9311: EMPTY
9312: LIST
9313: LIST
9314: LIST
9315: PUSH
9316: LD_EXP 76
9320: PUSH
9321: LD_INT 1
9323: PLUS
9324: ARRAY
9325: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9326: LD_ADDR_EXP 86
9330: PUSH
9331: LD_INT 6
9333: PUSH
9334: LD_INT 10
9336: PUSH
9337: LD_INT 13
9339: PUSH
9340: EMPTY
9341: LIST
9342: LIST
9343: LIST
9344: PUSH
9345: LD_EXP 76
9349: PUSH
9350: LD_INT 1
9352: PLUS
9353: ARRAY
9354: ST_TO_ADDR
// end ; for i = 1 to 8 do
9355: LD_ADDR_VAR 0 2
9359: PUSH
9360: DOUBLE
9361: LD_INT 1
9363: DEC
9364: ST_TO_ADDR
9365: LD_INT 8
9367: PUSH
9368: FOR_TO
9369: IFFALSE 9401
// if Side_Positions [ i ] then
9371: LD_EXP 43
9375: PUSH
9376: LD_VAR 0 2
9380: ARRAY
9381: IFFALSE 9399
// to_be_alone := to_be_alone ^ i ;
9383: LD_ADDR_EXP 87
9387: PUSH
9388: LD_EXP 87
9392: PUSH
9393: LD_VAR 0 2
9397: ADD
9398: ST_TO_ADDR
9399: GO 9368
9401: POP
9402: POP
// end ;
9403: LD_VAR 0 1
9407: RET
// function prepare_hunter_team ( side ) ; var i , team ; begin
9408: LD_INT 0
9410: PPUSH
9411: PPUSH
9412: PPUSH
// team := [ ] ;
9413: LD_ADDR_VAR 0 4
9417: PUSH
9418: EMPTY
9419: ST_TO_ADDR
// for i := 1 to size_of_hunt_team do
9420: LD_ADDR_VAR 0 3
9424: PUSH
9425: DOUBLE
9426: LD_INT 1
9428: DEC
9429: ST_TO_ADDR
9430: LD_EXP 82
9434: PUSH
9435: FOR_TO
9436: IFFALSE 9553
// begin uc_nation := side_nations [ side ] ;
9438: LD_ADDR_OWVAR 21
9442: PUSH
9443: LD_EXP 44
9447: PUSH
9448: LD_VAR 0 1
9452: ARRAY
9453: ST_TO_ADDR
// uc_side := side ;
9454: LD_ADDR_OWVAR 20
9458: PUSH
9459: LD_VAR 0 1
9463: ST_TO_ADDR
// hc_name :=  ;
9464: LD_ADDR_OWVAR 26
9468: PUSH
9469: LD_STRING 
9471: ST_TO_ADDR
// if i > size_of_hunt_team - doctors_in_team then
9472: LD_VAR 0 3
9476: PUSH
9477: LD_EXP 82
9481: PUSH
9482: LD_EXP 83
9486: MINUS
9487: GREATER
9488: IFFALSE 9504
// PrepareScientist ( 0 , hunter_level ) else
9490: LD_INT 0
9492: PPUSH
9493: LD_EXP 84
9497: PPUSH
9498: CALL_OW 384
9502: GO 9516
// PrepareSoldier ( 0 , hunter_level ) ;
9504: LD_INT 0
9506: PPUSH
9507: LD_EXP 84
9511: PPUSH
9512: CALL_OW 381
// hc_gallery :=  ;
9516: LD_ADDR_OWVAR 33
9520: PUSH
9521: LD_STRING 
9523: ST_TO_ADDR
// hc_importance := 0 ;
9524: LD_ADDR_OWVAR 32
9528: PUSH
9529: LD_INT 0
9531: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9532: LD_ADDR_VAR 0 4
9536: PUSH
9537: LD_VAR 0 4
9541: PUSH
9542: CALL_OW 44
9546: PUSH
9547: EMPTY
9548: LIST
9549: ADD
9550: ST_TO_ADDR
// end ;
9551: GO 9435
9553: POP
9554: POP
// people := Replace ( people , side , team ) ;
9555: LD_ADDR_EXP 88
9559: PUSH
9560: LD_EXP 88
9564: PPUSH
9565: LD_VAR 0 1
9569: PPUSH
9570: LD_VAR 0 4
9574: PPUSH
9575: CALL_OW 1
9579: ST_TO_ADDR
// end ;
9580: LD_VAR 0 2
9584: RET
// function prepare_ape_team ( side ) ; var i , team ; begin
9585: LD_INT 0
9587: PPUSH
9588: PPUSH
9589: PPUSH
// team := [ ] ;
9590: LD_ADDR_VAR 0 4
9594: PUSH
9595: EMPTY
9596: ST_TO_ADDR
// for i := 1 to size_of_ape_team do
9597: LD_ADDR_VAR 0 3
9601: PUSH
9602: DOUBLE
9603: LD_INT 1
9605: DEC
9606: ST_TO_ADDR
9607: LD_EXP 81
9611: PUSH
9612: FOR_TO
9613: IFFALSE 9736
// begin uc_nation := nation_nature ;
9615: LD_ADDR_OWVAR 21
9619: PUSH
9620: LD_INT 0
9622: ST_TO_ADDR
// uc_side := side ;
9623: LD_ADDR_OWVAR 20
9627: PUSH
9628: LD_VAR 0 1
9632: ST_TO_ADDR
// hc_name :=  ;
9633: LD_ADDR_OWVAR 26
9637: PUSH
9638: LD_STRING 
9640: ST_TO_ADDR
// hc_attr := [ ape_stamina , 14 ] ;
9641: LD_ADDR_OWVAR 29
9645: PUSH
9646: LD_EXP 86
9650: PUSH
9651: LD_INT 14
9653: PUSH
9654: EMPTY
9655: LIST
9656: LIST
9657: ST_TO_ADDR
// hc_skills := [ ape_level , 0 , 0 , 0 ] ;
9658: LD_ADDR_OWVAR 31
9662: PUSH
9663: LD_EXP 85
9667: PUSH
9668: LD_INT 0
9670: PUSH
9671: LD_INT 0
9673: PUSH
9674: LD_INT 0
9676: PUSH
9677: EMPTY
9678: LIST
9679: LIST
9680: LIST
9681: LIST
9682: ST_TO_ADDR
// hc_sex := sex_male ;
9683: LD_ADDR_OWVAR 27
9687: PUSH
9688: LD_INT 1
9690: ST_TO_ADDR
// hc_class := class_apeman ;
9691: LD_ADDR_OWVAR 28
9695: PUSH
9696: LD_INT 12
9698: ST_TO_ADDR
// hc_gallery :=  ;
9699: LD_ADDR_OWVAR 33
9703: PUSH
9704: LD_STRING 
9706: ST_TO_ADDR
// hc_importance := 0 ;
9707: LD_ADDR_OWVAR 32
9711: PUSH
9712: LD_INT 0
9714: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9715: LD_ADDR_VAR 0 4
9719: PUSH
9720: LD_VAR 0 4
9724: PUSH
9725: CALL_OW 44
9729: PUSH
9730: EMPTY
9731: LIST
9732: ADD
9733: ST_TO_ADDR
// end ;
9734: GO 9612
9736: POP
9737: POP
// people := Replace ( people , side , team ) ;
9738: LD_ADDR_EXP 88
9742: PUSH
9743: LD_EXP 88
9747: PPUSH
9748: LD_VAR 0 1
9752: PPUSH
9753: LD_VAR 0 4
9757: PPUSH
9758: CALL_OW 1
9762: ST_TO_ADDR
// end ;
9763: LD_VAR 0 2
9767: RET
// function display_score ( alone , t ) ; begin
9768: LD_INT 0
9770: PPUSH
// display_strings := scorestring ^  ;
9771: LD_ADDR_OWVAR 47
9775: PUSH
9776: LD_EXP 89
9780: PUSH
9781: LD_STRING 
9783: ADD
9784: ST_TO_ADDR
// if alone then
9785: LD_VAR 0 1
9789: IFFALSE 9869
// if one_hunter then
9791: LD_EXP 79
9795: IFFALSE 9834
// display_strings := display_strings ^ [ #Hunt-prepare2 , alone , alone , t ] else
9797: LD_ADDR_OWVAR 47
9801: PUSH
9802: LD_OWVAR 47
9806: PUSH
9807: LD_STRING #Hunt-prepare2
9809: PUSH
9810: LD_VAR 0 1
9814: PUSH
9815: LD_VAR 0 1
9819: PUSH
9820: LD_VAR 0 2
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: LIST
9830: ADD
9831: ST_TO_ADDR
9832: GO 9869
// display_strings := display_strings ^ [ #Hunt-prepare1 , alone , alone , t ] ;
9834: LD_ADDR_OWVAR 47
9838: PUSH
9839: LD_OWVAR 47
9843: PUSH
9844: LD_STRING #Hunt-prepare1
9846: PUSH
9847: LD_VAR 0 1
9851: PUSH
9852: LD_VAR 0 1
9856: PUSH
9857: LD_VAR 0 2
9861: PUSH
9862: EMPTY
9863: LIST
9864: LIST
9865: LIST
9866: LIST
9867: ADD
9868: ST_TO_ADDR
// end ;
9869: LD_VAR 0 3
9873: RET
// function set_attitudes ( alone ) ; var i , j ; begin
9874: LD_INT 0
9876: PPUSH
9877: PPUSH
9878: PPUSH
// for i := 1 to 8 do
9879: LD_ADDR_VAR 0 3
9883: PUSH
9884: DOUBLE
9885: LD_INT 1
9887: DEC
9888: ST_TO_ADDR
9889: LD_INT 8
9891: PUSH
9892: FOR_TO
9893: IFFALSE 9983
// for j := 1 to 8 do
9895: LD_ADDR_VAR 0 4
9899: PUSH
9900: DOUBLE
9901: LD_INT 1
9903: DEC
9904: ST_TO_ADDR
9905: LD_INT 8
9907: PUSH
9908: FOR_TO
9909: IFFALSE 9979
// if ( i = alone ) = ( j = alone ) then
9911: LD_VAR 0 3
9915: PUSH
9916: LD_VAR 0 1
9920: EQUAL
9921: PUSH
9922: LD_VAR 0 4
9926: PUSH
9927: LD_VAR 0 1
9931: EQUAL
9932: EQUAL
9933: IFFALSE 9957
// SetAttitude ( i , j , att_friend , true ) else
9935: LD_VAR 0 3
9939: PPUSH
9940: LD_VAR 0 4
9944: PPUSH
9945: LD_INT 1
9947: PPUSH
9948: LD_INT 1
9950: PPUSH
9951: CALL_OW 80
9955: GO 9977
// SetAttitude ( i , j , att_enemy , true ) ;
9957: LD_VAR 0 3
9961: PPUSH
9962: LD_VAR 0 4
9966: PPUSH
9967: LD_INT 2
9969: PPUSH
9970: LD_INT 1
9972: PPUSH
9973: CALL_OW 80
9977: GO 9908
9979: POP
9980: POP
9981: GO 9892
9983: POP
9984: POP
// end ;
9985: LD_VAR 0 2
9989: RET
// function set_technologies ( alone ) ; var i ; begin
9990: LD_INT 0
9992: PPUSH
9993: PPUSH
// for i := 1 to 8 do
9994: LD_ADDR_VAR 0 3
9998: PUSH
9999: DOUBLE
10000: LD_INT 1
10002: DEC
10003: ST_TO_ADDR
10004: LD_INT 8
10006: PUSH
10007: FOR_TO
10008: IFFALSE 10197
// begin if ( alone = i ) = one_hunter then
10010: LD_VAR 0 1
10014: PUSH
10015: LD_VAR 0 3
10019: EQUAL
10020: PUSH
10021: LD_EXP 79
10025: EQUAL
10026: IFFALSE 10090
// begin SetTech ( tech_Opto1 , i , state_disabled ) ;
10028: LD_INT 60
10030: PPUSH
10031: LD_VAR 0 3
10035: PPUSH
10036: LD_INT 0
10038: PPUSH
10039: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_disabled ) ;
10043: LD_INT 61
10045: PPUSH
10046: LD_VAR 0 3
10050: PPUSH
10051: LD_INT 0
10053: PPUSH
10054: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_disabled ) ;
10058: LD_INT 62
10060: PPUSH
10061: LD_VAR 0 3
10065: PPUSH
10066: LD_INT 0
10068: PPUSH
10069: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_disabled ) ;
10073: LD_INT 5
10075: PPUSH
10076: LD_VAR 0 3
10080: PPUSH
10081: LD_INT 0
10083: PPUSH
10084: CALL_OW 322
// end else
10088: GO 10150
// begin SetTech ( tech_Opto1 , i , state_researched ) ;
10090: LD_INT 60
10092: PPUSH
10093: LD_VAR 0 3
10097: PPUSH
10098: LD_INT 2
10100: PPUSH
10101: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_researched ) ;
10105: LD_INT 61
10107: PPUSH
10108: LD_VAR 0 3
10112: PPUSH
10113: LD_INT 2
10115: PPUSH
10116: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_researched ) ;
10120: LD_INT 62
10122: PPUSH
10123: LD_VAR 0 3
10127: PPUSH
10128: LD_INT 2
10130: PPUSH
10131: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_researched ) ;
10135: LD_INT 5
10137: PPUSH
10138: LD_VAR 0 3
10142: PPUSH
10143: LD_INT 2
10145: PPUSH
10146: CALL_OW 322
// end ; SetTech ( tech_Weap1 , i , state_disabled ) ;
10150: LD_INT 51
10152: PPUSH
10153: LD_VAR 0 3
10157: PPUSH
10158: LD_INT 0
10160: PPUSH
10161: CALL_OW 322
// SetTech ( tech_Weap2 , i , state_disabled ) ;
10165: LD_INT 52
10167: PPUSH
10168: LD_VAR 0 3
10172: PPUSH
10173: LD_INT 0
10175: PPUSH
10176: CALL_OW 322
// SetTech ( tech_Weap3 , i , state_disabled ) ;
10180: LD_INT 53
10182: PPUSH
10183: LD_VAR 0 3
10187: PPUSH
10188: LD_INT 0
10190: PPUSH
10191: CALL_OW 322
// end ;
10195: GO 10007
10197: POP
10198: POP
// end ;
10199: LD_VAR 0 2
10203: RET
// function prepare_map_coordinates_more_hunters ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10204: LD_INT 0
10206: PPUSH
10207: PPUSH
10208: PPUSH
10209: PPUSH
10210: PPUSH
10211: PPUSH
10212: PPUSH
10213: PPUSH
// best = 0 ;
10214: LD_ADDR_VAR 0 3
10218: PUSH
10219: LD_INT 0
10221: ST_TO_ADDR
// for n = 1 to 40 do
10222: LD_ADDR_VAR 0 9
10226: PUSH
10227: DOUBLE
10228: LD_INT 1
10230: DEC
10231: ST_TO_ADDR
10232: LD_INT 40
10234: PUSH
10235: FOR_TO
10236: IFFALSE 10544
// begin c = [ ] ;
10238: LD_ADDR_VAR 0 4
10242: PUSH
10243: EMPTY
10244: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10245: LD_ADDR_VAR 0 7
10249: PUSH
10250: DOUBLE
10251: LD_INT 1
10253: DEC
10254: ST_TO_ADDR
10255: LD_EXP 37
10259: PUSH
10260: LD_INT 1
10262: MINUS
10263: PUSH
10264: FOR_TO
10265: IFFALSE 10294
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
10267: LD_ADDR_VAR 0 4
10271: PUSH
10272: LD_VAR 0 4
10276: PUSH
10277: LD_INT 21
10279: PPUSH
10280: LD_INT 0
10282: PPUSH
10283: CALL_OW 16
10287: PUSH
10288: EMPTY
10289: LIST
10290: ADD
10291: ST_TO_ADDR
10292: GO 10264
10294: POP
10295: POP
// minv = 10000 ;
10296: LD_ADDR_VAR 0 6
10300: PUSH
10301: LD_INT 10000
10303: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10304: LD_ADDR_VAR 0 7
10308: PUSH
10309: DOUBLE
10310: LD_INT 1
10312: DEC
10313: ST_TO_ADDR
10314: LD_EXP 37
10318: PUSH
10319: LD_INT 1
10321: MINUS
10322: PUSH
10323: FOR_TO
10324: IFFALSE 10508
// for j = 1 to side_count - 1 do
10326: LD_ADDR_VAR 0 8
10330: PUSH
10331: DOUBLE
10332: LD_INT 1
10334: DEC
10335: ST_TO_ADDR
10336: LD_EXP 37
10340: PUSH
10341: LD_INT 1
10343: MINUS
10344: PUSH
10345: FOR_TO
10346: IFFALSE 10504
// if i <> j then
10348: LD_VAR 0 7
10352: PUSH
10353: LD_VAR 0 8
10357: NONEQUAL
10358: IFFALSE 10502
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10360: LD_VAR 0 4
10364: PUSH
10365: LD_VAR 0 7
10369: ARRAY
10370: PUSH
10371: LD_INT 1
10373: ARRAY
10374: PPUSH
10375: LD_VAR 0 4
10379: PUSH
10380: LD_VAR 0 7
10384: ARRAY
10385: PUSH
10386: LD_INT 2
10388: ARRAY
10389: PPUSH
10390: LD_VAR 0 4
10394: PUSH
10395: LD_VAR 0 8
10399: ARRAY
10400: PUSH
10401: LD_INT 1
10403: ARRAY
10404: PPUSH
10405: LD_VAR 0 4
10409: PUSH
10410: LD_VAR 0 8
10414: ARRAY
10415: PUSH
10416: LD_INT 2
10418: ARRAY
10419: PPUSH
10420: CALL_OW 298
10424: PUSH
10425: LD_VAR 0 6
10429: LESS
10430: IFFALSE 10502
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10432: LD_ADDR_VAR 0 6
10436: PUSH
10437: LD_VAR 0 4
10441: PUSH
10442: LD_VAR 0 7
10446: ARRAY
10447: PUSH
10448: LD_INT 1
10450: ARRAY
10451: PPUSH
10452: LD_VAR 0 4
10456: PUSH
10457: LD_VAR 0 7
10461: ARRAY
10462: PUSH
10463: LD_INT 2
10465: ARRAY
10466: PPUSH
10467: LD_VAR 0 4
10471: PUSH
10472: LD_VAR 0 8
10476: ARRAY
10477: PUSH
10478: LD_INT 1
10480: ARRAY
10481: PPUSH
10482: LD_VAR 0 4
10486: PUSH
10487: LD_VAR 0 8
10491: ARRAY
10492: PUSH
10493: LD_INT 2
10495: ARRAY
10496: PPUSH
10497: CALL_OW 298
10501: ST_TO_ADDR
// end ;
10502: GO 10345
10504: POP
10505: POP
10506: GO 10323
10508: POP
10509: POP
// if minv > best then
10510: LD_VAR 0 6
10514: PUSH
10515: LD_VAR 0 3
10519: GREATER
10520: IFFALSE 10542
// begin best := minv ;
10522: LD_ADDR_VAR 0 3
10526: PUSH
10527: LD_VAR 0 6
10531: ST_TO_ADDR
// bestc := c ;
10532: LD_ADDR_VAR 0 5
10536: PUSH
10537: LD_VAR 0 4
10541: ST_TO_ADDR
// end ; end ;
10542: GO 10235
10544: POP
10545: POP
// coordinates := [ ] ;
10546: LD_ADDR_EXP 34
10550: PUSH
10551: EMPTY
10552: ST_TO_ADDR
// for i = 1 to 8 do
10553: LD_ADDR_VAR 0 7
10557: PUSH
10558: DOUBLE
10559: LD_INT 1
10561: DEC
10562: ST_TO_ADDR
10563: LD_INT 8
10565: PUSH
10566: FOR_TO
10567: IFFALSE 10692
// if i = alone then
10569: LD_VAR 0 7
10573: PUSH
10574: LD_VAR 0 1
10578: EQUAL
10579: IFFALSE 10607
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
10581: LD_ADDR_EXP 34
10585: PUSH
10586: LD_EXP 34
10590: PUSH
10591: LD_INT 81
10593: PUSH
10594: LD_INT 57
10596: PUSH
10597: EMPTY
10598: LIST
10599: LIST
10600: PUSH
10601: EMPTY
10602: LIST
10603: ADD
10604: ST_TO_ADDR
10605: GO 10690
// if ( side_positions [ i ] = 0 ) then
10607: LD_EXP 43
10611: PUSH
10612: LD_VAR 0 7
10616: ARRAY
10617: PUSH
10618: LD_INT 0
10620: EQUAL
10621: IFFALSE 10649
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
10623: LD_ADDR_EXP 34
10627: PUSH
10628: LD_EXP 34
10632: PUSH
10633: LD_INT 0
10635: PUSH
10636: LD_INT 0
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: EMPTY
10644: LIST
10645: ADD
10646: ST_TO_ADDR
10647: GO 10690
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
10649: LD_ADDR_EXP 34
10653: PUSH
10654: LD_EXP 34
10658: PUSH
10659: LD_VAR 0 5
10663: PUSH
10664: LD_INT 1
10666: ARRAY
10667: PUSH
10668: EMPTY
10669: LIST
10670: ADD
10671: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
10672: LD_ADDR_VAR 0 5
10676: PUSH
10677: LD_VAR 0 5
10681: PPUSH
10682: LD_INT 1
10684: PPUSH
10685: CALL_OW 3
10689: ST_TO_ADDR
// end ;
10690: GO 10566
10692: POP
10693: POP
// end ;
10694: LD_VAR 0 2
10698: RET
// function prepare_map_coordinates_one_hunter ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10699: LD_INT 0
10701: PPUSH
10702: PPUSH
10703: PPUSH
10704: PPUSH
10705: PPUSH
10706: PPUSH
10707: PPUSH
10708: PPUSH
// best = 0 ;
10709: LD_ADDR_VAR 0 3
10713: PUSH
10714: LD_INT 0
10716: ST_TO_ADDR
// for n = 1 to 40 do
10717: LD_ADDR_VAR 0 9
10721: PUSH
10722: DOUBLE
10723: LD_INT 1
10725: DEC
10726: ST_TO_ADDR
10727: LD_INT 40
10729: PUSH
10730: FOR_TO
10731: IFFALSE 11039
// begin c = [ ] ;
10733: LD_ADDR_VAR 0 4
10737: PUSH
10738: EMPTY
10739: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10740: LD_ADDR_VAR 0 7
10744: PUSH
10745: DOUBLE
10746: LD_INT 1
10748: DEC
10749: ST_TO_ADDR
10750: LD_EXP 37
10754: PUSH
10755: LD_INT 1
10757: MINUS
10758: PUSH
10759: FOR_TO
10760: IFFALSE 10789
// c := c ^ [ RandHexArea ( arapestart , false ) ] ;
10762: LD_ADDR_VAR 0 4
10766: PUSH
10767: LD_VAR 0 4
10771: PUSH
10772: LD_INT 22
10774: PPUSH
10775: LD_INT 0
10777: PPUSH
10778: CALL_OW 16
10782: PUSH
10783: EMPTY
10784: LIST
10785: ADD
10786: ST_TO_ADDR
10787: GO 10759
10789: POP
10790: POP
// minv = 10000 ;
10791: LD_ADDR_VAR 0 6
10795: PUSH
10796: LD_INT 10000
10798: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10799: LD_ADDR_VAR 0 7
10803: PUSH
10804: DOUBLE
10805: LD_INT 1
10807: DEC
10808: ST_TO_ADDR
10809: LD_EXP 37
10813: PUSH
10814: LD_INT 1
10816: MINUS
10817: PUSH
10818: FOR_TO
10819: IFFALSE 11003
// for j = 1 to side_count - 1 do
10821: LD_ADDR_VAR 0 8
10825: PUSH
10826: DOUBLE
10827: LD_INT 1
10829: DEC
10830: ST_TO_ADDR
10831: LD_EXP 37
10835: PUSH
10836: LD_INT 1
10838: MINUS
10839: PUSH
10840: FOR_TO
10841: IFFALSE 10999
// if i <> j then
10843: LD_VAR 0 7
10847: PUSH
10848: LD_VAR 0 8
10852: NONEQUAL
10853: IFFALSE 10997
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10855: LD_VAR 0 4
10859: PUSH
10860: LD_VAR 0 7
10864: ARRAY
10865: PUSH
10866: LD_INT 1
10868: ARRAY
10869: PPUSH
10870: LD_VAR 0 4
10874: PUSH
10875: LD_VAR 0 7
10879: ARRAY
10880: PUSH
10881: LD_INT 2
10883: ARRAY
10884: PPUSH
10885: LD_VAR 0 4
10889: PUSH
10890: LD_VAR 0 8
10894: ARRAY
10895: PUSH
10896: LD_INT 1
10898: ARRAY
10899: PPUSH
10900: LD_VAR 0 4
10904: PUSH
10905: LD_VAR 0 8
10909: ARRAY
10910: PUSH
10911: LD_INT 2
10913: ARRAY
10914: PPUSH
10915: CALL_OW 298
10919: PUSH
10920: LD_VAR 0 6
10924: LESS
10925: IFFALSE 10997
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10927: LD_ADDR_VAR 0 6
10931: PUSH
10932: LD_VAR 0 4
10936: PUSH
10937: LD_VAR 0 7
10941: ARRAY
10942: PUSH
10943: LD_INT 1
10945: ARRAY
10946: PPUSH
10947: LD_VAR 0 4
10951: PUSH
10952: LD_VAR 0 7
10956: ARRAY
10957: PUSH
10958: LD_INT 2
10960: ARRAY
10961: PPUSH
10962: LD_VAR 0 4
10966: PUSH
10967: LD_VAR 0 8
10971: ARRAY
10972: PUSH
10973: LD_INT 1
10975: ARRAY
10976: PPUSH
10977: LD_VAR 0 4
10981: PUSH
10982: LD_VAR 0 8
10986: ARRAY
10987: PUSH
10988: LD_INT 2
10990: ARRAY
10991: PPUSH
10992: CALL_OW 298
10996: ST_TO_ADDR
// end ;
10997: GO 10840
10999: POP
11000: POP
11001: GO 10818
11003: POP
11004: POP
// if minv > best then
11005: LD_VAR 0 6
11009: PUSH
11010: LD_VAR 0 3
11014: GREATER
11015: IFFALSE 11037
// begin best := minv ;
11017: LD_ADDR_VAR 0 3
11021: PUSH
11022: LD_VAR 0 6
11026: ST_TO_ADDR
// bestc := c ;
11027: LD_ADDR_VAR 0 5
11031: PUSH
11032: LD_VAR 0 4
11036: ST_TO_ADDR
// end ; end ;
11037: GO 10730
11039: POP
11040: POP
// coordinates := [ ] ;
11041: LD_ADDR_EXP 34
11045: PUSH
11046: EMPTY
11047: ST_TO_ADDR
// for i = 1 to 8 do
11048: LD_ADDR_VAR 0 7
11052: PUSH
11053: DOUBLE
11054: LD_INT 1
11056: DEC
11057: ST_TO_ADDR
11058: LD_INT 8
11060: PUSH
11061: FOR_TO
11062: IFFALSE 11187
// if i = alone then
11064: LD_VAR 0 7
11068: PUSH
11069: LD_VAR 0 1
11073: EQUAL
11074: IFFALSE 11102
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
11076: LD_ADDR_EXP 34
11080: PUSH
11081: LD_EXP 34
11085: PUSH
11086: LD_INT 81
11088: PUSH
11089: LD_INT 57
11091: PUSH
11092: EMPTY
11093: LIST
11094: LIST
11095: PUSH
11096: EMPTY
11097: LIST
11098: ADD
11099: ST_TO_ADDR
11100: GO 11185
// if ( side_positions [ i ] = 0 ) then
11102: LD_EXP 43
11106: PUSH
11107: LD_VAR 0 7
11111: ARRAY
11112: PUSH
11113: LD_INT 0
11115: EQUAL
11116: IFFALSE 11144
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
11118: LD_ADDR_EXP 34
11122: PUSH
11123: LD_EXP 34
11127: PUSH
11128: LD_INT 0
11130: PUSH
11131: LD_INT 0
11133: PUSH
11134: EMPTY
11135: LIST
11136: LIST
11137: PUSH
11138: EMPTY
11139: LIST
11140: ADD
11141: ST_TO_ADDR
11142: GO 11185
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
11144: LD_ADDR_EXP 34
11148: PUSH
11149: LD_EXP 34
11153: PUSH
11154: LD_VAR 0 5
11158: PUSH
11159: LD_INT 1
11161: ARRAY
11162: PUSH
11163: EMPTY
11164: LIST
11165: ADD
11166: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
11167: LD_ADDR_VAR 0 5
11171: PUSH
11172: LD_VAR 0 5
11176: PPUSH
11177: LD_INT 1
11179: PPUSH
11180: CALL_OW 3
11184: ST_TO_ADDR
// end ;
11185: GO 11061
11187: POP
11188: POP
// end ;
11189: LD_VAR 0 2
11193: RET
// function prepare_game ( alone ) ; var i , t ; begin
11194: LD_INT 0
11196: PPUSH
11197: PPUSH
11198: PPUSH
// ResetFog ;
11199: CALL_OW 335
// AnimateTrees ( true ) ;
11203: LD_INT 1
11205: PPUSH
11206: CALL_OW 573
// for i := 1 to 8 do
11210: LD_ADDR_VAR 0 3
11214: PUSH
11215: DOUBLE
11216: LD_INT 1
11218: DEC
11219: ST_TO_ADDR
11220: LD_INT 8
11222: PUSH
11223: FOR_TO
11224: IFFALSE 11278
// if Side_Positions [ i ] then
11226: LD_EXP 43
11230: PUSH
11231: LD_VAR 0 3
11235: ARRAY
11236: IFFALSE 11276
// if i = alone then
11238: LD_VAR 0 3
11242: PUSH
11243: LD_VAR 0 1
11247: EQUAL
11248: IFFALSE 11264
// ChangeSideFog ( i , 1 ) else
11250: LD_VAR 0 3
11254: PPUSH
11255: LD_INT 1
11257: PPUSH
11258: CALL_OW 343
11262: GO 11276
// ChangeSideFog ( i , 2 ) ;
11264: LD_VAR 0 3
11268: PPUSH
11269: LD_INT 2
11271: PPUSH
11272: CALL_OW 343
11276: GO 11223
11278: POP
11279: POP
// set_attitudes ( alone ) ;
11280: LD_VAR 0 1
11284: PPUSH
11285: CALL 9874 0 1
// set_technologies ( alone ) ;
11289: LD_VAR 0 1
11293: PPUSH
11294: CALL 9990 0 1
// display_score ( alone , 0 0$8 ) ;
11298: LD_VAR 0 1
11302: PPUSH
11303: LD_INT 280
11305: PPUSH
11306: CALL 9768 0 2
// for i := 1 to 8 do
11310: LD_ADDR_VAR 0 3
11314: PUSH
11315: DOUBLE
11316: LD_INT 1
11318: DEC
11319: ST_TO_ADDR
11320: LD_INT 8
11322: PUSH
11323: FOR_TO
11324: IFFALSE 11378
// if Side_Positions [ i ] then
11326: LD_EXP 43
11330: PUSH
11331: LD_VAR 0 3
11335: ARRAY
11336: IFFALSE 11376
// if ( i = alone ) = ( one_hunter ) then
11338: LD_VAR 0 3
11342: PUSH
11343: LD_VAR 0 1
11347: EQUAL
11348: PUSH
11349: LD_EXP 79
11353: EQUAL
11354: IFFALSE 11367
// prepare_hunter_team ( i ) else
11356: LD_VAR 0 3
11360: PPUSH
11361: CALL 9408 0 1
11365: GO 11376
// prepare_ape_team ( i ) ;
11367: LD_VAR 0 3
11371: PPUSH
11372: CALL 9585 0 1
11376: GO 11323
11378: POP
11379: POP
// t := 8 ;
11380: LD_ADDR_VAR 0 4
11384: PUSH
11385: LD_INT 8
11387: ST_TO_ADDR
// repeat t := t - 1 ;
11388: LD_ADDR_VAR 0 4
11392: PUSH
11393: LD_VAR 0 4
11397: PUSH
11398: LD_INT 1
11400: MINUS
11401: ST_TO_ADDR
// display_score ( alone , t * 0 0$1 ) ;
11402: LD_VAR 0 1
11406: PPUSH
11407: LD_VAR 0 4
11411: PUSH
11412: LD_INT 35
11414: MUL
11415: PPUSH
11416: CALL 9768 0 2
// wait ( 0 0$1 ) ;
11420: LD_INT 35
11422: PPUSH
11423: CALL_OW 67
// until t = 0 ;
11427: LD_VAR 0 4
11431: PUSH
11432: LD_INT 0
11434: EQUAL
11435: IFFALSE 11388
// end ;
11437: LD_VAR 0 2
11441: RET
// function run_game ( alone ) ; var i , un , ape , time , alive , dead , aktsc ; begin
11442: LD_INT 0
11444: PPUSH
11445: PPUSH
11446: PPUSH
11447: PPUSH
11448: PPUSH
11449: PPUSH
11450: PPUSH
11451: PPUSH
// if ( your_side = alone ) <> one_hunter then
11452: LD_OWVAR 2
11456: PUSH
11457: LD_VAR 0 1
11461: EQUAL
11462: PUSH
11463: LD_EXP 79
11467: NONEQUAL
11468: IFFALSE 11480
// music_nat := nation_arabian else
11470: LD_ADDR_OWVAR 71
11474: PUSH
11475: LD_INT 2
11477: ST_TO_ADDR
11478: GO 11496
// music_nat := Side_Nations [ your_side ] ;
11480: LD_ADDR_OWVAR 71
11484: PUSH
11485: LD_EXP 44
11489: PUSH
11490: LD_OWVAR 2
11494: ARRAY
11495: ST_TO_ADDR
// if one_hunter then
11496: LD_EXP 79
11500: IFFALSE 11665
// begin prepare_map_coordinates_one_hunter ( alone ) ;
11502: LD_VAR 0 1
11506: PPUSH
11507: CALL 10699 0 1
// for i := 1 to 8 do
11511: LD_ADDR_VAR 0 3
11515: PUSH
11516: DOUBLE
11517: LD_INT 1
11519: DEC
11520: ST_TO_ADDR
11521: LD_INT 8
11523: PUSH
11524: FOR_TO
11525: IFFALSE 11661
// if side_positions [ i ] then
11527: LD_EXP 43
11531: PUSH
11532: LD_VAR 0 3
11536: ARRAY
11537: IFFALSE 11659
// if i = alone then
11539: LD_VAR 0 3
11543: PUSH
11544: LD_VAR 0 1
11548: EQUAL
11549: IFFALSE 11591
// for un in people [ i ] do
11551: LD_ADDR_VAR 0 4
11555: PUSH
11556: LD_EXP 88
11560: PUSH
11561: LD_VAR 0 3
11565: ARRAY
11566: PUSH
11567: FOR_IN
11568: IFFALSE 11587
// PlaceUnitArea ( un , arstartveh , false ) else
11570: LD_VAR 0 4
11574: PPUSH
11575: LD_INT 21
11577: PPUSH
11578: LD_INT 0
11580: PPUSH
11581: CALL_OW 49
11585: GO 11567
11587: POP
11588: POP
11589: GO 11659
// for un in people [ i ] do
11591: LD_ADDR_VAR 0 4
11595: PUSH
11596: LD_EXP 88
11600: PUSH
11601: LD_VAR 0 3
11605: ARRAY
11606: PUSH
11607: FOR_IN
11608: IFFALSE 11657
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 15 , false ) ;
11610: LD_VAR 0 4
11614: PPUSH
11615: LD_EXP 34
11619: PUSH
11620: LD_VAR 0 3
11624: ARRAY
11625: PUSH
11626: LD_INT 1
11628: ARRAY
11629: PPUSH
11630: LD_EXP 34
11634: PUSH
11635: LD_VAR 0 3
11639: ARRAY
11640: PUSH
11641: LD_INT 2
11643: ARRAY
11644: PPUSH
11645: LD_INT 15
11647: PPUSH
11648: LD_INT 0
11650: PPUSH
11651: CALL_OW 50
11655: GO 11607
11657: POP
11658: POP
11659: GO 11524
11661: POP
11662: POP
// end else
11663: GO 11826
// begin prepare_map_coordinates_more_hunters ( alone ) ;
11665: LD_VAR 0 1
11669: PPUSH
11670: CALL 10204 0 1
// for i := 1 to 8 do
11674: LD_ADDR_VAR 0 3
11678: PUSH
11679: DOUBLE
11680: LD_INT 1
11682: DEC
11683: ST_TO_ADDR
11684: LD_INT 8
11686: PUSH
11687: FOR_TO
11688: IFFALSE 11824
// if side_positions [ i ] then
11690: LD_EXP 43
11694: PUSH
11695: LD_VAR 0 3
11699: ARRAY
11700: IFFALSE 11822
// if i = alone then
11702: LD_VAR 0 3
11706: PUSH
11707: LD_VAR 0 1
11711: EQUAL
11712: IFFALSE 11754
// for un in people [ i ] do
11714: LD_ADDR_VAR 0 4
11718: PUSH
11719: LD_EXP 88
11723: PUSH
11724: LD_VAR 0 3
11728: ARRAY
11729: PUSH
11730: FOR_IN
11731: IFFALSE 11750
// PlaceUnitArea ( un , arapes , false ) else
11733: LD_VAR 0 4
11737: PPUSH
11738: LD_INT 23
11740: PPUSH
11741: LD_INT 0
11743: PPUSH
11744: CALL_OW 49
11748: GO 11730
11750: POP
11751: POP
11752: GO 11822
// for un in people [ i ] do
11754: LD_ADDR_VAR 0 4
11758: PUSH
11759: LD_EXP 88
11763: PUSH
11764: LD_VAR 0 3
11768: ARRAY
11769: PUSH
11770: FOR_IN
11771: IFFALSE 11820
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 4 , false ) ;
11773: LD_VAR 0 4
11777: PPUSH
11778: LD_EXP 34
11782: PUSH
11783: LD_VAR 0 3
11787: ARRAY
11788: PUSH
11789: LD_INT 1
11791: ARRAY
11792: PPUSH
11793: LD_EXP 34
11797: PUSH
11798: LD_VAR 0 3
11802: ARRAY
11803: PUSH
11804: LD_INT 2
11806: ARRAY
11807: PPUSH
11808: LD_INT 4
11810: PPUSH
11811: LD_INT 0
11813: PPUSH
11814: CALL_OW 50
11818: GO 11770
11820: POP
11821: POP
11822: GO 11687
11824: POP
11825: POP
// end ; CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
11826: LD_EXP 34
11830: PUSH
11831: LD_OWVAR 2
11835: ARRAY
11836: PUSH
11837: LD_INT 1
11839: ARRAY
11840: PPUSH
11841: LD_EXP 34
11845: PUSH
11846: LD_OWVAR 2
11850: ARRAY
11851: PUSH
11852: LD_INT 2
11854: ARRAY
11855: PPUSH
11856: CALL_OW 86
// display_score ( 0 , 0 ) ;
11860: LD_INT 0
11862: PPUSH
11863: LD_INT 0
11865: PPUSH
11866: CALL 9768 0 2
// time := hunt_limit div 0 0$1 ;
11870: LD_ADDR_VAR 0 6
11874: PUSH
11875: LD_EXP 80
11879: PUSH
11880: LD_INT 35
11882: DIV
11883: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11884: LD_INT 35
11886: PPUSH
11887: CALL_OW 67
// ape := FilterAllUnits ( [ f_class , class_apeman ] ) + 0 ;
11891: LD_ADDR_VAR 0 5
11895: PUSH
11896: LD_INT 25
11898: PUSH
11899: LD_INT 12
11901: PUSH
11902: EMPTY
11903: LIST
11904: LIST
11905: PPUSH
11906: CALL_OW 69
11910: PUSH
11911: LD_INT 0
11913: PLUS
11914: ST_TO_ADDR
// time := time - 1 ;
11915: LD_ADDR_VAR 0 6
11919: PUSH
11920: LD_VAR 0 6
11924: PUSH
11925: LD_INT 1
11927: MINUS
11928: ST_TO_ADDR
// display_strings := [ #Hunt-Apes , alone , ape , #Hunt-Limit , alone , time * 0 0$1 ] ;
11929: LD_ADDR_OWVAR 47
11933: PUSH
11934: LD_STRING #Hunt-Apes
11936: PUSH
11937: LD_VAR 0 1
11941: PUSH
11942: LD_VAR 0 5
11946: PUSH
11947: LD_STRING #Hunt-Limit
11949: PUSH
11950: LD_VAR 0 1
11954: PUSH
11955: LD_VAR 0 6
11959: PUSH
11960: LD_INT 35
11962: MUL
11963: PUSH
11964: EMPTY
11965: LIST
11966: LIST
11967: LIST
11968: LIST
11969: LIST
11970: LIST
11971: ST_TO_ADDR
// until ( ape = 0 ) or ( time = 0 ) ;
11972: LD_VAR 0 5
11976: PUSH
11977: LD_INT 0
11979: EQUAL
11980: PUSH
11981: LD_VAR 0 6
11985: PUSH
11986: LD_INT 0
11988: EQUAL
11989: OR
11990: IFFALSE 11884
// alive := FilterAllUnits ( [ f_or , [ f_class , class_soldier ] , [ f_class , class_scientistic ] ] ) + 0 ;
11992: LD_ADDR_VAR 0 7
11996: PUSH
11997: LD_INT 2
11999: PUSH
12000: LD_INT 25
12002: PUSH
12003: LD_INT 1
12005: PUSH
12006: EMPTY
12007: LIST
12008: LIST
12009: PUSH
12010: LD_INT 25
12012: PUSH
12013: LD_INT 4
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: LIST
12024: PPUSH
12025: CALL_OW 69
12029: PUSH
12030: LD_INT 0
12032: PLUS
12033: ST_TO_ADDR
// if one_hunter then
12034: LD_EXP 79
12038: IFFALSE 12189
// begin dead := size_of_hunt_team - alive ;
12040: LD_ADDR_VAR 0 8
12044: PUSH
12045: LD_EXP 82
12049: PUSH
12050: LD_VAR 0 7
12054: MINUS
12055: ST_TO_ADDR
// ape := size_of_ape_team * ( side_count - 1 ) - ape ;
12056: LD_ADDR_VAR 0 5
12060: PUSH
12061: LD_EXP 81
12065: PUSH
12066: LD_EXP 37
12070: PUSH
12071: LD_INT 1
12073: MINUS
12074: MUL
12075: PUSH
12076: LD_VAR 0 5
12080: MINUS
12081: ST_TO_ADDR
// aktsc := time + ape * 30 - dead * 20 ;
12082: LD_ADDR_VAR 0 9
12086: PUSH
12087: LD_VAR 0 6
12091: PUSH
12092: LD_VAR 0 5
12096: PUSH
12097: LD_INT 30
12099: MUL
12100: PLUS
12101: PUSH
12102: LD_VAR 0 8
12106: PUSH
12107: LD_INT 20
12109: MUL
12110: MINUS
12111: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score2 , alone , alone , time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12112: LD_ADDR_EXP 89
12116: PUSH
12117: LD_EXP 89
12121: PUSH
12122: LD_STRING #Hunt-score2
12124: PUSH
12125: LD_VAR 0 1
12129: PUSH
12130: LD_VAR 0 1
12134: PUSH
12135: LD_VAR 0 6
12139: PUSH
12140: LD_INT 35
12142: MUL
12143: PUSH
12144: LD_VAR 0 5
12148: PUSH
12149: LD_VAR 0 8
12153: PUSH
12154: LD_INT 0
12156: PUSH
12157: LD_VAR 0 9
12161: PUSH
12162: EMPTY
12163: LIST
12164: LIST
12165: LIST
12166: LIST
12167: LIST
12168: LIST
12169: LIST
12170: LIST
12171: ADD
12172: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12173: LD_VAR 0 1
12177: PPUSH
12178: LD_VAR 0 9
12182: PPUSH
12183: CALL_OW 506
// end else
12187: GO 12336
// begin dead := size_of_hunt_team * ( side_count - 1 ) - alive ;
12189: LD_ADDR_VAR 0 8
12193: PUSH
12194: LD_EXP 82
12198: PUSH
12199: LD_EXP 37
12203: PUSH
12204: LD_INT 1
12206: MINUS
12207: MUL
12208: PUSH
12209: LD_VAR 0 7
12213: MINUS
12214: ST_TO_ADDR
// aktsc := hunt_limit div 0 0$1 - time + ape * 30 + dead * 20 ;
12215: LD_ADDR_VAR 0 9
12219: PUSH
12220: LD_EXP 80
12224: PUSH
12225: LD_INT 35
12227: DIV
12228: PUSH
12229: LD_VAR 0 6
12233: MINUS
12234: PUSH
12235: LD_VAR 0 5
12239: PUSH
12240: LD_INT 30
12242: MUL
12243: PLUS
12244: PUSH
12245: LD_VAR 0 8
12249: PUSH
12250: LD_INT 20
12252: MUL
12253: PLUS
12254: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score1 , alone , alone , hunt_limit - time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12255: LD_ADDR_EXP 89
12259: PUSH
12260: LD_EXP 89
12264: PUSH
12265: LD_STRING #Hunt-score1
12267: PUSH
12268: LD_VAR 0 1
12272: PUSH
12273: LD_VAR 0 1
12277: PUSH
12278: LD_EXP 80
12282: PUSH
12283: LD_VAR 0 6
12287: PUSH
12288: LD_INT 35
12290: MUL
12291: MINUS
12292: PUSH
12293: LD_VAR 0 5
12297: PUSH
12298: LD_VAR 0 8
12302: PUSH
12303: LD_INT 0
12305: PUSH
12306: LD_VAR 0 9
12310: PUSH
12311: EMPTY
12312: LIST
12313: LIST
12314: LIST
12315: LIST
12316: LIST
12317: LIST
12318: LIST
12319: LIST
12320: ADD
12321: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12322: LD_VAR 0 1
12326: PPUSH
12327: LD_VAR 0 9
12331: PPUSH
12332: CALL_OW 506
// end ; end ;
12336: LD_VAR 0 2
12340: RET
// function close_game ( alone ) ; var un ; begin
12341: LD_INT 0
12343: PPUSH
12344: PPUSH
// for un in all_units do
12345: LD_ADDR_VAR 0 3
12349: PUSH
12350: LD_OWVAR 3
12354: PUSH
12355: FOR_IN
12356: IFFALSE 12369
// DestroyUnit ( un ) ;
12358: LD_VAR 0 3
12362: PPUSH
12363: CALL_OW 65
12367: GO 12355
12369: POP
12370: POP
// ResetFog ;
12371: CALL_OW 335
// end ;
12375: LD_VAR 0 2
12379: RET
// export function starting_hunt ; var alone , win , i ; begin
12380: LD_INT 0
12382: PPUSH
12383: PPUSH
12384: PPUSH
12385: PPUSH
// mp_selectmsg := true ;
12386: LD_ADDR_OWVAR 13
12390: PUSH
12391: LD_INT 1
12393: ST_TO_ADDR
// mp_with_score := true ;
12394: LD_ADDR_OWVAR 14
12398: PUSH
12399: LD_INT 1
12401: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
12402: CALL 8429 0 0
// your_side := Player_Side ;
12406: LD_ADDR_OWVAR 2
12410: PUSH
12411: LD_EXP 39
12415: ST_TO_ADDR
// while to_be_alone do
12416: LD_EXP 87
12420: IFFALSE 12491
// begin alone := to_be_alone [ Rand ( 1 , to_be_alone ) ] ;
12422: LD_ADDR_VAR 0 2
12426: PUSH
12427: LD_EXP 87
12431: PUSH
12432: LD_INT 1
12434: PPUSH
12435: LD_EXP 87
12439: PPUSH
12440: CALL_OW 12
12444: ARRAY
12445: ST_TO_ADDR
// to_be_alone := to_be_alone diff alone ;
12446: LD_ADDR_EXP 87
12450: PUSH
12451: LD_EXP 87
12455: PUSH
12456: LD_VAR 0 2
12460: DIFF
12461: ST_TO_ADDR
// prepare_game ( alone ) ;
12462: LD_VAR 0 2
12466: PPUSH
12467: CALL 11194 0 1
// run_game ( alone ) ;
12471: LD_VAR 0 2
12475: PPUSH
12476: CALL 11442 0 1
// close_game ( alone ) ;
12480: LD_VAR 0 2
12484: PPUSH
12485: CALL 12341 0 1
// end ;
12489: GO 12416
// display_score ( 0 , 0 ) ;
12491: LD_INT 0
12493: PPUSH
12494: LD_INT 0
12496: PPUSH
12497: CALL 9768 0 2
// wait ( 0 0$5 ) ;
12501: LD_INT 175
12503: PPUSH
12504: CALL_OW 67
// win := true ;
12508: LD_ADDR_VAR 0 3
12512: PUSH
12513: LD_INT 1
12515: ST_TO_ADDR
// for i := 1 to 8 do
12516: LD_ADDR_VAR 0 4
12520: PUSH
12521: DOUBLE
12522: LD_INT 1
12524: DEC
12525: ST_TO_ADDR
12526: LD_INT 8
12528: PUSH
12529: FOR_TO
12530: IFFALSE 12564
// if GetMultiScore ( i ) > GetMultiScore ( your_side ) then
12532: LD_VAR 0 4
12536: PPUSH
12537: CALL_OW 507
12541: PUSH
12542: LD_OWVAR 2
12546: PPUSH
12547: CALL_OW 507
12551: GREATER
12552: IFFALSE 12562
// win := false ;
12554: LD_ADDR_VAR 0 3
12558: PUSH
12559: LD_INT 0
12561: ST_TO_ADDR
12562: GO 12529
12564: POP
12565: POP
// if win then
12566: LD_VAR 0 3
12570: IFFALSE 12578
// YouWinInMultiplayer else
12572: CALL_OW 106
12576: GO 12582
// YouLostInMultiplayer ;
12578: CALL_OW 107
// end ; end_of_file
12582: LD_VAR 0 1
12586: RET
// export to_be_countdowned ; every 0 0$0.2 trigger to_be_countdowned marked 25 do var who , timer ;
12587: LD_EXP 90
12591: IFFALSE 12762
12593: GO 12595
12595: DISABLE
12596: LD_INT 0
12598: PPUSH
12599: PPUSH
// begin enable ;
12600: ENABLE
// who := to_be_countdowned [ 1 ] ;
12601: LD_ADDR_VAR 0 1
12605: PUSH
12606: LD_EXP 90
12610: PUSH
12611: LD_INT 1
12613: ARRAY
12614: ST_TO_ADDR
// to_be_countdowned := Delete ( to_be_countdowned , 1 ) ;
12615: LD_ADDR_EXP 90
12619: PUSH
12620: LD_EXP 90
12624: PPUSH
12625: LD_INT 1
12627: PPUSH
12628: CALL_OW 3
12632: ST_TO_ADDR
// repeat timer := GetTag ( who ) ;
12633: LD_ADDR_VAR 0 2
12637: PUSH
12638: LD_VAR 0 1
12642: PPUSH
12643: CALL_OW 110
12647: ST_TO_ADDR
// if GetSide ( who ) = your_side then
12648: LD_VAR 0 1
12652: PPUSH
12653: CALL_OW 255
12657: PUSH
12658: LD_OWVAR 2
12662: EQUAL
12663: IFFALSE 12679
// SetUnitDisplayNumber ( who , timer ) ;
12665: LD_VAR 0 1
12669: PPUSH
12670: LD_VAR 0 2
12674: PPUSH
12675: CALL_OW 505
// timer := timer - 1 ;
12679: LD_ADDR_VAR 0 2
12683: PUSH
12684: LD_VAR 0 2
12688: PUSH
12689: LD_INT 1
12691: MINUS
12692: ST_TO_ADDR
// SetTag ( who , timer ) ;
12693: LD_VAR 0 1
12697: PPUSH
12698: LD_VAR 0 2
12702: PPUSH
12703: CALL_OW 109
// wait ( 0 0$1 ) ;
12707: LD_INT 35
12709: PPUSH
12710: CALL_OW 67
// until not IsLive ( who ) or not GetTag ( who ) ;
12714: LD_VAR 0 1
12718: PPUSH
12719: CALL_OW 300
12723: NOT
12724: PUSH
12725: LD_VAR 0 1
12729: PPUSH
12730: CALL_OW 110
12734: NOT
12735: OR
12736: IFFALSE 12633
// if not GetTag ( who ) then
12738: LD_VAR 0 1
12742: PPUSH
12743: CALL_OW 110
12747: NOT
12748: IFFALSE 12762
// SetLives ( who , 0 ) ;
12750: LD_VAR 0 1
12754: PPUSH
12755: LD_INT 0
12757: PPUSH
12758: CALL_OW 234
// end ;
12762: PPOPN 2
12764: END
// every 0 0$0.5 + 0 0$0.05 marked 25 do var un , veh ;
12765: GO 12767
12767: DISABLE
12768: LD_INT 0
12770: PPUSH
12771: PPUSH
// begin veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , f_not , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12772: LD_ADDR_VAR 0 2
12776: PUSH
12777: LD_INT 20
12779: PPUSH
12780: LD_INT 21
12782: PUSH
12783: LD_INT 2
12785: PUSH
12786: EMPTY
12787: LIST
12788: LIST
12789: PUSH
12790: LD_INT 3
12792: PUSH
12793: LD_INT 58
12795: PUSH
12796: EMPTY
12797: LIST
12798: PUSH
12799: LD_INT 3
12801: PUSH
12802: LD_INT 22
12804: PUSH
12805: LD_INT 0
12807: PUSH
12808: EMPTY
12809: LIST
12810: LIST
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: LIST
12816: LIST
12817: LIST
12818: PPUSH
12819: CALL_OW 70
12823: ST_TO_ADDR
// for un in veh do
12824: LD_ADDR_VAR 0 1
12828: PUSH
12829: LD_VAR 0 2
12833: PUSH
12834: FOR_IN
12835: IFFALSE 12848
// ComExitVehicle ( veh ) ;
12837: LD_VAR 0 2
12841: PPUSH
12842: CALL_OW 121
12846: GO 12834
12848: POP
12849: POP
// veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12850: LD_ADDR_VAR 0 2
12854: PUSH
12855: LD_INT 20
12857: PPUSH
12858: LD_INT 21
12860: PUSH
12861: LD_INT 2
12863: PUSH
12864: EMPTY
12865: LIST
12866: LIST
12867: PUSH
12868: LD_INT 58
12870: PUSH
12871: EMPTY
12872: LIST
12873: PUSH
12874: LD_INT 3
12876: PUSH
12877: LD_INT 22
12879: PUSH
12880: LD_INT 0
12882: PUSH
12883: EMPTY
12884: LIST
12885: LIST
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: LIST
12891: LIST
12892: PPUSH
12893: CALL_OW 70
12897: ST_TO_ADDR
// for un in veh do
12898: LD_ADDR_VAR 0 1
12902: PUSH
12903: LD_VAR 0 2
12907: PUSH
12908: FOR_IN
12909: IFFALSE 12964
// begin SetMultiScore ( GetSide ( un ) , GetMultiScore ( GetSide ( un ) ) + 1 ) ;
12911: LD_VAR 0 1
12915: PPUSH
12916: CALL_OW 255
12920: PPUSH
12921: LD_VAR 0 1
12925: PPUSH
12926: CALL_OW 255
12930: PPUSH
12931: CALL_OW 507
12935: PUSH
12936: LD_INT 1
12938: PLUS
12939: PPUSH
12940: CALL_OW 506
// RemoveUnit ( un ) ;
12944: LD_VAR 0 1
12948: PPUSH
12949: CALL_OW 64
// DestroyUnit ( un ) ;
12953: LD_VAR 0 1
12957: PPUSH
12958: CALL_OW 65
// end ;
12962: GO 12908
12964: POP
12965: POP
// enable ;
12966: ENABLE
// end ;
12967: PPOPN 2
12969: END
// every 0 0$1 + 0 0$0.1 marked 25 do var i , best , nbest , lastbest , s , first , n ;
12970: GO 12972
12972: DISABLE
12973: LD_INT 0
12975: PPUSH
12976: PPUSH
12977: PPUSH
12978: PPUSH
12979: PPUSH
12980: PPUSH
12981: PPUSH
// begin lastbest := 99999 ;
12982: LD_ADDR_VAR 0 4
12986: PUSH
12987: LD_INT 99999
12989: ST_TO_ADDR
// s := [ ] ;
12990: LD_ADDR_VAR 0 5
12994: PUSH
12995: EMPTY
12996: ST_TO_ADDR
// n := 1 ;
12997: LD_ADDR_VAR 0 7
13001: PUSH
13002: LD_INT 1
13004: ST_TO_ADDR
// repeat best := - 99999 ;
13005: LD_ADDR_VAR 0 2
13009: PUSH
13010: LD_INT 99999
13012: NEG
13013: ST_TO_ADDR
// nbest := 0 ;
13014: LD_ADDR_VAR 0 3
13018: PUSH
13019: LD_INT 0
13021: ST_TO_ADDR
// for i := 1 to 8 do
13022: LD_ADDR_VAR 0 1
13026: PUSH
13027: DOUBLE
13028: LD_INT 1
13030: DEC
13031: ST_TO_ADDR
13032: LD_INT 8
13034: PUSH
13035: FOR_TO
13036: IFFALSE 13142
// if Side_Positions [ i ] then
13038: LD_EXP 43
13042: PUSH
13043: LD_VAR 0 1
13047: ARRAY
13048: IFFALSE 13140
// begin if ( GetMultiScore ( i ) > best ) and ( GetMultiScore ( i ) < lastbest ) then
13050: LD_VAR 0 1
13054: PPUSH
13055: CALL_OW 507
13059: PUSH
13060: LD_VAR 0 2
13064: GREATER
13065: PUSH
13066: LD_VAR 0 1
13070: PPUSH
13071: CALL_OW 507
13075: PUSH
13076: LD_VAR 0 4
13080: LESS
13081: AND
13082: IFFALSE 13109
// begin best := GetMultiScore ( i ) ;
13084: LD_ADDR_VAR 0 2
13088: PUSH
13089: LD_VAR 0 1
13093: PPUSH
13094: CALL_OW 507
13098: ST_TO_ADDR
// nbest := 1 ;
13099: LD_ADDR_VAR 0 3
13103: PUSH
13104: LD_INT 1
13106: ST_TO_ADDR
// end else
13107: GO 13140
// if GetMultiScore ( i ) = best then
13109: LD_VAR 0 1
13113: PPUSH
13114: CALL_OW 507
13118: PUSH
13119: LD_VAR 0 2
13123: EQUAL
13124: IFFALSE 13140
// begin nbest := nbest + 1 ;
13126: LD_ADDR_VAR 0 3
13130: PUSH
13131: LD_VAR 0 3
13135: PUSH
13136: LD_INT 1
13138: PLUS
13139: ST_TO_ADDR
// end ; end ;
13140: GO 13035
13142: POP
13143: POP
// first := true ;
13144: LD_ADDR_VAR 0 6
13148: PUSH
13149: LD_INT 1
13151: ST_TO_ADDR
// if nbest > 0 then
13152: LD_VAR 0 3
13156: PUSH
13157: LD_INT 0
13159: GREATER
13160: IFFALSE 13333
// for i := 1 to 8 do
13162: LD_ADDR_VAR 0 1
13166: PUSH
13167: DOUBLE
13168: LD_INT 1
13170: DEC
13171: ST_TO_ADDR
13172: LD_INT 8
13174: PUSH
13175: FOR_TO
13176: IFFALSE 13331
// if Side_Positions [ i ] then
13178: LD_EXP 43
13182: PUSH
13183: LD_VAR 0 1
13187: ARRAY
13188: IFFALSE 13329
// if GetMultiScore ( i ) = best then
13190: LD_VAR 0 1
13194: PPUSH
13195: CALL_OW 507
13199: PUSH
13200: LD_VAR 0 2
13204: EQUAL
13205: IFFALSE 13329
// if nbest = 1 then
13207: LD_VAR 0 3
13211: PUSH
13212: LD_INT 1
13214: EQUAL
13215: IFFALSE 13266
// s := s ^ [ #Multi-score , n , i , i , i , best ] else
13217: LD_ADDR_VAR 0 5
13221: PUSH
13222: LD_VAR 0 5
13226: PUSH
13227: LD_STRING #Multi-score
13229: PUSH
13230: LD_VAR 0 7
13234: PUSH
13235: LD_VAR 0 1
13239: PUSH
13240: LD_VAR 0 1
13244: PUSH
13245: LD_VAR 0 1
13249: PUSH
13250: LD_VAR 0 2
13254: PUSH
13255: EMPTY
13256: LIST
13257: LIST
13258: LIST
13259: LIST
13260: LIST
13261: LIST
13262: ADD
13263: ST_TO_ADDR
13264: GO 13329
// s := s ^ [ #Multi-score-range , n , n + nbest - 1 , i , i , i , best ] ;
13266: LD_ADDR_VAR 0 5
13270: PUSH
13271: LD_VAR 0 5
13275: PUSH
13276: LD_STRING #Multi-score-range
13278: PUSH
13279: LD_VAR 0 7
13283: PUSH
13284: LD_VAR 0 7
13288: PUSH
13289: LD_VAR 0 3
13293: PLUS
13294: PUSH
13295: LD_INT 1
13297: MINUS
13298: PUSH
13299: LD_VAR 0 1
13303: PUSH
13304: LD_VAR 0 1
13308: PUSH
13309: LD_VAR 0 1
13313: PUSH
13314: LD_VAR 0 2
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: LIST
13323: LIST
13324: LIST
13325: LIST
13326: LIST
13327: ADD
13328: ST_TO_ADDR
13329: GO 13175
13331: POP
13332: POP
// n := n + nbest ;
13333: LD_ADDR_VAR 0 7
13337: PUSH
13338: LD_VAR 0 7
13342: PUSH
13343: LD_VAR 0 3
13347: PLUS
13348: ST_TO_ADDR
// lastbest := best ;
13349: LD_ADDR_VAR 0 4
13353: PUSH
13354: LD_VAR 0 2
13358: ST_TO_ADDR
// until nbest = 0 ;
13359: LD_VAR 0 3
13363: PUSH
13364: LD_INT 0
13366: EQUAL
13367: IFFALSE 13005
// if game_time then
13369: LD_EXP 56
13373: IFFALSE 13408
// s := [ #Hunt-Limit , 0 , game_time - tick ] ^ s ;
13375: LD_ADDR_VAR 0 5
13379: PUSH
13380: LD_STRING #Hunt-Limit
13382: PUSH
13383: LD_INT 0
13385: PUSH
13386: LD_EXP 56
13390: PUSH
13391: LD_OWVAR 1
13395: MINUS
13396: PUSH
13397: EMPTY
13398: LIST
13399: LIST
13400: LIST
13401: PUSH
13402: LD_VAR 0 5
13406: ADD
13407: ST_TO_ADDR
// display_strings := s ;
13408: LD_ADDR_OWVAR 47
13412: PUSH
13413: LD_VAR 0 5
13417: ST_TO_ADDR
// enable ;
13418: ENABLE
// end ;
13419: PPOPN 7
13421: END
// every 0 0$1 marked 25 do var veh ;
13422: GO 13424
13424: DISABLE
13425: LD_INT 0
13427: PPUSH
// begin repeat repeat veh := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
13428: LD_ADDR_VAR 0 1
13432: PUSH
13433: LD_INT 21
13435: PUSH
13436: LD_INT 2
13438: PUSH
13439: EMPTY
13440: LIST
13441: LIST
13442: PPUSH
13443: CALL_OW 69
13447: ST_TO_ADDR
// wait ( 0 0$3 ) ;
13448: LD_INT 105
13450: PPUSH
13451: CALL_OW 67
// until veh < vehmax ;
13455: LD_VAR 0 1
13459: PUSH
13460: LD_EXP 61
13464: LESS
13465: IFFALSE 13428
// wait ( Rand ( vehresp [ 1 ] div side_count , vehresp [ 2 ] div side_count ) ) ;
13467: LD_EXP 58
13471: PUSH
13472: LD_INT 1
13474: ARRAY
13475: PUSH
13476: LD_EXP 37
13480: DIV
13481: PPUSH
13482: LD_EXP 58
13486: PUSH
13487: LD_INT 2
13489: ARRAY
13490: PUSH
13491: LD_EXP 37
13495: DIV
13496: PPUSH
13497: CALL_OW 12
13501: PPUSH
13502: CALL_OW 67
// vehicles_create_vehicle ( false ) ;
13506: LD_INT 0
13508: PPUSH
13509: CALL 6881 0 1
// until false ;
13513: LD_INT 0
13515: IFFALSE 13428
// end ;
13517: PPOPN 1
13519: END
// every 3 marked 25 do var side , peop ;
13520: GO 13522
13522: DISABLE
13523: LD_INT 0
13525: PPUSH
13526: PPUSH
// begin if not to_resp then
13527: LD_EXP 69
13531: NOT
13532: IFFALSE 13536
// exit ;
13534: GO 13737
// enable ;
13536: ENABLE
// side := to_resp [ 1 ] ;
13537: LD_ADDR_VAR 0 1
13541: PUSH
13542: LD_EXP 69
13546: PUSH
13547: LD_INT 1
13549: ARRAY
13550: ST_TO_ADDR
// to_resp := Delete ( to_resp , 1 ) ;
13551: LD_ADDR_EXP 69
13555: PUSH
13556: LD_EXP 69
13560: PPUSH
13561: LD_INT 1
13563: PPUSH
13564: CALL_OW 3
13568: ST_TO_ADDR
// repeat repeat peop := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_side , side ] , [ f_ok ] ] ) ;
13569: LD_ADDR_VAR 0 2
13573: PUSH
13574: LD_INT 21
13576: PUSH
13577: LD_INT 1
13579: PUSH
13580: EMPTY
13581: LIST
13582: LIST
13583: PUSH
13584: LD_INT 22
13586: PUSH
13587: LD_VAR 0 1
13591: PUSH
13592: EMPTY
13593: LIST
13594: LIST
13595: PUSH
13596: LD_INT 50
13598: PUSH
13599: EMPTY
13600: LIST
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: LIST
13606: PPUSH
13607: CALL_OW 69
13611: ST_TO_ADDR
// wait ( 0 0$5 ) ;
13612: LD_INT 175
13614: PPUSH
13615: CALL_OW 67
// until peop < npeop ;
13619: LD_VAR 0 2
13623: PUSH
13624: LD_EXP 65
13628: LESS
13629: IFFALSE 13569
// wait ( Rand ( peopresp [ 1 ] , peopresp [ 2 ] ) ) ;
13631: LD_EXP 66
13635: PUSH
13636: LD_INT 1
13638: ARRAY
13639: PPUSH
13640: LD_EXP 66
13644: PUSH
13645: LD_INT 2
13647: ARRAY
13648: PPUSH
13649: CALL_OW 12
13653: PPUSH
13654: CALL_OW 67
// uc_side := side ;
13658: LD_ADDR_OWVAR 20
13662: PUSH
13663: LD_VAR 0 1
13667: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
13668: LD_ADDR_OWVAR 21
13672: PUSH
13673: LD_EXP 44
13677: PUSH
13678: LD_VAR 0 1
13682: ARRAY
13683: ST_TO_ADDR
// hc_name :=  ;
13684: LD_ADDR_OWVAR 26
13688: PUSH
13689: LD_STRING 
13691: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
13692: LD_INT 0
13694: PPUSH
13695: LD_INT 4
13697: PPUSH
13698: CALL_OW 383
// hc_importance := 0 ;
13702: LD_ADDR_OWVAR 32
13706: PUSH
13707: LD_INT 0
13709: ST_TO_ADDR
// hc_gallery :=  ;
13710: LD_ADDR_OWVAR 33
13714: PUSH
13715: LD_STRING 
13717: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , arstartveh , true ) ;
13718: CALL_OW 44
13722: PPUSH
13723: LD_INT 21
13725: PPUSH
13726: LD_INT 1
13728: PPUSH
13729: CALL_OW 49
// until false ;
13733: LD_INT 0
13735: IFFALSE 13569
// end ;
13737: PPOPN 2
13739: END
// on siberiterocketexploded ( un , x , y ) do SA_OnSiberiteRocketExploded ( un , x , y , Your_Side ) ; end_of_file
13740: LD_VAR 0 1
13744: PPUSH
13745: LD_VAR 0 2
13749: PPUSH
13750: LD_VAR 0 3
13754: PPUSH
13755: LD_OWVAR 2
13759: PPUSH
13760: CALL 14717 0 4
13764: PPOPN 3
13766: END
// every 10 do
13767: GO 13769
13769: DISABLE
// begin if not multiplayer then
13770: LD_OWVAR 4
13774: NOT
13775: IFFALSE 13779
// exit ;
13777: GO 13836
// if ( tick >= 100 ) then
13779: LD_OWVAR 1
13783: PUSH
13784: LD_INT 100
13786: GREATEREQUAL
13787: IFFALSE 13807
// if tick mod 20 = 0 then
13789: LD_OWVAR 1
13793: PUSH
13794: LD_INT 20
13796: MOD
13797: PUSH
13798: LD_INT 0
13800: EQUAL
13801: IFFALSE 13807
// MultiplayerCRC ;
13803: CALL_OW 361
// if ( tick >= 100 ) then
13807: LD_OWVAR 1
13811: PUSH
13812: LD_INT 100
13814: GREATEREQUAL
13815: IFFALSE 13835
// if tick mod 30 = 0 then
13817: LD_OWVAR 1
13821: PUSH
13822: LD_INT 30
13824: MOD
13825: PUSH
13826: LD_INT 0
13828: EQUAL
13829: IFFALSE 13835
// DebugLogAll ;
13831: CALL_OW 360
// enable ;
13835: ENABLE
// end ; end_of_file
13836: END
// export Side_Comps ; export nonCombat , siberite_rocket ; every 1 do
13837: GO 13839
13839: DISABLE
// begin if GetMultiplayerSetting ( 49 ) or iseditor then
13840: LD_INT 49
13842: PPUSH
13843: CALL_OW 426
13847: PUSH
13848: LD_OWVAR 84
13852: OR
13853: IFFALSE 13862
// fogoff ( true ) ;
13855: LD_INT 1
13857: PPUSH
13858: CALL_OW 344
// disable ( 125 ) ;
13862: LD_INT 125
13864: DISABLE_MARKED
// Start_VehicleAI ;
13865: CALL 13870 0 0
// end ;
13869: END
// function Start_VehicleAI ; var i , k ; begin
13870: LD_INT 0
13872: PPUSH
13873: PPUSH
13874: PPUSH
// if multiplayer then
13875: LD_OWVAR 4
13879: IFFALSE 13893
// Side_Comps = mp_sides_comps else
13881: LD_ADDR_EXP 91
13885: PUSH
13886: CALL 14035 0 0
13890: ST_TO_ADDR
13891: GO 13932
// side_comps = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ;
13893: LD_ADDR_EXP 91
13897: PUSH
13898: LD_INT 1
13900: PUSH
13901: LD_INT 1
13903: PUSH
13904: LD_INT 1
13906: PUSH
13907: LD_INT 1
13909: PUSH
13910: LD_INT 1
13912: PUSH
13913: LD_INT 1
13915: PUSH
13916: LD_INT 1
13918: PUSH
13919: LD_INT 1
13921: PUSH
13922: EMPTY
13923: LIST
13924: LIST
13925: LIST
13926: LIST
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: ST_TO_ADDR
// k = false ;
13932: LD_ADDR_VAR 0 3
13936: PUSH
13937: LD_INT 0
13939: ST_TO_ADDR
// for i in side_comps do
13940: LD_ADDR_VAR 0 2
13944: PUSH
13945: LD_EXP 91
13949: PUSH
13950: FOR_IN
13951: IFFALSE 13969
// if i then
13953: LD_VAR 0 2
13957: IFFALSE 13967
// k = true ;
13959: LD_ADDR_VAR 0 3
13963: PUSH
13964: LD_INT 1
13966: ST_TO_ADDR
13967: GO 13950
13969: POP
13970: POP
// nonCombat = [ us_radar , us_bulldozer , us_siberium_rocket_remainder , ar_radar , ar_selfpropelled_bomb , ru_bulldozer , ru_siberium_rocket_remainder ] ;
13971: LD_ADDR_EXP 92
13975: PUSH
13976: LD_INT 11
13978: PUSH
13979: LD_INT 14
13981: PUSH
13982: LD_INT 15
13984: PUSH
13985: LD_INT 30
13987: PUSH
13988: LD_INT 29
13990: PUSH
13991: LD_INT 53
13993: PUSH
13994: LD_INT 55
13996: PUSH
13997: EMPTY
13998: LIST
13999: LIST
14000: LIST
14001: LIST
14002: LIST
14003: LIST
14004: LIST
14005: ST_TO_ADDR
// Siberite_Rocket = [ us_siberium_rocket , ru_siberium_rocket ] ;
14006: LD_ADDR_EXP 93
14010: PUSH
14011: LD_INT 8
14013: PUSH
14014: LD_INT 48
14016: PUSH
14017: EMPTY
14018: LIST
14019: LIST
14020: ST_TO_ADDR
// if k then
14021: LD_VAR 0 3
14025: IFFALSE 14030
// enable ( 125 ) ;
14027: LD_INT 125
14029: ENABLE_MARKED
// end ;
14030: LD_VAR 0 1
14034: RET
// function mp_sides_comps ; var c , i ; begin
14035: LD_INT 0
14037: PPUSH
14038: PPUSH
14039: PPUSH
// c = [ ] ;
14040: LD_ADDR_VAR 0 2
14044: PUSH
14045: EMPTY
14046: ST_TO_ADDR
// for i = 1 to 8 do
14047: LD_ADDR_VAR 0 3
14051: PUSH
14052: DOUBLE
14053: LD_INT 1
14055: DEC
14056: ST_TO_ADDR
14057: LD_INT 8
14059: PUSH
14060: FOR_TO
14061: IFFALSE 14086
// c = c ^ Multiplayer_GetPlayerIsComp ( i ) ;
14063: LD_ADDR_VAR 0 2
14067: PUSH
14068: LD_VAR 0 2
14072: PUSH
14073: LD_VAR 0 3
14077: PPUSH
14078: CALL_OW 532
14082: ADD
14083: ST_TO_ADDR
14084: GO 14060
14086: POP
14087: POP
// result = c ;
14088: LD_ADDR_VAR 0 1
14092: PUSH
14093: LD_VAR 0 2
14097: ST_TO_ADDR
// end ;
14098: LD_VAR 0 1
14102: RET
// every 0 0$1 marked 125 do var units , u , veh , k , c , i , hex ;
14103: GO 14105
14105: DISABLE
14106: LD_INT 0
14108: PPUSH
14109: PPUSH
14110: PPUSH
14111: PPUSH
14112: PPUSH
14113: PPUSH
14114: PPUSH
// begin units = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_human ] ] ) ;
14115: LD_ADDR_VAR 0 1
14119: PUSH
14120: LD_INT 52
14122: PUSH
14123: EMPTY
14124: LIST
14125: PUSH
14126: LD_INT 50
14128: PUSH
14129: EMPTY
14130: LIST
14131: PUSH
14132: LD_INT 21
14134: PUSH
14135: LD_INT 1
14137: PUSH
14138: EMPTY
14139: LIST
14140: LIST
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: LIST
14146: PPUSH
14147: CALL_OW 69
14151: ST_TO_ADDR
// k = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
14152: LD_ADDR_VAR 0 4
14156: PUSH
14157: LD_INT 52
14159: PUSH
14160: EMPTY
14161: LIST
14162: PUSH
14163: LD_INT 50
14165: PUSH
14166: EMPTY
14167: LIST
14168: PUSH
14169: LD_INT 21
14171: PUSH
14172: LD_INT 2
14174: PUSH
14175: EMPTY
14176: LIST
14177: LIST
14178: PUSH
14179: LD_INT 58
14181: PUSH
14182: EMPTY
14183: LIST
14184: PUSH
14185: EMPTY
14186: LIST
14187: LIST
14188: LIST
14189: LIST
14190: PPUSH
14191: CALL_OW 69
14195: ST_TO_ADDR
// for u in units do
14196: LD_ADDR_VAR 0 2
14200: PUSH
14201: LD_VAR 0 1
14205: PUSH
14206: FOR_IN
14207: IFFALSE 14278
// if getSide ( u ) = 0 then
14209: LD_VAR 0 2
14213: PPUSH
14214: CALL_OW 255
14218: PUSH
14219: LD_INT 0
14221: EQUAL
14222: IFFALSE 14242
// units = units diff u else
14224: LD_ADDR_VAR 0 1
14228: PUSH
14229: LD_VAR 0 1
14233: PUSH
14234: LD_VAR 0 2
14238: DIFF
14239: ST_TO_ADDR
14240: GO 14276
// if not Side_Comps [ getSide ( u ) ] then
14242: LD_EXP 91
14246: PUSH
14247: LD_VAR 0 2
14251: PPUSH
14252: CALL_OW 255
14256: ARRAY
14257: NOT
14258: IFFALSE 14276
// units = units diff u ;
14260: LD_ADDR_VAR 0 1
14264: PUSH
14265: LD_VAR 0 1
14269: PUSH
14270: LD_VAR 0 2
14274: DIFF
14275: ST_TO_ADDR
14276: GO 14206
14278: POP
14279: POP
// for u in units do
14280: LD_ADDR_VAR 0 2
14284: PUSH
14285: LD_VAR 0 1
14289: PUSH
14290: FOR_IN
14291: IFFALSE 14711
// begin if isinunit ( u ) then
14293: LD_VAR 0 2
14297: PPUSH
14298: CALL_OW 310
14302: IFFALSE 14519
// begin veh = isinunit ( u ) ;
14304: LD_ADDR_VAR 0 3
14308: PUSH
14309: LD_VAR 0 2
14313: PPUSH
14314: CALL_OW 310
14318: ST_TO_ADDR
// if not HasTask ( veh ) then
14319: LD_VAR 0 3
14323: PPUSH
14324: CALL_OW 314
14328: NOT
14329: IFFALSE 14517
// begin if getWeapon ( veh ) in nonCombat then
14331: LD_VAR 0 3
14335: PPUSH
14336: CALL_OW 264
14340: PUSH
14341: LD_EXP 92
14345: IN
14346: IFFALSE 14362
// comMoveToArea ( veh , exitarea ) else
14348: LD_VAR 0 3
14352: PPUSH
14353: LD_INT 20
14355: PPUSH
14356: CALL_OW 113
14360: GO 14517
// if getWeapon ( veh ) in Siberite_Rocket then
14362: LD_VAR 0 3
14366: PPUSH
14367: CALL_OW 264
14371: PUSH
14372: LD_EXP 93
14376: IN
14377: IFFALSE 14433
// begin hex = RandHex ( false ) ;
14379: LD_ADDR_VAR 0 7
14383: PUSH
14384: LD_INT 0
14386: PPUSH
14387: CALL_OW 15
14391: ST_TO_ADDR
// ComAttackPlace ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14392: LD_VAR 0 3
14396: PPUSH
14397: LD_VAR 0 7
14401: PUSH
14402: LD_INT 1
14404: ARRAY
14405: PPUSH
14406: LD_VAR 0 7
14410: PUSH
14411: LD_INT 2
14413: ARRAY
14414: PPUSH
14415: CALL_OW 116
// AddComMoveToArea ( veh , exitarea ) ;
14419: LD_VAR 0 3
14423: PPUSH
14424: LD_INT 20
14426: PPUSH
14427: CALL_OW 173
// end else
14431: GO 14517
// if getLives ( veh ) <= hranice_zraneni then
14433: LD_VAR 0 3
14437: PPUSH
14438: CALL_OW 256
14442: PUSH
14443: LD_INT 500
14445: LESSEQUAL
14446: IFFALSE 14462
// comMoveToArea ( veh , exitarea ) else
14448: LD_VAR 0 3
14452: PPUSH
14453: LD_INT 20
14455: PPUSH
14456: CALL_OW 113
14460: GO 14517
// begin hex = RandHexArea ( exitarea , false ) ;
14462: LD_ADDR_VAR 0 7
14466: PUSH
14467: LD_INT 20
14469: PPUSH
14470: LD_INT 0
14472: PPUSH
14473: CALL_OW 16
14477: ST_TO_ADDR
// comAgressiveMove ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14478: LD_VAR 0 3
14482: PPUSH
14483: LD_VAR 0 7
14487: PUSH
14488: LD_INT 1
14490: ARRAY
14491: PPUSH
14492: LD_VAR 0 7
14496: PUSH
14497: LD_INT 2
14499: ARRAY
14500: PPUSH
14501: CALL_OW 114
// AddComMoveToArea ( veh , exitarea ) ;
14505: LD_VAR 0 3
14509: PPUSH
14510: LD_INT 20
14512: PPUSH
14513: CALL_OW 173
// end ; end ; end else
14517: GO 14702
// begin if not HasTask ( u ) then
14519: LD_VAR 0 2
14523: PPUSH
14524: CALL_OW 314
14528: NOT
14529: IFFALSE 14573
// begin hex = RandHex ( false ) ;
14531: LD_ADDR_VAR 0 7
14535: PUSH
14536: LD_INT 0
14538: PPUSH
14539: CALL_OW 15
14543: ST_TO_ADDR
// ComMoveXY ( u , hex [ 1 ] , hex [ 2 ] ) ;
14544: LD_VAR 0 2
14548: PPUSH
14549: LD_VAR 0 7
14553: PUSH
14554: LD_INT 1
14556: ARRAY
14557: PPUSH
14558: LD_VAR 0 7
14562: PUSH
14563: LD_INT 2
14565: ARRAY
14566: PPUSH
14567: CALL_OW 111
// end else
14571: GO 14702
// begin c = [ ] ;
14573: LD_ADDR_VAR 0 5
14577: PUSH
14578: EMPTY
14579: ST_TO_ADDR
// for i in k do
14580: LD_ADDR_VAR 0 6
14584: PUSH
14585: LD_VAR 0 4
14589: PUSH
14590: FOR_IN
14591: IFFALSE 14632
// if See ( getSide ( u ) , i ) then
14593: LD_VAR 0 2
14597: PPUSH
14598: CALL_OW 255
14602: PPUSH
14603: LD_VAR 0 6
14607: PPUSH
14608: CALL_OW 292
14612: IFFALSE 14630
// c = c ^ i ;
14614: LD_ADDR_VAR 0 5
14618: PUSH
14619: LD_VAR 0 5
14623: PUSH
14624: LD_VAR 0 6
14628: ADD
14629: ST_TO_ADDR
14630: GO 14590
14632: POP
14633: POP
// if c + 0 > 0 then
14634: LD_VAR 0 5
14638: PUSH
14639: LD_INT 0
14641: PLUS
14642: PUSH
14643: LD_INT 0
14645: GREATER
14646: IFFALSE 14702
// begin c = NearestUnitToUnit ( c , u ) ;
14648: LD_ADDR_VAR 0 5
14652: PUSH
14653: LD_VAR 0 5
14657: PPUSH
14658: LD_VAR 0 2
14662: PPUSH
14663: CALL_OW 74
14667: ST_TO_ADDR
// if GetDistUnits ( u , c ) < 10 then
14668: LD_VAR 0 2
14672: PPUSH
14673: LD_VAR 0 5
14677: PPUSH
14678: CALL_OW 296
14682: PUSH
14683: LD_INT 10
14685: LESS
14686: IFFALSE 14702
// comEnterUnit ( u , c ) ;
14688: LD_VAR 0 2
14692: PPUSH
14693: LD_VAR 0 5
14697: PPUSH
14698: CALL_OW 120
// end ; end ; end ; wait ( 1 ) ;
14702: LD_INT 1
14704: PPUSH
14705: CALL_OW 67
// end ;
14709: GO 14290
14711: POP
14712: POP
// enable ;
14713: ENABLE
// end ; end_of_file
14714: PPOPN 7
14716: END
// export function SA_OnSiberiteRocketExploded ( siberite_rocket_vehicle , target_x , target_y , requestSide ) ; begin
14717: LD_INT 0
14719: PPUSH
// if GetSide ( siberite_rocket_vehicle ) = requestSide then
14720: LD_VAR 0 1
14724: PPUSH
14725: CALL_OW 255
14729: PUSH
14730: LD_VAR 0 4
14734: EQUAL
14735: IFFALSE 14754
// begin SetAchievement ( ACH_RAD ) ;
14737: LD_STRING ACH_RAD
14739: PPUSH
14740: CALL_OW 543
// SetAchievementEx ( ACH_NL , 1 ) ;
14744: LD_STRING ACH_NL
14746: PPUSH
14747: LD_INT 1
14749: PPUSH
14750: CALL_OW 564
// end end ;
14754: LD_VAR 0 5
14758: RET
// export function SA_Win ( side ) ; begin
14759: LD_INT 0
14761: PPUSH
// case side of 1 :
14762: LD_VAR 0 1
14766: PUSH
14767: LD_INT 1
14769: DOUBLE
14770: EQUAL
14771: IFTRUE 14775
14773: GO 14788
14775: POP
// SetAchievementEx ( ACH_AH , 1 ) ; 2 :
14776: LD_STRING ACH_AH
14778: PPUSH
14779: LD_INT 1
14781: PPUSH
14782: CALL_OW 564
14786: GO 14951
14788: LD_INT 2
14790: DOUBLE
14791: EQUAL
14792: IFTRUE 14796
14794: GO 14809
14796: POP
// SetAchievementEx ( ACH_E , 1 ) ; 3 :
14797: LD_STRING ACH_E
14799: PPUSH
14800: LD_INT 1
14802: PPUSH
14803: CALL_OW 564
14807: GO 14951
14809: LD_INT 3
14811: DOUBLE
14812: EQUAL
14813: IFTRUE 14817
14815: GO 14830
14817: POP
// SetAchievementEx ( ACH_OOL , 1 ) ; [ 1 , 2 ] :
14818: LD_STRING ACH_OOL
14820: PPUSH
14821: LD_INT 1
14823: PPUSH
14824: CALL_OW 564
14828: GO 14951
14830: LD_INT 1
14832: PUSH
14833: LD_INT 2
14835: PUSH
14836: EMPTY
14837: LIST
14838: LIST
14839: DOUBLE
14840: EQUAL
14841: IFTRUE 14845
14843: GO 14870
14845: POP
// begin SetAchievementEx ( ACH_AH , 0.5 ) ;
14846: LD_STRING ACH_AH
14848: PPUSH
14849: LD_REAL  5.00000000000000E-0001
14852: PPUSH
14853: CALL_OW 564
// SetAchievementEx ( ACH_E , 0.5 ) ;
14857: LD_STRING ACH_E
14859: PPUSH
14860: LD_REAL  5.00000000000000E-0001
14863: PPUSH
14864: CALL_OW 564
// end ; [ 2 , 3 ] :
14868: GO 14951
14870: LD_INT 2
14872: PUSH
14873: LD_INT 3
14875: PUSH
14876: EMPTY
14877: LIST
14878: LIST
14879: DOUBLE
14880: EQUAL
14881: IFTRUE 14885
14883: GO 14910
14885: POP
// begin SetAchievementEx ( ACH_OOL , 0.5 ) ;
14886: LD_STRING ACH_OOL
14888: PPUSH
14889: LD_REAL  5.00000000000000E-0001
14892: PPUSH
14893: CALL_OW 564
// SetAchievementEx ( ACH_E , 0.5 ) ;
14897: LD_STRING ACH_E
14899: PPUSH
14900: LD_REAL  5.00000000000000E-0001
14903: PPUSH
14904: CALL_OW 564
// end ; [ 3 , 1 ] :
14908: GO 14951
14910: LD_INT 3
14912: PUSH
14913: LD_INT 1
14915: PUSH
14916: EMPTY
14917: LIST
14918: LIST
14919: DOUBLE
14920: EQUAL
14921: IFTRUE 14925
14923: GO 14950
14925: POP
// begin SetAchievementEx ( ACH_AH , 0.5 ) ;
14926: LD_STRING ACH_AH
14928: PPUSH
14929: LD_REAL  5.00000000000000E-0001
14932: PPUSH
14933: CALL_OW 564
// SetAchievementEx ( ACH_OOL , 0.5 ) ;
14937: LD_STRING ACH_OOL
14939: PPUSH
14940: LD_REAL  5.00000000000000E-0001
14943: PPUSH
14944: CALL_OW 564
// end ; end ;
14948: GO 14951
14950: POP
// end ;
14951: LD_VAR 0 2
14955: RET
