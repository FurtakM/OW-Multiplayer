// export gametype ; starting begin if multiplayer then
   0: LD_OWVAR 4
   4: IFFALSE 18
// gametype = mp_game_type else
   6: LD_ADDR_EXP 1
  10: PUSH
  11: LD_OWVAR 6
  15: ST_TO_ADDR
  16: GO 26
// gametype = 25 ;
  18: LD_ADDR_EXP 1
  22: PUSH
  23: LD_INT 25
  25: ST_TO_ADDR
// case gametype of 15 :
  26: LD_EXP 1
  30: PUSH
  31: LD_INT 15
  33: DOUBLE
  34: EQUAL
  35: IFTRUE 39
  37: GO 55
  39: POP
// begin enable ( 15 ) ;
  40: LD_INT 15
  42: ENABLE_MARKED
// disable ( 25 ) ;
  43: LD_INT 25
  45: DISABLE_MARKED
// disable ( 35 ) ;
  46: LD_INT 35
  48: DISABLE_MARKED
// starting_sheherezad ;
  49: CALL 3956 0 0
// end ; 25 :
  53: GO 110
  55: LD_INT 25
  57: DOUBLE
  58: EQUAL
  59: IFTRUE 63
  61: GO 79
  63: POP
// begin enable ( 25 ) ;
  64: LD_INT 25
  66: ENABLE_MARKED
// disable ( 15 ) ;
  67: LD_INT 15
  69: DISABLE_MARKED
// disable ( 35 ) ;
  70: LD_INT 35
  72: DISABLE_MARKED
// starting_vehicles ;
  73: CALL 7340 0 0
// end ; 35 , 36 :
  77: GO 110
  79: LD_INT 35
  81: DOUBLE
  82: EQUAL
  83: IFTRUE 93
  85: LD_INT 36
  87: DOUBLE
  88: EQUAL
  89: IFTRUE 93
  91: GO 109
  93: POP
// begin enable ( 35 ) ;
  94: LD_INT 35
  96: ENABLE_MARKED
// disable ( 15 ) ;
  97: LD_INT 15
  99: DISABLE_MARKED
// disable ( 25 ) ;
 100: LD_INT 25
 102: DISABLE_MARKED
// starting_hunt ;
 103: CALL 12384 0 0
// end ; end ;
 107: GO 110
 109: POP
// end ; end_of_file
 110: END
// export def_sheherezade_speed , def_sheherezade_stamina , def_sheherezade_skills , def_number_of_sheikhs , def_sheikhs_level , def_number_of_soldiers , def_soldiers_level , def_charges_allowed , def_amount_of_apemen , def_apemen_level , def_apemen_abilities , def_number_of_mastodons , def_number_of_tigers , def_time_to_prepare , def_flags ; export shzd_speed , shzd_stamina , shzd_skills , nsh , sh_skills , nsol , sol_skills , nstart_ape , ape_respawning , ape_skills , nmast1 , nmast2 , nmast3 , ntig , tig_respawning , prep_time , flags ; export coordinates , sheherezades , lastunit ; export Side_Count , Team_Count , Player_Side , Player_Team , Side_Teams , Teams ; export Side_Positions , Side_Nations , Side_Names , Team_Names , Team_Game ; function read_multiplayer_and_game_parameters ; var i ; begin
 111: LD_INT 0
 113: PPUSH
 114: PPUSH
// if MultiPlayer then
 115: LD_OWVAR 4
 119: IFFALSE 183
// begin Player_Side = mp_player_side ;
 121: LD_ADDR_EXP 39
 125: PUSH
 126: LD_OWVAR 7
 130: ST_TO_ADDR
// Player_Team = mp_player_team ;
 131: LD_ADDR_EXP 40
 135: PUSH
 136: LD_OWVAR 8
 140: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
 141: LD_ADDR_EXP 43
 145: PUSH
 146: LD_OWVAR 17
 150: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
 151: LD_ADDR_EXP 41
 155: PUSH
 156: LD_OWVAR 15
 160: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
 161: LD_ADDR_EXP 44
 165: PUSH
 166: LD_OWVAR 16
 170: ST_TO_ADDR
// Teams = mp_teams ;
 171: LD_ADDR_EXP 42
 175: PUSH
 176: LD_OWVAR 12
 180: ST_TO_ADDR
// end else
 181: GO 323
// begin Player_Side = 1 ;
 183: LD_ADDR_EXP 39
 187: PUSH
 188: LD_INT 1
 190: ST_TO_ADDR
// Player_Team = 0 ;
 191: LD_ADDR_EXP 40
 195: PUSH
 196: LD_INT 0
 198: ST_TO_ADDR
// Side_Positions = [ 1 , 2 , 3 , 4 , 5 , 0 , 0 , 0 ] ;
 199: LD_ADDR_EXP 43
 203: PUSH
 204: LD_INT 1
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 4
 215: PUSH
 216: LD_INT 5
 218: PUSH
 219: LD_INT 0
 221: PUSH
 222: LD_INT 0
 224: PUSH
 225: LD_INT 0
 227: PUSH
 228: EMPTY
 229: LIST
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 238: LD_ADDR_EXP 41
 242: PUSH
 243: LD_INT 0
 245: PUSH
 246: LD_INT 0
 248: PUSH
 249: LD_INT 0
 251: PUSH
 252: LD_INT 0
 254: PUSH
 255: LD_INT 0
 257: PUSH
 258: LD_INT 0
 260: PUSH
 261: LD_INT 0
 263: PUSH
 264: LD_INT 0
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// Side_Nations = [ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ] ;
 277: LD_ADDR_EXP 44
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 2
 287: PUSH
 288: LD_INT 2
 290: PUSH
 291: LD_INT 2
 293: PUSH
 294: LD_INT 2
 296: PUSH
 297: LD_INT 2
 299: PUSH
 300: LD_INT 2
 302: PUSH
 303: LD_INT 2
 305: PUSH
 306: EMPTY
 307: LIST
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: LIST
 313: LIST
 314: LIST
 315: ST_TO_ADDR
// Teams = [ ] ;
 316: LD_ADDR_EXP 42
 320: PUSH
 321: EMPTY
 322: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
 323: LD_ADDR_EXP 37
 327: PUSH
 328: LD_EXP 43
 332: PUSH
 333: LD_INT 0
 335: PUSH
 336: EMPTY
 337: LIST
 338: DIFF
 339: PUSH
 340: LD_INT 0
 342: PLUS
 343: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
 344: LD_ADDR_EXP 38
 348: PUSH
 349: LD_EXP 41
 353: PUSH
 354: LD_INT 0
 356: PUSH
 357: EMPTY
 358: LIST
 359: DIFF
 360: PUSH
 361: LD_INT 0
 363: PLUS
 364: ST_TO_ADDR
// if MultiPlayer then
 365: LD_OWVAR 4
 369: IFFALSE 568
// begin def_sheherezade_speed = GetMultiplayerSetting ( 0 ) ;
 371: LD_ADDR_EXP 2
 375: PUSH
 376: LD_INT 0
 378: PPUSH
 379: CALL_OW 426
 383: ST_TO_ADDR
// def_sheherezade_stamina = GetMultiplayerSetting ( 1 ) ;
 384: LD_ADDR_EXP 3
 388: PUSH
 389: LD_INT 1
 391: PPUSH
 392: CALL_OW 426
 396: ST_TO_ADDR
// def_sheherezade_skills = GetMultiplayerSetting ( 2 ) ;
 397: LD_ADDR_EXP 4
 401: PUSH
 402: LD_INT 2
 404: PPUSH
 405: CALL_OW 426
 409: ST_TO_ADDR
// def_number_of_sheikhs = GetMultiplayerSetting ( 3 ) ;
 410: LD_ADDR_EXP 5
 414: PUSH
 415: LD_INT 3
 417: PPUSH
 418: CALL_OW 426
 422: ST_TO_ADDR
// def_sheikhs_level = GetMultiplayerSetting ( 4 ) ;
 423: LD_ADDR_EXP 6
 427: PUSH
 428: LD_INT 4
 430: PPUSH
 431: CALL_OW 426
 435: ST_TO_ADDR
// def_number_of_soldiers = GetMultiplayerSetting ( 5 ) ;
 436: LD_ADDR_EXP 7
 440: PUSH
 441: LD_INT 5
 443: PPUSH
 444: CALL_OW 426
 448: ST_TO_ADDR
// def_soldiers_level = GetMultiplayerSetting ( 6 ) ;
 449: LD_ADDR_EXP 8
 453: PUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 426
 461: ST_TO_ADDR
// def_charges_allowed = GetMultiplayerSetting ( 7 ) ;
 462: LD_ADDR_EXP 9
 466: PUSH
 467: LD_INT 7
 469: PPUSH
 470: CALL_OW 426
 474: ST_TO_ADDR
// def_amount_of_apemen = GetMultiplayerSetting ( 8 ) ;
 475: LD_ADDR_EXP 10
 479: PUSH
 480: LD_INT 8
 482: PPUSH
 483: CALL_OW 426
 487: ST_TO_ADDR
// def_apemen_level = GetMultiplayerSetting ( 9 ) ;
 488: LD_ADDR_EXP 11
 492: PUSH
 493: LD_INT 9
 495: PPUSH
 496: CALL_OW 426
 500: ST_TO_ADDR
// def_apemen_abilities = GetMultiplayerSetting ( 10 ) ;
 501: LD_ADDR_EXP 12
 505: PUSH
 506: LD_INT 10
 508: PPUSH
 509: CALL_OW 426
 513: ST_TO_ADDR
// def_number_of_mastodons = GetMultiplayerSetting ( 11 ) ;
 514: LD_ADDR_EXP 13
 518: PUSH
 519: LD_INT 11
 521: PPUSH
 522: CALL_OW 426
 526: ST_TO_ADDR
// def_number_of_tigers = GetMultiplayerSetting ( 12 ) ;
 527: LD_ADDR_EXP 14
 531: PUSH
 532: LD_INT 12
 534: PPUSH
 535: CALL_OW 426
 539: ST_TO_ADDR
// def_time_to_prepare = GetMultiplayerSetting ( 13 ) ;
 540: LD_ADDR_EXP 15
 544: PUSH
 545: LD_INT 13
 547: PPUSH
 548: CALL_OW 426
 552: ST_TO_ADDR
// def_flags = GetMultiplayerSetting ( 14 ) ;
 553: LD_ADDR_EXP 16
 557: PUSH
 558: LD_INT 14
 560: PPUSH
 561: CALL_OW 426
 565: ST_TO_ADDR
// end else
 566: GO 696
// begin randomize ;
 568: CALL_OW 10
// randomizeAll ;
 572: CALL_OW 11
// def_sheherezade_speed = 1 ;
 576: LD_ADDR_EXP 2
 580: PUSH
 581: LD_INT 1
 583: ST_TO_ADDR
// def_sheherezade_stamina = 1 ;
 584: LD_ADDR_EXP 3
 588: PUSH
 589: LD_INT 1
 591: ST_TO_ADDR
// def_sheherezade_skills = 2 ;
 592: LD_ADDR_EXP 4
 596: PUSH
 597: LD_INT 2
 599: ST_TO_ADDR
// def_number_of_sheikhs = 3 ;
 600: LD_ADDR_EXP 5
 604: PUSH
 605: LD_INT 3
 607: ST_TO_ADDR
// def_sheikhs_level = 2 ;
 608: LD_ADDR_EXP 6
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// def_number_of_soldiers = 3 ;
 616: LD_ADDR_EXP 7
 620: PUSH
 621: LD_INT 3
 623: ST_TO_ADDR
// def_soldiers_level = 1 ;
 624: LD_ADDR_EXP 8
 628: PUSH
 629: LD_INT 1
 631: ST_TO_ADDR
// def_charges_allowed = 3 ;
 632: LD_ADDR_EXP 9
 636: PUSH
 637: LD_INT 3
 639: ST_TO_ADDR
// def_amount_of_apemen = 2 ;
 640: LD_ADDR_EXP 10
 644: PUSH
 645: LD_INT 2
 647: ST_TO_ADDR
// def_apemen_level = 1 ;
 648: LD_ADDR_EXP 11
 652: PUSH
 653: LD_INT 1
 655: ST_TO_ADDR
// def_apemen_abilities = 1 ;
 656: LD_ADDR_EXP 12
 660: PUSH
 661: LD_INT 1
 663: ST_TO_ADDR
// def_number_of_mastodons = 2 ;
 664: LD_ADDR_EXP 13
 668: PUSH
 669: LD_INT 2
 671: ST_TO_ADDR
// def_number_of_tigers = 2 ;
 672: LD_ADDR_EXP 14
 676: PUSH
 677: LD_INT 2
 679: ST_TO_ADDR
// def_time_to_prepare = 2 ;
 680: LD_ADDR_EXP 15
 684: PUSH
 685: LD_INT 2
 687: ST_TO_ADDR
// def_flags = 2 ;
 688: LD_ADDR_EXP 16
 692: PUSH
 693: LD_INT 2
 695: ST_TO_ADDR
// end ; shzd_speed = [ 9 , 12 , 15 ] [ def_sheherezade_speed + 1 ] ;
 696: LD_ADDR_EXP 17
 700: PUSH
 701: LD_INT 9
 703: PUSH
 704: LD_INT 12
 706: PUSH
 707: LD_INT 15
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_EXP 2
 719: PUSH
 720: LD_INT 1
 722: PLUS
 723: ARRAY
 724: ST_TO_ADDR
// shzd_stamina = [ 6 , 10 , 15 ] [ def_sheherezade_stamina + 1 ] ;
 725: LD_ADDR_EXP 18
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 10
 735: PUSH
 736: LD_INT 15
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: PUSH
 744: LD_EXP 3
 748: PUSH
 749: LD_INT 1
 751: PLUS
 752: ARRAY
 753: ST_TO_ADDR
// shzd_skills = [ [ 1 , 0 , 0 , 3 ] , [ 2 , 0 , 0 , 5 ] , [ 3 , 0 , 0 , 7 ] ] [ def_sheherezade_skills + 1 ] ;
 754: LD_ADDR_EXP 19
 758: PUSH
 759: LD_INT 1
 761: PUSH
 762: LD_INT 0
 764: PUSH
 765: LD_INT 0
 767: PUSH
 768: LD_INT 3
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 2
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: LD_INT 5
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 0
 800: PUSH
 801: LD_INT 0
 803: PUSH
 804: LD_INT 7
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: LIST
 817: PUSH
 818: LD_EXP 4
 822: PUSH
 823: LD_INT 1
 825: PLUS
 826: ARRAY
 827: ST_TO_ADDR
// nsh = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_sheikhs + 1 ] ;
 828: LD_ADDR_EXP 20
 832: PUSH
 833: LD_INT 0
 835: PUSH
 836: LD_INT 1
 838: PUSH
 839: LD_INT 2
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 4
 847: PUSH
 848: LD_INT 5
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PUSH
 859: LD_EXP 5
 863: PUSH
 864: LD_INT 1
 866: PLUS
 867: ARRAY
 868: ST_TO_ADDR
// sh_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_sheikhs_level + 1 ] ;
 869: LD_ADDR_EXP 21
 873: PUSH
 874: LD_INT 2
 876: PUSH
 877: LD_INT 1
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 1
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: PUSH
 892: LD_INT 4
 894: PUSH
 895: LD_INT 2
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 2
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: PUSH
 910: LD_INT 6
 912: PUSH
 913: LD_INT 3
 915: PUSH
 916: LD_INT 3
 918: PUSH
 919: LD_INT 3
 921: PUSH
 922: EMPTY
 923: LIST
 924: LIST
 925: LIST
 926: LIST
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: LD_EXP 6
 937: PUSH
 938: LD_INT 1
 940: PLUS
 941: ARRAY
 942: ST_TO_ADDR
// nsol = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_soldiers + 1 ] ;
 943: LD_ADDR_EXP 22
 947: PUSH
 948: LD_INT 0
 950: PUSH
 951: LD_INT 1
 953: PUSH
 954: LD_INT 2
 956: PUSH
 957: LD_INT 3
 959: PUSH
 960: LD_INT 4
 962: PUSH
 963: LD_INT 5
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: LIST
 973: PUSH
 974: LD_EXP 7
 978: PUSH
 979: LD_INT 1
 981: PLUS
 982: ARRAY
 983: ST_TO_ADDR
// sol_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_soldiers_level + 1 ] ;
 984: LD_ADDR_EXP 23
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: LD_INT 1
 994: PUSH
 995: LD_INT 1
 997: PUSH
 998: LD_INT 1
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: LIST
1005: LIST
1006: PUSH
1007: LD_INT 4
1009: PUSH
1010: LD_INT 2
1012: PUSH
1013: LD_INT 2
1015: PUSH
1016: LD_INT 2
1018: PUSH
1019: EMPTY
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: PUSH
1025: LD_INT 6
1027: PUSH
1028: LD_INT 3
1030: PUSH
1031: LD_INT 3
1033: PUSH
1034: LD_INT 3
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PUSH
1043: EMPTY
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: LD_EXP 8
1052: PUSH
1053: LD_INT 1
1055: PLUS
1056: ARRAY
1057: ST_TO_ADDR
// nstart_ape = [ 0 , 2 , 4 , 6 , 8 ] [ def_amount_of_apemen + 1 ] ;
1058: LD_ADDR_EXP 24
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 4
1071: PUSH
1072: LD_INT 6
1074: PUSH
1075: LD_INT 8
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PUSH
1085: LD_EXP 10
1089: PUSH
1090: LD_INT 1
1092: PLUS
1093: ARRAY
1094: ST_TO_ADDR
// ape_respawning = [ 0 , 4 4$00 , 2 2$00 , 1 1$00 , 0 0$30 ] [ def_amount_of_apemen + 1 ] ;
1095: LD_ADDR_EXP 25
1099: PUSH
1100: LD_INT 0
1102: PUSH
1103: LD_INT 8400
1105: PUSH
1106: LD_INT 4200
1108: PUSH
1109: LD_INT 2100
1111: PUSH
1112: LD_INT 1050
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_EXP 10
1126: PUSH
1127: LD_INT 1
1129: PLUS
1130: ARRAY
1131: ST_TO_ADDR
// ape_skills = [ [ 1 , 0 , 0 , 0 ] , [ 3 , 0 , 0 , 0 ] , [ 5 , 0 , 0 , 0 ] ] [ def_apemen_level + 1 ] ;
1132: LD_ADDR_EXP 26
1136: PUSH
1137: LD_INT 1
1139: PUSH
1140: LD_INT 0
1142: PUSH
1143: LD_INT 0
1145: PUSH
1146: LD_INT 0
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 0
1160: PUSH
1161: LD_INT 0
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 0
1178: PUSH
1179: LD_INT 0
1181: PUSH
1182: LD_INT 0
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: LIST
1195: PUSH
1196: LD_EXP 11
1200: PUSH
1201: LD_INT 1
1203: PLUS
1204: ARRAY
1205: ST_TO_ADDR
// nmast1 = [ 0 , 2 , 4 , 6 ] [ def_number_of_mastodons + 1 ] ;
1206: LD_ADDR_EXP 27
1210: PUSH
1211: LD_INT 0
1213: PUSH
1214: LD_INT 2
1216: PUSH
1217: LD_INT 4
1219: PUSH
1220: LD_INT 6
1222: PUSH
1223: EMPTY
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: PUSH
1229: LD_EXP 13
1233: PUSH
1234: LD_INT 1
1236: PLUS
1237: ARRAY
1238: ST_TO_ADDR
// nmast2 = [ 0 , 1 , 2 , 3 ] [ def_number_of_mastodons + 1 ] ;
1239: LD_ADDR_EXP 28
1243: PUSH
1244: LD_INT 0
1246: PUSH
1247: LD_INT 1
1249: PUSH
1250: LD_INT 2
1252: PUSH
1253: LD_INT 3
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: PUSH
1262: LD_EXP 13
1266: PUSH
1267: LD_INT 1
1269: PLUS
1270: ARRAY
1271: ST_TO_ADDR
// nmast3 = [ 0 , 15 , 30 , 45 ] [ def_number_of_mastodons + 1 ] ;
1272: LD_ADDR_EXP 29
1276: PUSH
1277: LD_INT 0
1279: PUSH
1280: LD_INT 15
1282: PUSH
1283: LD_INT 30
1285: PUSH
1286: LD_INT 45
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_EXP 13
1299: PUSH
1300: LD_INT 1
1302: PLUS
1303: ARRAY
1304: ST_TO_ADDR
// ntig = [ 0 , 1 , 3 , 5 ] [ def_number_of_tigers + 1 ] ;
1305: LD_ADDR_EXP 30
1309: PUSH
1310: LD_INT 0
1312: PUSH
1313: LD_INT 1
1315: PUSH
1316: LD_INT 3
1318: PUSH
1319: LD_INT 5
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: PUSH
1328: LD_EXP 14
1332: PUSH
1333: LD_INT 1
1335: PLUS
1336: ARRAY
1337: ST_TO_ADDR
// tig_respawning = [ 0 , 8 8$00 , 4 4$00 , 2 2$00 ] [ def_number_of_tigers + 1 ] ;
1338: LD_ADDR_EXP 31
1342: PUSH
1343: LD_INT 0
1345: PUSH
1346: LD_INT 16800
1348: PUSH
1349: LD_INT 8400
1351: PUSH
1352: LD_INT 4200
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: PUSH
1361: LD_EXP 14
1365: PUSH
1366: LD_INT 1
1368: PLUS
1369: ARRAY
1370: ST_TO_ADDR
// prep_time = [ 0 , 0 0$20 , 0 0$40 , 1 1$20 ] [ def_time_to_prepare + 1 ] ;
1371: LD_ADDR_EXP 32
1375: PUSH
1376: LD_INT 0
1378: PUSH
1379: LD_INT 700
1381: PUSH
1382: LD_INT 1400
1384: PUSH
1385: LD_INT 2800
1387: PUSH
1388: EMPTY
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: PUSH
1394: LD_EXP 15
1398: PUSH
1399: LD_INT 1
1401: PLUS
1402: ARRAY
1403: ST_TO_ADDR
// flags = [ 0 , 25 , 50 , 75 ] [ def_flags + 1 ] ;
1404: LD_ADDR_EXP 33
1408: PUSH
1409: LD_INT 0
1411: PUSH
1412: LD_INT 25
1414: PUSH
1415: LD_INT 50
1417: PUSH
1418: LD_INT 75
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: PUSH
1427: LD_EXP 16
1431: PUSH
1432: LD_INT 1
1434: PLUS
1435: ARRAY
1436: ST_TO_ADDR
// if def_charges_allowed in [ 1 , 3 ] then
1437: LD_EXP 9
1441: PUSH
1442: LD_INT 1
1444: PUSH
1445: LD_INT 3
1447: PUSH
1448: EMPTY
1449: LIST
1450: LIST
1451: IN
1452: IFFALSE 1489
// for i := 1 to 8 do
1454: LD_ADDR_VAR 0 2
1458: PUSH
1459: DOUBLE
1460: LD_INT 1
1462: DEC
1463: ST_TO_ADDR
1464: LD_INT 8
1466: PUSH
1467: FOR_TO
1468: IFFALSE 1487
// SetTech ( tech_RemCharge , i , state_researched ) ;
1470: LD_INT 18
1472: PPUSH
1473: LD_VAR 0 2
1477: PPUSH
1478: LD_INT 2
1480: PPUSH
1481: CALL_OW 322
1485: GO 1467
1487: POP
1488: POP
// if def_charges_allowed in [ 1 , 3 ] then
1489: LD_EXP 9
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 3
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: IN
1504: IFFALSE 1541
// for i := 1 to 8 do
1506: LD_ADDR_VAR 0 2
1510: PUSH
1511: DOUBLE
1512: LD_INT 1
1514: DEC
1515: ST_TO_ADDR
1516: LD_INT 8
1518: PUSH
1519: FOR_TO
1520: IFFALSE 1539
// SetTech ( tech_Explos , i , state_researched ) ;
1522: LD_INT 42
1524: PPUSH
1525: LD_VAR 0 2
1529: PPUSH
1530: LD_INT 2
1532: PPUSH
1533: CALL_OW 322
1537: GO 1519
1539: POP
1540: POP
// for i := 1 to 8 do
1541: LD_ADDR_VAR 0 2
1545: PUSH
1546: DOUBLE
1547: LD_INT 1
1549: DEC
1550: ST_TO_ADDR
1551: LD_INT 8
1553: PUSH
1554: FOR_TO
1555: IFFALSE 1589
// begin SetTech ( tech_ApeLang , i , state_disabled ) ;
1557: LD_INT 1
1559: PPUSH
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 0
1567: PPUSH
1568: CALL_OW 322
// SetTech ( tech_SibContam , i , state_disabled ) ;
1572: LD_INT 26
1574: PPUSH
1575: LD_VAR 0 2
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL_OW 322
// end ;
1587: GO 1554
1589: POP
1590: POP
// end ;
1591: LD_VAR 0 1
1595: RET
// function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
1596: LD_INT 0
1598: PPUSH
1599: PPUSH
1600: PPUSH
1601: PPUSH
1602: PPUSH
1603: PPUSH
1604: PPUSH
1605: PPUSH
// best = 0 ;
1606: LD_ADDR_VAR 0 2
1610: PUSH
1611: LD_INT 0
1613: ST_TO_ADDR
// for n = 1 to 400 do
1614: LD_ADDR_VAR 0 8
1618: PUSH
1619: DOUBLE
1620: LD_INT 1
1622: DEC
1623: ST_TO_ADDR
1624: LD_INT 400
1626: PUSH
1627: FOR_TO
1628: IFFALSE 1924
// begin c = [ ] ;
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: EMPTY
1636: ST_TO_ADDR
// for i = 1 to side_count do
1637: LD_ADDR_VAR 0 6
1641: PUSH
1642: DOUBLE
1643: LD_INT 1
1645: DEC
1646: ST_TO_ADDR
1647: LD_EXP 37
1651: PUSH
1652: FOR_TO
1653: IFFALSE 1682
// c := c ^ [ RandHexArea ( arstart , false ) ] ;
1655: LD_ADDR_VAR 0 3
1659: PUSH
1660: LD_VAR 0 3
1664: PUSH
1665: LD_INT 7
1667: PPUSH
1668: LD_INT 0
1670: PPUSH
1671: CALL_OW 16
1675: PUSH
1676: EMPTY
1677: LIST
1678: ADD
1679: ST_TO_ADDR
1680: GO 1652
1682: POP
1683: POP
// minv = 10000 ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_INT 10000
1691: ST_TO_ADDR
// for i = 1 to side_count do
1692: LD_ADDR_VAR 0 6
1696: PUSH
1697: DOUBLE
1698: LD_INT 1
1700: DEC
1701: ST_TO_ADDR
1702: LD_EXP 37
1706: PUSH
1707: FOR_TO
1708: IFFALSE 1888
// for j = 1 to side_count do
1710: LD_ADDR_VAR 0 7
1714: PUSH
1715: DOUBLE
1716: LD_INT 1
1718: DEC
1719: ST_TO_ADDR
1720: LD_EXP 37
1724: PUSH
1725: FOR_TO
1726: IFFALSE 1884
// if i <> j then
1728: LD_VAR 0 6
1732: PUSH
1733: LD_VAR 0 7
1737: NONEQUAL
1738: IFFALSE 1882
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
1740: LD_VAR 0 3
1744: PUSH
1745: LD_VAR 0 6
1749: ARRAY
1750: PUSH
1751: LD_INT 1
1753: ARRAY
1754: PPUSH
1755: LD_VAR 0 3
1759: PUSH
1760: LD_VAR 0 6
1764: ARRAY
1765: PUSH
1766: LD_INT 2
1768: ARRAY
1769: PPUSH
1770: LD_VAR 0 3
1774: PUSH
1775: LD_VAR 0 7
1779: ARRAY
1780: PUSH
1781: LD_INT 1
1783: ARRAY
1784: PPUSH
1785: LD_VAR 0 3
1789: PUSH
1790: LD_VAR 0 7
1794: ARRAY
1795: PUSH
1796: LD_INT 2
1798: ARRAY
1799: PPUSH
1800: CALL_OW 298
1804: PUSH
1805: LD_VAR 0 5
1809: LESS
1810: IFFALSE 1882
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
1812: LD_ADDR_VAR 0 5
1816: PUSH
1817: LD_VAR 0 3
1821: PUSH
1822: LD_VAR 0 6
1826: ARRAY
1827: PUSH
1828: LD_INT 1
1830: ARRAY
1831: PPUSH
1832: LD_VAR 0 3
1836: PUSH
1837: LD_VAR 0 6
1841: ARRAY
1842: PUSH
1843: LD_INT 2
1845: ARRAY
1846: PPUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_VAR 0 7
1856: ARRAY
1857: PUSH
1858: LD_INT 1
1860: ARRAY
1861: PPUSH
1862: LD_VAR 0 3
1866: PUSH
1867: LD_VAR 0 7
1871: ARRAY
1872: PUSH
1873: LD_INT 2
1875: ARRAY
1876: PPUSH
1877: CALL_OW 298
1881: ST_TO_ADDR
// end ;
1882: GO 1725
1884: POP
1885: POP
1886: GO 1707
1888: POP
1889: POP
// if minv > best then
1890: LD_VAR 0 5
1894: PUSH
1895: LD_VAR 0 2
1899: GREATER
1900: IFFALSE 1922
// begin best := minv ;
1902: LD_ADDR_VAR 0 2
1906: PUSH
1907: LD_VAR 0 5
1911: ST_TO_ADDR
// bestc := c ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 3
1921: ST_TO_ADDR
// end ; end ;
1922: GO 1627
1924: POP
1925: POP
// coordinates := [ ] ;
1926: LD_ADDR_EXP 34
1930: PUSH
1931: EMPTY
1932: ST_TO_ADDR
// for i = 1 to 8 do
1933: LD_ADDR_VAR 0 6
1937: PUSH
1938: DOUBLE
1939: LD_INT 1
1941: DEC
1942: ST_TO_ADDR
1943: LD_INT 8
1945: PUSH
1946: FOR_TO
1947: IFFALSE 2034
// if side_positions [ i ] = 0 then
1949: LD_EXP 43
1953: PUSH
1954: LD_VAR 0 6
1958: ARRAY
1959: PUSH
1960: LD_INT 0
1962: EQUAL
1963: IFFALSE 1991
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
1965: LD_ADDR_EXP 34
1969: PUSH
1970: LD_EXP 34
1974: PUSH
1975: LD_INT 0
1977: PUSH
1978: LD_INT 0
1980: PUSH
1981: EMPTY
1982: LIST
1983: LIST
1984: PUSH
1985: EMPTY
1986: LIST
1987: ADD
1988: ST_TO_ADDR
1989: GO 2032
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
1991: LD_ADDR_EXP 34
1995: PUSH
1996: LD_EXP 34
2000: PUSH
2001: LD_VAR 0 4
2005: PUSH
2006: LD_INT 1
2008: ARRAY
2009: PUSH
2010: EMPTY
2011: LIST
2012: ADD
2013: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
2014: LD_ADDR_VAR 0 4
2018: PUSH
2019: LD_VAR 0 4
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: CALL_OW 3
2031: ST_TO_ADDR
// end ;
2032: GO 1946
2034: POP
2035: POP
// end ;
2036: LD_VAR 0 1
2040: RET
// function set_attitudes ; var i , j ; begin
2041: LD_INT 0
2043: PPUSH
2044: PPUSH
2045: PPUSH
// if not Team_Game then
2046: LD_EXP 47
2050: NOT
2051: IFFALSE 2147
// begin for i = 1 to 8 do
2053: LD_ADDR_VAR 0 2
2057: PUSH
2058: DOUBLE
2059: LD_INT 1
2061: DEC
2062: ST_TO_ADDR
2063: LD_INT 8
2065: PUSH
2066: FOR_TO
2067: IFFALSE 2145
// for j = 1 to 8 do
2069: LD_ADDR_VAR 0 3
2073: PUSH
2074: DOUBLE
2075: LD_INT 1
2077: DEC
2078: ST_TO_ADDR
2079: LD_INT 8
2081: PUSH
2082: FOR_TO
2083: IFFALSE 2141
// if i <> j then
2085: LD_VAR 0 2
2089: PUSH
2090: LD_VAR 0 3
2094: NONEQUAL
2095: IFFALSE 2119
// SetAttitude ( i , j , att_neutral , true ) else
2097: LD_VAR 0 2
2101: PPUSH
2102: LD_VAR 0 3
2106: PPUSH
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: CALL_OW 80
2117: GO 2139
// SetAttitude ( i , j , att_friend , true ) end ;
2119: LD_VAR 0 2
2123: PPUSH
2124: LD_VAR 0 3
2128: PPUSH
2129: LD_INT 1
2131: PPUSH
2132: LD_INT 1
2134: PPUSH
2135: CALL_OW 80
2139: GO 2082
2141: POP
2142: POP
2143: GO 2066
2145: POP
2146: POP
// end ;
2147: LD_VAR 0 1
2151: RET
// function create_sheherezade ( side ) ; var s ; begin
2152: LD_INT 0
2154: PPUSH
2155: PPUSH
// uc_side := side ;
2156: LD_ADDR_OWVAR 20
2160: PUSH
2161: LD_VAR 0 1
2165: ST_TO_ADDR
// uc_nation := nation_arabian ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 2
2173: ST_TO_ADDR
// hc_name = Sheherezade ;
2174: LD_ADDR_OWVAR 26
2178: PUSH
2179: LD_STRING Sheherezade
2181: ST_TO_ADDR
// hc_sex = sex_female ;
2182: LD_ADDR_OWVAR 27
2186: PUSH
2187: LD_INT 2
2189: ST_TO_ADDR
// hc_class = class_scientistic ;
2190: LD_ADDR_OWVAR 28
2194: PUSH
2195: LD_INT 4
2197: ST_TO_ADDR
// hc_basic_skills = shzd_skills ;
2198: LD_ADDR_OWVAR 30
2202: PUSH
2203: LD_EXP 19
2207: ST_TO_ADDR
// hc_skills = shzd_skills ;
2208: LD_ADDR_OWVAR 31
2212: PUSH
2213: LD_EXP 19
2217: ST_TO_ADDR
// hc_attr = [ shzd_stamina , shzd_speed ] ;
2218: LD_ADDR_OWVAR 29
2222: PUSH
2223: LD_EXP 18
2227: PUSH
2228: LD_EXP 17
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: ST_TO_ADDR
// hc_gallery = multi ;
2237: LD_ADDR_OWVAR 33
2241: PUSH
2242: LD_STRING multi
2244: ST_TO_ADDR
// hc_face_number = 18 ;
2245: LD_ADDR_OWVAR 34
2249: PUSH
2250: LD_INT 18
2252: ST_TO_ADDR
// hc_importance = 105 ;
2253: LD_ADDR_OWVAR 32
2257: PUSH
2258: LD_INT 105
2260: ST_TO_ADDR
// s = CreateHuman ;
2261: LD_ADDR_VAR 0 3
2265: PUSH
2266: CALL_OW 44
2270: ST_TO_ADDR
// PlaceUnitXYR ( s , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 1 , false ) ;
2271: LD_VAR 0 3
2275: PPUSH
2276: LD_EXP 34
2280: PUSH
2281: LD_VAR 0 1
2285: ARRAY
2286: PUSH
2287: LD_INT 1
2289: ARRAY
2290: PPUSH
2291: LD_EXP 34
2295: PUSH
2296: LD_VAR 0 1
2300: ARRAY
2301: PUSH
2302: LD_INT 2
2304: ARRAY
2305: PPUSH
2306: LD_INT 1
2308: PPUSH
2309: LD_INT 0
2311: PPUSH
2312: CALL_OW 50
// sheherezades = Replace ( sheherezades , side , s ) ;
2316: LD_ADDR_EXP 35
2320: PUSH
2321: LD_EXP 35
2325: PPUSH
2326: LD_VAR 0 1
2330: PPUSH
2331: LD_VAR 0 3
2335: PPUSH
2336: CALL_OW 1
2340: ST_TO_ADDR
// end ;
2341: LD_VAR 0 2
2345: RET
// function prepare_sides ; var i ; begin
2346: LD_INT 0
2348: PPUSH
2349: PPUSH
// for i := 1 to 8 do
2350: LD_ADDR_VAR 0 2
2354: PUSH
2355: DOUBLE
2356: LD_INT 1
2358: DEC
2359: ST_TO_ADDR
2360: LD_INT 8
2362: PUSH
2363: FOR_TO
2364: IFFALSE 2389
// if side_positions [ i ] then
2366: LD_EXP 43
2370: PUSH
2371: LD_VAR 0 2
2375: ARRAY
2376: IFFALSE 2387
// create_sheherezade ( i ) ;
2378: LD_VAR 0 2
2382: PPUSH
2383: CALL 2152 0 1
2387: GO 2363
2389: POP
2390: POP
// if prep_time = 0 then
2391: LD_EXP 32
2395: PUSH
2396: LD_INT 0
2398: EQUAL
2399: IFFALSE 2405
// sheherezade_start_the_fight ;
2401: CALL 3720 0 0
// end ;
2405: LD_VAR 0 1
2409: RET
// function prepare_side_to_the_fight ( side , materialization ) ; var x , y , i , sh , sol ; begin
2410: LD_INT 0
2412: PPUSH
2413: PPUSH
2414: PPUSH
2415: PPUSH
2416: PPUSH
2417: PPUSH
// SetTech ( tech_ApeLang , side , state_researched ) ;
2418: LD_INT 1
2420: PPUSH
2421: LD_VAR 0 1
2425: PPUSH
2426: LD_INT 2
2428: PPUSH
2429: CALL_OW 322
// x := GetX ( Sheherezades [ side ] ) ;
2433: LD_ADDR_VAR 0 4
2437: PUSH
2438: LD_EXP 35
2442: PUSH
2443: LD_VAR 0 1
2447: ARRAY
2448: PPUSH
2449: CALL_OW 250
2453: ST_TO_ADDR
// y := GetY ( Sheherezades [ side ] ) ;
2454: LD_ADDR_VAR 0 5
2458: PUSH
2459: LD_EXP 35
2463: PUSH
2464: LD_VAR 0 1
2468: ARRAY
2469: PPUSH
2470: CALL_OW 251
2474: ST_TO_ADDR
// coordinates := Replace ( coordinates , side , [ x , y ] ) ;
2475: LD_ADDR_EXP 34
2479: PUSH
2480: LD_EXP 34
2484: PPUSH
2485: LD_VAR 0 1
2489: PPUSH
2490: LD_VAR 0 4
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PPUSH
2504: CALL_OW 1
2508: ST_TO_ADDR
// if flags then
2509: LD_EXP 33
2513: IFFALSE 2592
// begin SetBattleFlag ( side , x , y , [ [ bfo_defend_bonus_human , flags ] , [ bfo_defend_bonus_vehicle , flags ] , [ bfo_defend_bonus_building , flags ] , [ bfo_height , flags + 25 ] ] ) ;
2515: LD_VAR 0 1
2519: PPUSH
2520: LD_VAR 0 4
2524: PPUSH
2525: LD_VAR 0 5
2529: PPUSH
2530: LD_INT 1
2532: PUSH
2533: LD_EXP 33
2537: PUSH
2538: EMPTY
2539: LIST
2540: LIST
2541: PUSH
2542: LD_INT 2
2544: PUSH
2545: LD_EXP 33
2549: PUSH
2550: EMPTY
2551: LIST
2552: LIST
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: LD_EXP 33
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: PUSH
2566: LD_INT 20
2568: PUSH
2569: LD_EXP 33
2573: PUSH
2574: LD_INT 25
2576: PLUS
2577: PUSH
2578: EMPTY
2579: LIST
2580: LIST
2581: PUSH
2582: EMPTY
2583: LIST
2584: LIST
2585: LIST
2586: LIST
2587: PPUSH
2588: CALL_OW 418
// end ; uc_side := side ;
2592: LD_ADDR_OWVAR 20
2596: PUSH
2597: LD_VAR 0 1
2601: ST_TO_ADDR
// uc_nation := nation_arabian ;
2602: LD_ADDR_OWVAR 21
2606: PUSH
2607: LD_INT 2
2609: ST_TO_ADDR
// hc_name :=  ;
2610: LD_ADDR_OWVAR 26
2614: PUSH
2615: LD_STRING 
2617: ST_TO_ADDR
// hc_class := class_desert_warior ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 11
2625: ST_TO_ADDR
// hc_sex := sex_male ;
2626: LD_ADDR_OWVAR 27
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_basic_skills := sh_skills ;
2634: LD_ADDR_OWVAR 30
2638: PUSH
2639: LD_EXP 21
2643: ST_TO_ADDR
// hc_skills := sh_skills ;
2644: LD_ADDR_OWVAR 31
2648: PUSH
2649: LD_EXP 21
2653: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2654: LD_ADDR_OWVAR 29
2658: PUSH
2659: LD_INT 10
2661: PUSH
2662: LD_INT 10
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: ST_TO_ADDR
// hc_importance := 0 ;
2669: LD_ADDR_OWVAR 32
2673: PUSH
2674: LD_INT 0
2676: ST_TO_ADDR
// hc_gallery :=  ;
2677: LD_ADDR_OWVAR 33
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// for i := 1 to nsol do
2685: LD_ADDR_VAR 0 6
2689: PUSH
2690: DOUBLE
2691: LD_INT 1
2693: DEC
2694: ST_TO_ADDR
2695: LD_EXP 22
2699: PUSH
2700: FOR_TO
2701: IFFALSE 2742
// begin sh := CreateHuman ;
2703: LD_ADDR_VAR 0 7
2707: PUSH
2708: CALL_OW 44
2712: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2713: LD_VAR 0 7
2717: PPUSH
2718: LD_VAR 0 4
2722: PPUSH
2723: LD_VAR 0 5
2727: PPUSH
2728: LD_INT 5
2730: PPUSH
2731: LD_VAR 0 2
2735: PPUSH
2736: CALL_OW 50
// end ;
2740: GO 2700
2742: POP
2743: POP
// hc_name :=  ;
2744: LD_ADDR_OWVAR 26
2748: PUSH
2749: LD_STRING 
2751: ST_TO_ADDR
// hc_class := class_soldier ;
2752: LD_ADDR_OWVAR 28
2756: PUSH
2757: LD_INT 1
2759: ST_TO_ADDR
// hc_sex := sex_male ;
2760: LD_ADDR_OWVAR 27
2764: PUSH
2765: LD_INT 1
2767: ST_TO_ADDR
// hc_basic_skills := sol_skills ;
2768: LD_ADDR_OWVAR 30
2772: PUSH
2773: LD_EXP 23
2777: ST_TO_ADDR
// hc_skills := sol_skills ;
2778: LD_ADDR_OWVAR 31
2782: PUSH
2783: LD_EXP 23
2787: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2788: LD_ADDR_OWVAR 29
2792: PUSH
2793: LD_INT 10
2795: PUSH
2796: LD_INT 10
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: ST_TO_ADDR
// hc_importance := 0 ;
2803: LD_ADDR_OWVAR 32
2807: PUSH
2808: LD_INT 0
2810: ST_TO_ADDR
// hc_gallery :=  ;
2811: LD_ADDR_OWVAR 33
2815: PUSH
2816: LD_STRING 
2818: ST_TO_ADDR
// for i := 1 to nsh do
2819: LD_ADDR_VAR 0 6
2823: PUSH
2824: DOUBLE
2825: LD_INT 1
2827: DEC
2828: ST_TO_ADDR
2829: LD_EXP 20
2833: PUSH
2834: FOR_TO
2835: IFFALSE 2876
// begin sh := CreateHuman ;
2837: LD_ADDR_VAR 0 7
2841: PUSH
2842: CALL_OW 44
2846: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2847: LD_VAR 0 7
2851: PPUSH
2852: LD_VAR 0 4
2856: PPUSH
2857: LD_VAR 0 5
2861: PPUSH
2862: LD_INT 5
2864: PPUSH
2865: LD_VAR 0 2
2869: PPUSH
2870: CALL_OW 50
// end ;
2874: GO 2834
2876: POP
2877: POP
// end ;
2878: LD_VAR 0 3
2882: RET
// function find_hidden_hex ( ar ) ; var i , j , seen ; begin
2883: LD_INT 0
2885: PPUSH
2886: PPUSH
2887: PPUSH
2888: PPUSH
// for i := 1 to 100 do
2889: LD_ADDR_VAR 0 3
2893: PUSH
2894: DOUBLE
2895: LD_INT 1
2897: DEC
2898: ST_TO_ADDR
2899: LD_INT 100
2901: PUSH
2902: FOR_TO
2903: IFFALSE 3026
// begin repeat result := RandHexArea ( ar , false ) ;
2905: LD_ADDR_VAR 0 2
2909: PUSH
2910: LD_VAR 0 1
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 16
2922: ST_TO_ADDR
// until not HexInfo ( result [ 1 ] , result [ 2 ] ) ;
2923: LD_VAR 0 2
2927: PUSH
2928: LD_INT 1
2930: ARRAY
2931: PPUSH
2932: LD_VAR 0 2
2936: PUSH
2937: LD_INT 2
2939: ARRAY
2940: PPUSH
2941: CALL_OW 428
2945: NOT
2946: IFFALSE 2905
// seen := false ;
2948: LD_ADDR_VAR 0 5
2952: PUSH
2953: LD_INT 0
2955: ST_TO_ADDR
// for j := 1 to 8 do
2956: LD_ADDR_VAR 0 4
2960: PUSH
2961: DOUBLE
2962: LD_INT 1
2964: DEC
2965: ST_TO_ADDR
2966: LD_INT 8
2968: PUSH
2969: FOR_TO
2970: IFFALSE 3011
// if SeeXY ( j , result [ 1 ] , result [ 2 ] ) then
2972: LD_VAR 0 4
2976: PPUSH
2977: LD_VAR 0 2
2981: PUSH
2982: LD_INT 1
2984: ARRAY
2985: PPUSH
2986: LD_VAR 0 2
2990: PUSH
2991: LD_INT 2
2993: ARRAY
2994: PPUSH
2995: CALL_OW 293
2999: IFFALSE 3009
// seen := true ;
3001: LD_ADDR_VAR 0 5
3005: PUSH
3006: LD_INT 1
3008: ST_TO_ADDR
3009: GO 2969
3011: POP
3012: POP
// if not seen then
3013: LD_VAR 0 5
3017: NOT
3018: IFFALSE 3024
// exit ;
3020: POP
3021: POP
3022: GO 3036
// end ;
3024: GO 2902
3026: POP
3027: POP
// result := 0 ;
3028: LD_ADDR_VAR 0 2
3032: PUSH
3033: LD_INT 0
3035: ST_TO_ADDR
// end ;
3036: LD_VAR 0 2
3040: RET
// function create_ape ; var coord , i ; begin
3041: LD_INT 0
3043: PPUSH
3044: PPUSH
3045: PPUSH
// if lastunit >= 1999 then
3046: LD_EXP 36
3050: PUSH
3051: LD_INT 1999
3053: GREATEREQUAL
3054: IFFALSE 3058
// exit ;
3056: GO 3225
// uc_nation := nation_nature ;
3058: LD_ADDR_OWVAR 21
3062: PUSH
3063: LD_INT 0
3065: ST_TO_ADDR
// uc_side := 0 ;
3066: LD_ADDR_OWVAR 20
3070: PUSH
3071: LD_INT 0
3073: ST_TO_ADDR
// hc_name :=  ;
3074: LD_ADDR_OWVAR 26
3078: PUSH
3079: LD_STRING 
3081: ST_TO_ADDR
// hc_class := class_apeman ;
3082: LD_ADDR_OWVAR 28
3086: PUSH
3087: LD_INT 12
3089: ST_TO_ADDR
// hc_sex := 1 ;
3090: LD_ADDR_OWVAR 27
3094: PUSH
3095: LD_INT 1
3097: ST_TO_ADDR
// hc_basic_skills := ape_skills ;
3098: LD_ADDR_OWVAR 30
3102: PUSH
3103: LD_EXP 26
3107: ST_TO_ADDR
// hc_skills := ape_skills ;
3108: LD_ADDR_OWVAR 31
3112: PUSH
3113: LD_EXP 26
3117: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3118: LD_ADDR_OWVAR 29
3122: PUSH
3123: LD_INT 12
3125: PUSH
3126: LD_INT 12
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: ST_TO_ADDR
// hc_importance := 0 ;
3133: LD_ADDR_OWVAR 32
3137: PUSH
3138: LD_INT 0
3140: ST_TO_ADDR
// hc_gallery :=  ;
3141: LD_ADDR_OWVAR 33
3145: PUSH
3146: LD_STRING 
3148: ST_TO_ADDR
// hc_agressivity := Rand ( - 15 , 15 ) ;
3149: LD_ADDR_OWVAR 35
3153: PUSH
3154: LD_INT 15
3156: NEG
3157: PPUSH
3158: LD_INT 15
3160: PPUSH
3161: CALL_OW 12
3165: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3166: LD_ADDR_VAR 0 2
3170: PUSH
3171: LD_INT 7
3173: PPUSH
3174: CALL 2883 0 1
3178: ST_TO_ADDR
// if coord then
3179: LD_VAR 0 2
3183: IFFALSE 3225
// begin lastunit := CreateHuman ;
3185: LD_ADDR_EXP 36
3189: PUSH
3190: CALL_OW 44
3194: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3195: LD_EXP 36
3199: PPUSH
3200: LD_VAR 0 2
3204: PUSH
3205: LD_INT 1
3207: ARRAY
3208: PPUSH
3209: LD_VAR 0 2
3213: PUSH
3214: LD_INT 2
3216: ARRAY
3217: PPUSH
3218: LD_INT 0
3220: PPUSH
3221: CALL_OW 48
// end ; end ;
3225: LD_VAR 0 1
3229: RET
// function prepare_apes ; var i ; begin
3230: LD_INT 0
3232: PPUSH
3233: PPUSH
// for i := 1 to side_count * nstart_ape do
3234: LD_ADDR_VAR 0 2
3238: PUSH
3239: DOUBLE
3240: LD_INT 1
3242: DEC
3243: ST_TO_ADDR
3244: LD_EXP 37
3248: PUSH
3249: LD_EXP 24
3253: MUL
3254: PUSH
3255: FOR_TO
3256: IFFALSE 3264
// begin create_ape ;
3258: CALL 3041 0 0
// end ;
3262: GO 3255
3264: POP
3265: POP
// end ;
3266: LD_VAR 0 1
3270: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3271: LD_OWVAR 1
3275: PUSH
3276: LD_EXP 32
3280: GREATER
3281: IFFALSE 3365
3283: GO 3285
3285: DISABLE
3286: LD_INT 0
3288: PPUSH
// begin if not ape_respawning then
3289: LD_EXP 25
3293: NOT
3294: IFFALSE 3298
// exit ;
3296: GO 3365
// delay := ape_respawning div side_count ;
3298: LD_ADDR_VAR 0 1
3302: PUSH
3303: LD_EXP 25
3307: PUSH
3308: LD_EXP 37
3312: DIV
3313: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3314: LD_VAR 0 1
3318: PUSH
3319: LD_INT 50
3321: PPUSH
3322: LD_INT 150
3324: PPUSH
3325: CALL_OW 12
3329: MUL
3330: PUSH
3331: LD_INT 100
3333: DIV
3334: PPUSH
3335: CALL_OW 67
// delay := delay * 110 div 100 ;
3339: LD_ADDR_VAR 0 1
3343: PUSH
3344: LD_VAR 0 1
3348: PUSH
3349: LD_INT 110
3351: MUL
3352: PUSH
3353: LD_INT 100
3355: DIV
3356: ST_TO_ADDR
// create_ape ;
3357: CALL 3041 0 0
// until false ;
3361: LD_INT 0
3363: IFFALSE 3314
// end ;
3365: PPOPN 1
3367: END
// function create_tiger ; var coord , i ; begin
3368: LD_INT 0
3370: PPUSH
3371: PPUSH
3372: PPUSH
// if lastunit >= 1999 then
3373: LD_EXP 36
3377: PUSH
3378: LD_INT 1999
3380: GREATEREQUAL
3381: IFFALSE 3385
// exit ;
3383: GO 3577
// uc_nation := nation_nature ;
3385: LD_ADDR_OWVAR 21
3389: PUSH
3390: LD_INT 0
3392: ST_TO_ADDR
// uc_side := 0 ;
3393: LD_ADDR_OWVAR 20
3397: PUSH
3398: LD_INT 0
3400: ST_TO_ADDR
// hc_name :=  ;
3401: LD_ADDR_OWVAR 26
3405: PUSH
3406: LD_STRING 
3408: ST_TO_ADDR
// hc_class := class_tiger ;
3409: LD_ADDR_OWVAR 28
3413: PUSH
3414: LD_INT 14
3416: ST_TO_ADDR
// hc_sex := 1 ;
3417: LD_ADDR_OWVAR 27
3421: PUSH
3422: LD_INT 1
3424: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 2 , 2 ] ;
3425: LD_ADDR_OWVAR 30
3429: PUSH
3430: LD_INT 2
3432: PUSH
3433: LD_INT 2
3435: PUSH
3436: LD_INT 2
3438: PUSH
3439: LD_INT 2
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// hc_skills := [ 2 , 2 , 2 , 2 ] ;
3448: LD_ADDR_OWVAR 31
3452: PUSH
3453: LD_INT 2
3455: PUSH
3456: LD_INT 2
3458: PUSH
3459: LD_INT 2
3461: PUSH
3462: LD_INT 2
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: LIST
3469: LIST
3470: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3471: LD_ADDR_OWVAR 29
3475: PUSH
3476: LD_INT 12
3478: PUSH
3479: LD_INT 12
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: ST_TO_ADDR
// hc_importance := 0 ;
3486: LD_ADDR_OWVAR 32
3490: PUSH
3491: LD_INT 0
3493: ST_TO_ADDR
// hc_gallery :=  ;
3494: LD_ADDR_OWVAR 33
3498: PUSH
3499: LD_STRING 
3501: ST_TO_ADDR
// hc_agressivity := Rand ( 30 , 50 ) ;
3502: LD_ADDR_OWVAR 35
3506: PUSH
3507: LD_INT 30
3509: PPUSH
3510: LD_INT 50
3512: PPUSH
3513: CALL_OW 12
3517: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3518: LD_ADDR_VAR 0 2
3522: PUSH
3523: LD_INT 7
3525: PPUSH
3526: CALL 2883 0 1
3530: ST_TO_ADDR
// if coord then
3531: LD_VAR 0 2
3535: IFFALSE 3577
// begin lastunit := CreateHuman ;
3537: LD_ADDR_EXP 36
3541: PUSH
3542: CALL_OW 44
3546: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3547: LD_EXP 36
3551: PPUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_INT 1
3559: ARRAY
3560: PPUSH
3561: LD_VAR 0 2
3565: PUSH
3566: LD_INT 2
3568: ARRAY
3569: PPUSH
3570: LD_INT 0
3572: PPUSH
3573: CALL_OW 48
// end ; end ;
3577: LD_VAR 0 1
3581: RET
// function prepare_tigers ; var i ; begin
3582: LD_INT 0
3584: PPUSH
3585: PPUSH
// for i := 1 to side_count * ntig do
3586: LD_ADDR_VAR 0 2
3590: PUSH
3591: DOUBLE
3592: LD_INT 1
3594: DEC
3595: ST_TO_ADDR
3596: LD_EXP 37
3600: PUSH
3601: LD_EXP 30
3605: MUL
3606: PUSH
3607: FOR_TO
3608: IFFALSE 3616
// begin create_tiger ;
3610: CALL 3368 0 0
// end ;
3614: GO 3607
3616: POP
3617: POP
// end ;
3618: LD_VAR 0 1
3622: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3623: LD_OWVAR 1
3627: PUSH
3628: LD_EXP 32
3632: GREATER
3633: IFFALSE 3717
3635: GO 3637
3637: DISABLE
3638: LD_INT 0
3640: PPUSH
// begin if not tig_respawning then
3641: LD_EXP 31
3645: NOT
3646: IFFALSE 3650
// exit ;
3648: GO 3717
// delay := tig_respawning div side_count ;
3650: LD_ADDR_VAR 0 1
3654: PUSH
3655: LD_EXP 31
3659: PUSH
3660: LD_EXP 37
3664: DIV
3665: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3666: LD_VAR 0 1
3670: PUSH
3671: LD_INT 50
3673: PPUSH
3674: LD_INT 150
3676: PPUSH
3677: CALL_OW 12
3681: MUL
3682: PUSH
3683: LD_INT 100
3685: DIV
3686: PPUSH
3687: CALL_OW 67
// delay := delay * 110 div 100 ;
3691: LD_ADDR_VAR 0 1
3695: PUSH
3696: LD_VAR 0 1
3700: PUSH
3701: LD_INT 110
3703: MUL
3704: PUSH
3705: LD_INT 100
3707: DIV
3708: ST_TO_ADDR
// create_tiger ;
3709: CALL 3368 0 0
// until false ;
3713: LD_INT 0
3715: IFFALSE 3666
// end ;
3717: PPOPN 1
3719: END
// export function sheherezade_start_the_fight ; var i ; begin
3720: LD_INT 0
3722: PPUSH
3723: PPUSH
// for i := 1 to 8 do
3724: LD_ADDR_VAR 0 2
3728: PUSH
3729: DOUBLE
3730: LD_INT 1
3732: DEC
3733: ST_TO_ADDR
3734: LD_INT 8
3736: PUSH
3737: FOR_TO
3738: IFFALSE 3772
// if side_positions [ i ] then
3740: LD_EXP 43
3744: PUSH
3745: LD_VAR 0 2
3749: ARRAY
3750: IFFALSE 3770
// prepare_side_to_the_fight ( i , prep_time > 0 ) ;
3752: LD_VAR 0 2
3756: PPUSH
3757: LD_EXP 32
3761: PUSH
3762: LD_INT 0
3764: GREATER
3765: PPUSH
3766: CALL 2410 0 2
3770: GO 3737
3772: POP
3773: POP
// end ;
3774: LD_VAR 0 1
3778: RET
// function create_mastodon ; var coord , i ; begin
3779: LD_INT 0
3781: PPUSH
3782: PPUSH
3783: PPUSH
// if lastunit >= 1999 then
3784: LD_EXP 36
3788: PUSH
3789: LD_INT 1999
3791: GREATEREQUAL
3792: IFFALSE 3796
// exit ;
3794: GO 3882
// uc_nation := nation_nature ;
3796: LD_ADDR_OWVAR 21
3800: PUSH
3801: LD_INT 0
3803: ST_TO_ADDR
// uc_side := 0 ;
3804: LD_ADDR_OWVAR 20
3808: PUSH
3809: LD_INT 0
3811: ST_TO_ADDR
// vc_chassis := 31 ;
3812: LD_ADDR_OWVAR 37
3816: PUSH
3817: LD_INT 31
3819: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3820: LD_ADDR_VAR 0 2
3824: PUSH
3825: LD_INT 7
3827: PPUSH
3828: CALL 2883 0 1
3832: ST_TO_ADDR
// if coord then
3833: LD_VAR 0 2
3837: IFFALSE 3882
// begin lastunit := CreateVehicle ;
3839: LD_ADDR_EXP 36
3843: PUSH
3844: CALL_OW 45
3848: ST_TO_ADDR
// PlaceUnitXYR ( lastunit , coord [ 1 ] , coord [ 2 ] , 3 , false ) ;
3849: LD_EXP 36
3853: PPUSH
3854: LD_VAR 0 2
3858: PUSH
3859: LD_INT 1
3861: ARRAY
3862: PPUSH
3863: LD_VAR 0 2
3867: PUSH
3868: LD_INT 2
3870: ARRAY
3871: PPUSH
3872: LD_INT 3
3874: PPUSH
3875: LD_INT 0
3877: PPUSH
3878: CALL_OW 50
// end ; end ;
3882: LD_VAR 0 1
3886: RET
// function prepare_mastodons ; var i ; begin
3887: LD_INT 0
3889: PPUSH
3890: PPUSH
// for i := 1 to nmast1 + side_count * nmast2 + side_count * nsh * nmast3 div 100 do
3891: LD_ADDR_VAR 0 2
3895: PUSH
3896: DOUBLE
3897: LD_INT 1
3899: DEC
3900: ST_TO_ADDR
3901: LD_EXP 27
3905: PUSH
3906: LD_EXP 37
3910: PUSH
3911: LD_EXP 28
3915: MUL
3916: PLUS
3917: PUSH
3918: LD_EXP 37
3922: PUSH
3923: LD_EXP 20
3927: MUL
3928: PUSH
3929: LD_EXP 29
3933: MUL
3934: PUSH
3935: LD_INT 100
3937: DIV
3938: PLUS
3939: PUSH
3940: FOR_TO
3941: IFFALSE 3949
// begin create_mastodon ;
3943: CALL 3779 0 0
// end ;
3947: GO 3940
3949: POP
3950: POP
// end ;
3951: LD_VAR 0 1
3955: RET
// export function starting_sheherezad ; begin
3956: LD_INT 0
3958: PPUSH
// mp_selectmsg := true ;
3959: LD_ADDR_OWVAR 13
3963: PUSH
3964: LD_INT 1
3966: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
3967: CALL 111 0 0
// prepare_map_coordinates ;
3971: CALL 1596 0 0
// set_attitudes ;
3975: CALL 2041 0 0
// prepare_sides ;
3979: CALL 2346 0 0
// prepare_apes ;
3983: CALL 3230 0 0
// prepare_tigers ;
3987: CALL 3582 0 0
// prepare_mastodons ;
3991: CALL 3887 0 0
// your_side := Player_Side ;
3995: LD_ADDR_OWVAR 2
3999: PUSH
4000: LD_EXP 39
4004: ST_TO_ADDR
// ResetFog ;
4005: CALL_OW 335
// AnimateTrees ( true ) ;
4009: LD_INT 1
4011: PPUSH
4012: CALL_OW 573
// music_nat := nation_arabian ;
4016: LD_ADDR_OWVAR 71
4020: PUSH
4021: LD_INT 2
4023: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
4024: LD_EXP 34
4028: PUSH
4029: LD_OWVAR 2
4033: ARRAY
4034: PUSH
4035: LD_INT 1
4037: ARRAY
4038: PPUSH
4039: LD_EXP 34
4043: PUSH
4044: LD_OWVAR 2
4048: ARRAY
4049: PUSH
4050: LD_INT 2
4052: ARRAY
4053: PPUSH
4054: CALL_OW 86
// end ; end_of_file
4058: LD_VAR 0 1
4062: RET
// export def_victory_conditions , def_number_of_people , def_people_respawning , def_vehicles_at_start , def_vehicles_respawning , def_vehicles_nations , def_siberite_rocket , def_vehicles_durability ; export game_time , point_limit , vehresp , vehmax1 , vehmax2 , vehmax , startvehperc , startveh , vehdur , npeop , peopresp , vehnats , sibrock , to_resp ; function read_multiplayer_and_game_parameters ; var i ; begin
4063: LD_INT 0
4065: PPUSH
4066: PPUSH
// if MultiPlayer then
4067: LD_OWVAR 4
4071: IFFALSE 4135
// begin Player_Side = mp_player_side ;
4073: LD_ADDR_EXP 39
4077: PUSH
4078: LD_OWVAR 7
4082: ST_TO_ADDR
// Player_Team = mp_player_team ;
4083: LD_ADDR_EXP 40
4087: PUSH
4088: LD_OWVAR 8
4092: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
4093: LD_ADDR_EXP 43
4097: PUSH
4098: LD_OWVAR 17
4102: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
4103: LD_ADDR_EXP 41
4107: PUSH
4108: LD_OWVAR 15
4112: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
4113: LD_ADDR_EXP 44
4117: PUSH
4118: LD_OWVAR 16
4122: ST_TO_ADDR
// Teams = mp_teams ;
4123: LD_ADDR_EXP 42
4127: PUSH
4128: LD_OWVAR 12
4132: ST_TO_ADDR
// end else
4133: GO 4279
// begin randomize ;
4135: CALL_OW 10
// Player_Side = 1 ;
4139: LD_ADDR_EXP 39
4143: PUSH
4144: LD_INT 1
4146: ST_TO_ADDR
// Player_Team = 0 ;
4147: LD_ADDR_EXP 40
4151: PUSH
4152: LD_INT 0
4154: ST_TO_ADDR
// Side_Positions = [ 1 , 3 , 6 , 0 , 0 , 0 , 0 , 7 ] ;
4155: LD_ADDR_EXP 43
4159: PUSH
4160: LD_INT 1
4162: PUSH
4163: LD_INT 3
4165: PUSH
4166: LD_INT 6
4168: PUSH
4169: LD_INT 0
4171: PUSH
4172: LD_INT 0
4174: PUSH
4175: LD_INT 0
4177: PUSH
4178: LD_INT 0
4180: PUSH
4181: LD_INT 7
4183: PUSH
4184: EMPTY
4185: LIST
4186: LIST
4187: LIST
4188: LIST
4189: LIST
4190: LIST
4191: LIST
4192: LIST
4193: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4194: LD_ADDR_EXP 41
4198: PUSH
4199: LD_INT 0
4201: PUSH
4202: LD_INT 0
4204: PUSH
4205: LD_INT 0
4207: PUSH
4208: LD_INT 0
4210: PUSH
4211: LD_INT 0
4213: PUSH
4214: LD_INT 0
4216: PUSH
4217: LD_INT 0
4219: PUSH
4220: LD_INT 0
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: LIST
4227: LIST
4228: LIST
4229: LIST
4230: LIST
4231: LIST
4232: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 2 , 2 , 2 , 2 ] ;
4233: LD_ADDR_EXP 44
4237: PUSH
4238: LD_INT 1
4240: PUSH
4241: LD_INT 3
4243: PUSH
4244: LD_INT 1
4246: PUSH
4247: LD_INT 2
4249: PUSH
4250: LD_INT 2
4252: PUSH
4253: LD_INT 2
4255: PUSH
4256: LD_INT 2
4258: PUSH
4259: LD_INT 2
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: ST_TO_ADDR
// Teams = [ ] ;
4272: LD_ADDR_EXP 42
4276: PUSH
4277: EMPTY
4278: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
4279: LD_ADDR_EXP 37
4283: PUSH
4284: LD_EXP 43
4288: PUSH
4289: LD_INT 0
4291: PUSH
4292: EMPTY
4293: LIST
4294: DIFF
4295: PUSH
4296: LD_INT 0
4298: PLUS
4299: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
4300: LD_ADDR_EXP 38
4304: PUSH
4305: LD_EXP 41
4309: PUSH
4310: LD_INT 0
4312: PUSH
4313: EMPTY
4314: LIST
4315: DIFF
4316: PUSH
4317: LD_INT 0
4319: PLUS
4320: ST_TO_ADDR
// if MultiPlayer then
4321: LD_OWVAR 4
4325: IFFALSE 4433
// begin def_victory_conditions = GetMultiplayerSetting ( 0 ) ;
4327: LD_ADDR_EXP 48
4331: PUSH
4332: LD_INT 0
4334: PPUSH
4335: CALL_OW 426
4339: ST_TO_ADDR
// def_number_of_people = GetMultiplayerSetting ( 1 ) ;
4340: LD_ADDR_EXP 49
4344: PUSH
4345: LD_INT 1
4347: PPUSH
4348: CALL_OW 426
4352: ST_TO_ADDR
// def_people_respawning = GetMultiplayerSetting ( 2 ) ;
4353: LD_ADDR_EXP 50
4357: PUSH
4358: LD_INT 2
4360: PPUSH
4361: CALL_OW 426
4365: ST_TO_ADDR
// def_vehicles_at_start = GetMultiplayerSetting ( 3 ) ;
4366: LD_ADDR_EXP 51
4370: PUSH
4371: LD_INT 3
4373: PPUSH
4374: CALL_OW 426
4378: ST_TO_ADDR
// def_vehicles_respawning = GetMultiplayerSetting ( 4 ) ;
4379: LD_ADDR_EXP 52
4383: PUSH
4384: LD_INT 4
4386: PPUSH
4387: CALL_OW 426
4391: ST_TO_ADDR
// def_vehicles_nations = GetMultiplayerSetting ( 5 ) ;
4392: LD_ADDR_EXP 53
4396: PUSH
4397: LD_INT 5
4399: PPUSH
4400: CALL_OW 426
4404: ST_TO_ADDR
// def_siberite_rocket = GetMultiplayerSetting ( 6 ) ;
4405: LD_ADDR_EXP 54
4409: PUSH
4410: LD_INT 6
4412: PPUSH
4413: CALL_OW 426
4417: ST_TO_ADDR
// def_vehicles_durability = GetMultiplayerSetting ( 7 ) ;
4418: LD_ADDR_EXP 55
4422: PUSH
4423: LD_INT 7
4425: PPUSH
4426: CALL_OW 426
4430: ST_TO_ADDR
// end else
4431: GO 4501
// begin randomize ;
4433: CALL_OW 10
// def_victory_conditions = 2 ;
4437: LD_ADDR_EXP 48
4441: PUSH
4442: LD_INT 2
4444: ST_TO_ADDR
// def_number_of_people = 1 ;
4445: LD_ADDR_EXP 49
4449: PUSH
4450: LD_INT 1
4452: ST_TO_ADDR
// def_people_respawning = 1 ;
4453: LD_ADDR_EXP 50
4457: PUSH
4458: LD_INT 1
4460: ST_TO_ADDR
// def_vehicles_at_start = 1 ;
4461: LD_ADDR_EXP 51
4465: PUSH
4466: LD_INT 1
4468: ST_TO_ADDR
// def_vehicles_respawning = 2 ;
4469: LD_ADDR_EXP 52
4473: PUSH
4474: LD_INT 2
4476: ST_TO_ADDR
// def_vehicles_nations = 0 ;
4477: LD_ADDR_EXP 53
4481: PUSH
4482: LD_INT 0
4484: ST_TO_ADDR
// def_siberite_rocket = 1 ;
4485: LD_ADDR_EXP 54
4489: PUSH
4490: LD_INT 1
4492: ST_TO_ADDR
// def_vehicles_durability = 1 ;
4493: LD_ADDR_EXP 55
4497: PUSH
4498: LD_INT 1
4500: ST_TO_ADDR
// end ; game_time = [ 5 5$0 , 10 10$0 , 15 15$0 , 20 20$0 , 30 30$0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ def_victory_conditions + 1 ] ;
4501: LD_ADDR_EXP 56
4505: PUSH
4506: LD_INT 10500
4508: PUSH
4509: LD_INT 21000
4511: PUSH
4512: LD_INT 31500
4514: PUSH
4515: LD_INT 42000
4517: PUSH
4518: LD_INT 63000
4520: PUSH
4521: LD_INT 0
4523: PUSH
4524: LD_INT 0
4526: PUSH
4527: LD_INT 0
4529: PUSH
4530: LD_INT 0
4532: PUSH
4533: LD_INT 0
4535: PUSH
4536: LD_INT 0
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: PUSH
4552: LD_EXP 48
4556: PUSH
4557: LD_INT 1
4559: PLUS
4560: ARRAY
4561: ST_TO_ADDR
// point_limit = [ 0 , 0 , 0 , 0 , 0 , 0 , 5 , 10 , 15 , 20 , 30 , 50 ] [ def_victory_conditions + 1 ] ;
4562: LD_ADDR_EXP 57
4566: PUSH
4567: LD_INT 0
4569: PUSH
4570: LD_INT 0
4572: PUSH
4573: LD_INT 0
4575: PUSH
4576: LD_INT 0
4578: PUSH
4579: LD_INT 0
4581: PUSH
4582: LD_INT 0
4584: PUSH
4585: LD_INT 5
4587: PUSH
4588: LD_INT 10
4590: PUSH
4591: LD_INT 15
4593: PUSH
4594: LD_INT 20
4596: PUSH
4597: LD_INT 30
4599: PUSH
4600: LD_INT 50
4602: PUSH
4603: EMPTY
4604: LIST
4605: LIST
4606: LIST
4607: LIST
4608: LIST
4609: LIST
4610: LIST
4611: LIST
4612: LIST
4613: LIST
4614: LIST
4615: LIST
4616: PUSH
4617: LD_EXP 48
4621: PUSH
4622: LD_INT 1
4624: PLUS
4625: ARRAY
4626: ST_TO_ADDR
// npeop = [ 4 , 6 , 8 , 10 ] [ def_number_of_people + 1 ] ;
4627: LD_ADDR_EXP 65
4631: PUSH
4632: LD_INT 4
4634: PUSH
4635: LD_INT 6
4637: PUSH
4638: LD_INT 8
4640: PUSH
4641: LD_INT 10
4643: PUSH
4644: EMPTY
4645: LIST
4646: LIST
4647: LIST
4648: LIST
4649: PUSH
4650: LD_EXP 49
4654: PUSH
4655: LD_INT 1
4657: PLUS
4658: ARRAY
4659: ST_TO_ADDR
// peopresp = [ false , [ 0 0$40 , 1 1$20 ] , [ 0 0$20 , 0 0$40 ] , [ 0 0$10 , 0 0$20 ] ] [ def_people_respawning + 1 ] ;
4660: LD_ADDR_EXP 66
4664: PUSH
4665: LD_INT 0
4667: PUSH
4668: LD_INT 1400
4670: PUSH
4671: LD_INT 2800
4673: PUSH
4674: EMPTY
4675: LIST
4676: LIST
4677: PUSH
4678: LD_INT 700
4680: PUSH
4681: LD_INT 1400
4683: PUSH
4684: EMPTY
4685: LIST
4686: LIST
4687: PUSH
4688: LD_INT 350
4690: PUSH
4691: LD_INT 700
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: LIST
4702: LIST
4703: PUSH
4704: LD_EXP 50
4708: PUSH
4709: LD_INT 1
4711: PLUS
4712: ARRAY
4713: ST_TO_ADDR
// vehmax1 = [ 3 , 6 , 9 ] [ def_vehicles_respawning + 1 ] ;
4714: LD_ADDR_EXP 59
4718: PUSH
4719: LD_INT 3
4721: PUSH
4722: LD_INT 6
4724: PUSH
4725: LD_INT 9
4727: PUSH
4728: EMPTY
4729: LIST
4730: LIST
4731: LIST
4732: PUSH
4733: LD_EXP 52
4737: PUSH
4738: LD_INT 1
4740: PLUS
4741: ARRAY
4742: ST_TO_ADDR
// vehmax2 = [ 2 , 4 , 6 ] [ def_vehicles_respawning + 1 ] ;
4743: LD_ADDR_EXP 60
4747: PUSH
4748: LD_INT 2
4750: PUSH
4751: LD_INT 4
4753: PUSH
4754: LD_INT 6
4756: PUSH
4757: EMPTY
4758: LIST
4759: LIST
4760: LIST
4761: PUSH
4762: LD_EXP 52
4766: PUSH
4767: LD_INT 1
4769: PLUS
4770: ARRAY
4771: ST_TO_ADDR
// vehmax = vehmax1 + side_count * vehmax2 ;
4772: LD_ADDR_EXP 61
4776: PUSH
4777: LD_EXP 59
4781: PUSH
4782: LD_EXP 37
4786: PUSH
4787: LD_EXP 60
4791: MUL
4792: PLUS
4793: ST_TO_ADDR
// vehdur = [ [ 40 , 80 ] , [ 60 , 120 ] , [ 100 , 200 ] ] [ def_vehicles_durability + 1 ] ;
4794: LD_ADDR_EXP 64
4798: PUSH
4799: LD_INT 40
4801: PUSH
4802: LD_INT 80
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: PUSH
4809: LD_INT 60
4811: PUSH
4812: LD_INT 120
4814: PUSH
4815: EMPTY
4816: LIST
4817: LIST
4818: PUSH
4819: LD_INT 100
4821: PUSH
4822: LD_INT 200
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: LIST
4833: PUSH
4834: LD_EXP 55
4838: PUSH
4839: LD_INT 1
4841: PLUS
4842: ARRAY
4843: ST_TO_ADDR
// vehresp = [ [ 0 0$40 , 2 2$00 ] , [ 0 0$20 , 1 1$00 ] , [ 0 0$10 , 0 0$30 ] ] [ def_vehicles_respawning + 1 ] ;
4844: LD_ADDR_EXP 58
4848: PUSH
4849: LD_INT 1400
4851: PUSH
4852: LD_INT 4200
4854: PUSH
4855: EMPTY
4856: LIST
4857: LIST
4858: PUSH
4859: LD_INT 700
4861: PUSH
4862: LD_INT 2100
4864: PUSH
4865: EMPTY
4866: LIST
4867: LIST
4868: PUSH
4869: LD_INT 350
4871: PUSH
4872: LD_INT 1050
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: LD_EXP 52
4888: PUSH
4889: LD_INT 1
4891: PLUS
4892: ARRAY
4893: ST_TO_ADDR
// startvehperc = [ 0 , 10 , 20 , 40 ] [ def_vehicles_at_start + 1 ] ;
4894: LD_ADDR_EXP 62
4898: PUSH
4899: LD_INT 0
4901: PUSH
4902: LD_INT 10
4904: PUSH
4905: LD_INT 20
4907: PUSH
4908: LD_INT 40
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: LIST
4915: LIST
4916: PUSH
4917: LD_EXP 51
4921: PUSH
4922: LD_INT 1
4924: PLUS
4925: ARRAY
4926: ST_TO_ADDR
// startveh = vehmax * startvehperc div 100 ;
4927: LD_ADDR_EXP 63
4931: PUSH
4932: LD_EXP 61
4936: PUSH
4937: LD_EXP 62
4941: MUL
4942: PUSH
4943: LD_INT 100
4945: DIV
4946: ST_TO_ADDR
// vehnats = [ [ 1 , 2 , 3 ] , [ 1 ] , [ 3 ] , [ 2 ] , [ 1 , 3 ] , [ 3 , 2 ] , [ 2 , 1 ] ] [ def_vehicles_nations + 1 ] ;
4947: LD_ADDR_EXP 67
4951: PUSH
4952: LD_INT 1
4954: PUSH
4955: LD_INT 2
4957: PUSH
4958: LD_INT 3
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: LIST
4965: PUSH
4966: LD_INT 1
4968: PUSH
4969: EMPTY
4970: LIST
4971: PUSH
4972: LD_INT 3
4974: PUSH
4975: EMPTY
4976: LIST
4977: PUSH
4978: LD_INT 2
4980: PUSH
4981: EMPTY
4982: LIST
4983: PUSH
4984: LD_INT 1
4986: PUSH
4987: LD_INT 3
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: PUSH
4994: LD_INT 3
4996: PUSH
4997: LD_INT 2
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 2
5006: PUSH
5007: LD_INT 1
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: LIST
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: PUSH
5023: LD_EXP 53
5027: PUSH
5028: LD_INT 1
5030: PLUS
5031: ARRAY
5032: ST_TO_ADDR
// sibrock = [ 0 , 3 , 7 ] [ def_siberite_rocket + 1 ] ;
5033: LD_ADDR_EXP 68
5037: PUSH
5038: LD_INT 0
5040: PUSH
5041: LD_INT 3
5043: PUSH
5044: LD_INT 7
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: LIST
5051: PUSH
5052: LD_EXP 54
5056: PUSH
5057: LD_INT 1
5059: PLUS
5060: ARRAY
5061: ST_TO_ADDR
// for i = 1 to 8 do
5062: LD_ADDR_VAR 0 2
5066: PUSH
5067: DOUBLE
5068: LD_INT 1
5070: DEC
5071: ST_TO_ADDR
5072: LD_INT 8
5074: PUSH
5075: FOR_TO
5076: IFFALSE 5108
// if Side_Positions [ i ] then
5078: LD_EXP 43
5082: PUSH
5083: LD_VAR 0 2
5087: ARRAY
5088: IFFALSE 5106
// to_resp := to_resp ^ i ;
5090: LD_ADDR_EXP 69
5094: PUSH
5095: LD_EXP 69
5099: PUSH
5100: LD_VAR 0 2
5104: ADD
5105: ST_TO_ADDR
5106: GO 5075
5108: POP
5109: POP
// end ;
5110: LD_VAR 0 1
5114: RET
// export chassis , weapons , areas_wheeled , areas_tracked ; function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
5115: LD_INT 0
5117: PPUSH
5118: PPUSH
5119: PPUSH
5120: PPUSH
5121: PPUSH
5122: PPUSH
5123: PPUSH
5124: PPUSH
// areas_wheeled = [ aw1 , aw2 , aw3 , aw4 ] ;
5125: LD_ADDR_EXP 72
5129: PUSH
5130: LD_INT 13
5132: PUSH
5133: LD_INT 15
5135: PUSH
5136: LD_INT 17
5138: PUSH
5139: LD_INT 19
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: ST_TO_ADDR
// areas_tracked = [ at1 , at2 , at3 , at4 ] ;
5148: LD_ADDR_EXP 73
5152: PUSH
5153: LD_INT 12
5155: PUSH
5156: LD_INT 14
5158: PUSH
5159: LD_INT 16
5161: PUSH
5162: LD_INT 18
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: ST_TO_ADDR
// best = 0 ;
5171: LD_ADDR_VAR 0 2
5175: PUSH
5176: LD_INT 0
5178: ST_TO_ADDR
// for n = 1 to 200 do
5179: LD_ADDR_VAR 0 8
5183: PUSH
5184: DOUBLE
5185: LD_INT 1
5187: DEC
5188: ST_TO_ADDR
5189: LD_INT 200
5191: PUSH
5192: FOR_TO
5193: IFFALSE 5489
// begin c = [ ] ;
5195: LD_ADDR_VAR 0 3
5199: PUSH
5200: EMPTY
5201: ST_TO_ADDR
// for i = 1 to side_count do
5202: LD_ADDR_VAR 0 6
5206: PUSH
5207: DOUBLE
5208: LD_INT 1
5210: DEC
5211: ST_TO_ADDR
5212: LD_EXP 37
5216: PUSH
5217: FOR_TO
5218: IFFALSE 5247
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
5220: LD_ADDR_VAR 0 3
5224: PUSH
5225: LD_VAR 0 3
5229: PUSH
5230: LD_INT 21
5232: PPUSH
5233: LD_INT 0
5235: PPUSH
5236: CALL_OW 16
5240: PUSH
5241: EMPTY
5242: LIST
5243: ADD
5244: ST_TO_ADDR
5245: GO 5217
5247: POP
5248: POP
// minv = 10000 ;
5249: LD_ADDR_VAR 0 5
5253: PUSH
5254: LD_INT 10000
5256: ST_TO_ADDR
// for i = 1 to side_count do
5257: LD_ADDR_VAR 0 6
5261: PUSH
5262: DOUBLE
5263: LD_INT 1
5265: DEC
5266: ST_TO_ADDR
5267: LD_EXP 37
5271: PUSH
5272: FOR_TO
5273: IFFALSE 5453
// for j = 1 to side_count do
5275: LD_ADDR_VAR 0 7
5279: PUSH
5280: DOUBLE
5281: LD_INT 1
5283: DEC
5284: ST_TO_ADDR
5285: LD_EXP 37
5289: PUSH
5290: FOR_TO
5291: IFFALSE 5449
// if i <> j then
5293: LD_VAR 0 6
5297: PUSH
5298: LD_VAR 0 7
5302: NONEQUAL
5303: IFFALSE 5447
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
5305: LD_VAR 0 3
5309: PUSH
5310: LD_VAR 0 6
5314: ARRAY
5315: PUSH
5316: LD_INT 1
5318: ARRAY
5319: PPUSH
5320: LD_VAR 0 3
5324: PUSH
5325: LD_VAR 0 6
5329: ARRAY
5330: PUSH
5331: LD_INT 2
5333: ARRAY
5334: PPUSH
5335: LD_VAR 0 3
5339: PUSH
5340: LD_VAR 0 7
5344: ARRAY
5345: PUSH
5346: LD_INT 1
5348: ARRAY
5349: PPUSH
5350: LD_VAR 0 3
5354: PUSH
5355: LD_VAR 0 7
5359: ARRAY
5360: PUSH
5361: LD_INT 2
5363: ARRAY
5364: PPUSH
5365: CALL_OW 298
5369: PUSH
5370: LD_VAR 0 5
5374: LESS
5375: IFFALSE 5447
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
5377: LD_ADDR_VAR 0 5
5381: PUSH
5382: LD_VAR 0 3
5386: PUSH
5387: LD_VAR 0 6
5391: ARRAY
5392: PUSH
5393: LD_INT 1
5395: ARRAY
5396: PPUSH
5397: LD_VAR 0 3
5401: PUSH
5402: LD_VAR 0 6
5406: ARRAY
5407: PUSH
5408: LD_INT 2
5410: ARRAY
5411: PPUSH
5412: LD_VAR 0 3
5416: PUSH
5417: LD_VAR 0 7
5421: ARRAY
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: LD_VAR 0 3
5431: PUSH
5432: LD_VAR 0 7
5436: ARRAY
5437: PUSH
5438: LD_INT 2
5440: ARRAY
5441: PPUSH
5442: CALL_OW 298
5446: ST_TO_ADDR
// end ;
5447: GO 5290
5449: POP
5450: POP
5451: GO 5272
5453: POP
5454: POP
// if minv > best then
5455: LD_VAR 0 5
5459: PUSH
5460: LD_VAR 0 2
5464: GREATER
5465: IFFALSE 5487
// begin best := minv ;
5467: LD_ADDR_VAR 0 2
5471: PUSH
5472: LD_VAR 0 5
5476: ST_TO_ADDR
// bestc := c ;
5477: LD_ADDR_VAR 0 4
5481: PUSH
5482: LD_VAR 0 3
5486: ST_TO_ADDR
// end ; end ;
5487: GO 5192
5489: POP
5490: POP
// coordinates := [ ] ;
5491: LD_ADDR_EXP 34
5495: PUSH
5496: EMPTY
5497: ST_TO_ADDR
// for i = 1 to 8 do
5498: LD_ADDR_VAR 0 6
5502: PUSH
5503: DOUBLE
5504: LD_INT 1
5506: DEC
5507: ST_TO_ADDR
5508: LD_INT 8
5510: PUSH
5511: FOR_TO
5512: IFFALSE 5599
// if side_positions [ i ] = 0 then
5514: LD_EXP 43
5518: PUSH
5519: LD_VAR 0 6
5523: ARRAY
5524: PUSH
5525: LD_INT 0
5527: EQUAL
5528: IFFALSE 5556
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
5530: LD_ADDR_EXP 34
5534: PUSH
5535: LD_EXP 34
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: LD_INT 0
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: EMPTY
5551: LIST
5552: ADD
5553: ST_TO_ADDR
5554: GO 5597
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
5556: LD_ADDR_EXP 34
5560: PUSH
5561: LD_EXP 34
5565: PUSH
5566: LD_VAR 0 4
5570: PUSH
5571: LD_INT 1
5573: ARRAY
5574: PUSH
5575: EMPTY
5576: LIST
5577: ADD
5578: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
5579: LD_ADDR_VAR 0 4
5583: PUSH
5584: LD_VAR 0 4
5588: PPUSH
5589: LD_INT 1
5591: PPUSH
5592: CALL_OW 3
5596: ST_TO_ADDR
// end ;
5597: GO 5511
5599: POP
5600: POP
// end ;
5601: LD_VAR 0 1
5605: RET
// function prepare_constants ; begin
5606: LD_INT 0
5608: PPUSH
// chassis = [ [ [ [ us_light_wheeled ] , [ ] ] , [ [ us_medium_wheeled ] , [ us_medium_tracked ] ] , [ [ ] , [ us_heavy_tracked , us_morphling ] ] ] , [ [ [ ar_light_trike , ar_hovercraft ] , [ ] ] , [ [ ar_medium_trike ] , [ ar_half_tracked ] ] , [ [ ] , [ ] ] ] , [ [ [ ] , [ ] ] , [ [ ru_medium_wheeled ] , [ ru_medium_tracked ] ] , [ [ ru_heavy_wheeled ] , [ ru_heavy_tracked ] ] ] ] ;
5609: LD_ADDR_EXP 70
5613: PUSH
5614: LD_INT 1
5616: PUSH
5617: EMPTY
5618: LIST
5619: PUSH
5620: EMPTY
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 2
5628: PUSH
5629: EMPTY
5630: LIST
5631: PUSH
5632: LD_INT 3
5634: PUSH
5635: EMPTY
5636: LIST
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PUSH
5642: EMPTY
5643: PUSH
5644: LD_INT 4
5646: PUSH
5647: LD_INT 5
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: LIST
5662: PUSH
5663: LD_INT 12
5665: PUSH
5666: LD_INT 11
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: PUSH
5673: EMPTY
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: PUSH
5679: LD_INT 13
5681: PUSH
5682: EMPTY
5683: LIST
5684: PUSH
5685: LD_INT 14
5687: PUSH
5688: EMPTY
5689: LIST
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: PUSH
5695: EMPTY
5696: PUSH
5697: EMPTY
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: LIST
5707: PUSH
5708: EMPTY
5709: PUSH
5710: EMPTY
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: PUSH
5716: LD_INT 21
5718: PUSH
5719: EMPTY
5720: LIST
5721: PUSH
5722: LD_INT 22
5724: PUSH
5725: EMPTY
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 23
5734: PUSH
5735: EMPTY
5736: LIST
5737: PUSH
5738: LD_INT 24
5740: PUSH
5741: EMPTY
5742: LIST
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: PUSH
5753: EMPTY
5754: LIST
5755: LIST
5756: LIST
5757: ST_TO_ADDR
// weapons = [ [ [ us_machine_gun , 1 , 100 ] , [ us_light_gun , 1 , 100 ] , [ us_radar , 1 , 100 ] , [ us_gatling_gun , 2 , 100 ] , [ us_double_gun , 2 , 100 ] , [ us_rocket_launcher , 2 , 100 ] , [ us_laser , 2 , 100 ] , [ us_heavy_gun , 3 , 100 ] , [ us_bulldozer , 3 , 100 ] , [ us_double_laser , 3 , 100 ] ] , [ [ ar_multimissile_ballista , 1 , 100 ] , [ ar_double_machine_gun , 1 , 100 ] , [ ar_light_gun , 1 , 100 ] , [ ar_radar , 1 , 100 ] , [ ar_gatling_gun , 2 , 100 ] , [ ar_gun , 2 , 100 ] , [ ar_rocket_launcher , 2 , 100 ] , [ ar_selfpropelled_bomb , 2 , 100 ] , [ ar_flame_thrower , 2 , 100 ] ] , [ [ ru_heavy_machine_gun , 2 , 100 ] , [ ru_gatling_gun , 2 , 100 ] , [ ru_gun , 2 , 100 ] , [ ru_rocket_launcher , 2 , 100 ] , [ ru_heavy_gun , 3 , 100 ] , [ ru_rocket , 3 , 100 ] , [ ru_bulldozer , 3 , 100 ] ] ] ;
5758: LD_ADDR_EXP 71
5762: PUSH
5763: LD_INT 2
5765: PUSH
5766: LD_INT 1
5768: PUSH
5769: LD_INT 100
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: LIST
5776: PUSH
5777: LD_INT 3
5779: PUSH
5780: LD_INT 1
5782: PUSH
5783: LD_INT 100
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 11
5793: PUSH
5794: LD_INT 1
5796: PUSH
5797: LD_INT 100
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: PUSH
5805: LD_INT 4
5807: PUSH
5808: LD_INT 2
5810: PUSH
5811: LD_INT 100
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: PUSH
5819: LD_INT 5
5821: PUSH
5822: LD_INT 2
5824: PUSH
5825: LD_INT 100
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 7
5835: PUSH
5836: LD_INT 2
5838: PUSH
5839: LD_INT 100
5841: PUSH
5842: EMPTY
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: LD_INT 9
5849: PUSH
5850: LD_INT 2
5852: PUSH
5853: LD_INT 100
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: LIST
5860: PUSH
5861: LD_INT 6
5863: PUSH
5864: LD_INT 3
5866: PUSH
5867: LD_INT 100
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: LIST
5874: PUSH
5875: LD_INT 14
5877: PUSH
5878: LD_INT 3
5880: PUSH
5881: LD_INT 100
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: PUSH
5889: LD_INT 10
5891: PUSH
5892: LD_INT 3
5894: PUSH
5895: LD_INT 100
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: LIST
5914: PUSH
5915: LD_INT 22
5917: PUSH
5918: LD_INT 1
5920: PUSH
5921: LD_INT 100
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: LIST
5928: PUSH
5929: LD_INT 24
5931: PUSH
5932: LD_INT 1
5934: PUSH
5935: LD_INT 100
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 23
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 100
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: LIST
5956: PUSH
5957: LD_INT 30
5959: PUSH
5960: LD_INT 1
5962: PUSH
5963: LD_INT 100
5965: PUSH
5966: EMPTY
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 25
5973: PUSH
5974: LD_INT 2
5976: PUSH
5977: LD_INT 100
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 27
5987: PUSH
5988: LD_INT 2
5990: PUSH
5991: LD_INT 100
5993: PUSH
5994: EMPTY
5995: LIST
5996: LIST
5997: LIST
5998: PUSH
5999: LD_INT 28
6001: PUSH
6002: LD_INT 2
6004: PUSH
6005: LD_INT 100
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: LD_INT 29
6015: PUSH
6016: LD_INT 2
6018: PUSH
6019: LD_INT 100
6021: PUSH
6022: EMPTY
6023: LIST
6024: LIST
6025: LIST
6026: PUSH
6027: LD_INT 26
6029: PUSH
6030: LD_INT 2
6032: PUSH
6033: LD_INT 100
6035: PUSH
6036: EMPTY
6037: LIST
6038: LIST
6039: LIST
6040: PUSH
6041: EMPTY
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: LIST
6048: LIST
6049: LIST
6050: LIST
6051: PUSH
6052: LD_INT 42
6054: PUSH
6055: LD_INT 2
6057: PUSH
6058: LD_INT 100
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 43
6068: PUSH
6069: LD_INT 2
6071: PUSH
6072: LD_INT 100
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: LIST
6079: PUSH
6080: LD_INT 44
6082: PUSH
6083: LD_INT 2
6085: PUSH
6086: LD_INT 100
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: LIST
6093: PUSH
6094: LD_INT 45
6096: PUSH
6097: LD_INT 2
6099: PUSH
6100: LD_INT 100
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: LIST
6107: PUSH
6108: LD_INT 46
6110: PUSH
6111: LD_INT 3
6113: PUSH
6114: LD_INT 100
6116: PUSH
6117: EMPTY
6118: LIST
6119: LIST
6120: LIST
6121: PUSH
6122: LD_INT 47
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: LD_INT 100
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: LIST
6135: PUSH
6136: LD_INT 53
6138: PUSH
6139: LD_INT 3
6141: PUSH
6142: LD_INT 100
6144: PUSH
6145: EMPTY
6146: LIST
6147: LIST
6148: LIST
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: LIST
6156: LIST
6157: LIST
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: LIST
6163: ST_TO_ADDR
// end ;
6164: LD_VAR 0 1
6168: RET
// var is_tracked ; function random_vehicle ( sibrockprob ) ; var nat , wpset , suma , tmp , i , weap , wwght , wght , chs , trck ; begin
6169: LD_INT 0
6171: PPUSH
6172: PPUSH
6173: PPUSH
6174: PPUSH
6175: PPUSH
6176: PPUSH
6177: PPUSH
6178: PPUSH
6179: PPUSH
6180: PPUSH
6181: PPUSH
// nat := vehnats [ rand ( 1 , vehnats ) ] ;
6182: LD_ADDR_VAR 0 3
6186: PUSH
6187: LD_EXP 67
6191: PUSH
6192: LD_INT 1
6194: PPUSH
6195: LD_EXP 67
6199: PPUSH
6200: CALL_OW 12
6204: ARRAY
6205: ST_TO_ADDR
// if ( nat in [ nation_russian , nation_american ] ) and ( Rand ( 1 , 1000 ) <= sibrockprob ) then
6206: LD_VAR 0 3
6210: PUSH
6211: LD_INT 3
6213: PUSH
6214: LD_INT 1
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: IN
6221: PUSH
6222: LD_INT 1
6224: PPUSH
6225: LD_INT 1000
6227: PPUSH
6228: CALL_OW 12
6232: PUSH
6233: LD_VAR 0 1
6237: LESSEQUAL
6238: AND
6239: IFFALSE 6295
// begin wght := 3 ;
6241: LD_ADDR_VAR 0 10
6245: PUSH
6246: LD_INT 3
6248: ST_TO_ADDR
// case nat of nation_russian :
6249: LD_VAR 0 3
6253: PUSH
6254: LD_INT 3
6256: DOUBLE
6257: EQUAL
6258: IFTRUE 6262
6260: GO 6273
6262: POP
// weap := ru_siberium_rocket ; nation_american :
6263: LD_ADDR_VAR 0 8
6267: PUSH
6268: LD_INT 48
6270: ST_TO_ADDR
6271: GO 6293
6273: LD_INT 1
6275: DOUBLE
6276: EQUAL
6277: IFTRUE 6281
6279: GO 6292
6281: POP
// weap := us_siberium_rocket ; end ;
6282: LD_ADDR_VAR 0 8
6286: PUSH
6287: LD_INT 8
6289: ST_TO_ADDR
6290: GO 6293
6292: POP
// end else
6293: GO 6497
// begin wpset := weapons [ nat ] ;
6295: LD_ADDR_VAR 0 4
6299: PUSH
6300: LD_EXP 71
6304: PUSH
6305: LD_VAR 0 3
6309: ARRAY
6310: ST_TO_ADDR
// suma := 0 ;
6311: LD_ADDR_VAR 0 5
6315: PUSH
6316: LD_INT 0
6318: ST_TO_ADDR
// for i := 1 to wpset do
6319: LD_ADDR_VAR 0 7
6323: PUSH
6324: DOUBLE
6325: LD_INT 1
6327: DEC
6328: ST_TO_ADDR
6329: LD_VAR 0 4
6333: PUSH
6334: FOR_TO
6335: IFFALSE 6365
// suma := suma + wpset [ i ] [ 3 ] ;
6337: LD_ADDR_VAR 0 5
6341: PUSH
6342: LD_VAR 0 5
6346: PUSH
6347: LD_VAR 0 4
6351: PUSH
6352: LD_VAR 0 7
6356: ARRAY
6357: PUSH
6358: LD_INT 3
6360: ARRAY
6361: PLUS
6362: ST_TO_ADDR
6363: GO 6334
6365: POP
6366: POP
// tmp := rand ( 1 , suma ) ;
6367: LD_ADDR_VAR 0 6
6371: PUSH
6372: LD_INT 1
6374: PPUSH
6375: LD_VAR 0 5
6379: PPUSH
6380: CALL_OW 12
6384: ST_TO_ADDR
// i := 1 ;
6385: LD_ADDR_VAR 0 7
6389: PUSH
6390: LD_INT 1
6392: ST_TO_ADDR
// while wpset [ i ] [ 3 ] < tmp do
6393: LD_VAR 0 4
6397: PUSH
6398: LD_VAR 0 7
6402: ARRAY
6403: PUSH
6404: LD_INT 3
6406: ARRAY
6407: PUSH
6408: LD_VAR 0 6
6412: LESS
6413: IFFALSE 6457
// begin tmp := tmp - wpset [ i ] [ 3 ] ;
6415: LD_ADDR_VAR 0 6
6419: PUSH
6420: LD_VAR 0 6
6424: PUSH
6425: LD_VAR 0 4
6429: PUSH
6430: LD_VAR 0 7
6434: ARRAY
6435: PUSH
6436: LD_INT 3
6438: ARRAY
6439: MINUS
6440: ST_TO_ADDR
// i := i + 1 ;
6441: LD_ADDR_VAR 0 7
6445: PUSH
6446: LD_VAR 0 7
6450: PUSH
6451: LD_INT 1
6453: PLUS
6454: ST_TO_ADDR
// end ;
6455: GO 6393
// weap := wpset [ i ] [ 1 ] ;
6457: LD_ADDR_VAR 0 8
6461: PUSH
6462: LD_VAR 0 4
6466: PUSH
6467: LD_VAR 0 7
6471: ARRAY
6472: PUSH
6473: LD_INT 1
6475: ARRAY
6476: ST_TO_ADDR
// wwght := wpset [ i ] [ 2 ] ;
6477: LD_ADDR_VAR 0 9
6481: PUSH
6482: LD_VAR 0 4
6486: PUSH
6487: LD_VAR 0 7
6491: ARRAY
6492: PUSH
6493: LD_INT 2
6495: ARRAY
6496: ST_TO_ADDR
// end ; repeat trck := Rand ( 1 , 2 ) ;
6497: LD_ADDR_VAR 0 12
6501: PUSH
6502: LD_INT 1
6504: PPUSH
6505: LD_INT 2
6507: PPUSH
6508: CALL_OW 12
6512: ST_TO_ADDR
// case wwght of 3 :
6513: LD_VAR 0 9
6517: PUSH
6518: LD_INT 3
6520: DOUBLE
6521: EQUAL
6522: IFTRUE 6526
6524: GO 6537
6526: POP
// wght := 3 ; 2 :
6527: LD_ADDR_VAR 0 10
6531: PUSH
6532: LD_INT 3
6534: ST_TO_ADDR
6535: GO 6654
6537: LD_INT 2
6539: DOUBLE
6540: EQUAL
6541: IFTRUE 6545
6543: GO 6582
6545: POP
// if Rand ( 1 , 100 ) <= 80 then
6546: LD_INT 1
6548: PPUSH
6549: LD_INT 100
6551: PPUSH
6552: CALL_OW 12
6556: PUSH
6557: LD_INT 80
6559: LESSEQUAL
6560: IFFALSE 6572
// wght := 2 else
6562: LD_ADDR_VAR 0 10
6566: PUSH
6567: LD_INT 2
6569: ST_TO_ADDR
6570: GO 6580
// wght := 3 ; 1 :
6572: LD_ADDR_VAR 0 10
6576: PUSH
6577: LD_INT 3
6579: ST_TO_ADDR
6580: GO 6654
6582: LD_INT 1
6584: DOUBLE
6585: EQUAL
6586: IFTRUE 6590
6588: GO 6653
6590: POP
// if Rand ( 1 , 100 ) <= 80 then
6591: LD_INT 1
6593: PPUSH
6594: LD_INT 100
6596: PPUSH
6597: CALL_OW 12
6601: PUSH
6602: LD_INT 80
6604: LESSEQUAL
6605: IFFALSE 6617
// wght := 1 else
6607: LD_ADDR_VAR 0 10
6611: PUSH
6612: LD_INT 1
6614: ST_TO_ADDR
6615: GO 6651
// if Rand ( 1 , 100 ) <= 80 then
6617: LD_INT 1
6619: PPUSH
6620: LD_INT 100
6622: PPUSH
6623: CALL_OW 12
6627: PUSH
6628: LD_INT 80
6630: LESSEQUAL
6631: IFFALSE 6643
// wght := 2 else
6633: LD_ADDR_VAR 0 10
6637: PUSH
6638: LD_INT 2
6640: ST_TO_ADDR
6641: GO 6651
// wght := 3 ; end ;
6643: LD_ADDR_VAR 0 10
6647: PUSH
6648: LD_INT 3
6650: ST_TO_ADDR
6651: GO 6654
6653: POP
// if chassis [ nat ] [ wght ] [ trck ] then
6654: LD_EXP 70
6658: PUSH
6659: LD_VAR 0 3
6663: ARRAY
6664: PUSH
6665: LD_VAR 0 10
6669: ARRAY
6670: PUSH
6671: LD_VAR 0 12
6675: ARRAY
6676: IFFALSE 6740
// chs := chassis [ nat ] [ wght ] [ trck ] [ Rand ( 1 , chassis [ nat ] [ wght ] [ trck ] ) ] else
6678: LD_ADDR_VAR 0 11
6682: PUSH
6683: LD_EXP 70
6687: PUSH
6688: LD_VAR 0 3
6692: ARRAY
6693: PUSH
6694: LD_VAR 0 10
6698: ARRAY
6699: PUSH
6700: LD_VAR 0 12
6704: ARRAY
6705: PUSH
6706: LD_INT 1
6708: PPUSH
6709: LD_EXP 70
6713: PUSH
6714: LD_VAR 0 3
6718: ARRAY
6719: PUSH
6720: LD_VAR 0 10
6724: ARRAY
6725: PUSH
6726: LD_VAR 0 12
6730: ARRAY
6731: PPUSH
6732: CALL_OW 12
6736: ARRAY
6737: ST_TO_ADDR
6738: GO 6748
// chs := 0 ;
6740: LD_ADDR_VAR 0 11
6744: PUSH
6745: LD_INT 0
6747: ST_TO_ADDR
// until chs ;
6748: LD_VAR 0 11
6752: IFFALSE 6497
// uc_side := 0 ;
6754: LD_ADDR_OWVAR 20
6758: PUSH
6759: LD_INT 0
6761: ST_TO_ADDR
// uc_nation := nat ;
6762: LD_ADDR_OWVAR 21
6766: PUSH
6767: LD_VAR 0 3
6771: ST_TO_ADDR
// uc_direction := rand ( 0 , 5 ) ;
6772: LD_ADDR_OWVAR 24
6776: PUSH
6777: LD_INT 0
6779: PPUSH
6780: LD_INT 5
6782: PPUSH
6783: CALL_OW 12
6787: ST_TO_ADDR
// vc_chassis := chs ;
6788: LD_ADDR_OWVAR 37
6792: PUSH
6793: LD_VAR 0 11
6797: ST_TO_ADDR
// vc_weapon := weap ;
6798: LD_ADDR_OWVAR 40
6802: PUSH
6803: LD_VAR 0 8
6807: ST_TO_ADDR
// vc_control := control_manual ;
6808: LD_ADDR_OWVAR 38
6812: PUSH
6813: LD_INT 1
6815: ST_TO_ADDR
// case wght of 1 :
6816: LD_VAR 0 10
6820: PUSH
6821: LD_INT 1
6823: DOUBLE
6824: EQUAL
6825: IFTRUE 6829
6827: GO 6840
6829: POP
// vc_engine := engine_solar ; 2 , 3 :
6830: LD_ADDR_OWVAR 39
6834: PUSH
6835: LD_INT 2
6837: ST_TO_ADDR
6838: GO 6866
6840: LD_INT 2
6842: DOUBLE
6843: EQUAL
6844: IFTRUE 6854
6846: LD_INT 3
6848: DOUBLE
6849: EQUAL
6850: IFTRUE 6854
6852: GO 6865
6854: POP
// vc_engine := engine_siberite ; end ;
6855: LD_ADDR_OWVAR 39
6859: PUSH
6860: LD_INT 3
6862: ST_TO_ADDR
6863: GO 6866
6865: POP
// is_tracked := trck = 2 ;
6866: LD_ADDR_LOC 1
6870: PUSH
6871: LD_VAR 0 12
6875: PUSH
6876: LD_INT 2
6878: EQUAL
6879: ST_TO_ADDR
// end ;
6880: LD_VAR 0 2
6884: RET
// export function vehicles_create_vehicle ( atstart ) ; var v , ar ; begin
6885: LD_INT 0
6887: PPUSH
6888: PPUSH
6889: PPUSH
// if atstart then
6890: LD_VAR 0 1
6894: IFFALSE 6905
// random_vehicle ( 0 ) else
6896: LD_INT 0
6898: PPUSH
6899: CALL 6169 0 1
6903: GO 6914
// random_vehicle ( sibrock ) ;
6905: LD_EXP 68
6909: PPUSH
6910: CALL 6169 0 1
// v := CreateVehicle ;
6914: LD_ADDR_VAR 0 3
6918: PUSH
6919: CALL_OW 45
6923: ST_TO_ADDR
// if is_tracked then
6924: LD_LOC 1
6928: IFFALSE 6956
// ar := areas_tracked [ Rand ( 1 , areas_tracked ) ] else
6930: LD_ADDR_VAR 0 4
6934: PUSH
6935: LD_EXP 73
6939: PUSH
6940: LD_INT 1
6942: PPUSH
6943: LD_EXP 73
6947: PPUSH
6948: CALL_OW 12
6952: ARRAY
6953: ST_TO_ADDR
6954: GO 6980
// ar := areas_wheeled [ Rand ( 1 , areas_wheeled ) ] ;
6956: LD_ADDR_VAR 0 4
6960: PUSH
6961: LD_EXP 72
6965: PUSH
6966: LD_INT 1
6968: PPUSH
6969: LD_EXP 72
6973: PPUSH
6974: CALL_OW 12
6978: ARRAY
6979: ST_TO_ADDR
// PlaceUnitArea ( v , ar , not atstart ) ;
6980: LD_VAR 0 3
6984: PPUSH
6985: LD_VAR 0 4
6989: PPUSH
6990: LD_VAR 0 1
6994: NOT
6995: PPUSH
6996: CALL_OW 49
// end ;
7000: LD_VAR 0 2
7004: RET
// function prepare_vehicles ; var i ; begin
7005: LD_INT 0
7007: PPUSH
7008: PPUSH
// for i := 1 to startveh do
7009: LD_ADDR_VAR 0 2
7013: PUSH
7014: DOUBLE
7015: LD_INT 1
7017: DEC
7018: ST_TO_ADDR
7019: LD_EXP 63
7023: PUSH
7024: FOR_TO
7025: IFFALSE 7036
// begin vehicles_create_vehicle ( true ) ;
7027: LD_INT 1
7029: PPUSH
7030: CALL 6885 0 1
// end ;
7034: GO 7024
7036: POP
7037: POP
// end ;
7038: LD_VAR 0 1
7042: RET
// function set_attitudes ; var i , j ; begin
7043: LD_INT 0
7045: PPUSH
7046: PPUSH
7047: PPUSH
// if not Team_Game then
7048: LD_EXP 47
7052: NOT
7053: IFFALSE 7149
// begin for i = 1 to 8 do
7055: LD_ADDR_VAR 0 2
7059: PUSH
7060: DOUBLE
7061: LD_INT 1
7063: DEC
7064: ST_TO_ADDR
7065: LD_INT 8
7067: PUSH
7068: FOR_TO
7069: IFFALSE 7147
// for j = 1 to 8 do
7071: LD_ADDR_VAR 0 3
7075: PUSH
7076: DOUBLE
7077: LD_INT 1
7079: DEC
7080: ST_TO_ADDR
7081: LD_INT 8
7083: PUSH
7084: FOR_TO
7085: IFFALSE 7143
// if i <> j then
7087: LD_VAR 0 2
7091: PUSH
7092: LD_VAR 0 3
7096: NONEQUAL
7097: IFFALSE 7121
// SetAttitude ( i , j , att_neutral , true ) else
7099: LD_VAR 0 2
7103: PPUSH
7104: LD_VAR 0 3
7108: PPUSH
7109: LD_INT 0
7111: PPUSH
7112: LD_INT 1
7114: PPUSH
7115: CALL_OW 80
7119: GO 7141
// SetAttitude ( i , j , att_friend , true ) end ;
7121: LD_VAR 0 2
7125: PPUSH
7126: LD_VAR 0 3
7130: PPUSH
7131: LD_INT 1
7133: PPUSH
7134: LD_INT 1
7136: PPUSH
7137: CALL_OW 80
7141: GO 7084
7143: POP
7144: POP
7145: GO 7068
7147: POP
7148: POP
// end ;
7149: LD_VAR 0 1
7153: RET
// function prepare_side ( side ) ; var i ; begin
7154: LD_INT 0
7156: PPUSH
7157: PPUSH
// for i := 1 to npeop do
7158: LD_ADDR_VAR 0 3
7162: PUSH
7163: DOUBLE
7164: LD_INT 1
7166: DEC
7167: ST_TO_ADDR
7168: LD_EXP 65
7172: PUSH
7173: FOR_TO
7174: IFFALSE 7283
// begin uc_side := side ;
7176: LD_ADDR_OWVAR 20
7180: PUSH
7181: LD_VAR 0 1
7185: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
7186: LD_ADDR_OWVAR 21
7190: PUSH
7191: LD_EXP 44
7195: PUSH
7196: LD_VAR 0 1
7200: ARRAY
7201: ST_TO_ADDR
// hc_name :=  ;
7202: LD_ADDR_OWVAR 26
7206: PUSH
7207: LD_STRING 
7209: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
7210: LD_INT 0
7212: PPUSH
7213: LD_INT 4
7215: PPUSH
7216: CALL_OW 383
// hc_importance := 0 ;
7220: LD_ADDR_OWVAR 32
7224: PUSH
7225: LD_INT 0
7227: ST_TO_ADDR
// hc_gallery :=  ;
7228: LD_ADDR_OWVAR 33
7232: PUSH
7233: LD_STRING 
7235: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 4 , false ) ;
7236: CALL_OW 44
7240: PPUSH
7241: LD_EXP 34
7245: PUSH
7246: LD_VAR 0 1
7250: ARRAY
7251: PUSH
7252: LD_INT 1
7254: ARRAY
7255: PPUSH
7256: LD_EXP 34
7260: PUSH
7261: LD_VAR 0 1
7265: ARRAY
7266: PUSH
7267: LD_INT 2
7269: ARRAY
7270: PPUSH
7271: LD_INT 4
7273: PPUSH
7274: LD_INT 0
7276: PPUSH
7277: CALL_OW 50
// end ;
7281: GO 7173
7283: POP
7284: POP
// end ;
7285: LD_VAR 0 2
7289: RET
// function prepare_sides ; var i ; begin
7290: LD_INT 0
7292: PPUSH
7293: PPUSH
// for i := 1 to 8 do
7294: LD_ADDR_VAR 0 2
7298: PUSH
7299: DOUBLE
7300: LD_INT 1
7302: DEC
7303: ST_TO_ADDR
7304: LD_INT 8
7306: PUSH
7307: FOR_TO
7308: IFFALSE 7333
// if side_positions [ i ] then
7310: LD_EXP 43
7314: PUSH
7315: LD_VAR 0 2
7319: ARRAY
7320: IFFALSE 7331
// prepare_side ( i ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: CALL 7154 0 1
7331: GO 7307
7333: POP
7334: POP
// end ;
7335: LD_VAR 0 1
7339: RET
// export function starting_vehicles ; begin
7340: LD_INT 0
7342: PPUSH
// mp_with_score := true ;
7343: LD_ADDR_OWVAR 14
7347: PUSH
7348: LD_INT 1
7350: ST_TO_ADDR
// mp_selectmsg := true ;
7351: LD_ADDR_OWVAR 13
7355: PUSH
7356: LD_INT 1
7358: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
7359: CALL 4063 0 0
// prepare_map_coordinates ;
7363: CALL 5115 0 0
// prepare_constants ;
7367: CALL 5606 0 0
// set_attitudes ;
7371: CALL 7043 0 0
// prepare_sides ;
7375: CALL 7290 0 0
// prepare_vehicles ;
7379: CALL 7005 0 0
// SetAreaMapShow ( exitarea , 1 ) ;
7383: LD_INT 20
7385: PPUSH
7386: LD_INT 1
7388: PPUSH
7389: CALL_OW 424
// your_side := Player_Side ;
7393: LD_ADDR_OWVAR 2
7397: PUSH
7398: LD_EXP 39
7402: ST_TO_ADDR
// ResetFog ;
7403: CALL_OW 335
// AnimateTrees ( true ) ;
7407: LD_INT 1
7409: PPUSH
7410: CALL_OW 573
// music_nat := Side_Nations [ your_side ] ;
7414: LD_ADDR_OWVAR 71
7418: PUSH
7419: LD_EXP 44
7423: PUSH
7424: LD_OWVAR 2
7428: ARRAY
7429: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
7430: LD_EXP 34
7434: PUSH
7435: LD_OWVAR 2
7439: ARRAY
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: LD_EXP 34
7449: PUSH
7450: LD_OWVAR 2
7454: ARRAY
7455: PUSH
7456: LD_INT 2
7458: ARRAY
7459: PPUSH
7460: CALL_OW 86
// end ; end_of_file
7464: LD_VAR 0 1
7468: RET
// every 0 0$0.5 + 2 marked 15 do var t , red ;
7469: GO 7471
7471: DISABLE
7472: LD_INT 0
7474: PPUSH
7475: PPUSH
// begin if not prep_time then
7476: LD_EXP 32
7480: NOT
7481: IFFALSE 7485
// exit ;
7483: GO 7607
// if tick >= prep_time then
7485: LD_OWVAR 1
7489: PUSH
7490: LD_EXP 32
7494: GREATEREQUAL
7495: IFFALSE 7510
// begin display_strings = [ ] ;
7497: LD_ADDR_OWVAR 47
7501: PUSH
7502: EMPTY
7503: ST_TO_ADDR
// sheherezade_start_the_fight ;
7504: CALL 3720 0 0
// end else
7508: GO 7607
// begin t = prep_time - tick ;
7510: LD_ADDR_VAR 0 1
7514: PUSH
7515: LD_EXP 32
7519: PUSH
7520: LD_OWVAR 1
7524: MINUS
7525: ST_TO_ADDR
// if t <= 0 0$5.5 then
7526: LD_VAR 0 1
7530: PUSH
7531: LD_INT 192
7533: LESSEQUAL
7534: IFFALSE 7556
// red := t mod 0 0$1 < 0 0$0.5 else
7536: LD_ADDR_VAR 0 2
7540: PUSH
7541: LD_VAR 0 1
7545: PUSH
7546: LD_INT 35
7548: MOD
7549: PUSH
7550: LD_INT 18
7552: LESS
7553: ST_TO_ADDR
7554: GO 7564
// red := false ;
7556: LD_ADDR_VAR 0 2
7560: PUSH
7561: LD_INT 0
7563: ST_TO_ADDR
// if red then
7564: LD_VAR 0 2
7568: IFFALSE 7589
// display_strings = [ #Sheherezade-Time2 , t ] else
7570: LD_ADDR_OWVAR 47
7574: PUSH
7575: LD_STRING #Sheherezade-Time2
7577: PUSH
7578: LD_VAR 0 1
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: ST_TO_ADDR
7587: GO 7606
// display_strings = [ #Sheherezade-Time1 , t ] ;
7589: LD_ADDR_OWVAR 47
7593: PUSH
7594: LD_STRING #Sheherezade-Time1
7596: PUSH
7597: LD_VAR 0 1
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: ST_TO_ADDR
// enable ;
7606: ENABLE
// end ; end ;
7607: PPOPN 2
7609: END
// every 4 marked 15 do
7610: GO 7612
7612: DISABLE
// begin if tick < prep_time then
7613: LD_OWVAR 1
7617: PUSH
7618: LD_EXP 32
7622: LESS
7623: IFFALSE 7638
// begin SetLives ( all_units , 1000 ) ;
7625: LD_OWVAR 3
7629: PPUSH
7630: LD_INT 1000
7632: PPUSH
7633: CALL_OW 234
// enable ;
7637: ENABLE
// end ; end ; end_of_file
7638: END
// on ApemanTamed ( ape , sci ) do begin if gametype = 15 then
7639: LD_EXP 1
7643: PUSH
7644: LD_INT 15
7646: EQUAL
7647: IFFALSE 7671
// begin if not def_apemen_abilities then
7649: LD_EXP 12
7653: NOT
7654: IFFALSE 7659
// disable else
7656: DISABLE
7657: GO 7671
// begin SetClass ( ape , class_apeman_soldier ) ;
7659: LD_VAR 0 1
7663: PPUSH
7664: LD_INT 15
7666: PPUSH
7667: CALL_OW 336
// end ; end ; end ;
7671: PPOPN 2
7673: END
// on UnitGoesToRed ( un ) do var killer , victim , near ;
7674: LD_INT 0
7676: PPUSH
7677: PPUSH
7678: PPUSH
// begin if gametype = 15 then
7679: LD_EXP 1
7683: PUSH
7684: LD_INT 15
7686: EQUAL
7687: IFFALSE 7912
// if un in sheherezades then
7689: LD_VAR 0 1
7693: PUSH
7694: LD_EXP 35
7698: IN
7699: IFFALSE 7912
// begin victim := GetSide ( un ) ;
7701: LD_ADDR_VAR 0 3
7705: PUSH
7706: LD_VAR 0 1
7710: PPUSH
7711: CALL_OW 255
7715: ST_TO_ADDR
// near := NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , victim ] , f_not , [ f_side , 0 ] ] ) , un ) ;
7716: LD_ADDR_VAR 0 4
7720: PUSH
7721: LD_INT 3
7723: PUSH
7724: LD_INT 22
7726: PUSH
7727: LD_VAR 0 3
7731: PUSH
7732: EMPTY
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 3
7738: PUSH
7739: LD_INT 22
7741: PUSH
7742: LD_INT 0
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: PUSH
7749: EMPTY
7750: LIST
7751: LIST
7752: LIST
7753: LIST
7754: PPUSH
7755: CALL_OW 69
7759: PPUSH
7760: LD_VAR 0 1
7764: PPUSH
7765: CALL_OW 74
7769: ST_TO_ADDR
// killer := GetSide ( near ) ;
7770: LD_ADDR_VAR 0 2
7774: PUSH
7775: LD_VAR 0 4
7779: PPUSH
7780: CALL_OW 255
7784: ST_TO_ADDR
// if your_side and ( your_side = victim ) then
7785: LD_OWVAR 2
7789: PUSH
7790: LD_OWVAR 2
7794: PUSH
7795: LD_VAR 0 3
7799: EQUAL
7800: AND
7801: IFFALSE 7830
// begin wait ( 0 0$3 ) ;
7803: LD_INT 105
7805: PPUSH
7806: CALL_OW 67
// if not multiplayer then
7810: LD_OWVAR 4
7814: NOT
7815: IFFALSE 7826
// msg ( You Lost ) else
7817: LD_STRING You Lost
7819: PPUSH
7820: CALL_OW 100
7824: GO 7830
// YouLostInMultiplayer ;
7826: CALL_OW 107
// end ; sheherezades := Replace ( sheherezades , victim , 0 ) ;
7830: LD_ADDR_EXP 35
7834: PUSH
7835: LD_EXP 35
7839: PPUSH
7840: LD_VAR 0 3
7844: PPUSH
7845: LD_INT 0
7847: PPUSH
7848: CALL_OW 1
7852: ST_TO_ADDR
// SetSide ( FilterAllUnits ( [ f_side , victim ] ) , killer ) ;
7853: LD_INT 22
7855: PUSH
7856: LD_VAR 0 3
7860: PUSH
7861: EMPTY
7862: LIST
7863: LIST
7864: PPUSH
7865: CALL_OW 69
7869: PPUSH
7870: LD_VAR 0 2
7874: PPUSH
7875: CALL_OW 235
// ComStop ( FilterAllUnits ( [ f_side , killer ] ) ) ;
7879: LD_INT 22
7881: PUSH
7882: LD_VAR 0 2
7886: PUSH
7887: EMPTY
7888: LIST
7889: LIST
7890: PPUSH
7891: CALL_OW 69
7895: PPUSH
7896: CALL_OW 141
// SetLives ( un , 0 ) ;
7900: LD_VAR 0 1
7904: PPUSH
7905: LD_INT 0
7907: PPUSH
7908: CALL_OW 234
// end ; end ;
7912: PPOPN 4
7914: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if gametype = 25 then
7915: LD_EXP 1
7919: PUSH
7920: LD_INT 25
7922: EQUAL
7923: IFFALSE 8032
// begin if origside = 0 then
7925: LD_VAR 0 3
7929: PUSH
7930: LD_INT 0
7932: EQUAL
7933: IFFALSE 7985
// begin SetTag ( vehnew , Rand ( vehdur [ 1 ] , vehdur [ 2 ] ) ) ;
7935: LD_VAR 0 1
7939: PPUSH
7940: LD_EXP 64
7944: PUSH
7945: LD_INT 1
7947: ARRAY
7948: PPUSH
7949: LD_EXP 64
7953: PUSH
7954: LD_INT 2
7956: ARRAY
7957: PPUSH
7958: CALL_OW 12
7962: PPUSH
7963: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
7967: LD_ADDR_EXP 90
7971: PUSH
7972: LD_EXP 90
7976: PUSH
7977: LD_VAR 0 1
7981: ADD
7982: ST_TO_ADDR
// end else
7983: GO 8032
// begin SetUnitDisplayNumber ( vehnew , 0 ) ;
7985: LD_VAR 0 1
7989: PPUSH
7990: LD_INT 0
7992: PPUSH
7993: CALL_OW 505
// SetTag ( vehnew , GetTag ( vehold ) ) ;
7997: LD_VAR 0 1
8001: PPUSH
8002: LD_VAR 0 2
8006: PPUSH
8007: CALL_OW 110
8011: PPUSH
8012: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
8016: LD_ADDR_EXP 90
8020: PUSH
8021: LD_EXP 90
8025: PUSH
8026: LD_VAR 0 1
8030: ADD
8031: ST_TO_ADDR
// end ; end end ; end_of_file
8032: PPOPN 4
8034: END
// every 0 0$1 marked 25 do var i , ends , best ;
8035: GO 8037
8037: DISABLE
8038: LD_INT 0
8040: PPUSH
8041: PPUSH
8042: PPUSH
// begin ends := false ;
8043: LD_ADDR_VAR 0 2
8047: PUSH
8048: LD_INT 0
8050: ST_TO_ADDR
// best := 0 ;
8051: LD_ADDR_VAR 0 3
8055: PUSH
8056: LD_INT 0
8058: ST_TO_ADDR
// for i := 1 to 8 do
8059: LD_ADDR_VAR 0 1
8063: PUSH
8064: DOUBLE
8065: LD_INT 1
8067: DEC
8068: ST_TO_ADDR
8069: LD_INT 8
8071: PUSH
8072: FOR_TO
8073: IFFALSE 8109
// if GetMultiScore ( i ) > best then
8075: LD_VAR 0 1
8079: PPUSH
8080: CALL_OW 507
8084: PUSH
8085: LD_VAR 0 3
8089: GREATER
8090: IFFALSE 8107
// best := GetMultiScore ( i ) ;
8092: LD_ADDR_VAR 0 3
8096: PUSH
8097: LD_VAR 0 1
8101: PPUSH
8102: CALL_OW 507
8106: ST_TO_ADDR
8107: GO 8072
8109: POP
8110: POP
// if point_limit then
8111: LD_EXP 57
8115: IFFALSE 8137
// if best > point_limit then
8117: LD_VAR 0 3
8121: PUSH
8122: LD_EXP 57
8126: GREATER
8127: IFFALSE 8137
// ends := true ;
8129: LD_ADDR_VAR 0 2
8133: PUSH
8134: LD_INT 1
8136: ST_TO_ADDR
// if game_time then
8137: LD_EXP 56
8141: IFFALSE 8163
// if game_time <= tick then
8143: LD_EXP 56
8147: PUSH
8148: LD_OWVAR 1
8152: LESSEQUAL
8153: IFFALSE 8163
// ends := true ;
8155: LD_ADDR_VAR 0 2
8159: PUSH
8160: LD_INT 1
8162: ST_TO_ADDR
// if ends then
8163: LD_VAR 0 2
8167: IFFALSE 8212
// begin if GetMultiScore ( your_side ) = best then
8169: LD_OWVAR 2
8173: PPUSH
8174: CALL_OW 507
8178: PUSH
8179: LD_VAR 0 3
8183: EQUAL
8184: IFFALSE 8199
// begin wait ( 0 0$1 ) ;
8186: LD_INT 35
8188: PPUSH
8189: CALL_OW 67
// YouWinInMultiplayer ;
8193: CALL_OW 106
// end else
8197: GO 8210
// begin wait ( 0 0$1 ) ;
8199: LD_INT 35
8201: PPUSH
8202: CALL_OW 67
// YouLostInMultiplayer ;
8206: CALL_OW 107
// end ; end else
8210: GO 8213
// enable ;
8212: ENABLE
// end ;
8213: PPOPN 3
8215: END
// every 0 0$3 marked 15 do var win , i ;
8216: GO 8218
8218: DISABLE
8219: LD_INT 0
8221: PPUSH
8222: PPUSH
// begin win := true ;
8223: LD_ADDR_VAR 0 1
8227: PUSH
8228: LD_INT 1
8230: ST_TO_ADDR
// for i = 1 to Side_Positions do
8231: LD_ADDR_VAR 0 2
8235: PUSH
8236: DOUBLE
8237: LD_INT 1
8239: DEC
8240: ST_TO_ADDR
8241: LD_EXP 43
8245: PUSH
8246: FOR_TO
8247: IFFALSE 8311
// if Side_Positions [ i ] and ( i <> your_side ) and MultiplayerSideAlive ( i ) then
8249: LD_EXP 43
8253: PUSH
8254: LD_VAR 0 2
8258: ARRAY
8259: PUSH
8260: LD_VAR 0 2
8264: PUSH
8265: LD_OWVAR 2
8269: NONEQUAL
8270: AND
8271: PUSH
8272: LD_VAR 0 2
8276: PPUSH
8277: CALL_OW 108
8281: AND
8282: IFFALSE 8309
// if not AlliedSides ( i , your_side ) then
8284: LD_VAR 0 2
8288: PPUSH
8289: LD_OWVAR 2
8293: PPUSH
8294: CALL 8336 0 2
8298: NOT
8299: IFFALSE 8309
// win := false ;
8301: LD_ADDR_VAR 0 1
8305: PUSH
8306: LD_INT 0
8308: ST_TO_ADDR
8309: GO 8246
8311: POP
8312: POP
// if win then
8313: LD_VAR 0 1
8317: IFFALSE 8332
// begin wait ( 0 0$3 ) ;
8319: LD_INT 105
8321: PPUSH
8322: CALL_OW 67
// YouWinInMultiplayer ;
8326: CALL_OW 106
// exit ;
8330: GO 8333
// end ; enable ;
8332: ENABLE
// end ;
8333: PPOPN 2
8335: END
// function AlliedSides ( i , j ) ; var vysledek ; begin
8336: LD_INT 0
8338: PPUSH
8339: PPUSH
// vysledek := false ;
8340: LD_ADDR_VAR 0 4
8344: PUSH
8345: LD_INT 0
8347: ST_TO_ADDR
// if ( GetAttitude ( i , j ) = att_friend ) and ( GetAttitude ( j , i ) = att_friend ) and GetAlliedVictory ( i ) and GetAlliedVictory ( j ) then
8348: LD_VAR 0 1
8352: PPUSH
8353: LD_VAR 0 2
8357: PPUSH
8358: CALL_OW 81
8362: PUSH
8363: LD_INT 1
8365: EQUAL
8366: PUSH
8367: LD_VAR 0 2
8371: PPUSH
8372: LD_VAR 0 1
8376: PPUSH
8377: CALL_OW 81
8381: PUSH
8382: LD_INT 1
8384: EQUAL
8385: AND
8386: PUSH
8387: LD_VAR 0 1
8391: PPUSH
8392: CALL_OW 83
8396: AND
8397: PUSH
8398: LD_VAR 0 2
8402: PPUSH
8403: CALL_OW 83
8407: AND
8408: IFFALSE 8418
// vysledek := true ;
8410: LD_ADDR_VAR 0 4
8414: PUSH
8415: LD_INT 1
8417: ST_TO_ADDR
// result := vysledek ;
8418: LD_ADDR_VAR 0 3
8422: PUSH
8423: LD_VAR 0 4
8427: ST_TO_ADDR
// end ; end_of_file
8428: LD_VAR 0 3
8432: RET
// export def_hunters , def_hunt_size , def_hunt_balance , def_hunt_limit , def_doctors ; export one_hunter , hunt_limit , size_of_ape_team , size_of_hunt_team , doctors_in_team , hunter_level , ape_level , ape_stamina , to_be_alone , people , scorestring ; function read_multiplayer_and_game_parameters ; var i , p1 , p2 ; begin
8433: LD_INT 0
8435: PPUSH
8436: PPUSH
8437: PPUSH
8438: PPUSH
// if MultiPlayer then
8439: LD_OWVAR 4
8443: IFFALSE 8507
// begin Player_Side = mp_player_side ;
8445: LD_ADDR_EXP 39
8449: PUSH
8450: LD_OWVAR 7
8454: ST_TO_ADDR
// Player_Team = mp_player_team ;
8455: LD_ADDR_EXP 40
8459: PUSH
8460: LD_OWVAR 8
8464: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
8465: LD_ADDR_EXP 43
8469: PUSH
8470: LD_OWVAR 17
8474: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
8475: LD_ADDR_EXP 41
8479: PUSH
8480: LD_OWVAR 15
8484: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
8485: LD_ADDR_EXP 44
8489: PUSH
8490: LD_OWVAR 16
8494: ST_TO_ADDR
// Teams = mp_teams ;
8495: LD_ADDR_EXP 42
8499: PUSH
8500: LD_OWVAR 12
8504: ST_TO_ADDR
// end else
8505: GO 8651
// begin randomize ;
8507: CALL_OW 10
// Player_Side = 1 ;
8511: LD_ADDR_EXP 39
8515: PUSH
8516: LD_INT 1
8518: ST_TO_ADDR
// Player_Team = 0 ;
8519: LD_ADDR_EXP 40
8523: PUSH
8524: LD_INT 0
8526: ST_TO_ADDR
// Side_Positions = [ 1 , 3 , 6 , 0 , 0 , 0 , 0 , 7 ] ;
8527: LD_ADDR_EXP 43
8531: PUSH
8532: LD_INT 1
8534: PUSH
8535: LD_INT 3
8537: PUSH
8538: LD_INT 6
8540: PUSH
8541: LD_INT 0
8543: PUSH
8544: LD_INT 0
8546: PUSH
8547: LD_INT 0
8549: PUSH
8550: LD_INT 0
8552: PUSH
8553: LD_INT 7
8555: PUSH
8556: EMPTY
8557: LIST
8558: LIST
8559: LIST
8560: LIST
8561: LIST
8562: LIST
8563: LIST
8564: LIST
8565: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
8566: LD_ADDR_EXP 41
8570: PUSH
8571: LD_INT 0
8573: PUSH
8574: LD_INT 0
8576: PUSH
8577: LD_INT 0
8579: PUSH
8580: LD_INT 0
8582: PUSH
8583: LD_INT 0
8585: PUSH
8586: LD_INT 0
8588: PUSH
8589: LD_INT 0
8591: PUSH
8592: LD_INT 0
8594: PUSH
8595: EMPTY
8596: LIST
8597: LIST
8598: LIST
8599: LIST
8600: LIST
8601: LIST
8602: LIST
8603: LIST
8604: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 2 , 2 , 2 , 2 ] ;
8605: LD_ADDR_EXP 44
8609: PUSH
8610: LD_INT 1
8612: PUSH
8613: LD_INT 3
8615: PUSH
8616: LD_INT 1
8618: PUSH
8619: LD_INT 2
8621: PUSH
8622: LD_INT 2
8624: PUSH
8625: LD_INT 2
8627: PUSH
8628: LD_INT 2
8630: PUSH
8631: LD_INT 2
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: LIST
8638: LIST
8639: LIST
8640: LIST
8641: LIST
8642: LIST
8643: ST_TO_ADDR
// Teams = [ ] ;
8644: LD_ADDR_EXP 42
8648: PUSH
8649: EMPTY
8650: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
8651: LD_ADDR_EXP 37
8655: PUSH
8656: LD_EXP 43
8660: PUSH
8661: LD_INT 0
8663: PUSH
8664: EMPTY
8665: LIST
8666: DIFF
8667: PUSH
8668: LD_INT 0
8670: PLUS
8671: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
8672: LD_ADDR_EXP 38
8676: PUSH
8677: LD_EXP 41
8681: PUSH
8682: LD_INT 0
8684: PUSH
8685: EMPTY
8686: LIST
8687: DIFF
8688: PUSH
8689: LD_INT 0
8691: PLUS
8692: ST_TO_ADDR
// if MultiPlayer then
8693: LD_OWVAR 4
8697: IFFALSE 8753
// begin def_hunt_size = GetMultiplayerSetting ( 1 ) ;
8699: LD_ADDR_EXP 75
8703: PUSH
8704: LD_INT 1
8706: PPUSH
8707: CALL_OW 426
8711: ST_TO_ADDR
// def_hunt_balance = GetMultiplayerSetting ( 2 ) ;
8712: LD_ADDR_EXP 76
8716: PUSH
8717: LD_INT 2
8719: PPUSH
8720: CALL_OW 426
8724: ST_TO_ADDR
// def_hunt_limit = GetMultiplayerSetting ( 3 ) ;
8725: LD_ADDR_EXP 77
8729: PUSH
8730: LD_INT 3
8732: PPUSH
8733: CALL_OW 426
8737: ST_TO_ADDR
// def_doctors = GetMultiplayerSetting ( 4 ) ;
8738: LD_ADDR_EXP 78
8742: PUSH
8743: LD_INT 4
8745: PPUSH
8746: CALL_OW 426
8750: ST_TO_ADDR
// end else
8751: GO 8789
// begin randomize ;
8753: CALL_OW 10
// def_hunt_size = 1 ;
8757: LD_ADDR_EXP 75
8761: PUSH
8762: LD_INT 1
8764: ST_TO_ADDR
// def_hunt_balance = 1 ;
8765: LD_ADDR_EXP 76
8769: PUSH
8770: LD_INT 1
8772: ST_TO_ADDR
// def_hunt_limit = 1 ;
8773: LD_ADDR_EXP 77
8777: PUSH
8778: LD_INT 1
8780: ST_TO_ADDR
// def_doctors = 1 ;
8781: LD_ADDR_EXP 78
8785: PUSH
8786: LD_INT 1
8788: ST_TO_ADDR
// end ; one_hunter = gametype = 36 ;
8789: LD_ADDR_EXP 79
8793: PUSH
8794: LD_EXP 1
8798: PUSH
8799: LD_INT 36
8801: EQUAL
8802: ST_TO_ADDR
// if one_hunter then
8803: LD_EXP 79
8807: IFFALSE 9080
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
8809: LD_ADDR_EXP 80
8813: PUSH
8814: LD_INT 4200
8816: PUSH
8817: LD_INT 6300
8819: PUSH
8820: LD_INT 8400
8822: PUSH
8823: LD_INT 10500
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: LIST
8830: LIST
8831: PUSH
8832: LD_EXP 77
8836: PUSH
8837: LD_INT 1
8839: PLUS
8840: ARRAY
8841: ST_TO_ADDR
// p1 = [ 6 , 10 , 12 ] [ def_hunt_size + 1 ] ;
8842: LD_ADDR_VAR 0 3
8846: PUSH
8847: LD_INT 6
8849: PUSH
8850: LD_INT 10
8852: PUSH
8853: LD_INT 12
8855: PUSH
8856: EMPTY
8857: LIST
8858: LIST
8859: LIST
8860: PUSH
8861: LD_EXP 75
8865: PUSH
8866: LD_INT 1
8868: PLUS
8869: ARRAY
8870: ST_TO_ADDR
// p2 = [ 2 , 4 , 6 ] [ def_hunt_size + 1 ] ;
8871: LD_ADDR_VAR 0 4
8875: PUSH
8876: LD_INT 2
8878: PUSH
8879: LD_INT 4
8881: PUSH
8882: LD_INT 6
8884: PUSH
8885: EMPTY
8886: LIST
8887: LIST
8888: LIST
8889: PUSH
8890: LD_EXP 75
8894: PUSH
8895: LD_INT 1
8897: PLUS
8898: ARRAY
8899: ST_TO_ADDR
// size_of_ape_team = p1 div side_count + p2 ;
8900: LD_ADDR_EXP 81
8904: PUSH
8905: LD_VAR 0 3
8909: PUSH
8910: LD_EXP 37
8914: DIV
8915: PUSH
8916: LD_VAR 0 4
8920: PLUS
8921: ST_TO_ADDR
// size_of_hunt_team = size_of_ape_team * ( side_count - 1 ) ;
8922: LD_ADDR_EXP 82
8926: PUSH
8927: LD_EXP 81
8931: PUSH
8932: LD_EXP 37
8936: PUSH
8937: LD_INT 1
8939: MINUS
8940: MUL
8941: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
8942: LD_ADDR_EXP 83
8946: PUSH
8947: LD_INT 0
8949: PUSH
8950: LD_EXP 82
8954: PUSH
8955: LD_INT 5
8957: PLUS
8958: PUSH
8959: LD_INT 6
8961: DIV
8962: PUSH
8963: LD_EXP 82
8967: PUSH
8968: LD_INT 3
8970: PLUS
8971: PUSH
8972: LD_INT 4
8974: DIV
8975: PUSH
8976: EMPTY
8977: LIST
8978: LIST
8979: LIST
8980: PUSH
8981: LD_EXP 78
8985: PUSH
8986: LD_INT 1
8988: PLUS
8989: ARRAY
8990: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
8991: LD_ADDR_EXP 84
8995: PUSH
8996: LD_INT 5
8998: PUSH
8999: LD_INT 3
9001: PUSH
9002: LD_INT 1
9004: PUSH
9005: EMPTY
9006: LIST
9007: LIST
9008: LIST
9009: PUSH
9010: LD_EXP 76
9014: PUSH
9015: LD_INT 1
9017: PLUS
9018: ARRAY
9019: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9020: LD_ADDR_EXP 85
9024: PUSH
9025: LD_INT 1
9027: PUSH
9028: LD_INT 2
9030: PUSH
9031: LD_INT 3
9033: PUSH
9034: EMPTY
9035: LIST
9036: LIST
9037: LIST
9038: PUSH
9039: LD_EXP 76
9043: PUSH
9044: LD_INT 1
9046: PLUS
9047: ARRAY
9048: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9049: LD_ADDR_EXP 86
9053: PUSH
9054: LD_INT 6
9056: PUSH
9057: LD_INT 10
9059: PUSH
9060: LD_INT 13
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: LIST
9067: PUSH
9068: LD_EXP 76
9072: PUSH
9073: LD_INT 1
9075: PLUS
9076: ARRAY
9077: ST_TO_ADDR
// end else
9078: GO 9359
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
9080: LD_ADDR_EXP 80
9084: PUSH
9085: LD_INT 4200
9087: PUSH
9088: LD_INT 6300
9090: PUSH
9091: LD_INT 8400
9093: PUSH
9094: LD_INT 10500
9096: PUSH
9097: EMPTY
9098: LIST
9099: LIST
9100: LIST
9101: LIST
9102: PUSH
9103: LD_EXP 77
9107: PUSH
9108: LD_INT 1
9110: PLUS
9111: ARRAY
9112: ST_TO_ADDR
// p1 = [ 10 , 15 , 20 ] [ def_hunt_size + 1 ] ;
9113: LD_ADDR_VAR 0 3
9117: PUSH
9118: LD_INT 10
9120: PUSH
9121: LD_INT 15
9123: PUSH
9124: LD_INT 20
9126: PUSH
9127: EMPTY
9128: LIST
9129: LIST
9130: LIST
9131: PUSH
9132: LD_EXP 75
9136: PUSH
9137: LD_INT 1
9139: PLUS
9140: ARRAY
9141: ST_TO_ADDR
// p2 = [ 3 , 5 , 7 ] [ def_hunt_size + 1 ] ;
9142: LD_ADDR_VAR 0 4
9146: PUSH
9147: LD_INT 3
9149: PUSH
9150: LD_INT 5
9152: PUSH
9153: LD_INT 7
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: LIST
9160: PUSH
9161: LD_EXP 75
9165: PUSH
9166: LD_INT 1
9168: PLUS
9169: ARRAY
9170: ST_TO_ADDR
// size_of_hunt_team = p1 div side_count + p2 ;
9171: LD_ADDR_EXP 82
9175: PUSH
9176: LD_VAR 0 3
9180: PUSH
9181: LD_EXP 37
9185: DIV
9186: PUSH
9187: LD_VAR 0 4
9191: PLUS
9192: ST_TO_ADDR
// size_of_ape_team = ( size_of_hunt_team + size_of_hunt_team * ( side_count - 1 ) ) div 2 ;
9193: LD_ADDR_EXP 81
9197: PUSH
9198: LD_EXP 82
9202: PUSH
9203: LD_EXP 82
9207: PUSH
9208: LD_EXP 37
9212: PUSH
9213: LD_INT 1
9215: MINUS
9216: MUL
9217: PLUS
9218: PUSH
9219: LD_INT 2
9221: DIV
9222: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
9223: LD_ADDR_EXP 83
9227: PUSH
9228: LD_INT 0
9230: PUSH
9231: LD_EXP 82
9235: PUSH
9236: LD_INT 5
9238: PLUS
9239: PUSH
9240: LD_INT 6
9242: DIV
9243: PUSH
9244: LD_EXP 82
9248: PUSH
9249: LD_INT 3
9251: PLUS
9252: PUSH
9253: LD_INT 4
9255: DIV
9256: PUSH
9257: EMPTY
9258: LIST
9259: LIST
9260: LIST
9261: PUSH
9262: LD_EXP 78
9266: PUSH
9267: LD_INT 1
9269: PLUS
9270: ARRAY
9271: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
9272: LD_ADDR_EXP 84
9276: PUSH
9277: LD_INT 5
9279: PUSH
9280: LD_INT 3
9282: PUSH
9283: LD_INT 1
9285: PUSH
9286: EMPTY
9287: LIST
9288: LIST
9289: LIST
9290: PUSH
9291: LD_EXP 76
9295: PUSH
9296: LD_INT 1
9298: PLUS
9299: ARRAY
9300: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9301: LD_ADDR_EXP 85
9305: PUSH
9306: LD_INT 1
9308: PUSH
9309: LD_INT 2
9311: PUSH
9312: LD_INT 3
9314: PUSH
9315: EMPTY
9316: LIST
9317: LIST
9318: LIST
9319: PUSH
9320: LD_EXP 76
9324: PUSH
9325: LD_INT 1
9327: PLUS
9328: ARRAY
9329: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9330: LD_ADDR_EXP 86
9334: PUSH
9335: LD_INT 6
9337: PUSH
9338: LD_INT 10
9340: PUSH
9341: LD_INT 13
9343: PUSH
9344: EMPTY
9345: LIST
9346: LIST
9347: LIST
9348: PUSH
9349: LD_EXP 76
9353: PUSH
9354: LD_INT 1
9356: PLUS
9357: ARRAY
9358: ST_TO_ADDR
// end ; for i = 1 to 8 do
9359: LD_ADDR_VAR 0 2
9363: PUSH
9364: DOUBLE
9365: LD_INT 1
9367: DEC
9368: ST_TO_ADDR
9369: LD_INT 8
9371: PUSH
9372: FOR_TO
9373: IFFALSE 9405
// if Side_Positions [ i ] then
9375: LD_EXP 43
9379: PUSH
9380: LD_VAR 0 2
9384: ARRAY
9385: IFFALSE 9403
// to_be_alone := to_be_alone ^ i ;
9387: LD_ADDR_EXP 87
9391: PUSH
9392: LD_EXP 87
9396: PUSH
9397: LD_VAR 0 2
9401: ADD
9402: ST_TO_ADDR
9403: GO 9372
9405: POP
9406: POP
// end ;
9407: LD_VAR 0 1
9411: RET
// function prepare_hunter_team ( side ) ; var i , team ; begin
9412: LD_INT 0
9414: PPUSH
9415: PPUSH
9416: PPUSH
// team := [ ] ;
9417: LD_ADDR_VAR 0 4
9421: PUSH
9422: EMPTY
9423: ST_TO_ADDR
// for i := 1 to size_of_hunt_team do
9424: LD_ADDR_VAR 0 3
9428: PUSH
9429: DOUBLE
9430: LD_INT 1
9432: DEC
9433: ST_TO_ADDR
9434: LD_EXP 82
9438: PUSH
9439: FOR_TO
9440: IFFALSE 9557
// begin uc_nation := side_nations [ side ] ;
9442: LD_ADDR_OWVAR 21
9446: PUSH
9447: LD_EXP 44
9451: PUSH
9452: LD_VAR 0 1
9456: ARRAY
9457: ST_TO_ADDR
// uc_side := side ;
9458: LD_ADDR_OWVAR 20
9462: PUSH
9463: LD_VAR 0 1
9467: ST_TO_ADDR
// hc_name :=  ;
9468: LD_ADDR_OWVAR 26
9472: PUSH
9473: LD_STRING 
9475: ST_TO_ADDR
// if i > size_of_hunt_team - doctors_in_team then
9476: LD_VAR 0 3
9480: PUSH
9481: LD_EXP 82
9485: PUSH
9486: LD_EXP 83
9490: MINUS
9491: GREATER
9492: IFFALSE 9508
// PrepareScientist ( 0 , hunter_level ) else
9494: LD_INT 0
9496: PPUSH
9497: LD_EXP 84
9501: PPUSH
9502: CALL_OW 384
9506: GO 9520
// PrepareSoldier ( 0 , hunter_level ) ;
9508: LD_INT 0
9510: PPUSH
9511: LD_EXP 84
9515: PPUSH
9516: CALL_OW 381
// hc_gallery :=  ;
9520: LD_ADDR_OWVAR 33
9524: PUSH
9525: LD_STRING 
9527: ST_TO_ADDR
// hc_importance := 0 ;
9528: LD_ADDR_OWVAR 32
9532: PUSH
9533: LD_INT 0
9535: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9536: LD_ADDR_VAR 0 4
9540: PUSH
9541: LD_VAR 0 4
9545: PUSH
9546: CALL_OW 44
9550: PUSH
9551: EMPTY
9552: LIST
9553: ADD
9554: ST_TO_ADDR
// end ;
9555: GO 9439
9557: POP
9558: POP
// people := Replace ( people , side , team ) ;
9559: LD_ADDR_EXP 88
9563: PUSH
9564: LD_EXP 88
9568: PPUSH
9569: LD_VAR 0 1
9573: PPUSH
9574: LD_VAR 0 4
9578: PPUSH
9579: CALL_OW 1
9583: ST_TO_ADDR
// end ;
9584: LD_VAR 0 2
9588: RET
// function prepare_ape_team ( side ) ; var i , team ; begin
9589: LD_INT 0
9591: PPUSH
9592: PPUSH
9593: PPUSH
// team := [ ] ;
9594: LD_ADDR_VAR 0 4
9598: PUSH
9599: EMPTY
9600: ST_TO_ADDR
// for i := 1 to size_of_ape_team do
9601: LD_ADDR_VAR 0 3
9605: PUSH
9606: DOUBLE
9607: LD_INT 1
9609: DEC
9610: ST_TO_ADDR
9611: LD_EXP 81
9615: PUSH
9616: FOR_TO
9617: IFFALSE 9740
// begin uc_nation := nation_nature ;
9619: LD_ADDR_OWVAR 21
9623: PUSH
9624: LD_INT 0
9626: ST_TO_ADDR
// uc_side := side ;
9627: LD_ADDR_OWVAR 20
9631: PUSH
9632: LD_VAR 0 1
9636: ST_TO_ADDR
// hc_name :=  ;
9637: LD_ADDR_OWVAR 26
9641: PUSH
9642: LD_STRING 
9644: ST_TO_ADDR
// hc_attr := [ ape_stamina , 14 ] ;
9645: LD_ADDR_OWVAR 29
9649: PUSH
9650: LD_EXP 86
9654: PUSH
9655: LD_INT 14
9657: PUSH
9658: EMPTY
9659: LIST
9660: LIST
9661: ST_TO_ADDR
// hc_skills := [ ape_level , 0 , 0 , 0 ] ;
9662: LD_ADDR_OWVAR 31
9666: PUSH
9667: LD_EXP 85
9671: PUSH
9672: LD_INT 0
9674: PUSH
9675: LD_INT 0
9677: PUSH
9678: LD_INT 0
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: LIST
9685: LIST
9686: ST_TO_ADDR
// hc_sex := sex_male ;
9687: LD_ADDR_OWVAR 27
9691: PUSH
9692: LD_INT 1
9694: ST_TO_ADDR
// hc_class := class_apeman ;
9695: LD_ADDR_OWVAR 28
9699: PUSH
9700: LD_INT 12
9702: ST_TO_ADDR
// hc_gallery :=  ;
9703: LD_ADDR_OWVAR 33
9707: PUSH
9708: LD_STRING 
9710: ST_TO_ADDR
// hc_importance := 0 ;
9711: LD_ADDR_OWVAR 32
9715: PUSH
9716: LD_INT 0
9718: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9719: LD_ADDR_VAR 0 4
9723: PUSH
9724: LD_VAR 0 4
9728: PUSH
9729: CALL_OW 44
9733: PUSH
9734: EMPTY
9735: LIST
9736: ADD
9737: ST_TO_ADDR
// end ;
9738: GO 9616
9740: POP
9741: POP
// people := Replace ( people , side , team ) ;
9742: LD_ADDR_EXP 88
9746: PUSH
9747: LD_EXP 88
9751: PPUSH
9752: LD_VAR 0 1
9756: PPUSH
9757: LD_VAR 0 4
9761: PPUSH
9762: CALL_OW 1
9766: ST_TO_ADDR
// end ;
9767: LD_VAR 0 2
9771: RET
// function display_score ( alone , t ) ; begin
9772: LD_INT 0
9774: PPUSH
// display_strings := scorestring ^  ;
9775: LD_ADDR_OWVAR 47
9779: PUSH
9780: LD_EXP 89
9784: PUSH
9785: LD_STRING 
9787: ADD
9788: ST_TO_ADDR
// if alone then
9789: LD_VAR 0 1
9793: IFFALSE 9873
// if one_hunter then
9795: LD_EXP 79
9799: IFFALSE 9838
// display_strings := display_strings ^ [ #Hunt-prepare2 , alone , alone , t ] else
9801: LD_ADDR_OWVAR 47
9805: PUSH
9806: LD_OWVAR 47
9810: PUSH
9811: LD_STRING #Hunt-prepare2
9813: PUSH
9814: LD_VAR 0 1
9818: PUSH
9819: LD_VAR 0 1
9823: PUSH
9824: LD_VAR 0 2
9828: PUSH
9829: EMPTY
9830: LIST
9831: LIST
9832: LIST
9833: LIST
9834: ADD
9835: ST_TO_ADDR
9836: GO 9873
// display_strings := display_strings ^ [ #Hunt-prepare1 , alone , alone , t ] ;
9838: LD_ADDR_OWVAR 47
9842: PUSH
9843: LD_OWVAR 47
9847: PUSH
9848: LD_STRING #Hunt-prepare1
9850: PUSH
9851: LD_VAR 0 1
9855: PUSH
9856: LD_VAR 0 1
9860: PUSH
9861: LD_VAR 0 2
9865: PUSH
9866: EMPTY
9867: LIST
9868: LIST
9869: LIST
9870: LIST
9871: ADD
9872: ST_TO_ADDR
// end ;
9873: LD_VAR 0 3
9877: RET
// function set_attitudes ( alone ) ; var i , j ; begin
9878: LD_INT 0
9880: PPUSH
9881: PPUSH
9882: PPUSH
// for i := 1 to 8 do
9883: LD_ADDR_VAR 0 3
9887: PUSH
9888: DOUBLE
9889: LD_INT 1
9891: DEC
9892: ST_TO_ADDR
9893: LD_INT 8
9895: PUSH
9896: FOR_TO
9897: IFFALSE 9987
// for j := 1 to 8 do
9899: LD_ADDR_VAR 0 4
9903: PUSH
9904: DOUBLE
9905: LD_INT 1
9907: DEC
9908: ST_TO_ADDR
9909: LD_INT 8
9911: PUSH
9912: FOR_TO
9913: IFFALSE 9983
// if ( i = alone ) = ( j = alone ) then
9915: LD_VAR 0 3
9919: PUSH
9920: LD_VAR 0 1
9924: EQUAL
9925: PUSH
9926: LD_VAR 0 4
9930: PUSH
9931: LD_VAR 0 1
9935: EQUAL
9936: EQUAL
9937: IFFALSE 9961
// SetAttitude ( i , j , att_friend , true ) else
9939: LD_VAR 0 3
9943: PPUSH
9944: LD_VAR 0 4
9948: PPUSH
9949: LD_INT 1
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: CALL_OW 80
9959: GO 9981
// SetAttitude ( i , j , att_enemy , true ) ;
9961: LD_VAR 0 3
9965: PPUSH
9966: LD_VAR 0 4
9970: PPUSH
9971: LD_INT 2
9973: PPUSH
9974: LD_INT 1
9976: PPUSH
9977: CALL_OW 80
9981: GO 9912
9983: POP
9984: POP
9985: GO 9896
9987: POP
9988: POP
// end ;
9989: LD_VAR 0 2
9993: RET
// function set_technologies ( alone ) ; var i ; begin
9994: LD_INT 0
9996: PPUSH
9997: PPUSH
// for i := 1 to 8 do
9998: LD_ADDR_VAR 0 3
10002: PUSH
10003: DOUBLE
10004: LD_INT 1
10006: DEC
10007: ST_TO_ADDR
10008: LD_INT 8
10010: PUSH
10011: FOR_TO
10012: IFFALSE 10201
// begin if ( alone = i ) = one_hunter then
10014: LD_VAR 0 1
10018: PUSH
10019: LD_VAR 0 3
10023: EQUAL
10024: PUSH
10025: LD_EXP 79
10029: EQUAL
10030: IFFALSE 10094
// begin SetTech ( tech_Opto1 , i , state_disabled ) ;
10032: LD_INT 60
10034: PPUSH
10035: LD_VAR 0 3
10039: PPUSH
10040: LD_INT 0
10042: PPUSH
10043: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_disabled ) ;
10047: LD_INT 61
10049: PPUSH
10050: LD_VAR 0 3
10054: PPUSH
10055: LD_INT 0
10057: PPUSH
10058: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_disabled ) ;
10062: LD_INT 62
10064: PPUSH
10065: LD_VAR 0 3
10069: PPUSH
10070: LD_INT 0
10072: PPUSH
10073: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_disabled ) ;
10077: LD_INT 5
10079: PPUSH
10080: LD_VAR 0 3
10084: PPUSH
10085: LD_INT 0
10087: PPUSH
10088: CALL_OW 322
// end else
10092: GO 10154
// begin SetTech ( tech_Opto1 , i , state_researched ) ;
10094: LD_INT 60
10096: PPUSH
10097: LD_VAR 0 3
10101: PPUSH
10102: LD_INT 2
10104: PPUSH
10105: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_researched ) ;
10109: LD_INT 61
10111: PPUSH
10112: LD_VAR 0 3
10116: PPUSH
10117: LD_INT 2
10119: PPUSH
10120: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_researched ) ;
10124: LD_INT 62
10126: PPUSH
10127: LD_VAR 0 3
10131: PPUSH
10132: LD_INT 2
10134: PPUSH
10135: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_researched ) ;
10139: LD_INT 5
10141: PPUSH
10142: LD_VAR 0 3
10146: PPUSH
10147: LD_INT 2
10149: PPUSH
10150: CALL_OW 322
// end ; SetTech ( tech_Weap1 , i , state_disabled ) ;
10154: LD_INT 51
10156: PPUSH
10157: LD_VAR 0 3
10161: PPUSH
10162: LD_INT 0
10164: PPUSH
10165: CALL_OW 322
// SetTech ( tech_Weap2 , i , state_disabled ) ;
10169: LD_INT 52
10171: PPUSH
10172: LD_VAR 0 3
10176: PPUSH
10177: LD_INT 0
10179: PPUSH
10180: CALL_OW 322
// SetTech ( tech_Weap3 , i , state_disabled ) ;
10184: LD_INT 53
10186: PPUSH
10187: LD_VAR 0 3
10191: PPUSH
10192: LD_INT 0
10194: PPUSH
10195: CALL_OW 322
// end ;
10199: GO 10011
10201: POP
10202: POP
// end ;
10203: LD_VAR 0 2
10207: RET
// function prepare_map_coordinates_more_hunters ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10208: LD_INT 0
10210: PPUSH
10211: PPUSH
10212: PPUSH
10213: PPUSH
10214: PPUSH
10215: PPUSH
10216: PPUSH
10217: PPUSH
// best = 0 ;
10218: LD_ADDR_VAR 0 3
10222: PUSH
10223: LD_INT 0
10225: ST_TO_ADDR
// for n = 1 to 40 do
10226: LD_ADDR_VAR 0 9
10230: PUSH
10231: DOUBLE
10232: LD_INT 1
10234: DEC
10235: ST_TO_ADDR
10236: LD_INT 40
10238: PUSH
10239: FOR_TO
10240: IFFALSE 10548
// begin c = [ ] ;
10242: LD_ADDR_VAR 0 4
10246: PUSH
10247: EMPTY
10248: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10249: LD_ADDR_VAR 0 7
10253: PUSH
10254: DOUBLE
10255: LD_INT 1
10257: DEC
10258: ST_TO_ADDR
10259: LD_EXP 37
10263: PUSH
10264: LD_INT 1
10266: MINUS
10267: PUSH
10268: FOR_TO
10269: IFFALSE 10298
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
10271: LD_ADDR_VAR 0 4
10275: PUSH
10276: LD_VAR 0 4
10280: PUSH
10281: LD_INT 21
10283: PPUSH
10284: LD_INT 0
10286: PPUSH
10287: CALL_OW 16
10291: PUSH
10292: EMPTY
10293: LIST
10294: ADD
10295: ST_TO_ADDR
10296: GO 10268
10298: POP
10299: POP
// minv = 10000 ;
10300: LD_ADDR_VAR 0 6
10304: PUSH
10305: LD_INT 10000
10307: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10308: LD_ADDR_VAR 0 7
10312: PUSH
10313: DOUBLE
10314: LD_INT 1
10316: DEC
10317: ST_TO_ADDR
10318: LD_EXP 37
10322: PUSH
10323: LD_INT 1
10325: MINUS
10326: PUSH
10327: FOR_TO
10328: IFFALSE 10512
// for j = 1 to side_count - 1 do
10330: LD_ADDR_VAR 0 8
10334: PUSH
10335: DOUBLE
10336: LD_INT 1
10338: DEC
10339: ST_TO_ADDR
10340: LD_EXP 37
10344: PUSH
10345: LD_INT 1
10347: MINUS
10348: PUSH
10349: FOR_TO
10350: IFFALSE 10508
// if i <> j then
10352: LD_VAR 0 7
10356: PUSH
10357: LD_VAR 0 8
10361: NONEQUAL
10362: IFFALSE 10506
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10364: LD_VAR 0 4
10368: PUSH
10369: LD_VAR 0 7
10373: ARRAY
10374: PUSH
10375: LD_INT 1
10377: ARRAY
10378: PPUSH
10379: LD_VAR 0 4
10383: PUSH
10384: LD_VAR 0 7
10388: ARRAY
10389: PUSH
10390: LD_INT 2
10392: ARRAY
10393: PPUSH
10394: LD_VAR 0 4
10398: PUSH
10399: LD_VAR 0 8
10403: ARRAY
10404: PUSH
10405: LD_INT 1
10407: ARRAY
10408: PPUSH
10409: LD_VAR 0 4
10413: PUSH
10414: LD_VAR 0 8
10418: ARRAY
10419: PUSH
10420: LD_INT 2
10422: ARRAY
10423: PPUSH
10424: CALL_OW 298
10428: PUSH
10429: LD_VAR 0 6
10433: LESS
10434: IFFALSE 10506
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10436: LD_ADDR_VAR 0 6
10440: PUSH
10441: LD_VAR 0 4
10445: PUSH
10446: LD_VAR 0 7
10450: ARRAY
10451: PUSH
10452: LD_INT 1
10454: ARRAY
10455: PPUSH
10456: LD_VAR 0 4
10460: PUSH
10461: LD_VAR 0 7
10465: ARRAY
10466: PUSH
10467: LD_INT 2
10469: ARRAY
10470: PPUSH
10471: LD_VAR 0 4
10475: PUSH
10476: LD_VAR 0 8
10480: ARRAY
10481: PUSH
10482: LD_INT 1
10484: ARRAY
10485: PPUSH
10486: LD_VAR 0 4
10490: PUSH
10491: LD_VAR 0 8
10495: ARRAY
10496: PUSH
10497: LD_INT 2
10499: ARRAY
10500: PPUSH
10501: CALL_OW 298
10505: ST_TO_ADDR
// end ;
10506: GO 10349
10508: POP
10509: POP
10510: GO 10327
10512: POP
10513: POP
// if minv > best then
10514: LD_VAR 0 6
10518: PUSH
10519: LD_VAR 0 3
10523: GREATER
10524: IFFALSE 10546
// begin best := minv ;
10526: LD_ADDR_VAR 0 3
10530: PUSH
10531: LD_VAR 0 6
10535: ST_TO_ADDR
// bestc := c ;
10536: LD_ADDR_VAR 0 5
10540: PUSH
10541: LD_VAR 0 4
10545: ST_TO_ADDR
// end ; end ;
10546: GO 10239
10548: POP
10549: POP
// coordinates := [ ] ;
10550: LD_ADDR_EXP 34
10554: PUSH
10555: EMPTY
10556: ST_TO_ADDR
// for i = 1 to 8 do
10557: LD_ADDR_VAR 0 7
10561: PUSH
10562: DOUBLE
10563: LD_INT 1
10565: DEC
10566: ST_TO_ADDR
10567: LD_INT 8
10569: PUSH
10570: FOR_TO
10571: IFFALSE 10696
// if i = alone then
10573: LD_VAR 0 7
10577: PUSH
10578: LD_VAR 0 1
10582: EQUAL
10583: IFFALSE 10611
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
10585: LD_ADDR_EXP 34
10589: PUSH
10590: LD_EXP 34
10594: PUSH
10595: LD_INT 81
10597: PUSH
10598: LD_INT 57
10600: PUSH
10601: EMPTY
10602: LIST
10603: LIST
10604: PUSH
10605: EMPTY
10606: LIST
10607: ADD
10608: ST_TO_ADDR
10609: GO 10694
// if ( side_positions [ i ] = 0 ) then
10611: LD_EXP 43
10615: PUSH
10616: LD_VAR 0 7
10620: ARRAY
10621: PUSH
10622: LD_INT 0
10624: EQUAL
10625: IFFALSE 10653
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
10627: LD_ADDR_EXP 34
10631: PUSH
10632: LD_EXP 34
10636: PUSH
10637: LD_INT 0
10639: PUSH
10640: LD_INT 0
10642: PUSH
10643: EMPTY
10644: LIST
10645: LIST
10646: PUSH
10647: EMPTY
10648: LIST
10649: ADD
10650: ST_TO_ADDR
10651: GO 10694
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
10653: LD_ADDR_EXP 34
10657: PUSH
10658: LD_EXP 34
10662: PUSH
10663: LD_VAR 0 5
10667: PUSH
10668: LD_INT 1
10670: ARRAY
10671: PUSH
10672: EMPTY
10673: LIST
10674: ADD
10675: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
10676: LD_ADDR_VAR 0 5
10680: PUSH
10681: LD_VAR 0 5
10685: PPUSH
10686: LD_INT 1
10688: PPUSH
10689: CALL_OW 3
10693: ST_TO_ADDR
// end ;
10694: GO 10570
10696: POP
10697: POP
// end ;
10698: LD_VAR 0 2
10702: RET
// function prepare_map_coordinates_one_hunter ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10703: LD_INT 0
10705: PPUSH
10706: PPUSH
10707: PPUSH
10708: PPUSH
10709: PPUSH
10710: PPUSH
10711: PPUSH
10712: PPUSH
// best = 0 ;
10713: LD_ADDR_VAR 0 3
10717: PUSH
10718: LD_INT 0
10720: ST_TO_ADDR
// for n = 1 to 40 do
10721: LD_ADDR_VAR 0 9
10725: PUSH
10726: DOUBLE
10727: LD_INT 1
10729: DEC
10730: ST_TO_ADDR
10731: LD_INT 40
10733: PUSH
10734: FOR_TO
10735: IFFALSE 11043
// begin c = [ ] ;
10737: LD_ADDR_VAR 0 4
10741: PUSH
10742: EMPTY
10743: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10744: LD_ADDR_VAR 0 7
10748: PUSH
10749: DOUBLE
10750: LD_INT 1
10752: DEC
10753: ST_TO_ADDR
10754: LD_EXP 37
10758: PUSH
10759: LD_INT 1
10761: MINUS
10762: PUSH
10763: FOR_TO
10764: IFFALSE 10793
// c := c ^ [ RandHexArea ( arapestart , false ) ] ;
10766: LD_ADDR_VAR 0 4
10770: PUSH
10771: LD_VAR 0 4
10775: PUSH
10776: LD_INT 22
10778: PPUSH
10779: LD_INT 0
10781: PPUSH
10782: CALL_OW 16
10786: PUSH
10787: EMPTY
10788: LIST
10789: ADD
10790: ST_TO_ADDR
10791: GO 10763
10793: POP
10794: POP
// minv = 10000 ;
10795: LD_ADDR_VAR 0 6
10799: PUSH
10800: LD_INT 10000
10802: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10803: LD_ADDR_VAR 0 7
10807: PUSH
10808: DOUBLE
10809: LD_INT 1
10811: DEC
10812: ST_TO_ADDR
10813: LD_EXP 37
10817: PUSH
10818: LD_INT 1
10820: MINUS
10821: PUSH
10822: FOR_TO
10823: IFFALSE 11007
// for j = 1 to side_count - 1 do
10825: LD_ADDR_VAR 0 8
10829: PUSH
10830: DOUBLE
10831: LD_INT 1
10833: DEC
10834: ST_TO_ADDR
10835: LD_EXP 37
10839: PUSH
10840: LD_INT 1
10842: MINUS
10843: PUSH
10844: FOR_TO
10845: IFFALSE 11003
// if i <> j then
10847: LD_VAR 0 7
10851: PUSH
10852: LD_VAR 0 8
10856: NONEQUAL
10857: IFFALSE 11001
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10859: LD_VAR 0 4
10863: PUSH
10864: LD_VAR 0 7
10868: ARRAY
10869: PUSH
10870: LD_INT 1
10872: ARRAY
10873: PPUSH
10874: LD_VAR 0 4
10878: PUSH
10879: LD_VAR 0 7
10883: ARRAY
10884: PUSH
10885: LD_INT 2
10887: ARRAY
10888: PPUSH
10889: LD_VAR 0 4
10893: PUSH
10894: LD_VAR 0 8
10898: ARRAY
10899: PUSH
10900: LD_INT 1
10902: ARRAY
10903: PPUSH
10904: LD_VAR 0 4
10908: PUSH
10909: LD_VAR 0 8
10913: ARRAY
10914: PUSH
10915: LD_INT 2
10917: ARRAY
10918: PPUSH
10919: CALL_OW 298
10923: PUSH
10924: LD_VAR 0 6
10928: LESS
10929: IFFALSE 11001
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10931: LD_ADDR_VAR 0 6
10935: PUSH
10936: LD_VAR 0 4
10940: PUSH
10941: LD_VAR 0 7
10945: ARRAY
10946: PUSH
10947: LD_INT 1
10949: ARRAY
10950: PPUSH
10951: LD_VAR 0 4
10955: PUSH
10956: LD_VAR 0 7
10960: ARRAY
10961: PUSH
10962: LD_INT 2
10964: ARRAY
10965: PPUSH
10966: LD_VAR 0 4
10970: PUSH
10971: LD_VAR 0 8
10975: ARRAY
10976: PUSH
10977: LD_INT 1
10979: ARRAY
10980: PPUSH
10981: LD_VAR 0 4
10985: PUSH
10986: LD_VAR 0 8
10990: ARRAY
10991: PUSH
10992: LD_INT 2
10994: ARRAY
10995: PPUSH
10996: CALL_OW 298
11000: ST_TO_ADDR
// end ;
11001: GO 10844
11003: POP
11004: POP
11005: GO 10822
11007: POP
11008: POP
// if minv > best then
11009: LD_VAR 0 6
11013: PUSH
11014: LD_VAR 0 3
11018: GREATER
11019: IFFALSE 11041
// begin best := minv ;
11021: LD_ADDR_VAR 0 3
11025: PUSH
11026: LD_VAR 0 6
11030: ST_TO_ADDR
// bestc := c ;
11031: LD_ADDR_VAR 0 5
11035: PUSH
11036: LD_VAR 0 4
11040: ST_TO_ADDR
// end ; end ;
11041: GO 10734
11043: POP
11044: POP
// coordinates := [ ] ;
11045: LD_ADDR_EXP 34
11049: PUSH
11050: EMPTY
11051: ST_TO_ADDR
// for i = 1 to 8 do
11052: LD_ADDR_VAR 0 7
11056: PUSH
11057: DOUBLE
11058: LD_INT 1
11060: DEC
11061: ST_TO_ADDR
11062: LD_INT 8
11064: PUSH
11065: FOR_TO
11066: IFFALSE 11191
// if i = alone then
11068: LD_VAR 0 7
11072: PUSH
11073: LD_VAR 0 1
11077: EQUAL
11078: IFFALSE 11106
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
11080: LD_ADDR_EXP 34
11084: PUSH
11085: LD_EXP 34
11089: PUSH
11090: LD_INT 81
11092: PUSH
11093: LD_INT 57
11095: PUSH
11096: EMPTY
11097: LIST
11098: LIST
11099: PUSH
11100: EMPTY
11101: LIST
11102: ADD
11103: ST_TO_ADDR
11104: GO 11189
// if ( side_positions [ i ] = 0 ) then
11106: LD_EXP 43
11110: PUSH
11111: LD_VAR 0 7
11115: ARRAY
11116: PUSH
11117: LD_INT 0
11119: EQUAL
11120: IFFALSE 11148
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
11122: LD_ADDR_EXP 34
11126: PUSH
11127: LD_EXP 34
11131: PUSH
11132: LD_INT 0
11134: PUSH
11135: LD_INT 0
11137: PUSH
11138: EMPTY
11139: LIST
11140: LIST
11141: PUSH
11142: EMPTY
11143: LIST
11144: ADD
11145: ST_TO_ADDR
11146: GO 11189
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
11148: LD_ADDR_EXP 34
11152: PUSH
11153: LD_EXP 34
11157: PUSH
11158: LD_VAR 0 5
11162: PUSH
11163: LD_INT 1
11165: ARRAY
11166: PUSH
11167: EMPTY
11168: LIST
11169: ADD
11170: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
11171: LD_ADDR_VAR 0 5
11175: PUSH
11176: LD_VAR 0 5
11180: PPUSH
11181: LD_INT 1
11183: PPUSH
11184: CALL_OW 3
11188: ST_TO_ADDR
// end ;
11189: GO 11065
11191: POP
11192: POP
// end ;
11193: LD_VAR 0 2
11197: RET
// function prepare_game ( alone ) ; var i , t ; begin
11198: LD_INT 0
11200: PPUSH
11201: PPUSH
11202: PPUSH
// ResetFog ;
11203: CALL_OW 335
// AnimateTrees ( true ) ;
11207: LD_INT 1
11209: PPUSH
11210: CALL_OW 573
// for i := 1 to 8 do
11214: LD_ADDR_VAR 0 3
11218: PUSH
11219: DOUBLE
11220: LD_INT 1
11222: DEC
11223: ST_TO_ADDR
11224: LD_INT 8
11226: PUSH
11227: FOR_TO
11228: IFFALSE 11282
// if Side_Positions [ i ] then
11230: LD_EXP 43
11234: PUSH
11235: LD_VAR 0 3
11239: ARRAY
11240: IFFALSE 11280
// if i = alone then
11242: LD_VAR 0 3
11246: PUSH
11247: LD_VAR 0 1
11251: EQUAL
11252: IFFALSE 11268
// ChangeSideFog ( i , 1 ) else
11254: LD_VAR 0 3
11258: PPUSH
11259: LD_INT 1
11261: PPUSH
11262: CALL_OW 343
11266: GO 11280
// ChangeSideFog ( i , 2 ) ;
11268: LD_VAR 0 3
11272: PPUSH
11273: LD_INT 2
11275: PPUSH
11276: CALL_OW 343
11280: GO 11227
11282: POP
11283: POP
// set_attitudes ( alone ) ;
11284: LD_VAR 0 1
11288: PPUSH
11289: CALL 9878 0 1
// set_technologies ( alone ) ;
11293: LD_VAR 0 1
11297: PPUSH
11298: CALL 9994 0 1
// display_score ( alone , 0 0$8 ) ;
11302: LD_VAR 0 1
11306: PPUSH
11307: LD_INT 280
11309: PPUSH
11310: CALL 9772 0 2
// for i := 1 to 8 do
11314: LD_ADDR_VAR 0 3
11318: PUSH
11319: DOUBLE
11320: LD_INT 1
11322: DEC
11323: ST_TO_ADDR
11324: LD_INT 8
11326: PUSH
11327: FOR_TO
11328: IFFALSE 11382
// if Side_Positions [ i ] then
11330: LD_EXP 43
11334: PUSH
11335: LD_VAR 0 3
11339: ARRAY
11340: IFFALSE 11380
// if ( i = alone ) = ( one_hunter ) then
11342: LD_VAR 0 3
11346: PUSH
11347: LD_VAR 0 1
11351: EQUAL
11352: PUSH
11353: LD_EXP 79
11357: EQUAL
11358: IFFALSE 11371
// prepare_hunter_team ( i ) else
11360: LD_VAR 0 3
11364: PPUSH
11365: CALL 9412 0 1
11369: GO 11380
// prepare_ape_team ( i ) ;
11371: LD_VAR 0 3
11375: PPUSH
11376: CALL 9589 0 1
11380: GO 11327
11382: POP
11383: POP
// t := 8 ;
11384: LD_ADDR_VAR 0 4
11388: PUSH
11389: LD_INT 8
11391: ST_TO_ADDR
// repeat t := t - 1 ;
11392: LD_ADDR_VAR 0 4
11396: PUSH
11397: LD_VAR 0 4
11401: PUSH
11402: LD_INT 1
11404: MINUS
11405: ST_TO_ADDR
// display_score ( alone , t * 0 0$1 ) ;
11406: LD_VAR 0 1
11410: PPUSH
11411: LD_VAR 0 4
11415: PUSH
11416: LD_INT 35
11418: MUL
11419: PPUSH
11420: CALL 9772 0 2
// wait ( 0 0$1 ) ;
11424: LD_INT 35
11426: PPUSH
11427: CALL_OW 67
// until t = 0 ;
11431: LD_VAR 0 4
11435: PUSH
11436: LD_INT 0
11438: EQUAL
11439: IFFALSE 11392
// end ;
11441: LD_VAR 0 2
11445: RET
// function run_game ( alone ) ; var i , un , ape , time , alive , dead , aktsc ; begin
11446: LD_INT 0
11448: PPUSH
11449: PPUSH
11450: PPUSH
11451: PPUSH
11452: PPUSH
11453: PPUSH
11454: PPUSH
11455: PPUSH
// if ( your_side = alone ) <> one_hunter then
11456: LD_OWVAR 2
11460: PUSH
11461: LD_VAR 0 1
11465: EQUAL
11466: PUSH
11467: LD_EXP 79
11471: NONEQUAL
11472: IFFALSE 11484
// music_nat := nation_arabian else
11474: LD_ADDR_OWVAR 71
11478: PUSH
11479: LD_INT 2
11481: ST_TO_ADDR
11482: GO 11500
// music_nat := Side_Nations [ your_side ] ;
11484: LD_ADDR_OWVAR 71
11488: PUSH
11489: LD_EXP 44
11493: PUSH
11494: LD_OWVAR 2
11498: ARRAY
11499: ST_TO_ADDR
// if one_hunter then
11500: LD_EXP 79
11504: IFFALSE 11669
// begin prepare_map_coordinates_one_hunter ( alone ) ;
11506: LD_VAR 0 1
11510: PPUSH
11511: CALL 10703 0 1
// for i := 1 to 8 do
11515: LD_ADDR_VAR 0 3
11519: PUSH
11520: DOUBLE
11521: LD_INT 1
11523: DEC
11524: ST_TO_ADDR
11525: LD_INT 8
11527: PUSH
11528: FOR_TO
11529: IFFALSE 11665
// if side_positions [ i ] then
11531: LD_EXP 43
11535: PUSH
11536: LD_VAR 0 3
11540: ARRAY
11541: IFFALSE 11663
// if i = alone then
11543: LD_VAR 0 3
11547: PUSH
11548: LD_VAR 0 1
11552: EQUAL
11553: IFFALSE 11595
// for un in people [ i ] do
11555: LD_ADDR_VAR 0 4
11559: PUSH
11560: LD_EXP 88
11564: PUSH
11565: LD_VAR 0 3
11569: ARRAY
11570: PUSH
11571: FOR_IN
11572: IFFALSE 11591
// PlaceUnitArea ( un , arstartveh , false ) else
11574: LD_VAR 0 4
11578: PPUSH
11579: LD_INT 21
11581: PPUSH
11582: LD_INT 0
11584: PPUSH
11585: CALL_OW 49
11589: GO 11571
11591: POP
11592: POP
11593: GO 11663
// for un in people [ i ] do
11595: LD_ADDR_VAR 0 4
11599: PUSH
11600: LD_EXP 88
11604: PUSH
11605: LD_VAR 0 3
11609: ARRAY
11610: PUSH
11611: FOR_IN
11612: IFFALSE 11661
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 15 , false ) ;
11614: LD_VAR 0 4
11618: PPUSH
11619: LD_EXP 34
11623: PUSH
11624: LD_VAR 0 3
11628: ARRAY
11629: PUSH
11630: LD_INT 1
11632: ARRAY
11633: PPUSH
11634: LD_EXP 34
11638: PUSH
11639: LD_VAR 0 3
11643: ARRAY
11644: PUSH
11645: LD_INT 2
11647: ARRAY
11648: PPUSH
11649: LD_INT 15
11651: PPUSH
11652: LD_INT 0
11654: PPUSH
11655: CALL_OW 50
11659: GO 11611
11661: POP
11662: POP
11663: GO 11528
11665: POP
11666: POP
// end else
11667: GO 11830
// begin prepare_map_coordinates_more_hunters ( alone ) ;
11669: LD_VAR 0 1
11673: PPUSH
11674: CALL 10208 0 1
// for i := 1 to 8 do
11678: LD_ADDR_VAR 0 3
11682: PUSH
11683: DOUBLE
11684: LD_INT 1
11686: DEC
11687: ST_TO_ADDR
11688: LD_INT 8
11690: PUSH
11691: FOR_TO
11692: IFFALSE 11828
// if side_positions [ i ] then
11694: LD_EXP 43
11698: PUSH
11699: LD_VAR 0 3
11703: ARRAY
11704: IFFALSE 11826
// if i = alone then
11706: LD_VAR 0 3
11710: PUSH
11711: LD_VAR 0 1
11715: EQUAL
11716: IFFALSE 11758
// for un in people [ i ] do
11718: LD_ADDR_VAR 0 4
11722: PUSH
11723: LD_EXP 88
11727: PUSH
11728: LD_VAR 0 3
11732: ARRAY
11733: PUSH
11734: FOR_IN
11735: IFFALSE 11754
// PlaceUnitArea ( un , arapes , false ) else
11737: LD_VAR 0 4
11741: PPUSH
11742: LD_INT 23
11744: PPUSH
11745: LD_INT 0
11747: PPUSH
11748: CALL_OW 49
11752: GO 11734
11754: POP
11755: POP
11756: GO 11826
// for un in people [ i ] do
11758: LD_ADDR_VAR 0 4
11762: PUSH
11763: LD_EXP 88
11767: PUSH
11768: LD_VAR 0 3
11772: ARRAY
11773: PUSH
11774: FOR_IN
11775: IFFALSE 11824
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 4 , false ) ;
11777: LD_VAR 0 4
11781: PPUSH
11782: LD_EXP 34
11786: PUSH
11787: LD_VAR 0 3
11791: ARRAY
11792: PUSH
11793: LD_INT 1
11795: ARRAY
11796: PPUSH
11797: LD_EXP 34
11801: PUSH
11802: LD_VAR 0 3
11806: ARRAY
11807: PUSH
11808: LD_INT 2
11810: ARRAY
11811: PPUSH
11812: LD_INT 4
11814: PPUSH
11815: LD_INT 0
11817: PPUSH
11818: CALL_OW 50
11822: GO 11774
11824: POP
11825: POP
11826: GO 11691
11828: POP
11829: POP
// end ; CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
11830: LD_EXP 34
11834: PUSH
11835: LD_OWVAR 2
11839: ARRAY
11840: PUSH
11841: LD_INT 1
11843: ARRAY
11844: PPUSH
11845: LD_EXP 34
11849: PUSH
11850: LD_OWVAR 2
11854: ARRAY
11855: PUSH
11856: LD_INT 2
11858: ARRAY
11859: PPUSH
11860: CALL_OW 86
// display_score ( 0 , 0 ) ;
11864: LD_INT 0
11866: PPUSH
11867: LD_INT 0
11869: PPUSH
11870: CALL 9772 0 2
// time := hunt_limit div 0 0$1 ;
11874: LD_ADDR_VAR 0 6
11878: PUSH
11879: LD_EXP 80
11883: PUSH
11884: LD_INT 35
11886: DIV
11887: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11888: LD_INT 35
11890: PPUSH
11891: CALL_OW 67
// ape := FilterAllUnits ( [ f_class , class_apeman ] ) + 0 ;
11895: LD_ADDR_VAR 0 5
11899: PUSH
11900: LD_INT 25
11902: PUSH
11903: LD_INT 12
11905: PUSH
11906: EMPTY
11907: LIST
11908: LIST
11909: PPUSH
11910: CALL_OW 69
11914: PUSH
11915: LD_INT 0
11917: PLUS
11918: ST_TO_ADDR
// time := time - 1 ;
11919: LD_ADDR_VAR 0 6
11923: PUSH
11924: LD_VAR 0 6
11928: PUSH
11929: LD_INT 1
11931: MINUS
11932: ST_TO_ADDR
// display_strings := [ #Hunt-Apes , alone , ape , #Hunt-Limit , alone , time * 0 0$1 ] ;
11933: LD_ADDR_OWVAR 47
11937: PUSH
11938: LD_STRING #Hunt-Apes
11940: PUSH
11941: LD_VAR 0 1
11945: PUSH
11946: LD_VAR 0 5
11950: PUSH
11951: LD_STRING #Hunt-Limit
11953: PUSH
11954: LD_VAR 0 1
11958: PUSH
11959: LD_VAR 0 6
11963: PUSH
11964: LD_INT 35
11966: MUL
11967: PUSH
11968: EMPTY
11969: LIST
11970: LIST
11971: LIST
11972: LIST
11973: LIST
11974: LIST
11975: ST_TO_ADDR
// until ( ape = 0 ) or ( time = 0 ) ;
11976: LD_VAR 0 5
11980: PUSH
11981: LD_INT 0
11983: EQUAL
11984: PUSH
11985: LD_VAR 0 6
11989: PUSH
11990: LD_INT 0
11992: EQUAL
11993: OR
11994: IFFALSE 11888
// alive := FilterAllUnits ( [ f_or , [ f_class , class_soldier ] , [ f_class , class_scientistic ] ] ) + 0 ;
11996: LD_ADDR_VAR 0 7
12000: PUSH
12001: LD_INT 2
12003: PUSH
12004: LD_INT 25
12006: PUSH
12007: LD_INT 1
12009: PUSH
12010: EMPTY
12011: LIST
12012: LIST
12013: PUSH
12014: LD_INT 25
12016: PUSH
12017: LD_INT 4
12019: PUSH
12020: EMPTY
12021: LIST
12022: LIST
12023: PUSH
12024: EMPTY
12025: LIST
12026: LIST
12027: LIST
12028: PPUSH
12029: CALL_OW 69
12033: PUSH
12034: LD_INT 0
12036: PLUS
12037: ST_TO_ADDR
// if one_hunter then
12038: LD_EXP 79
12042: IFFALSE 12193
// begin dead := size_of_hunt_team - alive ;
12044: LD_ADDR_VAR 0 8
12048: PUSH
12049: LD_EXP 82
12053: PUSH
12054: LD_VAR 0 7
12058: MINUS
12059: ST_TO_ADDR
// ape := size_of_ape_team * ( side_count - 1 ) - ape ;
12060: LD_ADDR_VAR 0 5
12064: PUSH
12065: LD_EXP 81
12069: PUSH
12070: LD_EXP 37
12074: PUSH
12075: LD_INT 1
12077: MINUS
12078: MUL
12079: PUSH
12080: LD_VAR 0 5
12084: MINUS
12085: ST_TO_ADDR
// aktsc := time + ape * 30 - dead * 20 ;
12086: LD_ADDR_VAR 0 9
12090: PUSH
12091: LD_VAR 0 6
12095: PUSH
12096: LD_VAR 0 5
12100: PUSH
12101: LD_INT 30
12103: MUL
12104: PLUS
12105: PUSH
12106: LD_VAR 0 8
12110: PUSH
12111: LD_INT 20
12113: MUL
12114: MINUS
12115: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score2 , alone , alone , time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12116: LD_ADDR_EXP 89
12120: PUSH
12121: LD_EXP 89
12125: PUSH
12126: LD_STRING #Hunt-score2
12128: PUSH
12129: LD_VAR 0 1
12133: PUSH
12134: LD_VAR 0 1
12138: PUSH
12139: LD_VAR 0 6
12143: PUSH
12144: LD_INT 35
12146: MUL
12147: PUSH
12148: LD_VAR 0 5
12152: PUSH
12153: LD_VAR 0 8
12157: PUSH
12158: LD_INT 0
12160: PUSH
12161: LD_VAR 0 9
12165: PUSH
12166: EMPTY
12167: LIST
12168: LIST
12169: LIST
12170: LIST
12171: LIST
12172: LIST
12173: LIST
12174: LIST
12175: ADD
12176: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12177: LD_VAR 0 1
12181: PPUSH
12182: LD_VAR 0 9
12186: PPUSH
12187: CALL_OW 506
// end else
12191: GO 12340
// begin dead := size_of_hunt_team * ( side_count - 1 ) - alive ;
12193: LD_ADDR_VAR 0 8
12197: PUSH
12198: LD_EXP 82
12202: PUSH
12203: LD_EXP 37
12207: PUSH
12208: LD_INT 1
12210: MINUS
12211: MUL
12212: PUSH
12213: LD_VAR 0 7
12217: MINUS
12218: ST_TO_ADDR
// aktsc := hunt_limit div 0 0$1 - time + ape * 30 + dead * 20 ;
12219: LD_ADDR_VAR 0 9
12223: PUSH
12224: LD_EXP 80
12228: PUSH
12229: LD_INT 35
12231: DIV
12232: PUSH
12233: LD_VAR 0 6
12237: MINUS
12238: PUSH
12239: LD_VAR 0 5
12243: PUSH
12244: LD_INT 30
12246: MUL
12247: PLUS
12248: PUSH
12249: LD_VAR 0 8
12253: PUSH
12254: LD_INT 20
12256: MUL
12257: PLUS
12258: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score1 , alone , alone , hunt_limit - time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12259: LD_ADDR_EXP 89
12263: PUSH
12264: LD_EXP 89
12268: PUSH
12269: LD_STRING #Hunt-score1
12271: PUSH
12272: LD_VAR 0 1
12276: PUSH
12277: LD_VAR 0 1
12281: PUSH
12282: LD_EXP 80
12286: PUSH
12287: LD_VAR 0 6
12291: PUSH
12292: LD_INT 35
12294: MUL
12295: MINUS
12296: PUSH
12297: LD_VAR 0 5
12301: PUSH
12302: LD_VAR 0 8
12306: PUSH
12307: LD_INT 0
12309: PUSH
12310: LD_VAR 0 9
12314: PUSH
12315: EMPTY
12316: LIST
12317: LIST
12318: LIST
12319: LIST
12320: LIST
12321: LIST
12322: LIST
12323: LIST
12324: ADD
12325: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12326: LD_VAR 0 1
12330: PPUSH
12331: LD_VAR 0 9
12335: PPUSH
12336: CALL_OW 506
// end ; end ;
12340: LD_VAR 0 2
12344: RET
// function close_game ( alone ) ; var un ; begin
12345: LD_INT 0
12347: PPUSH
12348: PPUSH
// for un in all_units do
12349: LD_ADDR_VAR 0 3
12353: PUSH
12354: LD_OWVAR 3
12358: PUSH
12359: FOR_IN
12360: IFFALSE 12373
// DestroyUnit ( un ) ;
12362: LD_VAR 0 3
12366: PPUSH
12367: CALL_OW 65
12371: GO 12359
12373: POP
12374: POP
// ResetFog ;
12375: CALL_OW 335
// end ;
12379: LD_VAR 0 2
12383: RET
// export function starting_hunt ; var alone , win , i ; begin
12384: LD_INT 0
12386: PPUSH
12387: PPUSH
12388: PPUSH
12389: PPUSH
// mp_selectmsg := true ;
12390: LD_ADDR_OWVAR 13
12394: PUSH
12395: LD_INT 1
12397: ST_TO_ADDR
// mp_with_score := true ;
12398: LD_ADDR_OWVAR 14
12402: PUSH
12403: LD_INT 1
12405: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
12406: CALL 8433 0 0
// your_side := Player_Side ;
12410: LD_ADDR_OWVAR 2
12414: PUSH
12415: LD_EXP 39
12419: ST_TO_ADDR
// while to_be_alone do
12420: LD_EXP 87
12424: IFFALSE 12495
// begin alone := to_be_alone [ Rand ( 1 , to_be_alone ) ] ;
12426: LD_ADDR_VAR 0 2
12430: PUSH
12431: LD_EXP 87
12435: PUSH
12436: LD_INT 1
12438: PPUSH
12439: LD_EXP 87
12443: PPUSH
12444: CALL_OW 12
12448: ARRAY
12449: ST_TO_ADDR
// to_be_alone := to_be_alone diff alone ;
12450: LD_ADDR_EXP 87
12454: PUSH
12455: LD_EXP 87
12459: PUSH
12460: LD_VAR 0 2
12464: DIFF
12465: ST_TO_ADDR
// prepare_game ( alone ) ;
12466: LD_VAR 0 2
12470: PPUSH
12471: CALL 11198 0 1
// run_game ( alone ) ;
12475: LD_VAR 0 2
12479: PPUSH
12480: CALL 11446 0 1
// close_game ( alone ) ;
12484: LD_VAR 0 2
12488: PPUSH
12489: CALL 12345 0 1
// end ;
12493: GO 12420
// display_score ( 0 , 0 ) ;
12495: LD_INT 0
12497: PPUSH
12498: LD_INT 0
12500: PPUSH
12501: CALL 9772 0 2
// wait ( 0 0$5 ) ;
12505: LD_INT 175
12507: PPUSH
12508: CALL_OW 67
// win := true ;
12512: LD_ADDR_VAR 0 3
12516: PUSH
12517: LD_INT 1
12519: ST_TO_ADDR
// for i := 1 to 8 do
12520: LD_ADDR_VAR 0 4
12524: PUSH
12525: DOUBLE
12526: LD_INT 1
12528: DEC
12529: ST_TO_ADDR
12530: LD_INT 8
12532: PUSH
12533: FOR_TO
12534: IFFALSE 12568
// if GetMultiScore ( i ) > GetMultiScore ( your_side ) then
12536: LD_VAR 0 4
12540: PPUSH
12541: CALL_OW 507
12545: PUSH
12546: LD_OWVAR 2
12550: PPUSH
12551: CALL_OW 507
12555: GREATER
12556: IFFALSE 12566
// win := false ;
12558: LD_ADDR_VAR 0 3
12562: PUSH
12563: LD_INT 0
12565: ST_TO_ADDR
12566: GO 12533
12568: POP
12569: POP
// if win then
12570: LD_VAR 0 3
12574: IFFALSE 12582
// YouWinInMultiplayer else
12576: CALL_OW 106
12580: GO 12586
// YouLostInMultiplayer ;
12582: CALL_OW 107
// end ; end_of_file
12586: LD_VAR 0 1
12590: RET
// export to_be_countdowned ; every 0 0$0.2 trigger to_be_countdowned marked 25 do var who , timer ;
12591: LD_EXP 90
12595: IFFALSE 12766
12597: GO 12599
12599: DISABLE
12600: LD_INT 0
12602: PPUSH
12603: PPUSH
// begin enable ;
12604: ENABLE
// who := to_be_countdowned [ 1 ] ;
12605: LD_ADDR_VAR 0 1
12609: PUSH
12610: LD_EXP 90
12614: PUSH
12615: LD_INT 1
12617: ARRAY
12618: ST_TO_ADDR
// to_be_countdowned := Delete ( to_be_countdowned , 1 ) ;
12619: LD_ADDR_EXP 90
12623: PUSH
12624: LD_EXP 90
12628: PPUSH
12629: LD_INT 1
12631: PPUSH
12632: CALL_OW 3
12636: ST_TO_ADDR
// repeat timer := GetTag ( who ) ;
12637: LD_ADDR_VAR 0 2
12641: PUSH
12642: LD_VAR 0 1
12646: PPUSH
12647: CALL_OW 110
12651: ST_TO_ADDR
// if GetSide ( who ) = your_side then
12652: LD_VAR 0 1
12656: PPUSH
12657: CALL_OW 255
12661: PUSH
12662: LD_OWVAR 2
12666: EQUAL
12667: IFFALSE 12683
// SetUnitDisplayNumber ( who , timer ) ;
12669: LD_VAR 0 1
12673: PPUSH
12674: LD_VAR 0 2
12678: PPUSH
12679: CALL_OW 505
// timer := timer - 1 ;
12683: LD_ADDR_VAR 0 2
12687: PUSH
12688: LD_VAR 0 2
12692: PUSH
12693: LD_INT 1
12695: MINUS
12696: ST_TO_ADDR
// SetTag ( who , timer ) ;
12697: LD_VAR 0 1
12701: PPUSH
12702: LD_VAR 0 2
12706: PPUSH
12707: CALL_OW 109
// wait ( 0 0$1 ) ;
12711: LD_INT 35
12713: PPUSH
12714: CALL_OW 67
// until not IsLive ( who ) or not GetTag ( who ) ;
12718: LD_VAR 0 1
12722: PPUSH
12723: CALL_OW 300
12727: NOT
12728: PUSH
12729: LD_VAR 0 1
12733: PPUSH
12734: CALL_OW 110
12738: NOT
12739: OR
12740: IFFALSE 12637
// if not GetTag ( who ) then
12742: LD_VAR 0 1
12746: PPUSH
12747: CALL_OW 110
12751: NOT
12752: IFFALSE 12766
// SetLives ( who , 0 ) ;
12754: LD_VAR 0 1
12758: PPUSH
12759: LD_INT 0
12761: PPUSH
12762: CALL_OW 234
// end ;
12766: PPOPN 2
12768: END
// every 0 0$0.5 + 0 0$0.05 marked 25 do var un , veh ;
12769: GO 12771
12771: DISABLE
12772: LD_INT 0
12774: PPUSH
12775: PPUSH
// begin veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , f_not , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12776: LD_ADDR_VAR 0 2
12780: PUSH
12781: LD_INT 20
12783: PPUSH
12784: LD_INT 21
12786: PUSH
12787: LD_INT 2
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 3
12796: PUSH
12797: LD_INT 58
12799: PUSH
12800: EMPTY
12801: LIST
12802: PUSH
12803: LD_INT 3
12805: PUSH
12806: LD_INT 22
12808: PUSH
12809: LD_INT 0
12811: PUSH
12812: EMPTY
12813: LIST
12814: LIST
12815: PUSH
12816: EMPTY
12817: LIST
12818: LIST
12819: LIST
12820: LIST
12821: LIST
12822: PPUSH
12823: CALL_OW 70
12827: ST_TO_ADDR
// for un in veh do
12828: LD_ADDR_VAR 0 1
12832: PUSH
12833: LD_VAR 0 2
12837: PUSH
12838: FOR_IN
12839: IFFALSE 12852
// ComExitVehicle ( veh ) ;
12841: LD_VAR 0 2
12845: PPUSH
12846: CALL_OW 121
12850: GO 12838
12852: POP
12853: POP
// veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12854: LD_ADDR_VAR 0 2
12858: PUSH
12859: LD_INT 20
12861: PPUSH
12862: LD_INT 21
12864: PUSH
12865: LD_INT 2
12867: PUSH
12868: EMPTY
12869: LIST
12870: LIST
12871: PUSH
12872: LD_INT 58
12874: PUSH
12875: EMPTY
12876: LIST
12877: PUSH
12878: LD_INT 3
12880: PUSH
12881: LD_INT 22
12883: PUSH
12884: LD_INT 0
12886: PUSH
12887: EMPTY
12888: LIST
12889: LIST
12890: PUSH
12891: EMPTY
12892: LIST
12893: LIST
12894: LIST
12895: LIST
12896: PPUSH
12897: CALL_OW 70
12901: ST_TO_ADDR
// for un in veh do
12902: LD_ADDR_VAR 0 1
12906: PUSH
12907: LD_VAR 0 2
12911: PUSH
12912: FOR_IN
12913: IFFALSE 12968
// begin SetMultiScore ( GetSide ( un ) , GetMultiScore ( GetSide ( un ) ) + 1 ) ;
12915: LD_VAR 0 1
12919: PPUSH
12920: CALL_OW 255
12924: PPUSH
12925: LD_VAR 0 1
12929: PPUSH
12930: CALL_OW 255
12934: PPUSH
12935: CALL_OW 507
12939: PUSH
12940: LD_INT 1
12942: PLUS
12943: PPUSH
12944: CALL_OW 506
// RemoveUnit ( un ) ;
12948: LD_VAR 0 1
12952: PPUSH
12953: CALL_OW 64
// DestroyUnit ( un ) ;
12957: LD_VAR 0 1
12961: PPUSH
12962: CALL_OW 65
// end ;
12966: GO 12912
12968: POP
12969: POP
// enable ;
12970: ENABLE
// end ;
12971: PPOPN 2
12973: END
// every 0 0$1 + 0 0$0.1 marked 25 do var i , best , nbest , lastbest , s , first , n ;
12974: GO 12976
12976: DISABLE
12977: LD_INT 0
12979: PPUSH
12980: PPUSH
12981: PPUSH
12982: PPUSH
12983: PPUSH
12984: PPUSH
12985: PPUSH
// begin lastbest := 99999 ;
12986: LD_ADDR_VAR 0 4
12990: PUSH
12991: LD_INT 99999
12993: ST_TO_ADDR
// s := [ ] ;
12994: LD_ADDR_VAR 0 5
12998: PUSH
12999: EMPTY
13000: ST_TO_ADDR
// n := 1 ;
13001: LD_ADDR_VAR 0 7
13005: PUSH
13006: LD_INT 1
13008: ST_TO_ADDR
// repeat best := - 99999 ;
13009: LD_ADDR_VAR 0 2
13013: PUSH
13014: LD_INT 99999
13016: NEG
13017: ST_TO_ADDR
// nbest := 0 ;
13018: LD_ADDR_VAR 0 3
13022: PUSH
13023: LD_INT 0
13025: ST_TO_ADDR
// for i := 1 to 8 do
13026: LD_ADDR_VAR 0 1
13030: PUSH
13031: DOUBLE
13032: LD_INT 1
13034: DEC
13035: ST_TO_ADDR
13036: LD_INT 8
13038: PUSH
13039: FOR_TO
13040: IFFALSE 13146
// if Side_Positions [ i ] then
13042: LD_EXP 43
13046: PUSH
13047: LD_VAR 0 1
13051: ARRAY
13052: IFFALSE 13144
// begin if ( GetMultiScore ( i ) > best ) and ( GetMultiScore ( i ) < lastbest ) then
13054: LD_VAR 0 1
13058: PPUSH
13059: CALL_OW 507
13063: PUSH
13064: LD_VAR 0 2
13068: GREATER
13069: PUSH
13070: LD_VAR 0 1
13074: PPUSH
13075: CALL_OW 507
13079: PUSH
13080: LD_VAR 0 4
13084: LESS
13085: AND
13086: IFFALSE 13113
// begin best := GetMultiScore ( i ) ;
13088: LD_ADDR_VAR 0 2
13092: PUSH
13093: LD_VAR 0 1
13097: PPUSH
13098: CALL_OW 507
13102: ST_TO_ADDR
// nbest := 1 ;
13103: LD_ADDR_VAR 0 3
13107: PUSH
13108: LD_INT 1
13110: ST_TO_ADDR
// end else
13111: GO 13144
// if GetMultiScore ( i ) = best then
13113: LD_VAR 0 1
13117: PPUSH
13118: CALL_OW 507
13122: PUSH
13123: LD_VAR 0 2
13127: EQUAL
13128: IFFALSE 13144
// begin nbest := nbest + 1 ;
13130: LD_ADDR_VAR 0 3
13134: PUSH
13135: LD_VAR 0 3
13139: PUSH
13140: LD_INT 1
13142: PLUS
13143: ST_TO_ADDR
// end ; end ;
13144: GO 13039
13146: POP
13147: POP
// first := true ;
13148: LD_ADDR_VAR 0 6
13152: PUSH
13153: LD_INT 1
13155: ST_TO_ADDR
// if nbest > 0 then
13156: LD_VAR 0 3
13160: PUSH
13161: LD_INT 0
13163: GREATER
13164: IFFALSE 13337
// for i := 1 to 8 do
13166: LD_ADDR_VAR 0 1
13170: PUSH
13171: DOUBLE
13172: LD_INT 1
13174: DEC
13175: ST_TO_ADDR
13176: LD_INT 8
13178: PUSH
13179: FOR_TO
13180: IFFALSE 13335
// if Side_Positions [ i ] then
13182: LD_EXP 43
13186: PUSH
13187: LD_VAR 0 1
13191: ARRAY
13192: IFFALSE 13333
// if GetMultiScore ( i ) = best then
13194: LD_VAR 0 1
13198: PPUSH
13199: CALL_OW 507
13203: PUSH
13204: LD_VAR 0 2
13208: EQUAL
13209: IFFALSE 13333
// if nbest = 1 then
13211: LD_VAR 0 3
13215: PUSH
13216: LD_INT 1
13218: EQUAL
13219: IFFALSE 13270
// s := s ^ [ #Multi-score , n , i , i , i , best ] else
13221: LD_ADDR_VAR 0 5
13225: PUSH
13226: LD_VAR 0 5
13230: PUSH
13231: LD_STRING #Multi-score
13233: PUSH
13234: LD_VAR 0 7
13238: PUSH
13239: LD_VAR 0 1
13243: PUSH
13244: LD_VAR 0 1
13248: PUSH
13249: LD_VAR 0 1
13253: PUSH
13254: LD_VAR 0 2
13258: PUSH
13259: EMPTY
13260: LIST
13261: LIST
13262: LIST
13263: LIST
13264: LIST
13265: LIST
13266: ADD
13267: ST_TO_ADDR
13268: GO 13333
// s := s ^ [ #Multi-score-range , n , n + nbest - 1 , i , i , i , best ] ;
13270: LD_ADDR_VAR 0 5
13274: PUSH
13275: LD_VAR 0 5
13279: PUSH
13280: LD_STRING #Multi-score-range
13282: PUSH
13283: LD_VAR 0 7
13287: PUSH
13288: LD_VAR 0 7
13292: PUSH
13293: LD_VAR 0 3
13297: PLUS
13298: PUSH
13299: LD_INT 1
13301: MINUS
13302: PUSH
13303: LD_VAR 0 1
13307: PUSH
13308: LD_VAR 0 1
13312: PUSH
13313: LD_VAR 0 1
13317: PUSH
13318: LD_VAR 0 2
13322: PUSH
13323: EMPTY
13324: LIST
13325: LIST
13326: LIST
13327: LIST
13328: LIST
13329: LIST
13330: LIST
13331: ADD
13332: ST_TO_ADDR
13333: GO 13179
13335: POP
13336: POP
// n := n + nbest ;
13337: LD_ADDR_VAR 0 7
13341: PUSH
13342: LD_VAR 0 7
13346: PUSH
13347: LD_VAR 0 3
13351: PLUS
13352: ST_TO_ADDR
// lastbest := best ;
13353: LD_ADDR_VAR 0 4
13357: PUSH
13358: LD_VAR 0 2
13362: ST_TO_ADDR
// until nbest = 0 ;
13363: LD_VAR 0 3
13367: PUSH
13368: LD_INT 0
13370: EQUAL
13371: IFFALSE 13009
// if game_time then
13373: LD_EXP 56
13377: IFFALSE 13412
// s := [ #Hunt-Limit , 0 , game_time - tick ] ^ s ;
13379: LD_ADDR_VAR 0 5
13383: PUSH
13384: LD_STRING #Hunt-Limit
13386: PUSH
13387: LD_INT 0
13389: PUSH
13390: LD_EXP 56
13394: PUSH
13395: LD_OWVAR 1
13399: MINUS
13400: PUSH
13401: EMPTY
13402: LIST
13403: LIST
13404: LIST
13405: PUSH
13406: LD_VAR 0 5
13410: ADD
13411: ST_TO_ADDR
// display_strings := s ;
13412: LD_ADDR_OWVAR 47
13416: PUSH
13417: LD_VAR 0 5
13421: ST_TO_ADDR
// enable ;
13422: ENABLE
// end ;
13423: PPOPN 7
13425: END
// every 0 0$1 marked 25 do var veh ;
13426: GO 13428
13428: DISABLE
13429: LD_INT 0
13431: PPUSH
// begin repeat repeat veh := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
13432: LD_ADDR_VAR 0 1
13436: PUSH
13437: LD_INT 21
13439: PUSH
13440: LD_INT 2
13442: PUSH
13443: EMPTY
13444: LIST
13445: LIST
13446: PPUSH
13447: CALL_OW 69
13451: ST_TO_ADDR
// wait ( 0 0$3 ) ;
13452: LD_INT 105
13454: PPUSH
13455: CALL_OW 67
// until veh < vehmax ;
13459: LD_VAR 0 1
13463: PUSH
13464: LD_EXP 61
13468: LESS
13469: IFFALSE 13432
// wait ( Rand ( vehresp [ 1 ] div side_count , vehresp [ 2 ] div side_count ) ) ;
13471: LD_EXP 58
13475: PUSH
13476: LD_INT 1
13478: ARRAY
13479: PUSH
13480: LD_EXP 37
13484: DIV
13485: PPUSH
13486: LD_EXP 58
13490: PUSH
13491: LD_INT 2
13493: ARRAY
13494: PUSH
13495: LD_EXP 37
13499: DIV
13500: PPUSH
13501: CALL_OW 12
13505: PPUSH
13506: CALL_OW 67
// vehicles_create_vehicle ( false ) ;
13510: LD_INT 0
13512: PPUSH
13513: CALL 6885 0 1
// until false ;
13517: LD_INT 0
13519: IFFALSE 13432
// end ;
13521: PPOPN 1
13523: END
// every 3 marked 25 do var side , peop ;
13524: GO 13526
13526: DISABLE
13527: LD_INT 0
13529: PPUSH
13530: PPUSH
// begin if not to_resp then
13531: LD_EXP 69
13535: NOT
13536: IFFALSE 13540
// exit ;
13538: GO 13741
// enable ;
13540: ENABLE
// side := to_resp [ 1 ] ;
13541: LD_ADDR_VAR 0 1
13545: PUSH
13546: LD_EXP 69
13550: PUSH
13551: LD_INT 1
13553: ARRAY
13554: ST_TO_ADDR
// to_resp := Delete ( to_resp , 1 ) ;
13555: LD_ADDR_EXP 69
13559: PUSH
13560: LD_EXP 69
13564: PPUSH
13565: LD_INT 1
13567: PPUSH
13568: CALL_OW 3
13572: ST_TO_ADDR
// repeat repeat peop := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_side , side ] , [ f_ok ] ] ) ;
13573: LD_ADDR_VAR 0 2
13577: PUSH
13578: LD_INT 21
13580: PUSH
13581: LD_INT 1
13583: PUSH
13584: EMPTY
13585: LIST
13586: LIST
13587: PUSH
13588: LD_INT 22
13590: PUSH
13591: LD_VAR 0 1
13595: PUSH
13596: EMPTY
13597: LIST
13598: LIST
13599: PUSH
13600: LD_INT 50
13602: PUSH
13603: EMPTY
13604: LIST
13605: PUSH
13606: EMPTY
13607: LIST
13608: LIST
13609: LIST
13610: PPUSH
13611: CALL_OW 69
13615: ST_TO_ADDR
// wait ( 0 0$5 ) ;
13616: LD_INT 175
13618: PPUSH
13619: CALL_OW 67
// until peop < npeop ;
13623: LD_VAR 0 2
13627: PUSH
13628: LD_EXP 65
13632: LESS
13633: IFFALSE 13573
// wait ( Rand ( peopresp [ 1 ] , peopresp [ 2 ] ) ) ;
13635: LD_EXP 66
13639: PUSH
13640: LD_INT 1
13642: ARRAY
13643: PPUSH
13644: LD_EXP 66
13648: PUSH
13649: LD_INT 2
13651: ARRAY
13652: PPUSH
13653: CALL_OW 12
13657: PPUSH
13658: CALL_OW 67
// uc_side := side ;
13662: LD_ADDR_OWVAR 20
13666: PUSH
13667: LD_VAR 0 1
13671: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
13672: LD_ADDR_OWVAR 21
13676: PUSH
13677: LD_EXP 44
13681: PUSH
13682: LD_VAR 0 1
13686: ARRAY
13687: ST_TO_ADDR
// hc_name :=  ;
13688: LD_ADDR_OWVAR 26
13692: PUSH
13693: LD_STRING 
13695: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
13696: LD_INT 0
13698: PPUSH
13699: LD_INT 4
13701: PPUSH
13702: CALL_OW 383
// hc_importance := 0 ;
13706: LD_ADDR_OWVAR 32
13710: PUSH
13711: LD_INT 0
13713: ST_TO_ADDR
// hc_gallery :=  ;
13714: LD_ADDR_OWVAR 33
13718: PUSH
13719: LD_STRING 
13721: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , arstartveh , true ) ;
13722: CALL_OW 44
13726: PPUSH
13727: LD_INT 21
13729: PPUSH
13730: LD_INT 1
13732: PPUSH
13733: CALL_OW 49
// until false ;
13737: LD_INT 0
13739: IFFALSE 13573
// end ;
13741: PPOPN 2
13743: END
// on siberiterocketexploded ( un , x , y ) do SA_OnSiberiteRocketExploded ( un , x , y , Your_Side ) ; end_of_file
13744: LD_VAR 0 1
13748: PPUSH
13749: LD_VAR 0 2
13753: PPUSH
13754: LD_VAR 0 3
13758: PPUSH
13759: LD_OWVAR 2
13763: PPUSH
13764: CALL 14721 0 4
13768: PPOPN 3
13770: END
// every 10 do
13771: GO 13773
13773: DISABLE
// begin if not multiplayer then
13774: LD_OWVAR 4
13778: NOT
13779: IFFALSE 13783
// exit ;
13781: GO 13840
// if ( tick >= 100 ) then
13783: LD_OWVAR 1
13787: PUSH
13788: LD_INT 100
13790: GREATEREQUAL
13791: IFFALSE 13811
// if tick mod 20 = 0 then
13793: LD_OWVAR 1
13797: PUSH
13798: LD_INT 20
13800: MOD
13801: PUSH
13802: LD_INT 0
13804: EQUAL
13805: IFFALSE 13811
// MultiplayerCRC ;
13807: CALL_OW 361
// if ( tick >= 100 ) then
13811: LD_OWVAR 1
13815: PUSH
13816: LD_INT 100
13818: GREATEREQUAL
13819: IFFALSE 13839
// if tick mod 30 = 0 then
13821: LD_OWVAR 1
13825: PUSH
13826: LD_INT 30
13828: MOD
13829: PUSH
13830: LD_INT 0
13832: EQUAL
13833: IFFALSE 13839
// DebugLogAll ;
13835: CALL_OW 360
// enable ;
13839: ENABLE
// end ; end_of_file
13840: END
// export Side_Comps ; export nonCombat , siberite_rocket ; every 1 do
13841: GO 13843
13843: DISABLE
// begin if GetMultiplayerSetting ( 49 ) or iseditor then
13844: LD_INT 49
13846: PPUSH
13847: CALL_OW 426
13851: PUSH
13852: LD_OWVAR 84
13856: OR
13857: IFFALSE 13866
// fogoff ( true ) ;
13859: LD_INT 1
13861: PPUSH
13862: CALL_OW 344
// disable ( 125 ) ;
13866: LD_INT 125
13868: DISABLE_MARKED
// Start_VehicleAI ;
13869: CALL 13874 0 0
// end ;
13873: END
// function Start_VehicleAI ; var i , k ; begin
13874: LD_INT 0
13876: PPUSH
13877: PPUSH
13878: PPUSH
// if multiplayer then
13879: LD_OWVAR 4
13883: IFFALSE 13897
// Side_Comps = mp_sides_comps else
13885: LD_ADDR_EXP 91
13889: PUSH
13890: CALL 14039 0 0
13894: ST_TO_ADDR
13895: GO 13936
// side_comps = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ;
13897: LD_ADDR_EXP 91
13901: PUSH
13902: LD_INT 1
13904: PUSH
13905: LD_INT 1
13907: PUSH
13908: LD_INT 1
13910: PUSH
13911: LD_INT 1
13913: PUSH
13914: LD_INT 1
13916: PUSH
13917: LD_INT 1
13919: PUSH
13920: LD_INT 1
13922: PUSH
13923: LD_INT 1
13925: PUSH
13926: EMPTY
13927: LIST
13928: LIST
13929: LIST
13930: LIST
13931: LIST
13932: LIST
13933: LIST
13934: LIST
13935: ST_TO_ADDR
// k = false ;
13936: LD_ADDR_VAR 0 3
13940: PUSH
13941: LD_INT 0
13943: ST_TO_ADDR
// for i in side_comps do
13944: LD_ADDR_VAR 0 2
13948: PUSH
13949: LD_EXP 91
13953: PUSH
13954: FOR_IN
13955: IFFALSE 13973
// if i then
13957: LD_VAR 0 2
13961: IFFALSE 13971
// k = true ;
13963: LD_ADDR_VAR 0 3
13967: PUSH
13968: LD_INT 1
13970: ST_TO_ADDR
13971: GO 13954
13973: POP
13974: POP
// nonCombat = [ us_radar , us_bulldozer , us_siberium_rocket_remainder , ar_radar , ar_selfpropelled_bomb , ru_bulldozer , ru_siberium_rocket_remainder ] ;
13975: LD_ADDR_EXP 92
13979: PUSH
13980: LD_INT 11
13982: PUSH
13983: LD_INT 14
13985: PUSH
13986: LD_INT 15
13988: PUSH
13989: LD_INT 30
13991: PUSH
13992: LD_INT 29
13994: PUSH
13995: LD_INT 53
13997: PUSH
13998: LD_INT 55
14000: PUSH
14001: EMPTY
14002: LIST
14003: LIST
14004: LIST
14005: LIST
14006: LIST
14007: LIST
14008: LIST
14009: ST_TO_ADDR
// Siberite_Rocket = [ us_siberium_rocket , ru_siberium_rocket ] ;
14010: LD_ADDR_EXP 93
14014: PUSH
14015: LD_INT 8
14017: PUSH
14018: LD_INT 48
14020: PUSH
14021: EMPTY
14022: LIST
14023: LIST
14024: ST_TO_ADDR
// if k then
14025: LD_VAR 0 3
14029: IFFALSE 14034
// enable ( 125 ) ;
14031: LD_INT 125
14033: ENABLE_MARKED
// end ;
14034: LD_VAR 0 1
14038: RET
// function mp_sides_comps ; var c , i ; begin
14039: LD_INT 0
14041: PPUSH
14042: PPUSH
14043: PPUSH
// c = [ ] ;
14044: LD_ADDR_VAR 0 2
14048: PUSH
14049: EMPTY
14050: ST_TO_ADDR
// for i = 1 to 8 do
14051: LD_ADDR_VAR 0 3
14055: PUSH
14056: DOUBLE
14057: LD_INT 1
14059: DEC
14060: ST_TO_ADDR
14061: LD_INT 8
14063: PUSH
14064: FOR_TO
14065: IFFALSE 14090
// c = c ^ Multiplayer_GetPlayerIsComp ( i ) ;
14067: LD_ADDR_VAR 0 2
14071: PUSH
14072: LD_VAR 0 2
14076: PUSH
14077: LD_VAR 0 3
14081: PPUSH
14082: CALL_OW 532
14086: ADD
14087: ST_TO_ADDR
14088: GO 14064
14090: POP
14091: POP
// result = c ;
14092: LD_ADDR_VAR 0 1
14096: PUSH
14097: LD_VAR 0 2
14101: ST_TO_ADDR
// end ;
14102: LD_VAR 0 1
14106: RET
// every 0 0$1 marked 125 do var units , u , veh , k , c , i , hex ;
14107: GO 14109
14109: DISABLE
14110: LD_INT 0
14112: PPUSH
14113: PPUSH
14114: PPUSH
14115: PPUSH
14116: PPUSH
14117: PPUSH
14118: PPUSH
// begin units = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_human ] ] ) ;
14119: LD_ADDR_VAR 0 1
14123: PUSH
14124: LD_INT 52
14126: PUSH
14127: EMPTY
14128: LIST
14129: PUSH
14130: LD_INT 50
14132: PUSH
14133: EMPTY
14134: LIST
14135: PUSH
14136: LD_INT 21
14138: PUSH
14139: LD_INT 1
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: LIST
14150: PPUSH
14151: CALL_OW 69
14155: ST_TO_ADDR
// k = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
14156: LD_ADDR_VAR 0 4
14160: PUSH
14161: LD_INT 52
14163: PUSH
14164: EMPTY
14165: LIST
14166: PUSH
14167: LD_INT 50
14169: PUSH
14170: EMPTY
14171: LIST
14172: PUSH
14173: LD_INT 21
14175: PUSH
14176: LD_INT 2
14178: PUSH
14179: EMPTY
14180: LIST
14181: LIST
14182: PUSH
14183: LD_INT 58
14185: PUSH
14186: EMPTY
14187: LIST
14188: PUSH
14189: EMPTY
14190: LIST
14191: LIST
14192: LIST
14193: LIST
14194: PPUSH
14195: CALL_OW 69
14199: ST_TO_ADDR
// for u in units do
14200: LD_ADDR_VAR 0 2
14204: PUSH
14205: LD_VAR 0 1
14209: PUSH
14210: FOR_IN
14211: IFFALSE 14282
// if getSide ( u ) = 0 then
14213: LD_VAR 0 2
14217: PPUSH
14218: CALL_OW 255
14222: PUSH
14223: LD_INT 0
14225: EQUAL
14226: IFFALSE 14246
// units = units diff u else
14228: LD_ADDR_VAR 0 1
14232: PUSH
14233: LD_VAR 0 1
14237: PUSH
14238: LD_VAR 0 2
14242: DIFF
14243: ST_TO_ADDR
14244: GO 14280
// if not Side_Comps [ getSide ( u ) ] then
14246: LD_EXP 91
14250: PUSH
14251: LD_VAR 0 2
14255: PPUSH
14256: CALL_OW 255
14260: ARRAY
14261: NOT
14262: IFFALSE 14280
// units = units diff u ;
14264: LD_ADDR_VAR 0 1
14268: PUSH
14269: LD_VAR 0 1
14273: PUSH
14274: LD_VAR 0 2
14278: DIFF
14279: ST_TO_ADDR
14280: GO 14210
14282: POP
14283: POP
// for u in units do
14284: LD_ADDR_VAR 0 2
14288: PUSH
14289: LD_VAR 0 1
14293: PUSH
14294: FOR_IN
14295: IFFALSE 14715
// begin if isinunit ( u ) then
14297: LD_VAR 0 2
14301: PPUSH
14302: CALL_OW 310
14306: IFFALSE 14523
// begin veh = isinunit ( u ) ;
14308: LD_ADDR_VAR 0 3
14312: PUSH
14313: LD_VAR 0 2
14317: PPUSH
14318: CALL_OW 310
14322: ST_TO_ADDR
// if not HasTask ( veh ) then
14323: LD_VAR 0 3
14327: PPUSH
14328: CALL_OW 314
14332: NOT
14333: IFFALSE 14521
// begin if getWeapon ( veh ) in nonCombat then
14335: LD_VAR 0 3
14339: PPUSH
14340: CALL_OW 264
14344: PUSH
14345: LD_EXP 92
14349: IN
14350: IFFALSE 14366
// comMoveToArea ( veh , exitarea ) else
14352: LD_VAR 0 3
14356: PPUSH
14357: LD_INT 20
14359: PPUSH
14360: CALL_OW 113
14364: GO 14521
// if getWeapon ( veh ) in Siberite_Rocket then
14366: LD_VAR 0 3
14370: PPUSH
14371: CALL_OW 264
14375: PUSH
14376: LD_EXP 93
14380: IN
14381: IFFALSE 14437
// begin hex = RandHex ( false ) ;
14383: LD_ADDR_VAR 0 7
14387: PUSH
14388: LD_INT 0
14390: PPUSH
14391: CALL_OW 15
14395: ST_TO_ADDR
// ComAttackPlace ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14396: LD_VAR 0 3
14400: PPUSH
14401: LD_VAR 0 7
14405: PUSH
14406: LD_INT 1
14408: ARRAY
14409: PPUSH
14410: LD_VAR 0 7
14414: PUSH
14415: LD_INT 2
14417: ARRAY
14418: PPUSH
14419: CALL_OW 116
// AddComMoveToArea ( veh , exitarea ) ;
14423: LD_VAR 0 3
14427: PPUSH
14428: LD_INT 20
14430: PPUSH
14431: CALL_OW 173
// end else
14435: GO 14521
// if getLives ( veh ) <= hranice_zraneni then
14437: LD_VAR 0 3
14441: PPUSH
14442: CALL_OW 256
14446: PUSH
14447: LD_INT 500
14449: LESSEQUAL
14450: IFFALSE 14466
// comMoveToArea ( veh , exitarea ) else
14452: LD_VAR 0 3
14456: PPUSH
14457: LD_INT 20
14459: PPUSH
14460: CALL_OW 113
14464: GO 14521
// begin hex = RandHexArea ( exitarea , false ) ;
14466: LD_ADDR_VAR 0 7
14470: PUSH
14471: LD_INT 20
14473: PPUSH
14474: LD_INT 0
14476: PPUSH
14477: CALL_OW 16
14481: ST_TO_ADDR
// comAgressiveMove ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14482: LD_VAR 0 3
14486: PPUSH
14487: LD_VAR 0 7
14491: PUSH
14492: LD_INT 1
14494: ARRAY
14495: PPUSH
14496: LD_VAR 0 7
14500: PUSH
14501: LD_INT 2
14503: ARRAY
14504: PPUSH
14505: CALL_OW 114
// AddComMoveToArea ( veh , exitarea ) ;
14509: LD_VAR 0 3
14513: PPUSH
14514: LD_INT 20
14516: PPUSH
14517: CALL_OW 173
// end ; end ; end else
14521: GO 14706
// begin if not HasTask ( u ) then
14523: LD_VAR 0 2
14527: PPUSH
14528: CALL_OW 314
14532: NOT
14533: IFFALSE 14577
// begin hex = RandHex ( false ) ;
14535: LD_ADDR_VAR 0 7
14539: PUSH
14540: LD_INT 0
14542: PPUSH
14543: CALL_OW 15
14547: ST_TO_ADDR
// ComMoveXY ( u , hex [ 1 ] , hex [ 2 ] ) ;
14548: LD_VAR 0 2
14552: PPUSH
14553: LD_VAR 0 7
14557: PUSH
14558: LD_INT 1
14560: ARRAY
14561: PPUSH
14562: LD_VAR 0 7
14566: PUSH
14567: LD_INT 2
14569: ARRAY
14570: PPUSH
14571: CALL_OW 111
// end else
14575: GO 14706
// begin c = [ ] ;
14577: LD_ADDR_VAR 0 5
14581: PUSH
14582: EMPTY
14583: ST_TO_ADDR
// for i in k do
14584: LD_ADDR_VAR 0 6
14588: PUSH
14589: LD_VAR 0 4
14593: PUSH
14594: FOR_IN
14595: IFFALSE 14636
// if See ( getSide ( u ) , i ) then
14597: LD_VAR 0 2
14601: PPUSH
14602: CALL_OW 255
14606: PPUSH
14607: LD_VAR 0 6
14611: PPUSH
14612: CALL_OW 292
14616: IFFALSE 14634
// c = c ^ i ;
14618: LD_ADDR_VAR 0 5
14622: PUSH
14623: LD_VAR 0 5
14627: PUSH
14628: LD_VAR 0 6
14632: ADD
14633: ST_TO_ADDR
14634: GO 14594
14636: POP
14637: POP
// if c + 0 > 0 then
14638: LD_VAR 0 5
14642: PUSH
14643: LD_INT 0
14645: PLUS
14646: PUSH
14647: LD_INT 0
14649: GREATER
14650: IFFALSE 14706
// begin c = NearestUnitToUnit ( c , u ) ;
14652: LD_ADDR_VAR 0 5
14656: PUSH
14657: LD_VAR 0 5
14661: PPUSH
14662: LD_VAR 0 2
14666: PPUSH
14667: CALL_OW 74
14671: ST_TO_ADDR
// if GetDistUnits ( u , c ) < 10 then
14672: LD_VAR 0 2
14676: PPUSH
14677: LD_VAR 0 5
14681: PPUSH
14682: CALL_OW 296
14686: PUSH
14687: LD_INT 10
14689: LESS
14690: IFFALSE 14706
// comEnterUnit ( u , c ) ;
14692: LD_VAR 0 2
14696: PPUSH
14697: LD_VAR 0 5
14701: PPUSH
14702: CALL_OW 120
// end ; end ; end ; wait ( 1 ) ;
14706: LD_INT 1
14708: PPUSH
14709: CALL_OW 67
// end ;
14713: GO 14294
14715: POP
14716: POP
// enable ;
14717: ENABLE
// end ; end_of_file
14718: PPOPN 7
14720: END
// export function SA_OnSiberiteRocketExploded ( siberite_rocket_vehicle , target_x , target_y , requestSide ) ; begin
14721: LD_INT 0
14723: PPUSH
// if GetSide ( siberite_rocket_vehicle ) = requestSide then
14724: LD_VAR 0 1
14728: PPUSH
14729: CALL_OW 255
14733: PUSH
14734: LD_VAR 0 4
14738: EQUAL
14739: IFFALSE 14758
// begin SetAchievement ( ACH_RAD ) ;
14741: LD_STRING ACH_RAD
14743: PPUSH
14744: CALL_OW 543
// SetAchievementEx ( ACH_NL , 1 ) ;
14748: LD_STRING ACH_NL
14750: PPUSH
14751: LD_INT 1
14753: PPUSH
14754: CALL_OW 564
// end end ;
14758: LD_VAR 0 5
14762: RET
// export function SA_Win ( side ) ; begin
14763: LD_INT 0
14765: PPUSH
// case side of 1 :
14766: LD_VAR 0 1
14770: PUSH
14771: LD_INT 1
14773: DOUBLE
14774: EQUAL
14775: IFTRUE 14779
14777: GO 14792
14779: POP
// SetAchievementEx ( ACH_AH , 1 ) ; 2 :
14780: LD_STRING ACH_AH
14782: PPUSH
14783: LD_INT 1
14785: PPUSH
14786: CALL_OW 564
14790: GO 14955
14792: LD_INT 2
14794: DOUBLE
14795: EQUAL
14796: IFTRUE 14800
14798: GO 14813
14800: POP
// SetAchievementEx ( ACH_E , 1 ) ; 3 :
14801: LD_STRING ACH_E
14803: PPUSH
14804: LD_INT 1
14806: PPUSH
14807: CALL_OW 564
14811: GO 14955
14813: LD_INT 3
14815: DOUBLE
14816: EQUAL
14817: IFTRUE 14821
14819: GO 14834
14821: POP
// SetAchievementEx ( ACH_OOL , 1 ) ; [ 1 , 2 ] :
14822: LD_STRING ACH_OOL
14824: PPUSH
14825: LD_INT 1
14827: PPUSH
14828: CALL_OW 564
14832: GO 14955
14834: LD_INT 1
14836: PUSH
14837: LD_INT 2
14839: PUSH
14840: EMPTY
14841: LIST
14842: LIST
14843: DOUBLE
14844: EQUAL
14845: IFTRUE 14849
14847: GO 14874
14849: POP
// begin SetAchievementEx ( ACH_AH , 0.5 ) ;
14850: LD_STRING ACH_AH
14852: PPUSH
14853: LD_REAL  5.00000000000000E-0001
14856: PPUSH
14857: CALL_OW 564
// SetAchievementEx ( ACH_E , 0.5 ) ;
14861: LD_STRING ACH_E
14863: PPUSH
14864: LD_REAL  5.00000000000000E-0001
14867: PPUSH
14868: CALL_OW 564
// end ; [ 2 , 3 ] :
14872: GO 14955
14874: LD_INT 2
14876: PUSH
14877: LD_INT 3
14879: PUSH
14880: EMPTY
14881: LIST
14882: LIST
14883: DOUBLE
14884: EQUAL
14885: IFTRUE 14889
14887: GO 14914
14889: POP
// begin SetAchievementEx ( ACH_OOL , 0.5 ) ;
14890: LD_STRING ACH_OOL
14892: PPUSH
14893: LD_REAL  5.00000000000000E-0001
14896: PPUSH
14897: CALL_OW 564
// SetAchievementEx ( ACH_E , 0.5 ) ;
14901: LD_STRING ACH_E
14903: PPUSH
14904: LD_REAL  5.00000000000000E-0001
14907: PPUSH
14908: CALL_OW 564
// end ; [ 3 , 1 ] :
14912: GO 14955
14914: LD_INT 3
14916: PUSH
14917: LD_INT 1
14919: PUSH
14920: EMPTY
14921: LIST
14922: LIST
14923: DOUBLE
14924: EQUAL
14925: IFTRUE 14929
14927: GO 14954
14929: POP
// begin SetAchievementEx ( ACH_AH , 0.5 ) ;
14930: LD_STRING ACH_AH
14932: PPUSH
14933: LD_REAL  5.00000000000000E-0001
14936: PPUSH
14937: CALL_OW 564
// SetAchievementEx ( ACH_OOL , 0.5 ) ;
14941: LD_STRING ACH_OOL
14943: PPUSH
14944: LD_REAL  5.00000000000000E-0001
14947: PPUSH
14948: CALL_OW 564
// end ; end ;
14952: GO 14955
14954: POP
// end ;
14955: LD_VAR 0 2
14959: RET
