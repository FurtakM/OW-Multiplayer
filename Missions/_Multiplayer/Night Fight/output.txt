// export Def_pocet_lidi , Def_uroven_konvoje , def_priblizna_uroven , def_cetnost_zasilek , def_mnozstvi_lozisek , def_nahodnost_lozisek , deF_viditelnost_stran , def_sib_detekce , def_obnovovaci_cas , def_pocet_opicaku , def_pocet_tygru , def_arab , def_sib_bomb ; export pocet_lidi , priblizna_uroven , initial_level , cetnost_zasilek , obnova_opic , obnova_tygru , obnovovaci_cas_min , obnovovaci_cas_max , respawning_time_delay_min , respawning_time_delay_max , pozice_ropy , pozice_sib , pozice_beden , start_def ; export Game_Type , Player_Side , Player_Team , Side_Positions , Side_Nations , Side_Teams , Teams , Side_Count , team_Count , Team_Game ; export commander ; var global_units , global_defined , soldiers_created ; function cteni_multiplayeru_a_hernich_parametru ; var strana , un , i , stran , sib , oil , loziska_ropy , loziska_sib , pozice , souradnice ; begin
   0: LD_INT 0
   2: PPUSH
   3: PPUSH
   4: PPUSH
   5: PPUSH
   6: PPUSH
   7: PPUSH
   8: PPUSH
   9: PPUSH
  10: PPUSH
  11: PPUSH
  12: PPUSH
// if MultiPlayer then
  13: LD_OWVAR 4
  17: IFFALSE 81
// begin Player_Side = mp_player_side ;
  19: LD_ADDR_EXP 29
  23: PUSH
  24: LD_OWVAR 7
  28: ST_TO_ADDR
// Player_Team = mp_player_team ;
  29: LD_ADDR_EXP 30
  33: PUSH
  34: LD_OWVAR 8
  38: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
  39: LD_ADDR_EXP 31
  43: PUSH
  44: LD_OWVAR 17
  48: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
  49: LD_ADDR_EXP 33
  53: PUSH
  54: LD_OWVAR 15
  58: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
  59: LD_ADDR_EXP 32
  63: PUSH
  64: LD_OWVAR 16
  68: ST_TO_ADDR
// Teams = mp_teams ;
  69: LD_ADDR_EXP 34
  73: PUSH
  74: LD_OWVAR 12
  78: ST_TO_ADDR
// end else
  79: GO 255
// begin Game_Type = 1 ;
  81: LD_ADDR_EXP 28
  85: PUSH
  86: LD_INT 1
  88: ST_TO_ADDR
// Player_Side = 4 ;
  89: LD_ADDR_EXP 29
  93: PUSH
  94: LD_INT 4
  96: ST_TO_ADDR
// Player_Team = 2 ;
  97: LD_ADDR_EXP 30
 101: PUSH
 102: LD_INT 2
 104: ST_TO_ADDR
// Side_Positions = [ 2 , 0 , 0 , 1 , 5 , 3 , 0 , 4 ] ;
 105: LD_ADDR_EXP 31
 109: PUSH
 110: LD_INT 2
 112: PUSH
 113: LD_INT 0
 115: PUSH
 116: LD_INT 0
 118: PUSH
 119: LD_INT 1
 121: PUSH
 122: LD_INT 5
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 0
 130: PUSH
 131: LD_INT 4
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: LIST
 140: LIST
 141: LIST
 142: LIST
 143: ST_TO_ADDR
// Side_Teams = [ 2 , 0 , 0 , 1 , 1 , 1 , 0 , 2 ] ;
 144: LD_ADDR_EXP 33
 148: PUSH
 149: LD_INT 2
 151: PUSH
 152: LD_INT 0
 154: PUSH
 155: LD_INT 0
 157: PUSH
 158: LD_INT 1
 160: PUSH
 161: LD_INT 1
 163: PUSH
 164: LD_INT 1
 166: PUSH
 167: LD_INT 0
 169: PUSH
 170: LD_INT 2
 172: PUSH
 173: EMPTY
 174: LIST
 175: LIST
 176: LIST
 177: LIST
 178: LIST
 179: LIST
 180: LIST
 181: LIST
 182: ST_TO_ADDR
// Side_Nations = [ 2 , 0 , 0 , 1 , 3 , 2 , 0 , 2 ] ;
 183: LD_ADDR_EXP 32
 187: PUSH
 188: LD_INT 2
 190: PUSH
 191: LD_INT 0
 193: PUSH
 194: LD_INT 0
 196: PUSH
 197: LD_INT 1
 199: PUSH
 200: LD_INT 3
 202: PUSH
 203: LD_INT 2
 205: PUSH
 206: LD_INT 0
 208: PUSH
 209: LD_INT 2
 211: PUSH
 212: EMPTY
 213: LIST
 214: LIST
 215: LIST
 216: LIST
 217: LIST
 218: LIST
 219: LIST
 220: LIST
 221: ST_TO_ADDR
// Teams = [ [ 4 , 6 , 5 ] , [ 1 , 8 ] ] ;
 222: LD_ADDR_EXP 34
 226: PUSH
 227: LD_INT 4
 229: PUSH
 230: LD_INT 6
 232: PUSH
 233: LD_INT 5
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: LIST
 240: PUSH
 241: LD_INT 1
 243: PUSH
 244: LD_INT 8
 246: PUSH
 247: EMPTY
 248: LIST
 249: LIST
 250: PUSH
 251: EMPTY
 252: LIST
 253: LIST
 254: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
 255: LD_ADDR_EXP 35
 259: PUSH
 260: LD_EXP 31
 264: PUSH
 265: LD_INT 0
 267: PUSH
 268: EMPTY
 269: LIST
 270: DIFF
 271: PUSH
 272: LD_INT 0
 274: PLUS
 275: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
 276: LD_ADDR_EXP 36
 280: PUSH
 281: LD_EXP 33
 285: PUSH
 286: LD_INT 0
 288: PUSH
 289: EMPTY
 290: LIST
 291: DIFF
 292: PUSH
 293: LD_INT 0
 295: PLUS
 296: ST_TO_ADDR
// if MultiPlayer then
 297: LD_OWVAR 4
 301: IFFALSE 461
// begin def_pocet_lidi = GetMultiplayerSetting ( 1 ) ;
 303: LD_ADDR_EXP 1
 307: PUSH
 308: LD_INT 1
 310: PPUSH
 311: CALL_OW 426
 315: ST_TO_ADDR
// def_priblizna_uroven = GetMultiplayerSetting ( 2 ) ;
 316: LD_ADDR_EXP 3
 320: PUSH
 321: LD_INT 2
 323: PPUSH
 324: CALL_OW 426
 328: ST_TO_ADDR
// def_cetnost_zasilek = GetMultiplayerSetting ( 4 ) ;
 329: LD_ADDR_EXP 4
 333: PUSH
 334: LD_INT 4
 336: PPUSH
 337: CALL_OW 426
 341: ST_TO_ADDR
// def_mnozstvi_lozisek = GetMultiplayerSetting ( 5 ) ;
 342: LD_ADDR_EXP 5
 346: PUSH
 347: LD_INT 5
 349: PPUSH
 350: CALL_OW 426
 354: ST_TO_ADDR
// def_nahodnost_lozisek = GetMultiplayerSetting ( 6 ) ;
 355: LD_ADDR_EXP 6
 359: PUSH
 360: LD_INT 6
 362: PPUSH
 363: CALL_OW 426
 367: ST_TO_ADDR
// def_uroven_konvoje = GetMultiplayerSetting ( 7 ) ;
 368: LD_ADDR_EXP 2
 372: PUSH
 373: LD_INT 7
 375: PPUSH
 376: CALL_OW 426
 380: ST_TO_ADDR
// deF_viditelnost_stran = GetMultiplayerSetting ( 10 ) ;
 381: LD_ADDR_EXP 7
 385: PUSH
 386: LD_INT 10
 388: PPUSH
 389: CALL_OW 426
 393: ST_TO_ADDR
// def_sib_detekce = GetMultiplayerSetting ( 12 ) ;
 394: LD_ADDR_EXP 8
 398: PUSH
 399: LD_INT 12
 401: PPUSH
 402: CALL_OW 426
 406: ST_TO_ADDR
// def_sib_bomb = GetMultiplayerSetting ( 15 ) ;
 407: LD_ADDR_EXP 13
 411: PUSH
 412: LD_INT 15
 414: PPUSH
 415: CALL_OW 426
 419: ST_TO_ADDR
// def_pocet_opicaku = GetMultiplayerSetting ( 13 ) ;
 420: LD_ADDR_EXP 10
 424: PUSH
 425: LD_INT 13
 427: PPUSH
 428: CALL_OW 426
 432: ST_TO_ADDR
// def_pocet_tygru = GetMultiplayerSetting ( 18 ) ;
 433: LD_ADDR_EXP 11
 437: PUSH
 438: LD_INT 18
 440: PPUSH
 441: CALL_OW 426
 445: ST_TO_ADDR
// def_obnovovaci_cas = GetMultiplayerSetting ( 14 ) ;
 446: LD_ADDR_EXP 9
 450: PUSH
 451: LD_INT 14
 453: PPUSH
 454: CALL_OW 426
 458: ST_TO_ADDR
// end else
 459: GO 561
// begin randomize ;
 461: CALL_OW 10
// def_pocet_lidi = 3 ;
 465: LD_ADDR_EXP 1
 469: PUSH
 470: LD_INT 3
 472: ST_TO_ADDR
// def_priblizna_uroven = 2 ;
 473: LD_ADDR_EXP 3
 477: PUSH
 478: LD_INT 2
 480: ST_TO_ADDR
// def_cetnost_zasilek = 1 ;
 481: LD_ADDR_EXP 4
 485: PUSH
 486: LD_INT 1
 488: ST_TO_ADDR
// def_mnozstvi_lozisek = 0 ;
 489: LD_ADDR_EXP 5
 493: PUSH
 494: LD_INT 0
 496: ST_TO_ADDR
// def_nahodnost_lozisek = 0 ;
 497: LD_ADDR_EXP 6
 501: PUSH
 502: LD_INT 0
 504: ST_TO_ADDR
// deF_viditelnost_stran = 1 ;
 505: LD_ADDR_EXP 7
 509: PUSH
 510: LD_INT 1
 512: ST_TO_ADDR
// def_sib_detekce = 1 ;
 513: LD_ADDR_EXP 8
 517: PUSH
 518: LD_INT 1
 520: ST_TO_ADDR
// def_sib_bomb = 1 ;
 521: LD_ADDR_EXP 13
 525: PUSH
 526: LD_INT 1
 528: ST_TO_ADDR
// def_pocet_opicaku = 2 ;
 529: LD_ADDR_EXP 10
 533: PUSH
 534: LD_INT 2
 536: ST_TO_ADDR
// def_pocet_tygru = 2 ;
 537: LD_ADDR_EXP 11
 541: PUSH
 542: LD_INT 2
 544: ST_TO_ADDR
// def_obnovovaci_cas = 1 ;
 545: LD_ADDR_EXP 9
 549: PUSH
 550: LD_INT 1
 552: ST_TO_ADDR
// def_uroven_konvoje = 3 ;
 553: LD_ADDR_EXP 2
 557: PUSH
 558: LD_INT 3
 560: ST_TO_ADDR
// end ; if isSGUI then
 561: LD_OWVAR 83
 565: IFFALSE 571
// setMpTechs ( ) ;
 567: CALL 11224 0 0
// pocet_lidi = [ 6 , 9 , 12 , 15 , 18 , 21 , 24 ] [ def_pocet_lidi + 1 ] ;
 571: LD_ADDR_EXP 14
 575: PUSH
 576: LD_INT 6
 578: PUSH
 579: LD_INT 9
 581: PUSH
 582: LD_INT 12
 584: PUSH
 585: LD_INT 15
 587: PUSH
 588: LD_INT 18
 590: PUSH
 591: LD_INT 21
 593: PUSH
 594: LD_INT 24
 596: PUSH
 597: EMPTY
 598: LIST
 599: LIST
 600: LIST
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: LD_EXP 1
 610: PUSH
 611: LD_INT 1
 613: PLUS
 614: ARRAY
 615: ST_TO_ADDR
// priblizna_uroven = [ 2 , 3 , 4 , 5 ] [ def_priblizna_uroven + 1 ] ;
 616: LD_ADDR_EXP 15
 620: PUSH
 621: LD_INT 2
 623: PUSH
 624: LD_INT 3
 626: PUSH
 627: LD_INT 4
 629: PUSH
 630: LD_INT 5
 632: PUSH
 633: EMPTY
 634: LIST
 635: LIST
 636: LIST
 637: LIST
 638: PUSH
 639: LD_EXP 3
 643: PUSH
 644: LD_INT 1
 646: PLUS
 647: ARRAY
 648: ST_TO_ADDR
// cetnost_zasilek = [ 20 , 30 , 40 ] [ def_cetnost_zasilek + 1 ] ;
 649: LD_ADDR_EXP 17
 653: PUSH
 654: LD_INT 20
 656: PUSH
 657: LD_INT 30
 659: PUSH
 660: LD_INT 40
 662: PUSH
 663: EMPTY
 664: LIST
 665: LIST
 666: LIST
 667: PUSH
 668: LD_EXP 4
 672: PUSH
 673: LD_INT 1
 675: PLUS
 676: ARRAY
 677: ST_TO_ADDR
// obnova_opic = [ 0 , 165 , 140 , 115 ] [ def_pocet_opicaku + 1 ] ;
 678: LD_ADDR_EXP 18
 682: PUSH
 683: LD_INT 0
 685: PUSH
 686: LD_INT 165
 688: PUSH
 689: LD_INT 140
 691: PUSH
 692: LD_INT 115
 694: PUSH
 695: EMPTY
 696: LIST
 697: LIST
 698: LIST
 699: LIST
 700: PUSH
 701: LD_EXP 10
 705: PUSH
 706: LD_INT 1
 708: PLUS
 709: ARRAY
 710: ST_TO_ADDR
// obnova_tygru = [ 0 , 165 , 140 , 115 ] [ def_pocet_tygru + 1 ] ;
 711: LD_ADDR_EXP 19
 715: PUSH
 716: LD_INT 0
 718: PUSH
 719: LD_INT 165
 721: PUSH
 722: LD_INT 140
 724: PUSH
 725: LD_INT 115
 727: PUSH
 728: EMPTY
 729: LIST
 730: LIST
 731: LIST
 732: LIST
 733: PUSH
 734: LD_EXP 11
 738: PUSH
 739: LD_INT 1
 741: PLUS
 742: ARRAY
 743: ST_TO_ADDR
// obnovovaci_cas_min = [ 0 0$0 , 4 4$00 , 0 0$50 ] [ def_obnovovaci_cas + 1 ] ;
 744: LD_ADDR_EXP 20
 748: PUSH
 749: LD_INT 0
 751: PUSH
 752: LD_INT 8400
 754: PUSH
 755: LD_INT 1750
 757: PUSH
 758: EMPTY
 759: LIST
 760: LIST
 761: LIST
 762: PUSH
 763: LD_EXP 9
 767: PUSH
 768: LD_INT 1
 770: PLUS
 771: ARRAY
 772: ST_TO_ADDR
// obnovovaci_cas_max = [ 0 0$0 , 10 10$00 , 2 2$00 ] [ def_obnovovaci_cas + 1 ] ;
 773: LD_ADDR_EXP 21
 777: PUSH
 778: LD_INT 0
 780: PUSH
 781: LD_INT 21000
 783: PUSH
 784: LD_INT 4200
 786: PUSH
 787: EMPTY
 788: LIST
 789: LIST
 790: LIST
 791: PUSH
 792: LD_EXP 9
 796: PUSH
 797: LD_INT 1
 799: PLUS
 800: ARRAY
 801: ST_TO_ADDR
// respawning_time_delay_min := [ 0 0$0 , 0 0$30 , 0 0$15 ] [ def_obnovovaci_cas + 1 ] ;
 802: LD_ADDR_EXP 22
 806: PUSH
 807: LD_INT 0
 809: PUSH
 810: LD_INT 1050
 812: PUSH
 813: LD_INT 525
 815: PUSH
 816: EMPTY
 817: LIST
 818: LIST
 819: LIST
 820: PUSH
 821: LD_EXP 9
 825: PUSH
 826: LD_INT 1
 828: PLUS
 829: ARRAY
 830: ST_TO_ADDR
// respawning_time_delay_max := [ 0 0$0 , 1 1$00 , 0 0$45 ] [ def_obnovovaci_cas + 1 ] ;
 831: LD_ADDR_EXP 23
 835: PUSH
 836: LD_INT 0
 838: PUSH
 839: LD_INT 2100
 841: PUSH
 842: LD_INT 1575
 844: PUSH
 845: EMPTY
 846: LIST
 847: LIST
 848: LIST
 849: PUSH
 850: LD_EXP 9
 854: PUSH
 855: LD_INT 1
 857: PLUS
 858: ARRAY
 859: ST_TO_ADDR
// initial_level = priblizna_uroven ;
 860: LD_ADDR_EXP 16
 864: PUSH
 865: LD_EXP 15
 869: ST_TO_ADDR
// pozice_sib := [ [ 112 , 117 ] , [ 131 , 86 ] , [ 207 , 145 ] , [ 180 , 86 ] , [ 118 , 36 ] , [ 103 , 65 ] , [ 54 , 54 ] ] ;
 870: LD_ADDR_EXP 25
 874: PUSH
 875: LD_INT 112
 877: PUSH
 878: LD_INT 117
 880: PUSH
 881: EMPTY
 882: LIST
 883: LIST
 884: PUSH
 885: LD_INT 131
 887: PUSH
 888: LD_INT 86
 890: PUSH
 891: EMPTY
 892: LIST
 893: LIST
 894: PUSH
 895: LD_INT 207
 897: PUSH
 898: LD_INT 145
 900: PUSH
 901: EMPTY
 902: LIST
 903: LIST
 904: PUSH
 905: LD_INT 180
 907: PUSH
 908: LD_INT 86
 910: PUSH
 911: EMPTY
 912: LIST
 913: LIST
 914: PUSH
 915: LD_INT 118
 917: PUSH
 918: LD_INT 36
 920: PUSH
 921: EMPTY
 922: LIST
 923: LIST
 924: PUSH
 925: LD_INT 103
 927: PUSH
 928: LD_INT 65
 930: PUSH
 931: EMPTY
 932: LIST
 933: LIST
 934: PUSH
 935: LD_INT 54
 937: PUSH
 938: LD_INT 54
 940: PUSH
 941: EMPTY
 942: LIST
 943: LIST
 944: PUSH
 945: EMPTY
 946: LIST
 947: LIST
 948: LIST
 949: LIST
 950: LIST
 951: LIST
 952: LIST
 953: ST_TO_ADDR
// pozice_ropy := [ [ 91 , 110 ] , [ 107 , 84 ] , [ 210 , 125 ] , [ 147 , 113 ] , [ 144 , 46 ] , [ 91 , 42 ] , [ 39 , 68 ] , [ 128 , 147 ] , [ 136 , 3 ] ] ;
 954: LD_ADDR_EXP 24
 958: PUSH
 959: LD_INT 91
 961: PUSH
 962: LD_INT 110
 964: PUSH
 965: EMPTY
 966: LIST
 967: LIST
 968: PUSH
 969: LD_INT 107
 971: PUSH
 972: LD_INT 84
 974: PUSH
 975: EMPTY
 976: LIST
 977: LIST
 978: PUSH
 979: LD_INT 210
 981: PUSH
 982: LD_INT 125
 984: PUSH
 985: EMPTY
 986: LIST
 987: LIST
 988: PUSH
 989: LD_INT 147
 991: PUSH
 992: LD_INT 113
 994: PUSH
 995: EMPTY
 996: LIST
 997: LIST
 998: PUSH
 999: LD_INT 144
1001: PUSH
1002: LD_INT 46
1004: PUSH
1005: EMPTY
1006: LIST
1007: LIST
1008: PUSH
1009: LD_INT 91
1011: PUSH
1012: LD_INT 42
1014: PUSH
1015: EMPTY
1016: LIST
1017: LIST
1018: PUSH
1019: LD_INT 39
1021: PUSH
1022: LD_INT 68
1024: PUSH
1025: EMPTY
1026: LIST
1027: LIST
1028: PUSH
1029: LD_INT 128
1031: PUSH
1032: LD_INT 147
1034: PUSH
1035: EMPTY
1036: LIST
1037: LIST
1038: PUSH
1039: LD_INT 136
1041: PUSH
1042: LD_INT 3
1044: PUSH
1045: EMPTY
1046: LIST
1047: LIST
1048: PUSH
1049: EMPTY
1050: LIST
1051: LIST
1052: LIST
1053: LIST
1054: LIST
1055: LIST
1056: LIST
1057: LIST
1058: LIST
1059: ST_TO_ADDR
// pozice_beden := [ Bedny1 , Bedny2 , Bedny3 , Bedny4 , Bedny5 , Bedny6 , Bedny7 , Bedny8 , Bedny9 ] ;
1060: LD_ADDR_EXP 26
1064: PUSH
1065: LD_INT 11
1067: PUSH
1068: LD_INT 12
1070: PUSH
1071: LD_INT 13
1073: PUSH
1074: LD_INT 14
1076: PUSH
1077: LD_INT 15
1079: PUSH
1080: LD_INT 16
1082: PUSH
1083: LD_INT 17
1085: PUSH
1086: LD_INT 18
1088: PUSH
1089: LD_INT 19
1091: PUSH
1092: EMPTY
1093: LIST
1094: LIST
1095: LIST
1096: LIST
1097: LIST
1098: LIST
1099: LIST
1100: LIST
1101: LIST
1102: ST_TO_ADDR
// pozice = NahodneIndexy ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ) ;
1103: LD_ADDR_VAR 0 10
1107: PUSH
1108: LD_INT 1
1110: PUSH
1111: LD_INT 2
1113: PUSH
1114: LD_INT 3
1116: PUSH
1117: LD_INT 4
1119: PUSH
1120: LD_INT 5
1122: PUSH
1123: LD_INT 6
1125: PUSH
1126: LD_INT 7
1128: PUSH
1129: EMPTY
1130: LIST
1131: LIST
1132: LIST
1133: LIST
1134: LIST
1135: LIST
1136: LIST
1137: PPUSH
1138: CALL 1936 0 1
1142: ST_TO_ADDR
// souradnice = [ [ 38 , 51 ] , [ 77 , 17 ] , [ 155 , 21 ] , [ 79 , 141 ] , [ 176 , 142 ] , [ 193 , 105 ] ] ;
1143: LD_ADDR_VAR 0 11
1147: PUSH
1148: LD_INT 38
1150: PUSH
1151: LD_INT 51
1153: PUSH
1154: EMPTY
1155: LIST
1156: LIST
1157: PUSH
1158: LD_INT 77
1160: PUSH
1161: LD_INT 17
1163: PUSH
1164: EMPTY
1165: LIST
1166: LIST
1167: PUSH
1168: LD_INT 155
1170: PUSH
1171: LD_INT 21
1173: PUSH
1174: EMPTY
1175: LIST
1176: LIST
1177: PUSH
1178: LD_INT 79
1180: PUSH
1181: LD_INT 141
1183: PUSH
1184: EMPTY
1185: LIST
1186: LIST
1187: PUSH
1188: LD_INT 176
1190: PUSH
1191: LD_INT 142
1193: PUSH
1194: EMPTY
1195: LIST
1196: LIST
1197: PUSH
1198: LD_INT 193
1200: PUSH
1201: LD_INT 105
1203: PUSH
1204: EMPTY
1205: LIST
1206: LIST
1207: PUSH
1208: EMPTY
1209: LIST
1210: LIST
1211: LIST
1212: LIST
1213: LIST
1214: LIST
1215: ST_TO_ADDR
// start_def := [ souradnice [ pozice [ 1 ] ] , souradnice [ pozice [ 2 ] ] , souradnice [ pozice [ 3 ] ] , souradnice [ pozice [ 4 ] ] , souradnice [ pozice [ 5 ] ] , souradnice [ pozice [ 6 ] ] ] ;
1216: LD_ADDR_EXP 27
1220: PUSH
1221: LD_VAR 0 11
1225: PUSH
1226: LD_VAR 0 10
1230: PUSH
1231: LD_INT 1
1233: ARRAY
1234: ARRAY
1235: PUSH
1236: LD_VAR 0 11
1240: PUSH
1241: LD_VAR 0 10
1245: PUSH
1246: LD_INT 2
1248: ARRAY
1249: ARRAY
1250: PUSH
1251: LD_VAR 0 11
1255: PUSH
1256: LD_VAR 0 10
1260: PUSH
1261: LD_INT 3
1263: ARRAY
1264: ARRAY
1265: PUSH
1266: LD_VAR 0 11
1270: PUSH
1271: LD_VAR 0 10
1275: PUSH
1276: LD_INT 4
1278: ARRAY
1279: ARRAY
1280: PUSH
1281: LD_VAR 0 11
1285: PUSH
1286: LD_VAR 0 10
1290: PUSH
1291: LD_INT 5
1293: ARRAY
1294: ARRAY
1295: PUSH
1296: LD_VAR 0 11
1300: PUSH
1301: LD_VAR 0 10
1305: PUSH
1306: LD_INT 6
1308: ARRAY
1309: ARRAY
1310: PUSH
1311: EMPTY
1312: LIST
1313: LIST
1314: LIST
1315: LIST
1316: LIST
1317: LIST
1318: ST_TO_ADDR
// stran = [ ] ;
1319: LD_ADDR_VAR 0 5
1323: PUSH
1324: EMPTY
1325: ST_TO_ADDR
// for i = 1 to Side_Positions do
1326: LD_ADDR_VAR 0 4
1330: PUSH
1331: DOUBLE
1332: LD_INT 1
1334: DEC
1335: ST_TO_ADDR
1336: LD_EXP 31
1340: PUSH
1341: FOR_TO
1342: IFFALSE 1374
// if Side_Positions [ i ] then
1344: LD_EXP 31
1348: PUSH
1349: LD_VAR 0 4
1353: ARRAY
1354: IFFALSE 1372
// stran = stran ^ i ;
1356: LD_ADDR_VAR 0 5
1360: PUSH
1361: LD_VAR 0 5
1365: PUSH
1366: LD_VAR 0 4
1370: ADD
1371: ST_TO_ADDR
1372: GO 1341
1374: POP
1375: POP
// loziska_ropy = NahodneIndexy ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ) ;
1376: LD_ADDR_VAR 0 8
1380: PUSH
1381: LD_INT 1
1383: PUSH
1384: LD_INT 2
1386: PUSH
1387: LD_INT 3
1389: PUSH
1390: LD_INT 4
1392: PUSH
1393: LD_INT 5
1395: PUSH
1396: LD_INT 6
1398: PUSH
1399: LD_INT 7
1401: PUSH
1402: LD_INT 8
1404: PUSH
1405: LD_INT 9
1407: PUSH
1408: LD_INT 10
1410: PUSH
1411: EMPTY
1412: LIST
1413: LIST
1414: LIST
1415: LIST
1416: LIST
1417: LIST
1418: LIST
1419: LIST
1420: LIST
1421: LIST
1422: PPUSH
1423: CALL 1936 0 1
1427: ST_TO_ADDR
// loziska_sib = NahodneIndexy ( [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ) ;
1428: LD_ADDR_VAR 0 9
1432: PUSH
1433: LD_INT 1
1435: PUSH
1436: LD_INT 2
1438: PUSH
1439: LD_INT 3
1441: PUSH
1442: LD_INT 4
1444: PUSH
1445: LD_INT 5
1447: PUSH
1448: LD_INT 6
1450: PUSH
1451: LD_INT 7
1453: PUSH
1454: LD_INT 8
1456: PUSH
1457: EMPTY
1458: LIST
1459: LIST
1460: LIST
1461: LIST
1462: LIST
1463: LIST
1464: LIST
1465: LIST
1466: PPUSH
1467: CALL 1936 0 1
1471: ST_TO_ADDR
// case def_mnozstvi_lozisek of 0 :
1472: LD_EXP 5
1476: PUSH
1477: LD_INT 0
1479: DOUBLE
1480: EQUAL
1481: IFTRUE 1485
1483: GO 1521
1485: POP
// begin oil = stran + 0 ;
1486: LD_ADDR_VAR 0 7
1490: PUSH
1491: LD_VAR 0 5
1495: PUSH
1496: LD_INT 0
1498: PLUS
1499: ST_TO_ADDR
// sib = ( stran / 2 ) + 0.8 ;
1500: LD_ADDR_VAR 0 6
1504: PUSH
1505: LD_VAR 0 5
1509: PUSH
1510: LD_INT 2
1512: DIVREAL
1513: PUSH
1514: LD_REAL  8.00000000000000E-0001
1517: PLUS
1518: ST_TO_ADDR
// end ; 1 :
1519: GO 1588
1521: LD_INT 1
1523: DOUBLE
1524: EQUAL
1525: IFTRUE 1529
1527: GO 1560
1529: POP
// begin oil = stran + 0 ;
1530: LD_ADDR_VAR 0 7
1534: PUSH
1535: LD_VAR 0 5
1539: PUSH
1540: LD_INT 0
1542: PLUS
1543: ST_TO_ADDR
// sib = stran + 0 ;
1544: LD_ADDR_VAR 0 6
1548: PUSH
1549: LD_VAR 0 5
1553: PUSH
1554: LD_INT 0
1556: PLUS
1557: ST_TO_ADDR
// end ; 2 :
1558: GO 1588
1560: LD_INT 2
1562: DOUBLE
1563: EQUAL
1564: IFTRUE 1568
1566: GO 1587
1568: POP
// begin oil = 9 ;
1569: LD_ADDR_VAR 0 7
1573: PUSH
1574: LD_INT 9
1576: ST_TO_ADDR
// sib = 7 ;
1577: LD_ADDR_VAR 0 6
1581: PUSH
1582: LD_INT 7
1584: ST_TO_ADDR
// end ; end ;
1585: GO 1588
1587: POP
// if def_nahodnost_lozisek and not def_mnozstvi_lozisek = 2 then
1588: LD_EXP 6
1592: PUSH
1593: LD_EXP 5
1597: PUSH
1598: LD_INT 2
1600: EQUAL
1601: NOT
1602: AND
1603: IFFALSE 1789
// begin for i = 1 to sib do
1605: LD_ADDR_VAR 0 4
1609: PUSH
1610: DOUBLE
1611: LD_INT 1
1613: DEC
1614: ST_TO_ADDR
1615: LD_VAR 0 6
1619: PUSH
1620: FOR_TO
1621: IFFALSE 1696
// begin CreateDepositXY ( pozice_ropy [ loziska_sib [ i ] ] [ 1 ] , pozice_ropy [ loziska_sib [ i ] ] [ 2 ] , mat_oil ) ;
1623: LD_EXP 24
1627: PUSH
1628: LD_VAR 0 9
1632: PUSH
1633: LD_VAR 0 4
1637: ARRAY
1638: ARRAY
1639: PUSH
1640: LD_INT 1
1642: ARRAY
1643: PPUSH
1644: LD_EXP 24
1648: PUSH
1649: LD_VAR 0 9
1653: PUSH
1654: LD_VAR 0 4
1658: ARRAY
1659: ARRAY
1660: PUSH
1661: LD_INT 2
1663: ARRAY
1664: PPUSH
1665: LD_INT 2
1667: PPUSH
1668: CALL_OW 62
// loziska_ropy := loziska_ropy diff loziska_sib [ i ] ;
1672: LD_ADDR_VAR 0 8
1676: PUSH
1677: LD_VAR 0 8
1681: PUSH
1682: LD_VAR 0 9
1686: PUSH
1687: LD_VAR 0 4
1691: ARRAY
1692: DIFF
1693: ST_TO_ADDR
// end ;
1694: GO 1620
1696: POP
1697: POP
// if sib <> oil then
1698: LD_VAR 0 6
1702: PUSH
1703: LD_VAR 0 7
1707: NONEQUAL
1708: IFFALSE 1787
// for i = 1 to ( oil - sib ) do
1710: LD_ADDR_VAR 0 4
1714: PUSH
1715: DOUBLE
1716: LD_INT 1
1718: DEC
1719: ST_TO_ADDR
1720: LD_VAR 0 7
1724: PUSH
1725: LD_VAR 0 6
1729: MINUS
1730: PUSH
1731: FOR_TO
1732: IFFALSE 1785
// CreateDepositXY ( pozice_ropy [ loziska_ropy [ i ] ] [ 1 ] , pozice_ropy [ loziska_ropy [ i ] ] [ 2 ] , mat_oil ) ;
1734: LD_EXP 24
1738: PUSH
1739: LD_VAR 0 8
1743: PUSH
1744: LD_VAR 0 4
1748: ARRAY
1749: ARRAY
1750: PUSH
1751: LD_INT 1
1753: ARRAY
1754: PPUSH
1755: LD_EXP 24
1759: PUSH
1760: LD_VAR 0 8
1764: PUSH
1765: LD_VAR 0 4
1769: ARRAY
1770: ARRAY
1771: PUSH
1772: LD_INT 2
1774: ARRAY
1775: PPUSH
1776: LD_INT 2
1778: PPUSH
1779: CALL_OW 62
1783: GO 1731
1785: POP
1786: POP
// end else
1787: GO 1860
// for i = 1 to oil do
1789: LD_ADDR_VAR 0 4
1793: PUSH
1794: DOUBLE
1795: LD_INT 1
1797: DEC
1798: ST_TO_ADDR
1799: LD_VAR 0 7
1803: PUSH
1804: FOR_TO
1805: IFFALSE 1858
// CreateDepositXY ( pozice_ropy [ loziska_ropy [ i ] ] [ 1 ] , pozice_ropy [ loziska_ropy [ i ] ] [ 2 ] , mat_oil ) ;
1807: LD_EXP 24
1811: PUSH
1812: LD_VAR 0 8
1816: PUSH
1817: LD_VAR 0 4
1821: ARRAY
1822: ARRAY
1823: PUSH
1824: LD_INT 1
1826: ARRAY
1827: PPUSH
1828: LD_EXP 24
1832: PUSH
1833: LD_VAR 0 8
1837: PUSH
1838: LD_VAR 0 4
1842: ARRAY
1843: ARRAY
1844: PUSH
1845: LD_INT 2
1847: ARRAY
1848: PPUSH
1849: LD_INT 2
1851: PPUSH
1852: CALL_OW 62
1856: GO 1804
1858: POP
1859: POP
// for i = 1 to sib do
1860: LD_ADDR_VAR 0 4
1864: PUSH
1865: DOUBLE
1866: LD_INT 1
1868: DEC
1869: ST_TO_ADDR
1870: LD_VAR 0 6
1874: PUSH
1875: FOR_TO
1876: IFFALSE 1929
// CreateDepositXY ( pozice_sib [ loziska_sib [ i ] ] [ 1 ] , pozice_sib [ loziska_sib [ i ] ] [ 2 ] , mat_siberit ) ;
1878: LD_EXP 25
1882: PUSH
1883: LD_VAR 0 9
1887: PUSH
1888: LD_VAR 0 4
1892: ARRAY
1893: ARRAY
1894: PUSH
1895: LD_INT 1
1897: ARRAY
1898: PPUSH
1899: LD_EXP 25
1903: PUSH
1904: LD_VAR 0 9
1908: PUSH
1909: LD_VAR 0 4
1913: ARRAY
1914: ARRAY
1915: PUSH
1916: LD_INT 2
1918: ARRAY
1919: PPUSH
1920: LD_INT 3
1922: PPUSH
1923: CALL_OW 62
1927: GO 1875
1929: POP
1930: POP
// end ;
1931: LD_VAR 0 1
1935: RET
// function NahodneIndexy ( arr ) ; var i , x , n ; var novy ; begin
1936: LD_INT 0
1938: PPUSH
1939: PPUSH
1940: PPUSH
1941: PPUSH
1942: PPUSH
// x := arr ;
1943: LD_ADDR_VAR 0 4
1947: PUSH
1948: LD_VAR 0 1
1952: ST_TO_ADDR
// for i := 1 to arr do
1953: LD_ADDR_VAR 0 3
1957: PUSH
1958: DOUBLE
1959: LD_INT 1
1961: DEC
1962: ST_TO_ADDR
1963: LD_VAR 0 1
1967: PUSH
1968: FOR_TO
1969: IFFALSE 2044
// begin n := x [ rand ( 1 , arr - i ) ] ;
1971: LD_ADDR_VAR 0 5
1975: PUSH
1976: LD_VAR 0 4
1980: PUSH
1981: LD_INT 1
1983: PPUSH
1984: LD_VAR 0 1
1988: PUSH
1989: LD_VAR 0 3
1993: MINUS
1994: PPUSH
1995: CALL_OW 12
1999: ARRAY
2000: ST_TO_ADDR
// novy := novy ^ [ arr [ n ] ] ;
2001: LD_ADDR_VAR 0 6
2005: PUSH
2006: LD_VAR 0 6
2010: PUSH
2011: LD_VAR 0 1
2015: PUSH
2016: LD_VAR 0 5
2020: ARRAY
2021: PUSH
2022: EMPTY
2023: LIST
2024: ADD
2025: ST_TO_ADDR
// x := x diff n ;
2026: LD_ADDR_VAR 0 4
2030: PUSH
2031: LD_VAR 0 4
2035: PUSH
2036: LD_VAR 0 5
2040: DIFF
2041: ST_TO_ADDR
// end ;
2042: GO 1968
2044: POP
2045: POP
// result := novy diff [ 0 ] ;
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_VAR 0 6
2055: PUSH
2056: LD_INT 0
2058: PUSH
2059: EMPTY
2060: LIST
2061: DIFF
2062: ST_TO_ADDR
// end ;
2063: LD_VAR 0 2
2067: RET
// function nastav_viditelnost_stran_a_alianci ; var i , j ; begin
2068: LD_INT 0
2070: PPUSH
2071: PPUSH
2072: PPUSH
// Team_Game := 0 ;
2073: LD_ADDR_EXP 37
2077: PUSH
2078: LD_INT 0
2080: ST_TO_ADDR
// for i = 1 to 8 do
2081: LD_ADDR_VAR 0 2
2085: PUSH
2086: DOUBLE
2087: LD_INT 1
2089: DEC
2090: ST_TO_ADDR
2091: LD_INT 8
2093: PUSH
2094: FOR_TO
2095: IFFALSE 2121
// Team_Game := Team_Game + Side_Teams [ i ] ;
2097: LD_ADDR_EXP 37
2101: PUSH
2102: LD_EXP 37
2106: PUSH
2107: LD_EXP 33
2111: PUSH
2112: LD_VAR 0 2
2116: ARRAY
2117: PLUS
2118: ST_TO_ADDR
2119: GO 2094
2121: POP
2122: POP
// if not Team_Game then
2123: LD_EXP 37
2127: NOT
2128: IFFALSE 2140
// Team_Game := false else
2130: LD_ADDR_EXP 37
2134: PUSH
2135: LD_INT 0
2137: ST_TO_ADDR
2138: GO 2148
// Team_Game := true ;
2140: LD_ADDR_EXP 37
2144: PUSH
2145: LD_INT 1
2147: ST_TO_ADDR
// if not Team_Game then
2148: LD_EXP 37
2152: NOT
2153: IFFALSE 2251
// begin for i = 1 to 8 do
2155: LD_ADDR_VAR 0 2
2159: PUSH
2160: DOUBLE
2161: LD_INT 1
2163: DEC
2164: ST_TO_ADDR
2165: LD_INT 8
2167: PUSH
2168: FOR_TO
2169: IFFALSE 2247
// for j = 1 to 8 do
2171: LD_ADDR_VAR 0 3
2175: PUSH
2176: DOUBLE
2177: LD_INT 1
2179: DEC
2180: ST_TO_ADDR
2181: LD_INT 8
2183: PUSH
2184: FOR_TO
2185: IFFALSE 2243
// if i <> j then
2187: LD_VAR 0 2
2191: PUSH
2192: LD_VAR 0 3
2196: NONEQUAL
2197: IFFALSE 2221
// SetAttitude ( i , j , att_neutral , true ) else
2199: LD_VAR 0 2
2203: PPUSH
2204: LD_VAR 0 3
2208: PPUSH
2209: LD_INT 0
2211: PPUSH
2212: LD_INT 1
2214: PPUSH
2215: CALL_OW 80
2219: GO 2241
// SetAttitude ( i , j , att_friend , true ) ;
2221: LD_VAR 0 2
2225: PPUSH
2226: LD_VAR 0 3
2230: PPUSH
2231: LD_INT 1
2233: PPUSH
2234: LD_INT 1
2236: PPUSH
2237: CALL_OW 80
2241: GO 2184
2243: POP
2244: POP
2245: GO 2168
2247: POP
2248: POP
// end else
2249: GO 2426
// begin if deF_viditelnost_stran then
2251: LD_EXP 7
2255: IFFALSE 2320
// begin for i in Teams do
2257: LD_ADDR_VAR 0 2
2261: PUSH
2262: LD_EXP 34
2266: PUSH
2267: FOR_IN
2268: IFFALSE 2318
// for j = 2 to i do
2270: LD_ADDR_VAR 0 3
2274: PUSH
2275: DOUBLE
2276: LD_INT 2
2278: DEC
2279: ST_TO_ADDR
2280: LD_VAR 0 2
2284: PUSH
2285: FOR_TO
2286: IFFALSE 2314
// ChangeSideFog ( i [ j ] , i [ 1 ] ) ;
2288: LD_VAR 0 2
2292: PUSH
2293: LD_VAR 0 3
2297: ARRAY
2298: PPUSH
2299: LD_VAR 0 2
2303: PUSH
2304: LD_INT 1
2306: ARRAY
2307: PPUSH
2308: CALL_OW 343
2312: GO 2285
2314: POP
2315: POP
2316: GO 2267
2318: POP
2319: POP
// end ; for i = 1 to 8 do
2320: LD_ADDR_VAR 0 2
2324: PUSH
2325: DOUBLE
2326: LD_INT 1
2328: DEC
2329: ST_TO_ADDR
2330: LD_INT 8
2332: PUSH
2333: FOR_TO
2334: IFFALSE 2424
// for j = 1 to 8 do
2336: LD_ADDR_VAR 0 3
2340: PUSH
2341: DOUBLE
2342: LD_INT 1
2344: DEC
2345: ST_TO_ADDR
2346: LD_INT 8
2348: PUSH
2349: FOR_TO
2350: IFFALSE 2420
// if Side_Teams [ i ] = Side_Teams [ j ] then
2352: LD_EXP 33
2356: PUSH
2357: LD_VAR 0 2
2361: ARRAY
2362: PUSH
2363: LD_EXP 33
2367: PUSH
2368: LD_VAR 0 3
2372: ARRAY
2373: EQUAL
2374: IFFALSE 2398
// SetAttitude ( i , j , att_friend , true ) else
2376: LD_VAR 0 2
2380: PPUSH
2381: LD_VAR 0 3
2385: PPUSH
2386: LD_INT 1
2388: PPUSH
2389: LD_INT 1
2391: PPUSH
2392: CALL_OW 80
2396: GO 2418
// SetAttitude ( i , j , att_enemy , true ) ;
2398: LD_VAR 0 2
2402: PPUSH
2403: LD_VAR 0 3
2407: PPUSH
2408: LD_INT 2
2410: PPUSH
2411: LD_INT 1
2413: PPUSH
2414: CALL_OW 80
2418: GO 2349
2420: POP
2421: POP
2422: GO 2333
2424: POP
2425: POP
// end ; end ;
2426: LD_VAR 0 1
2430: RET
// export function priprava_lidi ( side , count , cl , x , y , r , var commander ) ; var i , j , un ; begin
2431: LD_INT 0
2433: PPUSH
2434: PPUSH
2435: PPUSH
2436: PPUSH
// result := [ ] ;
2437: LD_ADDR_VAR 0 8
2441: PUSH
2442: EMPTY
2443: ST_TO_ADDR
// for i := 1 to count do
2444: LD_ADDR_VAR 0 9
2448: PUSH
2449: DOUBLE
2450: LD_INT 1
2452: DEC
2453: ST_TO_ADDR
2454: LD_VAR 0 2
2458: PUSH
2459: FOR_TO
2460: IFFALSE 2854
// begin uc_direction := Rand ( 0 , 5 ) ;
2462: LD_ADDR_OWVAR 24
2466: PUSH
2467: LD_INT 0
2469: PPUSH
2470: LD_INT 5
2472: PPUSH
2473: CALL_OW 12
2477: ST_TO_ADDR
// if commander then
2478: LD_FROM_VAR 0 7
2482: IFFALSE 2591
// begin hc_name := mp_sides_players_names [ side ] ;
2484: LD_ADDR_OWVAR 26
2488: PUSH
2489: LD_OWVAR 19
2493: PUSH
2494: LD_VAR 0 1
2498: ARRAY
2499: ST_TO_ADDR
// PrepareHuman ( Rand ( 1 , 2 ) , cl , priblizna_uroven + 2 ) ;
2500: LD_INT 1
2502: PPUSH
2503: LD_INT 2
2505: PPUSH
2506: CALL_OW 12
2510: PPUSH
2511: LD_VAR 0 3
2515: PPUSH
2516: LD_EXP 15
2520: PUSH
2521: LD_INT 2
2523: PLUS
2524: PPUSH
2525: CALL_OW 380
// hc_importance := 105 ;
2529: LD_ADDR_OWVAR 32
2533: PUSH
2534: LD_INT 105
2536: ST_TO_ADDR
// commander := false ;
2537: LD_VAR 0 7
2541: PUSH
2542: LD_INT 0
2544: ST_TO_ADDR
// if Multiplayer then
2545: LD_OWVAR 4
2549: IFFALSE 2589
// begin hc_gallery := MULTIAVATARS ;
2551: LD_ADDR_OWVAR 33
2555: PUSH
2556: LD_STRING MULTIAVATARS
2558: ST_TO_ADDR
// hc_face_number := Multiplayer_GetPlayerSideNum ( Side ) ;
2559: LD_ADDR_OWVAR 34
2563: PUSH
2564: LD_VAR 0 1
2568: PPUSH
2569: CALL_OW 525
2573: ST_TO_ADDR
// hc_sex := Multiplayer_GetPlayerSex ( Side ) ;
2574: LD_ADDR_OWVAR 27
2578: PUSH
2579: LD_VAR 0 1
2583: PPUSH
2584: CALL_OW 526
2588: ST_TO_ADDR
// end ; end else
2589: GO 2654
// begin hc_name :=  ;
2591: LD_ADDR_OWVAR 26
2595: PUSH
2596: LD_STRING 
2598: ST_TO_ADDR
// PrepareHuman ( rand ( 1 , 2 ) , cl , priblizna_uroven ) ;
2599: LD_INT 1
2601: PPUSH
2602: LD_INT 2
2604: PPUSH
2605: CALL_OW 12
2609: PPUSH
2610: LD_VAR 0 3
2614: PPUSH
2615: LD_EXP 15
2619: PPUSH
2620: CALL_OW 380
// hc_importance := 0 ;
2624: LD_ADDR_OWVAR 32
2628: PUSH
2629: LD_INT 0
2631: ST_TO_ADDR
// if Multiplayer then
2632: LD_OWVAR 4
2636: IFFALSE 2654
// begin hc_gallery :=  ;
2638: LD_ADDR_OWVAR 33
2642: PUSH
2643: LD_STRING 
2645: ST_TO_ADDR
// hc_face_number := 0 ;
2646: LD_ADDR_OWVAR 34
2650: PUSH
2651: LD_INT 0
2653: ST_TO_ADDR
// end ; end ; un := CreateHuman ;
2654: LD_ADDR_VAR 0 11
2658: PUSH
2659: CALL_OW 44
2663: ST_TO_ADDR
// if global_defined then
2664: LD_LOC 2
2668: IFFALSE 2806
// begin j := i ;
2670: LD_ADDR_VAR 0 10
2674: PUSH
2675: LD_VAR 0 9
2679: ST_TO_ADDR
// if cl = class_soldier then
2680: LD_VAR 0 3
2684: PUSH
2685: LD_INT 1
2687: EQUAL
2688: IFFALSE 2706
// j := i + soldiers_created ;
2690: LD_ADDR_VAR 0 10
2694: PUSH
2695: LD_VAR 0 9
2699: PUSH
2700: LD_LOC 3
2704: PLUS
2705: ST_TO_ADDR
// CopySkills ( global_units [ cl ] [ j ] , un ) ;
2706: LD_LOC 1
2710: PUSH
2711: LD_VAR 0 3
2715: ARRAY
2716: PUSH
2717: LD_VAR 0 10
2721: ARRAY
2722: PPUSH
2723: LD_VAR 0 11
2727: PPUSH
2728: CALL_OW 510
// SetAttr ( un , attr_speed , GetAttr ( global_units [ cl ] [ j ] , attr_speed ) ) ;
2732: LD_VAR 0 11
2736: PPUSH
2737: LD_INT 2
2739: PPUSH
2740: LD_LOC 1
2744: PUSH
2745: LD_VAR 0 3
2749: ARRAY
2750: PUSH
2751: LD_VAR 0 10
2755: ARRAY
2756: PPUSH
2757: LD_INT 2
2759: PPUSH
2760: CALL_OW 260
2764: PPUSH
2765: CALL_OW 239
// SetAttr ( un , attr_stamina , GetAttr ( global_units [ cl ] [ j ] , attr_stamina ) ) ;
2769: LD_VAR 0 11
2773: PPUSH
2774: LD_INT 1
2776: PPUSH
2777: LD_LOC 1
2781: PUSH
2782: LD_VAR 0 3
2786: ARRAY
2787: PUSH
2788: LD_VAR 0 10
2792: ARRAY
2793: PPUSH
2794: LD_INT 1
2796: PPUSH
2797: CALL_OW 260
2801: PPUSH
2802: CALL_OW 239
// end ; PlaceUnitXYR ( un , x , y , r , false ) ;
2806: LD_VAR 0 11
2810: PPUSH
2811: LD_VAR 0 4
2815: PPUSH
2816: LD_VAR 0 5
2820: PPUSH
2821: LD_VAR 0 6
2825: PPUSH
2826: LD_INT 0
2828: PPUSH
2829: CALL_OW 50
// result := result ^ [ un ] ;
2833: LD_ADDR_VAR 0 8
2837: PUSH
2838: LD_VAR 0 8
2842: PUSH
2843: LD_VAR 0 11
2847: PUSH
2848: EMPTY
2849: LIST
2850: ADD
2851: ST_TO_ADDR
// end ;
2852: GO 2459
2854: POP
2855: POP
// if not global_defined then
2856: LD_LOC 2
2860: NOT
2861: IFFALSE 2923
// if cl = class_soldier and global_units then
2863: LD_VAR 0 3
2867: PUSH
2868: LD_INT 1
2870: EQUAL
2871: PUSH
2872: LD_LOC 1
2876: AND
2877: IFFALSE 2904
// global_units := [ global_units [ 1 ] ^ result ] else
2879: LD_ADDR_LOC 1
2883: PUSH
2884: LD_LOC 1
2888: PUSH
2889: LD_INT 1
2891: ARRAY
2892: PUSH
2893: LD_VAR 0 8
2897: ADD
2898: PUSH
2899: EMPTY
2900: LIST
2901: ST_TO_ADDR
2902: GO 2923
// global_units := global_units ^ [ result ] end ;
2904: LD_ADDR_LOC 1
2908: PUSH
2909: LD_LOC 1
2913: PUSH
2914: LD_VAR 0 8
2918: PUSH
2919: EMPTY
2920: LIST
2921: ADD
2922: ST_TO_ADDR
2923: LD_VAR 0 8
2927: RET
// function priprava_strany ( side ) ; var pos , x , y , i , r , sol , br , dep , neng , nsci , nmech , nsol , pocet_bunkru_obsazenych ; begin
2928: LD_INT 0
2930: PPUSH
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
2935: PPUSH
2936: PPUSH
2937: PPUSH
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
2942: PPUSH
2943: PPUSH
// pos := Side_Positions [ side ] ;
2944: LD_ADDR_VAR 0 3
2948: PUSH
2949: LD_EXP 31
2953: PUSH
2954: LD_VAR 0 1
2958: ARRAY
2959: ST_TO_ADDR
// uc_nation := Side_Nations [ side ] ;
2960: LD_ADDR_OWVAR 21
2964: PUSH
2965: LD_EXP 32
2969: PUSH
2970: LD_VAR 0 1
2974: ARRAY
2975: ST_TO_ADDR
// uc_side := side ;
2976: LD_ADDR_OWVAR 20
2980: PUSH
2981: LD_VAR 0 1
2985: ST_TO_ADDR
// x := start_def [ pos ] [ 1 ] ;
2986: LD_ADDR_VAR 0 4
2990: PUSH
2991: LD_EXP 27
2995: PUSH
2996: LD_VAR 0 3
3000: ARRAY
3001: PUSH
3002: LD_INT 1
3004: ARRAY
3005: ST_TO_ADDR
// y := start_def [ pos ] [ 2 ] ;
3006: LD_ADDR_VAR 0 5
3010: PUSH
3011: LD_EXP 27
3015: PUSH
3016: LD_VAR 0 3
3020: ARRAY
3021: PUSH
3022: LD_INT 2
3024: ARRAY
3025: ST_TO_ADDR
// neng := pocet_lidi ;
3026: LD_ADDR_VAR 0 11
3030: PUSH
3031: LD_EXP 14
3035: ST_TO_ADDR
// nsol := 0 ;
3036: LD_ADDR_VAR 0 14
3040: PUSH
3041: LD_INT 0
3043: ST_TO_ADDR
// if nsol < neng div 4 then
3044: LD_VAR 0 14
3048: PUSH
3049: LD_VAR 0 11
3053: PUSH
3054: LD_INT 4
3056: DIV
3057: LESS
3058: IFFALSE 3074
// nsol := neng div 4 ;
3060: LD_ADDR_VAR 0 14
3064: PUSH
3065: LD_VAR 0 11
3069: PUSH
3070: LD_INT 4
3072: DIV
3073: ST_TO_ADDR
// neng := neng - nsol ;
3074: LD_ADDR_VAR 0 11
3078: PUSH
3079: LD_VAR 0 11
3083: PUSH
3084: LD_VAR 0 14
3088: MINUS
3089: ST_TO_ADDR
// nsci := neng div 3 ;
3090: LD_ADDR_VAR 0 12
3094: PUSH
3095: LD_VAR 0 11
3099: PUSH
3100: LD_INT 3
3102: DIV
3103: ST_TO_ADDR
// if nsci < 1 then
3104: LD_VAR 0 12
3108: PUSH
3109: LD_INT 1
3111: LESS
3112: IFFALSE 3122
// nsci := 1 ;
3114: LD_ADDR_VAR 0 12
3118: PUSH
3119: LD_INT 1
3121: ST_TO_ADDR
// neng := neng - nsci ;
3122: LD_ADDR_VAR 0 11
3126: PUSH
3127: LD_VAR 0 11
3131: PUSH
3132: LD_VAR 0 12
3136: MINUS
3137: ST_TO_ADDR
// nmech := neng div 2 ;
3138: LD_ADDR_VAR 0 13
3142: PUSH
3143: LD_VAR 0 11
3147: PUSH
3148: LD_INT 2
3150: DIV
3151: ST_TO_ADDR
// neng := neng - nmech ;
3152: LD_ADDR_VAR 0 11
3156: PUSH
3157: LD_VAR 0 11
3161: PUSH
3162: LD_VAR 0 13
3166: MINUS
3167: ST_TO_ADDR
// if neng < 1 then
3168: LD_VAR 0 11
3172: PUSH
3173: LD_INT 1
3175: LESS
3176: IFFALSE 3186
// neng := 1 ;
3178: LD_ADDR_VAR 0 11
3182: PUSH
3183: LD_INT 1
3185: ST_TO_ADDR
// commander := true ;
3186: LD_ADDR_EXP 38
3190: PUSH
3191: LD_INT 1
3193: ST_TO_ADDR
// x := start_def [ pos ] [ 1 ] ;
3194: LD_ADDR_VAR 0 4
3198: PUSH
3199: LD_EXP 27
3203: PUSH
3204: LD_VAR 0 3
3208: ARRAY
3209: PUSH
3210: LD_INT 1
3212: ARRAY
3213: ST_TO_ADDR
// y := start_def [ pos ] [ 2 ] ;
3214: LD_ADDR_VAR 0 5
3218: PUSH
3219: LD_EXP 27
3223: PUSH
3224: LD_VAR 0 3
3228: ARRAY
3229: PUSH
3230: LD_INT 2
3232: ARRAY
3233: ST_TO_ADDR
// priprava_lidi ( side , nsol , class_soldier , x , y , 5 , commander ) ;
3234: LD_VAR 0 1
3238: PPUSH
3239: LD_VAR 0 14
3243: PPUSH
3244: LD_INT 1
3246: PPUSH
3247: LD_VAR 0 4
3251: PPUSH
3252: LD_VAR 0 5
3256: PPUSH
3257: LD_INT 5
3259: PPUSH
3260: LD_ADDR_EXP 38
3264: PPUSH
3265: CALL 2431 0 7
// priprava_lidi ( side , neng , class_engineer , x , y , 5 , commander ) ;
3269: LD_VAR 0 1
3273: PPUSH
3274: LD_VAR 0 11
3278: PPUSH
3279: LD_INT 2
3281: PPUSH
3282: LD_VAR 0 4
3286: PPUSH
3287: LD_VAR 0 5
3291: PPUSH
3292: LD_INT 5
3294: PPUSH
3295: LD_ADDR_EXP 38
3299: PPUSH
3300: CALL 2431 0 7
// priprava_lidi ( side , nmech , class_mechanic , x , y , 5 , commander ) ;
3304: LD_VAR 0 1
3308: PPUSH
3309: LD_VAR 0 13
3313: PPUSH
3314: LD_INT 3
3316: PPUSH
3317: LD_VAR 0 4
3321: PPUSH
3322: LD_VAR 0 5
3326: PPUSH
3327: LD_INT 5
3329: PPUSH
3330: LD_ADDR_EXP 38
3334: PPUSH
3335: CALL 2431 0 7
// priprava_lidi ( side , nsci , class_scientistic , x , y , 5 , commander ) ;
3339: LD_VAR 0 1
3343: PPUSH
3344: LD_VAR 0 12
3348: PPUSH
3349: LD_INT 4
3351: PPUSH
3352: LD_VAR 0 4
3356: PPUSH
3357: LD_VAR 0 5
3361: PPUSH
3362: LD_INT 5
3364: PPUSH
3365: LD_ADDR_EXP 38
3369: PPUSH
3370: CALL 2431 0 7
// if not global_defined then
3374: LD_LOC 2
3378: NOT
3379: IFFALSE 3389
// global_defined := true ;
3381: LD_ADDR_LOC 2
3385: PUSH
3386: LD_INT 1
3388: ST_TO_ADDR
// if def_sib_detekce then
3389: LD_EXP 8
3393: IFFALSE 3410
// SetTech ( tech_SibDet , side , state_researched ) ;
3395: LD_INT 20
3397: PPUSH
3398: LD_VAR 0 1
3402: PPUSH
3403: LD_INT 2
3405: PPUSH
3406: CALL_OW 322
// priprava_vozidla ( side , def_uroven_konvoje , x , y , 5 ) ;
3410: LD_VAR 0 1
3414: PPUSH
3415: LD_EXP 2
3419: PPUSH
3420: LD_VAR 0 4
3424: PPUSH
3425: LD_VAR 0 5
3429: PPUSH
3430: LD_INT 5
3432: PPUSH
3433: CALL 3442 0 5
// end ;
3437: LD_VAR 0 2
3441: RET
// function priprava_vozidla ( side , k , x , y , r ) ; var i , un ; begin
3442: LD_INT 0
3444: PPUSH
3445: PPUSH
3446: PPUSH
// uc_nation := Side_Nations [ side ] ;
3447: LD_ADDR_OWVAR 21
3451: PUSH
3452: LD_EXP 32
3456: PUSH
3457: LD_VAR 0 1
3461: ARRAY
3462: ST_TO_ADDR
// uc_side := side ;
3463: LD_ADDR_OWVAR 20
3467: PUSH
3468: LD_VAR 0 1
3472: ST_TO_ADDR
// case uc_nation of 1 :
3473: LD_OWVAR 21
3477: PUSH
3478: LD_INT 1
3480: DOUBLE
3481: EQUAL
3482: IFTRUE 3486
3484: GO 3993
3486: POP
// case k of 1 :
3487: LD_VAR 0 2
3491: PUSH
3492: LD_INT 1
3494: DOUBLE
3495: EQUAL
3496: IFTRUE 3500
3498: GO 3601
3500: POP
// begin vc_weapon = us_cargo_bay ;
3501: LD_ADDR_OWVAR 40
3505: PUSH
3506: LD_INT 12
3508: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
3509: LD_ADDR_OWVAR 37
3513: PUSH
3514: LD_INT 3
3516: ST_TO_ADDR
// un := createvehicle ;
3517: LD_ADDR_VAR 0 8
3521: PUSH
3522: CALL_OW 45
3526: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
3527: LD_VAR 0 8
3531: PPUSH
3532: LD_VAR 0 3
3536: PPUSH
3537: LD_VAR 0 4
3541: PPUSH
3542: LD_VAR 0 5
3546: PPUSH
3547: LD_INT 0
3549: PPUSH
3550: CALL_OW 50
// setcargo ( un , mat_oil , 20 ) ;
3554: LD_VAR 0 8
3558: PPUSH
3559: LD_INT 2
3561: PPUSH
3562: LD_INT 20
3564: PPUSH
3565: CALL_OW 290
// addcargo ( un , mat_cans , 70 ) ;
3569: LD_VAR 0 8
3573: PPUSH
3574: LD_INT 1
3576: PPUSH
3577: LD_INT 70
3579: PPUSH
3580: CALL_OW 291
// addcargo ( un , mat_siberit , 10 ) ;
3584: LD_VAR 0 8
3588: PPUSH
3589: LD_INT 3
3591: PPUSH
3592: LD_INT 10
3594: PPUSH
3595: CALL_OW 291
// end ; 2 :
3599: GO 3991
3601: LD_INT 2
3603: DOUBLE
3604: EQUAL
3605: IFTRUE 3609
3607: GO 3763
3609: POP
// begin vc_weapon = us_cargo_bay ;
3610: LD_ADDR_OWVAR 40
3614: PUSH
3615: LD_INT 12
3617: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
3618: LD_ADDR_OWVAR 37
3622: PUSH
3623: LD_INT 3
3625: ST_TO_ADDR
// un := createvehicle ;
3626: LD_ADDR_VAR 0 8
3630: PUSH
3631: CALL_OW 45
3635: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
3636: LD_VAR 0 8
3640: PPUSH
3641: LD_VAR 0 3
3645: PPUSH
3646: LD_VAR 0 4
3650: PPUSH
3651: LD_VAR 0 5
3655: PPUSH
3656: LD_INT 0
3658: PPUSH
3659: CALL_OW 50
// setcargo ( un , mat_oil , 20 ) ;
3663: LD_VAR 0 8
3667: PPUSH
3668: LD_INT 2
3670: PPUSH
3671: LD_INT 20
3673: PPUSH
3674: CALL_OW 290
// addcargo ( un , mat_cans , 70 ) ;
3678: LD_VAR 0 8
3682: PPUSH
3683: LD_INT 1
3685: PPUSH
3686: LD_INT 70
3688: PPUSH
3689: CALL_OW 291
// addcargo ( un , mat_siberit , 10 ) ;
3693: LD_VAR 0 8
3697: PPUSH
3698: LD_INT 3
3700: PPUSH
3701: LD_INT 10
3703: PPUSH
3704: CALL_OW 291
// vc_weapon = us_light_gun ;
3708: LD_ADDR_OWVAR 40
3712: PUSH
3713: LD_INT 3
3715: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
3716: LD_ADDR_OWVAR 37
3720: PUSH
3721: LD_INT 3
3723: ST_TO_ADDR
// un := createvehicle ;
3724: LD_ADDR_VAR 0 8
3728: PUSH
3729: CALL_OW 45
3733: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
3734: LD_VAR 0 8
3738: PPUSH
3739: LD_VAR 0 3
3743: PPUSH
3744: LD_VAR 0 4
3748: PPUSH
3749: LD_VAR 0 5
3753: PPUSH
3754: LD_INT 0
3756: PPUSH
3757: CALL_OW 50
// end ; 3 :
3761: GO 3991
3763: LD_INT 3
3765: DOUBLE
3766: EQUAL
3767: IFTRUE 3771
3769: GO 3990
3771: POP
// begin vc_weapon = us_cargo_bay ;
3772: LD_ADDR_OWVAR 40
3776: PUSH
3777: LD_INT 12
3779: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
3780: LD_ADDR_OWVAR 37
3784: PUSH
3785: LD_INT 3
3787: ST_TO_ADDR
// un := createvehicle ;
3788: LD_ADDR_VAR 0 8
3792: PUSH
3793: CALL_OW 45
3797: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
3798: LD_VAR 0 8
3802: PPUSH
3803: LD_VAR 0 3
3807: PPUSH
3808: LD_VAR 0 4
3812: PPUSH
3813: LD_VAR 0 5
3817: PPUSH
3818: LD_INT 0
3820: PPUSH
3821: CALL_OW 50
// setcargo ( un , mat_oil , 20 ) ;
3825: LD_VAR 0 8
3829: PPUSH
3830: LD_INT 2
3832: PPUSH
3833: LD_INT 20
3835: PPUSH
3836: CALL_OW 290
// addcargo ( un , mat_cans , 70 ) ;
3840: LD_VAR 0 8
3844: PPUSH
3845: LD_INT 1
3847: PPUSH
3848: LD_INT 70
3850: PPUSH
3851: CALL_OW 291
// addcargo ( un , mat_siberit , 10 ) ;
3855: LD_VAR 0 8
3859: PPUSH
3860: LD_INT 3
3862: PPUSH
3863: LD_INT 10
3865: PPUSH
3866: CALL_OW 291
// for i = 1 to 2 do
3870: LD_ADDR_VAR 0 7
3874: PUSH
3875: DOUBLE
3876: LD_INT 1
3878: DEC
3879: ST_TO_ADDR
3880: LD_INT 2
3882: PUSH
3883: FOR_TO
3884: IFFALSE 3986
// begin vc_weapon = us_light_gun ;
3886: LD_ADDR_OWVAR 40
3890: PUSH
3891: LD_INT 3
3893: ST_TO_ADDR
// vc_chassis = us_medium_tracked ;
3894: LD_ADDR_OWVAR 37
3898: PUSH
3899: LD_INT 3
3901: ST_TO_ADDR
// un := createvehicle ;
3902: LD_ADDR_VAR 0 8
3906: PUSH
3907: CALL_OW 45
3911: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
3912: LD_VAR 0 8
3916: PPUSH
3917: LD_VAR 0 3
3921: PPUSH
3922: LD_VAR 0 4
3926: PPUSH
3927: LD_VAR 0 5
3931: PPUSH
3932: LD_INT 0
3934: PPUSH
3935: CALL_OW 50
// setcargo ( un , mat_oil , 20 ) ;
3939: LD_VAR 0 8
3943: PPUSH
3944: LD_INT 2
3946: PPUSH
3947: LD_INT 20
3949: PPUSH
3950: CALL_OW 290
// addcargo ( un , mat_cans , 70 ) ;
3954: LD_VAR 0 8
3958: PPUSH
3959: LD_INT 1
3961: PPUSH
3962: LD_INT 70
3964: PPUSH
3965: CALL_OW 291
// addcargo ( un , mat_siberit , 10 ) ;
3969: LD_VAR 0 8
3973: PPUSH
3974: LD_INT 3
3976: PPUSH
3977: LD_INT 10
3979: PPUSH
3980: CALL_OW 291
// end ;
3984: GO 3883
3986: POP
3987: POP
// end ; end ; 2 :
3988: GO 3991
3990: POP
3991: GO 4934
3993: LD_INT 2
3995: DOUBLE
3996: EQUAL
3997: IFTRUE 4001
3999: GO 4463
4001: POP
// case k of 1 :
4002: LD_VAR 0 2
4006: PUSH
4007: LD_INT 1
4009: DOUBLE
4010: EQUAL
4011: IFTRUE 4015
4013: GO 4116
4015: POP
// begin vc_weapon = ar_cargo_bay ;
4016: LD_ADDR_OWVAR 40
4020: PUSH
4021: LD_INT 32
4023: ST_TO_ADDR
// vc_chassis = ar_half_tracked ;
4024: LD_ADDR_OWVAR 37
4028: PUSH
4029: LD_INT 14
4031: ST_TO_ADDR
// un := createvehicle ;
4032: LD_ADDR_VAR 0 8
4036: PUSH
4037: CALL_OW 45
4041: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
4042: LD_VAR 0 8
4046: PPUSH
4047: LD_VAR 0 3
4051: PPUSH
4052: LD_VAR 0 4
4056: PPUSH
4057: LD_VAR 0 5
4061: PPUSH
4062: LD_INT 0
4064: PPUSH
4065: CALL_OW 50
// setcargo ( un , mat_oil , 20 ) ;
4069: LD_VAR 0 8
4073: PPUSH
4074: LD_INT 2
4076: PPUSH
4077: LD_INT 20
4079: PPUSH
4080: CALL_OW 290
// addcargo ( un , mat_cans , 70 ) ;
4084: LD_VAR 0 8
4088: PPUSH
4089: LD_INT 1
4091: PPUSH
4092: LD_INT 70
4094: PPUSH
4095: CALL_OW 291
// addcargo ( un , mat_siberit , 10 ) ;
4099: LD_VAR 0 8
4103: PPUSH
4104: LD_INT 3
4106: PPUSH
4107: LD_INT 10
4109: PPUSH
4110: CALL_OW 291
// end ; 2 :
4114: GO 4461
4116: LD_INT 2
4118: DOUBLE
4119: EQUAL
4120: IFTRUE 4124
4122: GO 4278
4124: POP
// begin vc_weapon = ar_cargo_bay ;
4125: LD_ADDR_OWVAR 40
4129: PUSH
4130: LD_INT 32
4132: ST_TO_ADDR
// vc_chassis = ar_half_tracked ;
4133: LD_ADDR_OWVAR 37
4137: PUSH
4138: LD_INT 14
4140: ST_TO_ADDR
// un := createvehicle ;
4141: LD_ADDR_VAR 0 8
4145: PUSH
4146: CALL_OW 45
4150: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
4151: LD_VAR 0 8
4155: PPUSH
4156: LD_VAR 0 3
4160: PPUSH
4161: LD_VAR 0 4
4165: PPUSH
4166: LD_VAR 0 5
4170: PPUSH
4171: LD_INT 0
4173: PPUSH
4174: CALL_OW 50
// setcargo ( un , mat_oil , 20 ) ;
4178: LD_VAR 0 8
4182: PPUSH
4183: LD_INT 2
4185: PPUSH
4186: LD_INT 20
4188: PPUSH
4189: CALL_OW 290
// addcargo ( un , mat_cans , 70 ) ;
4193: LD_VAR 0 8
4197: PPUSH
4198: LD_INT 1
4200: PPUSH
4201: LD_INT 70
4203: PPUSH
4204: CALL_OW 291
// addcargo ( un , mat_siberit , 10 ) ;
4208: LD_VAR 0 8
4212: PPUSH
4213: LD_INT 3
4215: PPUSH
4216: LD_INT 10
4218: PPUSH
4219: CALL_OW 291
// vc_weapon = ar_light_gun ;
4223: LD_ADDR_OWVAR 40
4227: PUSH
4228: LD_INT 23
4230: ST_TO_ADDR
// vc_chassis = ar_half_tracked ;
4231: LD_ADDR_OWVAR 37
4235: PUSH
4236: LD_INT 14
4238: ST_TO_ADDR
// un := createvehicle ;
4239: LD_ADDR_VAR 0 8
4243: PUSH
4244: CALL_OW 45
4248: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
4249: LD_VAR 0 8
4253: PPUSH
4254: LD_VAR 0 3
4258: PPUSH
4259: LD_VAR 0 4
4263: PPUSH
4264: LD_VAR 0 5
4268: PPUSH
4269: LD_INT 0
4271: PPUSH
4272: CALL_OW 50
// end ; 3 :
4276: GO 4461
4278: LD_INT 3
4280: DOUBLE
4281: EQUAL
4282: IFTRUE 4286
4284: GO 4460
4286: POP
// begin vc_weapon = ar_cargo_bay ;
4287: LD_ADDR_OWVAR 40
4291: PUSH
4292: LD_INT 32
4294: ST_TO_ADDR
// vc_chassis = ar_half_tracked ;
4295: LD_ADDR_OWVAR 37
4299: PUSH
4300: LD_INT 14
4302: ST_TO_ADDR
// un := createvehicle ;
4303: LD_ADDR_VAR 0 8
4307: PUSH
4308: CALL_OW 45
4312: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
4313: LD_VAR 0 8
4317: PPUSH
4318: LD_VAR 0 3
4322: PPUSH
4323: LD_VAR 0 4
4327: PPUSH
4328: LD_VAR 0 5
4332: PPUSH
4333: LD_INT 0
4335: PPUSH
4336: CALL_OW 50
// setcargo ( un , mat_oil , 20 ) ;
4340: LD_VAR 0 8
4344: PPUSH
4345: LD_INT 2
4347: PPUSH
4348: LD_INT 20
4350: PPUSH
4351: CALL_OW 290
// addcargo ( un , mat_cans , 70 ) ;
4355: LD_VAR 0 8
4359: PPUSH
4360: LD_INT 1
4362: PPUSH
4363: LD_INT 70
4365: PPUSH
4366: CALL_OW 291
// addcargo ( un , mat_siberit , 10 ) ;
4370: LD_VAR 0 8
4374: PPUSH
4375: LD_INT 3
4377: PPUSH
4378: LD_INT 10
4380: PPUSH
4381: CALL_OW 291
// for i = 1 to 2 do
4385: LD_ADDR_VAR 0 7
4389: PUSH
4390: DOUBLE
4391: LD_INT 1
4393: DEC
4394: ST_TO_ADDR
4395: LD_INT 2
4397: PUSH
4398: FOR_TO
4399: IFFALSE 4456
// begin vc_weapon = ar_light_gun ;
4401: LD_ADDR_OWVAR 40
4405: PUSH
4406: LD_INT 23
4408: ST_TO_ADDR
// vc_chassis = ar_half_tracked ;
4409: LD_ADDR_OWVAR 37
4413: PUSH
4414: LD_INT 14
4416: ST_TO_ADDR
// un := createvehicle ;
4417: LD_ADDR_VAR 0 8
4421: PUSH
4422: CALL_OW 45
4426: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
4427: LD_VAR 0 8
4431: PPUSH
4432: LD_VAR 0 3
4436: PPUSH
4437: LD_VAR 0 4
4441: PPUSH
4442: LD_VAR 0 5
4446: PPUSH
4447: LD_INT 0
4449: PPUSH
4450: CALL_OW 50
// end ;
4454: GO 4398
4456: POP
4457: POP
// end ; end ; 3 :
4458: GO 4461
4460: POP
4461: GO 4934
4463: LD_INT 3
4465: DOUBLE
4466: EQUAL
4467: IFTRUE 4471
4469: GO 4933
4471: POP
// case k of 1 :
4472: LD_VAR 0 2
4476: PUSH
4477: LD_INT 1
4479: DOUBLE
4480: EQUAL
4481: IFTRUE 4485
4483: GO 4586
4485: POP
// begin vc_weapon = ru_cargo_bay ;
4486: LD_ADDR_OWVAR 40
4490: PUSH
4491: LD_INT 51
4493: ST_TO_ADDR
// vc_chassis = ru_medium_wheeled ;
4494: LD_ADDR_OWVAR 37
4498: PUSH
4499: LD_INT 21
4501: ST_TO_ADDR
// un := createvehicle ;
4502: LD_ADDR_VAR 0 8
4506: PUSH
4507: CALL_OW 45
4511: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
4512: LD_VAR 0 8
4516: PPUSH
4517: LD_VAR 0 3
4521: PPUSH
4522: LD_VAR 0 4
4526: PPUSH
4527: LD_VAR 0 5
4531: PPUSH
4532: LD_INT 0
4534: PPUSH
4535: CALL_OW 50
// setcargo ( un , mat_oil , 20 ) ;
4539: LD_VAR 0 8
4543: PPUSH
4544: LD_INT 2
4546: PPUSH
4547: LD_INT 20
4549: PPUSH
4550: CALL_OW 290
// addcargo ( un , mat_cans , 70 ) ;
4554: LD_VAR 0 8
4558: PPUSH
4559: LD_INT 1
4561: PPUSH
4562: LD_INT 70
4564: PPUSH
4565: CALL_OW 291
// addcargo ( un , mat_siberit , 10 ) ;
4569: LD_VAR 0 8
4573: PPUSH
4574: LD_INT 3
4576: PPUSH
4577: LD_INT 10
4579: PPUSH
4580: CALL_OW 291
// end ; 2 :
4584: GO 4931
4586: LD_INT 2
4588: DOUBLE
4589: EQUAL
4590: IFTRUE 4594
4592: GO 4748
4594: POP
// begin vc_weapon = ru_cargo_bay ;
4595: LD_ADDR_OWVAR 40
4599: PUSH
4600: LD_INT 51
4602: ST_TO_ADDR
// vc_chassis = ru_medium_wheeled ;
4603: LD_ADDR_OWVAR 37
4607: PUSH
4608: LD_INT 21
4610: ST_TO_ADDR
// un := createvehicle ;
4611: LD_ADDR_VAR 0 8
4615: PUSH
4616: CALL_OW 45
4620: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
4621: LD_VAR 0 8
4625: PPUSH
4626: LD_VAR 0 3
4630: PPUSH
4631: LD_VAR 0 4
4635: PPUSH
4636: LD_VAR 0 5
4640: PPUSH
4641: LD_INT 0
4643: PPUSH
4644: CALL_OW 50
// setcargo ( un , mat_oil , 20 ) ;
4648: LD_VAR 0 8
4652: PPUSH
4653: LD_INT 2
4655: PPUSH
4656: LD_INT 20
4658: PPUSH
4659: CALL_OW 290
// addcargo ( un , mat_cans , 70 ) ;
4663: LD_VAR 0 8
4667: PPUSH
4668: LD_INT 1
4670: PPUSH
4671: LD_INT 70
4673: PPUSH
4674: CALL_OW 291
// addcargo ( un , mat_siberit , 10 ) ;
4678: LD_VAR 0 8
4682: PPUSH
4683: LD_INT 3
4685: PPUSH
4686: LD_INT 10
4688: PPUSH
4689: CALL_OW 291
// vc_weapon = ru_gun ;
4693: LD_ADDR_OWVAR 40
4697: PUSH
4698: LD_INT 44
4700: ST_TO_ADDR
// vc_chassis = ru_medium_wheeled ;
4701: LD_ADDR_OWVAR 37
4705: PUSH
4706: LD_INT 21
4708: ST_TO_ADDR
// un := createvehicle ;
4709: LD_ADDR_VAR 0 8
4713: PUSH
4714: CALL_OW 45
4718: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
4719: LD_VAR 0 8
4723: PPUSH
4724: LD_VAR 0 3
4728: PPUSH
4729: LD_VAR 0 4
4733: PPUSH
4734: LD_VAR 0 5
4738: PPUSH
4739: LD_INT 0
4741: PPUSH
4742: CALL_OW 50
// end ; 3 :
4746: GO 4931
4748: LD_INT 3
4750: DOUBLE
4751: EQUAL
4752: IFTRUE 4756
4754: GO 4930
4756: POP
// begin vc_weapon = ru_cargo_bay ;
4757: LD_ADDR_OWVAR 40
4761: PUSH
4762: LD_INT 51
4764: ST_TO_ADDR
// vc_chassis = ru_medium_wheeled ;
4765: LD_ADDR_OWVAR 37
4769: PUSH
4770: LD_INT 21
4772: ST_TO_ADDR
// un := createvehicle ;
4773: LD_ADDR_VAR 0 8
4777: PUSH
4778: CALL_OW 45
4782: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
4783: LD_VAR 0 8
4787: PPUSH
4788: LD_VAR 0 3
4792: PPUSH
4793: LD_VAR 0 4
4797: PPUSH
4798: LD_VAR 0 5
4802: PPUSH
4803: LD_INT 0
4805: PPUSH
4806: CALL_OW 50
// setcargo ( un , mat_oil , 20 ) ;
4810: LD_VAR 0 8
4814: PPUSH
4815: LD_INT 2
4817: PPUSH
4818: LD_INT 20
4820: PPUSH
4821: CALL_OW 290
// addcargo ( un , mat_cans , 70 ) ;
4825: LD_VAR 0 8
4829: PPUSH
4830: LD_INT 1
4832: PPUSH
4833: LD_INT 70
4835: PPUSH
4836: CALL_OW 291
// addcargo ( un , mat_siberit , 10 ) ;
4840: LD_VAR 0 8
4844: PPUSH
4845: LD_INT 3
4847: PPUSH
4848: LD_INT 10
4850: PPUSH
4851: CALL_OW 291
// for i = 1 to 2 do
4855: LD_ADDR_VAR 0 7
4859: PUSH
4860: DOUBLE
4861: LD_INT 1
4863: DEC
4864: ST_TO_ADDR
4865: LD_INT 2
4867: PUSH
4868: FOR_TO
4869: IFFALSE 4926
// begin vc_weapon = ru_gun ;
4871: LD_ADDR_OWVAR 40
4875: PUSH
4876: LD_INT 44
4878: ST_TO_ADDR
// vc_chassis = ru_medium_wheeled ;
4879: LD_ADDR_OWVAR 37
4883: PUSH
4884: LD_INT 21
4886: ST_TO_ADDR
// un := createvehicle ;
4887: LD_ADDR_VAR 0 8
4891: PUSH
4892: CALL_OW 45
4896: ST_TO_ADDR
// PlaceUnitXYR ( un , x , y , r , false ) ;
4897: LD_VAR 0 8
4901: PPUSH
4902: LD_VAR 0 3
4906: PPUSH
4907: LD_VAR 0 4
4911: PPUSH
4912: LD_VAR 0 5
4916: PPUSH
4917: LD_INT 0
4919: PPUSH
4920: CALL_OW 50
// end ;
4924: GO 4868
4926: POP
4927: POP
// end ; end ; end ;
4928: GO 4931
4930: POP
4931: GO 4934
4933: POP
// end ;
4934: LD_VAR 0 6
4938: RET
// function priprava_stran ; var i ; begin
4939: LD_INT 0
4941: PPUSH
4942: PPUSH
// global_units := [ ] ;
4943: LD_ADDR_LOC 1
4947: PUSH
4948: EMPTY
4949: ST_TO_ADDR
// global_defined := false ;
4950: LD_ADDR_LOC 2
4954: PUSH
4955: LD_INT 0
4957: ST_TO_ADDR
// for i := 1 to Side_Positions do
4958: LD_ADDR_VAR 0 2
4962: PUSH
4963: DOUBLE
4964: LD_INT 1
4966: DEC
4967: ST_TO_ADDR
4968: LD_EXP 31
4972: PUSH
4973: FOR_TO
4974: IFFALSE 4999
// if Side_Positions [ i ] then
4976: LD_EXP 31
4980: PUSH
4981: LD_VAR 0 2
4985: ARRAY
4986: IFFALSE 4997
// priprava_strany ( i ) ;
4988: LD_VAR 0 2
4992: PPUSH
4993: CALL 2928 0 1
4997: GO 4973
4999: POP
5000: POP
// end ;
5001: LD_VAR 0 1
5005: RET
// starting begin enable_human_prediction := true ;
5006: LD_ADDR_OWVAR 51
5010: PUSH
5011: LD_INT 1
5013: ST_TO_ADDR
// Vypni_vsechny_Markety ;
5014: CALL 5340 0 0
// mp_selectmsg := true ;
5018: LD_ADDR_OWVAR 13
5022: PUSH
5023: LD_INT 1
5025: ST_TO_ADDR
// cteni_multiplayeru_a_hernich_parametru ;
5026: CALL 0 0 0
// nastav_viditelnost_stran_a_alianci ;
5030: CALL 2068 0 0
// ResetFog ;
5034: CALL_OW 335
// ClearAllFogForSide ( Player_Side ) ;
5038: LD_EXP 29
5042: PPUSH
5043: CALL_OW 520
// priprava_stran ;
5047: CALL 4939 0 0
// Init_Podminky_Vyhry ;
5051: CALL 5578 0 0
// InitMultiplayerTime ;
5055: CALL 5505 0 0
// Oblasti_Bedny ;
5059: CALL 7442 0 0
// init_respawn ;
5063: CALL 8068 0 0
// your_side := Player_Side ;
5067: LD_ADDR_OWVAR 2
5071: PUSH
5072: LD_EXP 29
5076: ST_TO_ADDR
// music_nat := Side_Nations [ your_side ] ;
5077: LD_ADDR_OWVAR 71
5081: PUSH
5082: LD_EXP 32
5086: PUSH
5087: LD_OWVAR 2
5091: ARRAY
5092: ST_TO_ADDR
// CenterNowOnXY ( start_def [ Side_Positions [ your_side ] ] [ 1 ] , start_def [ Side_Positions [ your_side ] ] [ 2 ] ) ;
5093: LD_EXP 27
5097: PUSH
5098: LD_EXP 31
5102: PUSH
5103: LD_OWVAR 2
5107: ARRAY
5108: ARRAY
5109: PUSH
5110: LD_INT 1
5112: ARRAY
5113: PPUSH
5114: LD_EXP 27
5118: PUSH
5119: LD_EXP 31
5123: PUSH
5124: LD_OWVAR 2
5128: ARRAY
5129: ARRAY
5130: PUSH
5131: LD_INT 2
5133: ARRAY
5134: PPUSH
5135: CALL_OW 86
// end ;
5139: END
// every 0 0$1 do var i ;
5140: GO 5142
5142: DISABLE
5143: LD_INT 0
5145: PPUSH
// begin for i = 1 to 8 do
5146: LD_ADDR_VAR 0 1
5150: PUSH
5151: DOUBLE
5152: LD_INT 1
5154: DEC
5155: ST_TO_ADDR
5156: LD_INT 8
5158: PUSH
5159: FOR_TO
5160: IFFALSE 5194
// begin SetTech ( tech_SibFiss , i , state_disabled ) ;
5162: LD_INT 25
5164: PPUSH
5165: LD_VAR 0 1
5169: PPUSH
5170: LD_INT 0
5172: PPUSH
5173: CALL_OW 322
// SetTech ( 73 , i , state_disabled ) ;
5177: LD_INT 73
5179: PPUSH
5180: LD_VAR 0 1
5184: PPUSH
5185: LD_INT 0
5187: PPUSH
5188: CALL_OW 322
// end ;
5192: GO 5159
5194: POP
5195: POP
// case def_sib_bomb of 0 :
5196: LD_EXP 13
5200: PUSH
5201: LD_INT 0
5203: DOUBLE
5204: EQUAL
5205: IFTRUE 5209
5207: GO 5214
5209: POP
// exit ; 2 :
5210: GO 5337
5212: GO 5287
5214: LD_INT 2
5216: DOUBLE
5217: EQUAL
5218: IFTRUE 5222
5220: GO 5232
5222: POP
// wait ( 30 30$0 ) ; 3 :
5223: LD_INT 63000
5225: PPUSH
5226: CALL_OW 67
5230: GO 5287
5232: LD_INT 3
5234: DOUBLE
5235: EQUAL
5236: IFTRUE 5240
5238: GO 5250
5240: POP
// wait ( 60 60$0 ) ; 4 :
5241: LD_INT 126000
5243: PPUSH
5244: CALL_OW 67
5248: GO 5287
5250: LD_INT 4
5252: DOUBLE
5253: EQUAL
5254: IFTRUE 5258
5256: GO 5268
5258: POP
// wait ( 90 90$0 ) ; 5 :
5259: LD_INT 189000
5261: PPUSH
5262: CALL_OW 67
5266: GO 5287
5268: LD_INT 5
5270: DOUBLE
5271: EQUAL
5272: IFTRUE 5276
5274: GO 5286
5276: POP
// wait ( 120 120$0 ) ; end ;
5277: LD_INT 252000
5279: PPUSH
5280: CALL_OW 67
5284: GO 5287
5286: POP
// for i = 1 to 8 do
5287: LD_ADDR_VAR 0 1
5291: PUSH
5292: DOUBLE
5293: LD_INT 1
5295: DEC
5296: ST_TO_ADDR
5297: LD_INT 8
5299: PUSH
5300: FOR_TO
5301: IFFALSE 5335
// begin SetTech ( tech_SibFiss , i , state_enabled ) ;
5303: LD_INT 25
5305: PPUSH
5306: LD_VAR 0 1
5310: PPUSH
5311: LD_INT 1
5313: PPUSH
5314: CALL_OW 322
// SetTech ( 73 , i , state_enabled ) ;
5318: LD_INT 73
5320: PPUSH
5321: LD_VAR 0 1
5325: PPUSH
5326: LD_INT 1
5328: PPUSH
5329: CALL_OW 322
// end ;
5333: GO 5300
5335: POP
5336: POP
// end ; end_of_file
5337: PPOPN 1
5339: END
// export function Vypni_vsechny_Markety ; begin
5340: LD_INT 0
5342: PPUSH
// disable ( 350 ) ;
5343: LD_INT 350
5345: DISABLE_MARKED
// disable ( 400 ) ;
5346: LD_INT 400
5348: DISABLE_MARKED
// disable ( 401 ) ;
5349: LD_INT 401
5351: DISABLE_MARKED
// end ; end_of_file
5352: LD_VAR 0 1
5356: RET
// export function ZobrazJmena ; var i ; begin
5357: LD_INT 0
5359: PPUSH
5360: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) do
5361: LD_ADDR_VAR 0 2
5365: PUSH
5366: LD_INT 2
5368: PUSH
5369: LD_INT 30
5371: PUSH
5372: LD_INT 0
5374: PUSH
5375: EMPTY
5376: LIST
5377: LIST
5378: PUSH
5379: LD_INT 30
5381: PUSH
5382: LD_INT 1
5384: PUSH
5385: EMPTY
5386: LIST
5387: LIST
5388: PUSH
5389: EMPTY
5390: LIST
5391: LIST
5392: LIST
5393: PPUSH
5394: CALL_OW 69
5398: PUSH
5399: FOR_IN
5400: IFFALSE 5427
// SetBName ( i , @ & GetSide ( i ) ) ;
5402: LD_VAR 0 2
5406: PPUSH
5407: LD_STRING @
5409: PUSH
5410: LD_VAR 0 2
5414: PPUSH
5415: CALL_OW 255
5419: STR
5420: PPUSH
5421: CALL_OW 500
5425: GO 5399
5427: POP
5428: POP
// end ;
5429: LD_VAR 0 1
5433: RET
// every 0 0$2 do
5434: GO 5436
5436: DISABLE
// ZobrazJmena ;
5437: CALL 5357 0 0
5441: END
// on BuildingComplete ( b ) do ZobrazJmena ;
5442: CALL 5357 0 0
5446: PPOPN 1
5448: END
// on BuildingStarted ( b , h ) do ZobrazJmena ;
5449: CALL 5357 0 0
5453: PPOPN 2
5455: END
// on BuildingCaptured ( b , o , e ) do ZobrazJmena ; end_of_file
5456: CALL 5357 0 0
5460: PPOPN 3
5462: END
// export MultiplayerTimeEnabled ; export function GetMultiplayerTime ; begin
5463: LD_INT 0
5465: PPUSH
// Result = [ #gamespeed , game_speed - 4 ] ^ [ #Multi1x1-Time , tick ] ;
5466: LD_ADDR_VAR 0 1
5470: PUSH
5471: LD_STRING #gamespeed
5473: PUSH
5474: LD_OWVAR 65
5478: PUSH
5479: LD_INT 4
5481: MINUS
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: PUSH
5487: LD_STRING #Multi1x1-Time
5489: PUSH
5490: LD_OWVAR 1
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: ADD
5499: ST_TO_ADDR
// end ;
5500: LD_VAR 0 1
5504: RET
// export function InitMultiplayerTime ; begin
5505: LD_INT 0
5507: PPUSH
// MultiplayerTimeEnabled := true ;
5508: LD_ADDR_EXP 39
5512: PUSH
5513: LD_INT 1
5515: ST_TO_ADDR
// display_strings = GetMultiplayerTime ;
5516: LD_ADDR_OWVAR 47
5520: PUSH
5521: CALL 5463 0 0
5525: ST_TO_ADDR
// end ;
5526: LD_VAR 0 1
5530: RET
// every 0 0$1 + 0 0$0.1 trigger MultiplayerTimeEnabled do
5531: LD_EXP 39
5535: IFFALSE 5577
5537: GO 5539
5539: DISABLE
// begin display_strings = GetMultiplayerTime ;
5540: LD_ADDR_OWVAR 47
5544: PUSH
5545: CALL 5463 0 0
5549: ST_TO_ADDR
// if ( WaitServerStrings ) then
5550: LD_EXP 40
5554: IFFALSE 5576
// display_strings := display_strings ^  ^ WaitServerStrings ;
5556: LD_ADDR_OWVAR 47
5560: PUSH
5561: LD_OWVAR 47
5565: PUSH
5566: LD_STRING 
5568: ADD
5569: PUSH
5570: LD_EXP 40
5574: ADD
5575: ST_TO_ADDR
// enable ;
5576: ENABLE
// end ; end_of_file
5577: END
// export function Init_Podminky_Vyhry ; begin
5578: LD_INT 0
5580: PPUSH
// if Team_Game then
5581: LD_EXP 37
5585: IFFALSE 5592
// enable ( 98 ) else
5587: LD_INT 98
5589: ENABLE_MARKED
5590: GO 5595
// enable ( 99 ) ;
5592: LD_INT 99
5594: ENABLE_MARKED
// end ;
5595: LD_VAR 0 1
5599: RET
// function CanWinLoose ; begin
5600: LD_INT 0
5602: PPUSH
// Result := true ;
5603: LD_ADDR_VAR 0 1
5607: PUSH
5608: LD_INT 1
5610: ST_TO_ADDR
// if IAmServer and PlayerCount > 0 then
5611: CALL_OW 518
5615: PUSH
5616: CALL_OW 519
5620: PUSH
5621: LD_INT 0
5623: GREATER
5624: AND
5625: IFFALSE 5635
// Result := false ;
5627: LD_ADDR_VAR 0 1
5631: PUSH
5632: LD_INT 0
5634: ST_TO_ADDR
// if IAmSpec and PlayerCount > 1 then
5635: CALL_OW 531
5639: PUSH
5640: CALL_OW 519
5644: PUSH
5645: LD_INT 1
5647: GREATER
5648: AND
5649: IFFALSE 5659
// Result := false ;
5651: LD_ADDR_VAR 0 1
5655: PUSH
5656: LD_INT 0
5658: ST_TO_ADDR
// end ;
5659: LD_VAR 0 1
5663: RET
// function HasPower ( i ) ; begin
5664: LD_INT 0
5666: PPUSH
// Result := FilterAllUnits ( [ [ f_side , i ] , [ f_or , [ f_type , unit_human ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
5667: LD_ADDR_VAR 0 2
5671: PUSH
5672: LD_INT 22
5674: PUSH
5675: LD_VAR 0 1
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: PUSH
5684: LD_INT 2
5686: PUSH
5687: LD_INT 21
5689: PUSH
5690: LD_INT 1
5692: PUSH
5693: EMPTY
5694: LIST
5695: LIST
5696: PUSH
5697: LD_INT 30
5699: PUSH
5700: LD_INT 0
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: PUSH
5707: LD_INT 30
5709: PUSH
5710: LD_INT 1
5712: PUSH
5713: EMPTY
5714: LIST
5715: LIST
5716: PUSH
5717: EMPTY
5718: LIST
5719: LIST
5720: LIST
5721: LIST
5722: PUSH
5723: EMPTY
5724: LIST
5725: LIST
5726: PPUSH
5727: CALL_OW 69
5731: ST_TO_ADDR
// end ;
5732: LD_VAR 0 2
5736: RET
// function AlliedSides ( i , j ) ; begin
5737: LD_INT 0
5739: PPUSH
// Result := false ;
5740: LD_ADDR_VAR 0 3
5744: PUSH
5745: LD_INT 0
5747: ST_TO_ADDR
// if ( GetAttitude ( i , j ) = att_friend ) and ( GetAttitude ( j , i ) = att_friend ) and GetAlliedVictory ( i ) and GetAlliedVictory ( j ) then
5748: LD_VAR 0 1
5752: PPUSH
5753: LD_VAR 0 2
5757: PPUSH
5758: CALL_OW 81
5762: PUSH
5763: LD_INT 1
5765: EQUAL
5766: PUSH
5767: LD_VAR 0 2
5771: PPUSH
5772: LD_VAR 0 1
5776: PPUSH
5777: CALL_OW 81
5781: PUSH
5782: LD_INT 1
5784: EQUAL
5785: AND
5786: PUSH
5787: LD_VAR 0 1
5791: PPUSH
5792: CALL_OW 83
5796: AND
5797: PUSH
5798: LD_VAR 0 2
5802: PPUSH
5803: CALL_OW 83
5807: AND
5808: IFFALSE 5818
// Result := true ;
5810: LD_ADDR_VAR 0 3
5814: PUSH
5815: LD_INT 1
5817: ST_TO_ADDR
// end ;
5818: LD_VAR 0 3
5822: RET
// every 100 trigger CanWinLoose marked 400 do
5823: CALL 5600 0 0
5827: IFFALSE 5836
5829: GO 5831
5831: DISABLE
// YouLostInMultiplayer ;
5832: CALL_OW 107
5836: END
// export WaitServerStrings ; every 100 trigger not CanWinLoose marked 400 do
5837: CALL 5600 0 0
5841: NOT
5842: IFFALSE 5858
5844: GO 5846
5846: DISABLE
// WaitServerStrings = [ #reb01-server-wait ] ;
5847: LD_ADDR_EXP 40
5851: PUSH
5852: LD_STRING #reb01-server-wait
5854: PUSH
5855: EMPTY
5856: LIST
5857: ST_TO_ADDR
5858: END
// every 100 trigger CanWinLoose marked 401 do
5859: CALL 5600 0 0
5863: IFFALSE 5872
5865: GO 5867
5867: DISABLE
// YouWinInMultiplayer ;
5868: CALL_OW 106
5872: END
// every 100 marked 98 do var i , CanWin ;
5873: GO 5875
5875: DISABLE
5876: LD_INT 0
5878: PPUSH
5879: PPUSH
// begin if not HasPower ( your_side ) then
5880: LD_OWVAR 2
5884: PPUSH
5885: CALL 5664 0 1
5889: NOT
5890: IFFALSE 5901
// begin Multiplayer_Loose_Message ;
5892: CALL_OW 521
// enable ( 400 ) ;
5896: LD_INT 400
5898: ENABLE_MARKED
// end else
5899: GO 6022
// begin CanWin := true ;
5901: LD_ADDR_VAR 0 2
5905: PUSH
5906: LD_INT 1
5908: ST_TO_ADDR
// for i := 1 to 8 do
5909: LD_ADDR_VAR 0 1
5913: PUSH
5914: DOUBLE
5915: LD_INT 1
5917: DEC
5918: ST_TO_ADDR
5919: LD_INT 8
5921: PUSH
5922: FOR_TO
5923: IFFALSE 6008
// if MultiplayerSideAlive ( i ) and ( i <> your_side ) then
5925: LD_VAR 0 1
5929: PPUSH
5930: CALL_OW 108
5934: PUSH
5935: LD_VAR 0 1
5939: PUSH
5940: LD_OWVAR 2
5944: NONEQUAL
5945: AND
5946: IFFALSE 6006
// if not Side_Teams [ i ] or ( Side_Teams [ i ] <> Side_Teams [ your_side ] ) then
5948: LD_EXP 33
5952: PUSH
5953: LD_VAR 0 1
5957: ARRAY
5958: NOT
5959: PUSH
5960: LD_EXP 33
5964: PUSH
5965: LD_VAR 0 1
5969: ARRAY
5970: PUSH
5971: LD_EXP 33
5975: PUSH
5976: LD_OWVAR 2
5980: ARRAY
5981: NONEQUAL
5982: OR
5983: IFFALSE 6006
// if HasPower ( i ) then
5985: LD_VAR 0 1
5989: PPUSH
5990: CALL 5664 0 1
5994: IFFALSE 6006
// begin CanWin := false ;
5996: LD_ADDR_VAR 0 2
6000: PUSH
6001: LD_INT 0
6003: ST_TO_ADDR
// break ;
6004: GO 6008
// end ;
6006: GO 5922
6008: POP
6009: POP
// if CanWin then
6010: LD_VAR 0 2
6014: IFFALSE 6021
// enable ( 401 ) else
6016: LD_INT 401
6018: ENABLE_MARKED
6019: GO 6022
// enable ;
6021: ENABLE
// end ; end ;
6022: PPOPN 2
6024: END
// every 100 marked 99 do var i , CanWin ;
6025: GO 6027
6027: DISABLE
6028: LD_INT 0
6030: PPUSH
6031: PPUSH
// begin if not HasPower ( your_side ) then
6032: LD_OWVAR 2
6036: PPUSH
6037: CALL 5664 0 1
6041: NOT
6042: IFFALSE 6053
// begin Multiplayer_Loose_Message ;
6044: CALL_OW 521
// enable ( 400 ) ;
6048: LD_INT 400
6050: ENABLE_MARKED
// end else
6051: GO 6154
// begin CanWin := true ;
6053: LD_ADDR_VAR 0 2
6057: PUSH
6058: LD_INT 1
6060: ST_TO_ADDR
// for i := 1 to 8 do
6061: LD_ADDR_VAR 0 1
6065: PUSH
6066: DOUBLE
6067: LD_INT 1
6069: DEC
6070: ST_TO_ADDR
6071: LD_INT 8
6073: PUSH
6074: FOR_TO
6075: IFFALSE 6140
// if MultiplayerSideAlive ( i ) and ( i <> your_side ) then
6077: LD_VAR 0 1
6081: PPUSH
6082: CALL_OW 108
6086: PUSH
6087: LD_VAR 0 1
6091: PUSH
6092: LD_OWVAR 2
6096: NONEQUAL
6097: AND
6098: IFFALSE 6138
// if not AlliedSides ( i , your_side ) then
6100: LD_VAR 0 1
6104: PPUSH
6105: LD_OWVAR 2
6109: PPUSH
6110: CALL 5737 0 2
6114: NOT
6115: IFFALSE 6138
// if HasPower ( i ) then
6117: LD_VAR 0 1
6121: PPUSH
6122: CALL 5664 0 1
6126: IFFALSE 6138
// begin CanWin := false ;
6128: LD_ADDR_VAR 0 2
6132: PUSH
6133: LD_INT 0
6135: ST_TO_ADDR
// break ;
6136: GO 6140
// end ;
6138: GO 6074
6140: POP
6141: POP
// if CanWin then
6142: LD_VAR 0 2
6146: IFFALSE 6153
// enable ( 401 ) else
6148: LD_INT 401
6150: ENABLE_MARKED
6151: GO 6154
// enable ;
6153: ENABLE
// end ; end ; end_of_file
6154: PPOPN 2
6156: END
// function apeman_init ; var ape_names ; begin
6157: LD_INT 0
6159: PPUSH
6160: PPUSH
// uc_side := 0 ;
6161: LD_ADDR_OWVAR 20
6165: PUSH
6166: LD_INT 0
6168: ST_TO_ADDR
// uc_nation := nation_nature ;
6169: LD_ADDR_OWVAR 21
6173: PUSH
6174: LD_INT 0
6176: ST_TO_ADDR
// ape_names = [ Fredy , Montana , Pishkot , Riko , Kowalrski , Neo , Kessi , Riko , Lulu , Edie , Edy , Roxy , Roxas , Beast , Drago , Draco , Ali , Lessie , White Fang , Chess , Nora , Shriek , Bl Tesk , Barkman , Meuznenapadazadnejmeno , Ihavenotthinkofanyname , Hiro , Scooby , Fantasy , Troll , Baltazar , Pamella , Kleopatra , Ceasar , Gimmy , Scooby Dooby Doo , Yogi , Brutal , Brutus , Janina , Crazy , Jen , Jenova , Kiosuke , Akamaru ] ;
6177: LD_ADDR_VAR 0 2
6181: PUSH
6182: LD_STRING Fredy
6184: PUSH
6185: LD_STRING Montana
6187: PUSH
6188: LD_STRING Pishkot
6190: PUSH
6191: LD_STRING Riko
6193: PUSH
6194: LD_STRING Kowalrski
6196: PUSH
6197: LD_STRING Neo
6199: PUSH
6200: LD_STRING Kessi
6202: PUSH
6203: LD_STRING Riko
6205: PUSH
6206: LD_STRING Lulu
6208: PUSH
6209: LD_STRING Edie
6211: PUSH
6212: LD_STRING Edy
6214: PUSH
6215: LD_STRING Roxy
6217: PUSH
6218: LD_STRING Roxas
6220: PUSH
6221: LD_STRING Beast
6223: PUSH
6224: LD_STRING Drago
6226: PUSH
6227: LD_STRING Draco
6229: PUSH
6230: LD_STRING Ali
6232: PUSH
6233: LD_STRING Lessie
6235: PUSH
6236: LD_STRING White Fang
6238: PUSH
6239: LD_STRING Chess
6241: PUSH
6242: LD_STRING Nora
6244: PUSH
6245: LD_STRING Shriek
6247: PUSH
6248: LD_STRING Bl Tesk
6250: PUSH
6251: LD_STRING Barkman
6253: PUSH
6254: LD_STRING Meuznenapadazadnejmeno
6256: PUSH
6257: LD_STRING Ihavenotthinkofanyname
6259: PUSH
6260: LD_STRING Hiro
6262: PUSH
6263: LD_STRING Scooby
6265: PUSH
6266: LD_STRING Fantasy
6268: PUSH
6269: LD_STRING Troll
6271: PUSH
6272: LD_STRING Baltazar
6274: PUSH
6275: LD_STRING Pamella
6277: PUSH
6278: LD_STRING Kleopatra
6280: PUSH
6281: LD_STRING Ceasar
6283: PUSH
6284: LD_STRING Gimmy
6286: PUSH
6287: LD_STRING Scooby Dooby Doo
6289: PUSH
6290: LD_STRING Yogi
6292: PUSH
6293: LD_STRING Brutal
6295: PUSH
6296: LD_STRING Brutus
6298: PUSH
6299: LD_STRING Janina
6301: PUSH
6302: LD_STRING Crazy
6304: PUSH
6305: LD_STRING Jen
6307: PUSH
6308: LD_STRING Jenova
6310: PUSH
6311: LD_STRING Kiosuke
6313: PUSH
6314: LD_STRING Akamaru
6316: PUSH
6317: EMPTY
6318: LIST
6319: LIST
6320: LIST
6321: LIST
6322: LIST
6323: LIST
6324: LIST
6325: LIST
6326: LIST
6327: LIST
6328: LIST
6329: LIST
6330: LIST
6331: LIST
6332: LIST
6333: LIST
6334: LIST
6335: LIST
6336: LIST
6337: LIST
6338: LIST
6339: LIST
6340: LIST
6341: LIST
6342: LIST
6343: LIST
6344: LIST
6345: LIST
6346: LIST
6347: LIST
6348: LIST
6349: LIST
6350: LIST
6351: LIST
6352: LIST
6353: LIST
6354: LIST
6355: LIST
6356: LIST
6357: LIST
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: LIST
6363: ST_TO_ADDR
// hc_name = ape_names [ Rand ( 1 , ape_names ) ] ;
6364: LD_ADDR_OWVAR 26
6368: PUSH
6369: LD_VAR 0 2
6373: PUSH
6374: LD_INT 1
6376: PPUSH
6377: LD_VAR 0 2
6381: PPUSH
6382: CALL_OW 12
6386: ARRAY
6387: ST_TO_ADDR
// randomHumanStats ( priblizna_uroven - 2 ) ;
6388: LD_EXP 15
6392: PUSH
6393: LD_INT 2
6395: MINUS
6396: PPUSH
6397: CALL 8786 0 1
// hc_class := class_apeman ;
6401: LD_ADDR_OWVAR 28
6405: PUSH
6406: LD_INT 12
6408: ST_TO_ADDR
// if hc_attr [ 2 ] < 12 then
6409: LD_OWVAR 29
6413: PUSH
6414: LD_INT 2
6416: ARRAY
6417: PUSH
6418: LD_INT 12
6420: LESS
6421: IFFALSE 6460
// hc_attr = [ hc_attr [ 1 ] + 5 , hc_attr [ 2 ] + 1 ] else
6423: LD_ADDR_OWVAR 29
6427: PUSH
6428: LD_OWVAR 29
6432: PUSH
6433: LD_INT 1
6435: ARRAY
6436: PUSH
6437: LD_INT 5
6439: PLUS
6440: PUSH
6441: LD_OWVAR 29
6445: PUSH
6446: LD_INT 2
6448: ARRAY
6449: PUSH
6450: LD_INT 1
6452: PLUS
6453: PUSH
6454: EMPTY
6455: LIST
6456: LIST
6457: ST_TO_ADDR
6458: GO 6491
// hc_attr = [ hc_attr [ 1 ] + 5 , hc_attr [ 2 ] ] ;
6460: LD_ADDR_OWVAR 29
6464: PUSH
6465: LD_OWVAR 29
6469: PUSH
6470: LD_INT 1
6472: ARRAY
6473: PUSH
6474: LD_INT 5
6476: PLUS
6477: PUSH
6478: LD_OWVAR 29
6482: PUSH
6483: LD_INT 2
6485: ARRAY
6486: PUSH
6487: EMPTY
6488: LIST
6489: LIST
6490: ST_TO_ADDR
// hc_sex := sex_male ;
6491: LD_ADDR_OWVAR 27
6495: PUSH
6496: LD_INT 1
6498: ST_TO_ADDR
// hc_importance := 0 ;
6499: LD_ADDR_OWVAR 32
6503: PUSH
6504: LD_INT 0
6506: ST_TO_ADDR
// hc_agressivity := Rand ( - 20 , 20 ) ;
6507: LD_ADDR_OWVAR 35
6511: PUSH
6512: LD_INT 20
6514: NEG
6515: PPUSH
6516: LD_INT 20
6518: PPUSH
6519: CALL_OW 12
6523: ST_TO_ADDR
// end ;
6524: LD_VAR 0 1
6528: RET
// function prepare_apemen ; var i , j , area , hex , see_it , un , ape , delay , first , d1 , d2 ; begin
6529: LD_INT 0
6531: PPUSH
6532: PPUSH
6533: PPUSH
6534: PPUSH
6535: PPUSH
6536: PPUSH
6537: PPUSH
6538: PPUSH
6539: PPUSH
6540: PPUSH
6541: PPUSH
6542: PPUSH
// if not obnova_opic then
6543: LD_EXP 18
6547: NOT
6548: IFFALSE 6552
// exit ;
6550: GO 6916
// delay := 2 2$0 ;
6552: LD_ADDR_VAR 0 9
6556: PUSH
6557: LD_INT 4200
6559: ST_TO_ADDR
// repeat d1 := Rand ( delay div 2 , delay ) ;
6560: LD_ADDR_VAR 0 11
6564: PUSH
6565: LD_VAR 0 9
6569: PUSH
6570: LD_INT 2
6572: DIV
6573: PPUSH
6574: LD_VAR 0 9
6578: PPUSH
6579: CALL_OW 12
6583: ST_TO_ADDR
// d2 := Rand ( 0 , delay div 2 ) ;
6584: LD_ADDR_VAR 0 12
6588: PUSH
6589: LD_INT 0
6591: PPUSH
6592: LD_VAR 0 9
6596: PUSH
6597: LD_INT 2
6599: DIV
6600: PPUSH
6601: CALL_OW 12
6605: ST_TO_ADDR
// delay := delay * obnova_opic div 100 ;
6606: LD_ADDR_VAR 0 9
6610: PUSH
6611: LD_VAR 0 9
6615: PUSH
6616: LD_EXP 18
6620: MUL
6621: PUSH
6622: LD_INT 100
6624: DIV
6625: ST_TO_ADDR
// first := Rand ( 1 , 2 ) ;
6626: LD_ADDR_VAR 0 10
6630: PUSH
6631: LD_INT 1
6633: PPUSH
6634: LD_INT 2
6636: PPUSH
6637: CALL_OW 12
6641: ST_TO_ADDR
// wait ( d1 ) ;
6642: LD_VAR 0 11
6646: PPUSH
6647: CALL_OW 67
// for i := 1 to 2 do
6651: LD_ADDR_VAR 0 2
6655: PUSH
6656: DOUBLE
6657: LD_INT 1
6659: DEC
6660: ST_TO_ADDR
6661: LD_INT 2
6663: PUSH
6664: FOR_TO
6665: IFFALSE 6910
// begin for j = 1 to 2 do
6667: LD_ADDR_VAR 0 3
6671: PUSH
6672: DOUBLE
6673: LD_INT 1
6675: DEC
6676: ST_TO_ADDR
6677: LD_INT 2
6679: PUSH
6680: FOR_TO
6681: IFFALSE 6887
// begin apeman_init ;
6683: CALL 6157 0 0
// ape := CreateHuman ;
6687: LD_ADDR_VAR 0 8
6691: PUSH
6692: CALL_OW 44
6696: ST_TO_ADDR
// if i = first then
6697: LD_VAR 0 2
6701: PUSH
6702: LD_VAR 0 10
6706: EQUAL
6707: IFFALSE 6774
// case j of 1 :
6709: LD_VAR 0 3
6713: PUSH
6714: LD_INT 1
6716: DOUBLE
6717: EQUAL
6718: IFTRUE 6722
6720: GO 6733
6722: POP
// area := Opice1 ; 2 :
6723: LD_ADDR_VAR 0 4
6727: PUSH
6728: LD_INT 3
6730: ST_TO_ADDR
6731: GO 6772
6733: LD_INT 2
6735: DOUBLE
6736: EQUAL
6737: IFTRUE 6741
6739: GO 6752
6741: POP
// area := Opice2 ; 3 :
6742: LD_ADDR_VAR 0 4
6746: PUSH
6747: LD_INT 4
6749: ST_TO_ADDR
6750: GO 6772
6752: LD_INT 3
6754: DOUBLE
6755: EQUAL
6756: IFTRUE 6760
6758: GO 6771
6760: POP
// area := all ; end else
6761: LD_ADDR_VAR 0 4
6765: PUSH
6766: LD_INT 2
6768: ST_TO_ADDR
6769: GO 6772
6771: POP
6772: GO 6837
// case j of 1 :
6774: LD_VAR 0 3
6778: PUSH
6779: LD_INT 1
6781: DOUBLE
6782: EQUAL
6783: IFTRUE 6787
6785: GO 6798
6787: POP
// area := Opice3 ; 2 :
6788: LD_ADDR_VAR 0 4
6792: PUSH
6793: LD_INT 5
6795: ST_TO_ADDR
6796: GO 6837
6798: LD_INT 2
6800: DOUBLE
6801: EQUAL
6802: IFTRUE 6806
6804: GO 6817
6806: POP
// area := Opice4 ; 3 :
6807: LD_ADDR_VAR 0 4
6811: PUSH
6812: LD_INT 6
6814: ST_TO_ADDR
6815: GO 6837
6817: LD_INT 3
6819: DOUBLE
6820: EQUAL
6821: IFTRUE 6825
6823: GO 6836
6825: POP
// area := all ; end ;
6826: LD_ADDR_VAR 0 4
6830: PUSH
6831: LD_INT 2
6833: ST_TO_ADDR
6834: GO 6837
6836: POP
// hex := RandHexArea ( area , true ) ;
6837: LD_ADDR_VAR 0 5
6841: PUSH
6842: LD_VAR 0 4
6846: PPUSH
6847: LD_INT 1
6849: PPUSH
6850: CALL_OW 16
6854: ST_TO_ADDR
// PlaceUnitXY ( ape , hex [ 1 ] , hex [ 2 ] , false ) ;
6855: LD_VAR 0 8
6859: PPUSH
6860: LD_VAR 0 5
6864: PUSH
6865: LD_INT 1
6867: ARRAY
6868: PPUSH
6869: LD_VAR 0 5
6873: PUSH
6874: LD_INT 2
6876: ARRAY
6877: PPUSH
6878: LD_INT 0
6880: PPUSH
6881: CALL_OW 48
// end ;
6885: GO 6680
6887: POP
6888: POP
// if i = 1 then
6889: LD_VAR 0 2
6893: PUSH
6894: LD_INT 1
6896: EQUAL
6897: IFFALSE 6908
// wait ( d2 ) ;
6899: LD_VAR 0 12
6903: PPUSH
6904: CALL_OW 67
// end ;
6908: GO 6664
6910: POP
6911: POP
// until false ;
6912: LD_INT 0
6914: IFFALSE 6560
// end ;
6916: LD_VAR 0 1
6920: RET
// every 0 0$15 do
6921: GO 6923
6923: DISABLE
// begin prepare_apemen ;
6924: CALL 6529 0 0
// end ;
6928: END
// function tiger_init ; var tiger_names ; begin
6929: LD_INT 0
6931: PPUSH
6932: PPUSH
// uc_side := 0 ;
6933: LD_ADDR_OWVAR 20
6937: PUSH
6938: LD_INT 0
6940: ST_TO_ADDR
// uc_nation := nation_nature ;
6941: LD_ADDR_OWVAR 21
6945: PUSH
6946: LD_INT 0
6948: ST_TO_ADDR
// randomHumanStats ( priblizna_uroven - 2 ) ;
6949: LD_EXP 15
6953: PUSH
6954: LD_INT 2
6956: MINUS
6957: PPUSH
6958: CALL 8786 0 1
// hc_class := class_tiger ;
6962: LD_ADDR_OWVAR 28
6966: PUSH
6967: LD_INT 14
6969: ST_TO_ADDR
// hc_attr = [ hc_attr [ 1 ] + 2 , hc_attr [ 2 ] + 1 ] ;
6970: LD_ADDR_OWVAR 29
6974: PUSH
6975: LD_OWVAR 29
6979: PUSH
6980: LD_INT 1
6982: ARRAY
6983: PUSH
6984: LD_INT 2
6986: PLUS
6987: PUSH
6988: LD_OWVAR 29
6992: PUSH
6993: LD_INT 2
6995: ARRAY
6996: PUSH
6997: LD_INT 1
6999: PLUS
7000: PUSH
7001: EMPTY
7002: LIST
7003: LIST
7004: ST_TO_ADDR
// hc_sex := sex_male ;
7005: LD_ADDR_OWVAR 27
7009: PUSH
7010: LD_INT 1
7012: ST_TO_ADDR
// hc_importance := 0 ;
7013: LD_ADDR_OWVAR 32
7017: PUSH
7018: LD_INT 0
7020: ST_TO_ADDR
// hc_agressivity := Rand ( 10 , 50 ) ;
7021: LD_ADDR_OWVAR 35
7025: PUSH
7026: LD_INT 10
7028: PPUSH
7029: LD_INT 50
7031: PPUSH
7032: CALL_OW 12
7036: ST_TO_ADDR
// end ;
7037: LD_VAR 0 1
7041: RET
// function prepare_tiger ; var i , j , area , hex , see_it , un , tiger , delay , first , d1 , d2 ; begin
7042: LD_INT 0
7044: PPUSH
7045: PPUSH
7046: PPUSH
7047: PPUSH
7048: PPUSH
7049: PPUSH
7050: PPUSH
7051: PPUSH
7052: PPUSH
7053: PPUSH
7054: PPUSH
7055: PPUSH
// if not obnova_tygru then
7056: LD_EXP 19
7060: NOT
7061: IFFALSE 7065
// exit ;
7063: GO 7429
// delay := 4 4$0 ;
7065: LD_ADDR_VAR 0 9
7069: PUSH
7070: LD_INT 8400
7072: ST_TO_ADDR
// repeat d1 := Rand ( delay div 4 , delay ) ;
7073: LD_ADDR_VAR 0 11
7077: PUSH
7078: LD_VAR 0 9
7082: PUSH
7083: LD_INT 4
7085: DIV
7086: PPUSH
7087: LD_VAR 0 9
7091: PPUSH
7092: CALL_OW 12
7096: ST_TO_ADDR
// d2 := Rand ( 0 , delay div 4 ) ;
7097: LD_ADDR_VAR 0 12
7101: PUSH
7102: LD_INT 0
7104: PPUSH
7105: LD_VAR 0 9
7109: PUSH
7110: LD_INT 4
7112: DIV
7113: PPUSH
7114: CALL_OW 12
7118: ST_TO_ADDR
// delay := delay * obnova_tygru div 100 ;
7119: LD_ADDR_VAR 0 9
7123: PUSH
7124: LD_VAR 0 9
7128: PUSH
7129: LD_EXP 19
7133: MUL
7134: PUSH
7135: LD_INT 100
7137: DIV
7138: ST_TO_ADDR
// first := Rand ( 1 , 2 ) ;
7139: LD_ADDR_VAR 0 10
7143: PUSH
7144: LD_INT 1
7146: PPUSH
7147: LD_INT 2
7149: PPUSH
7150: CALL_OW 12
7154: ST_TO_ADDR
// wait ( d1 ) ;
7155: LD_VAR 0 11
7159: PPUSH
7160: CALL_OW 67
// for i := 1 to 2 do
7164: LD_ADDR_VAR 0 2
7168: PUSH
7169: DOUBLE
7170: LD_INT 1
7172: DEC
7173: ST_TO_ADDR
7174: LD_INT 2
7176: PUSH
7177: FOR_TO
7178: IFFALSE 7423
// begin for j = 1 to 2 do
7180: LD_ADDR_VAR 0 3
7184: PUSH
7185: DOUBLE
7186: LD_INT 1
7188: DEC
7189: ST_TO_ADDR
7190: LD_INT 2
7192: PUSH
7193: FOR_TO
7194: IFFALSE 7400
// begin tiger_init ;
7196: CALL 6929 0 0
// tiger := CreateHuman ;
7200: LD_ADDR_VAR 0 8
7204: PUSH
7205: CALL_OW 44
7209: ST_TO_ADDR
// if i = first then
7210: LD_VAR 0 2
7214: PUSH
7215: LD_VAR 0 10
7219: EQUAL
7220: IFFALSE 7287
// case j of 1 :
7222: LD_VAR 0 3
7226: PUSH
7227: LD_INT 1
7229: DOUBLE
7230: EQUAL
7231: IFTRUE 7235
7233: GO 7246
7235: POP
// area := Tygri1 ; 2 :
7236: LD_ADDR_VAR 0 4
7240: PUSH
7241: LD_INT 8
7243: ST_TO_ADDR
7244: GO 7285
7246: LD_INT 2
7248: DOUBLE
7249: EQUAL
7250: IFTRUE 7254
7252: GO 7265
7254: POP
// area := Tygri2 ; 3 :
7255: LD_ADDR_VAR 0 4
7259: PUSH
7260: LD_INT 7
7262: ST_TO_ADDR
7263: GO 7285
7265: LD_INT 3
7267: DOUBLE
7268: EQUAL
7269: IFTRUE 7273
7271: GO 7284
7273: POP
// area := all ; end else
7274: LD_ADDR_VAR 0 4
7278: PUSH
7279: LD_INT 2
7281: ST_TO_ADDR
7282: GO 7285
7284: POP
7285: GO 7350
// case j of 1 :
7287: LD_VAR 0 3
7291: PUSH
7292: LD_INT 1
7294: DOUBLE
7295: EQUAL
7296: IFTRUE 7300
7298: GO 7311
7300: POP
// area := Tygri3 ; 2 :
7301: LD_ADDR_VAR 0 4
7305: PUSH
7306: LD_INT 9
7308: ST_TO_ADDR
7309: GO 7350
7311: LD_INT 2
7313: DOUBLE
7314: EQUAL
7315: IFTRUE 7319
7317: GO 7330
7319: POP
// area := Tygri4 ; 3 :
7320: LD_ADDR_VAR 0 4
7324: PUSH
7325: LD_INT 10
7327: ST_TO_ADDR
7328: GO 7350
7330: LD_INT 3
7332: DOUBLE
7333: EQUAL
7334: IFTRUE 7338
7336: GO 7349
7338: POP
// area := all ; end ;
7339: LD_ADDR_VAR 0 4
7343: PUSH
7344: LD_INT 2
7346: ST_TO_ADDR
7347: GO 7350
7349: POP
// hex := RandHexArea ( area , true ) ;
7350: LD_ADDR_VAR 0 5
7354: PUSH
7355: LD_VAR 0 4
7359: PPUSH
7360: LD_INT 1
7362: PPUSH
7363: CALL_OW 16
7367: ST_TO_ADDR
// PlaceUnitXY ( tiger , hex [ 1 ] , hex [ 2 ] , true ) ;
7368: LD_VAR 0 8
7372: PPUSH
7373: LD_VAR 0 5
7377: PUSH
7378: LD_INT 1
7380: ARRAY
7381: PPUSH
7382: LD_VAR 0 5
7386: PUSH
7387: LD_INT 2
7389: ARRAY
7390: PPUSH
7391: LD_INT 1
7393: PPUSH
7394: CALL_OW 48
// end ;
7398: GO 7193
7400: POP
7401: POP
// if i = 1 then
7402: LD_VAR 0 2
7406: PUSH
7407: LD_INT 1
7409: EQUAL
7410: IFFALSE 7421
// wait ( d2 ) ;
7412: LD_VAR 0 12
7416: PPUSH
7417: CALL_OW 67
// end ;
7421: GO 7177
7423: POP
7424: POP
// until false ;
7425: LD_INT 0
7427: IFFALSE 7073
// end ;
7429: LD_VAR 0 1
7433: RET
// every 0 0$15 do
7434: GO 7436
7436: DISABLE
// begin prepare_tiger ;
7437: CALL 7042 0 0
// end ; end_of_file
7441: END
// export function Oblasti_Bedny ; var i , pocet_hracu ; begin
7442: LD_INT 0
7444: PPUSH
7445: PPUSH
7446: PPUSH
// pocet_hracu := 0 ;
7447: LD_ADDR_VAR 0 3
7451: PUSH
7452: LD_INT 0
7454: ST_TO_ADDR
// for i := 1 to 8 do
7455: LD_ADDR_VAR 0 2
7459: PUSH
7460: DOUBLE
7461: LD_INT 1
7463: DEC
7464: ST_TO_ADDR
7465: LD_INT 8
7467: PUSH
7468: FOR_TO
7469: IFFALSE 7503
// if Side_Positions [ i ] <> 0 then
7471: LD_EXP 31
7475: PUSH
7476: LD_VAR 0 2
7480: ARRAY
7481: PUSH
7482: LD_INT 0
7484: NONEQUAL
7485: IFFALSE 7501
// pocet_hracu := pocet_hracu + 1 ;
7487: LD_ADDR_VAR 0 3
7491: PUSH
7492: LD_VAR 0 3
7496: PUSH
7497: LD_INT 1
7499: PLUS
7500: ST_TO_ADDR
7501: GO 7468
7503: POP
7504: POP
// if pocet_hracu = 2 then
7505: LD_VAR 0 3
7509: PUSH
7510: LD_INT 2
7512: EQUAL
7513: IFFALSE 7580
// case cetnost_zasilek of 20 :
7515: LD_EXP 17
7519: PUSH
7520: LD_INT 20
7522: DOUBLE
7523: EQUAL
7524: IFTRUE 7528
7526: GO 7539
7528: POP
// cetnost_zasilek := 8 ; 30 :
7529: LD_ADDR_EXP 17
7533: PUSH
7534: LD_INT 8
7536: ST_TO_ADDR
7537: GO 7578
7539: LD_INT 30
7541: DOUBLE
7542: EQUAL
7543: IFTRUE 7547
7545: GO 7558
7547: POP
// cetnost_zasilek := 16 ; 40 :
7548: LD_ADDR_EXP 17
7552: PUSH
7553: LD_INT 16
7555: ST_TO_ADDR
7556: GO 7578
7558: LD_INT 40
7560: DOUBLE
7561: EQUAL
7562: IFTRUE 7566
7564: GO 7577
7566: POP
// cetnost_zasilek := 24 ; end else
7567: LD_ADDR_EXP 17
7571: PUSH
7572: LD_INT 24
7574: ST_TO_ADDR
7575: GO 7578
7577: POP
7578: GO 7718
// if pocet_hracu <= 4 then
7580: LD_VAR 0 3
7584: PUSH
7585: LD_INT 4
7587: LESSEQUAL
7588: IFFALSE 7655
// case cetnost_zasilek of 20 :
7590: LD_EXP 17
7594: PUSH
7595: LD_INT 20
7597: DOUBLE
7598: EQUAL
7599: IFTRUE 7603
7601: GO 7614
7603: POP
// cetnost_zasilek := 12 ; 30 :
7604: LD_ADDR_EXP 17
7608: PUSH
7609: LD_INT 12
7611: ST_TO_ADDR
7612: GO 7653
7614: LD_INT 30
7616: DOUBLE
7617: EQUAL
7618: IFTRUE 7622
7620: GO 7633
7622: POP
// cetnost_zasilek := 24 ; 40 :
7623: LD_ADDR_EXP 17
7627: PUSH
7628: LD_INT 24
7630: ST_TO_ADDR
7631: GO 7653
7633: LD_INT 40
7635: DOUBLE
7636: EQUAL
7637: IFTRUE 7641
7639: GO 7652
7641: POP
// cetnost_zasilek := 37 ; end else
7642: LD_ADDR_EXP 17
7646: PUSH
7647: LD_INT 37
7649: ST_TO_ADDR
7650: GO 7653
7652: POP
7653: GO 7718
// case cetnost_zasilek of 20 :
7655: LD_EXP 17
7659: PUSH
7660: LD_INT 20
7662: DOUBLE
7663: EQUAL
7664: IFTRUE 7668
7666: GO 7679
7668: POP
// cetnost_zasilek := 16 ; 30 :
7669: LD_ADDR_EXP 17
7673: PUSH
7674: LD_INT 16
7676: ST_TO_ADDR
7677: GO 7718
7679: LD_INT 30
7681: DOUBLE
7682: EQUAL
7683: IFTRUE 7687
7685: GO 7698
7687: POP
// cetnost_zasilek := 32 ; 40 :
7688: LD_ADDR_EXP 17
7692: PUSH
7693: LD_INT 32
7695: ST_TO_ADDR
7696: GO 7718
7698: LD_INT 40
7700: DOUBLE
7701: EQUAL
7702: IFTRUE 7706
7704: GO 7717
7706: POP
// cetnost_zasilek := 49 ; end ;
7707: LD_ADDR_EXP 17
7711: PUSH
7712: LD_INT 49
7714: ST_TO_ADDR
7715: GO 7718
7717: POP
// end ;
7718: LD_VAR 0 1
7722: RET
// every 1 1$0 + 0 0$1 do
7723: GO 7725
7725: DISABLE
// begin CreateCratesAnywhere ( Rand ( 1 , 5 ) , true ) ;
7726: LD_INT 1
7728: PPUSH
7729: LD_INT 5
7731: PPUSH
7732: CALL_OW 12
7736: PPUSH
7737: LD_INT 1
7739: PPUSH
7740: CALL_OW 57
// enable ;
7744: ENABLE
// end ;
7745: END
// every 0 0$20 do var i , d , tictac ;
7746: GO 7748
7748: DISABLE
7749: LD_INT 0
7751: PPUSH
7752: PPUSH
7753: PPUSH
// begin tictac := 0 ;
7754: LD_ADDR_VAR 0 3
7758: PUSH
7759: LD_INT 0
7761: ST_TO_ADDR
// case tick of 1 .. 1 1$0 :
7762: LD_OWVAR 1
7766: PUSH
7767: LD_INT 1
7769: DOUBLE
7770: GREATEREQUAL
7771: IFFALSE 7779
7773: LD_INT 2100
7775: DOUBLE
7776: LESSEQUAL
7777: IFTRUE 7781
7779: GO 7792
7781: POP
// d := 150 ; 1 1$0 + 1 .. 5 5$0 :
7782: LD_ADDR_VAR 0 2
7786: PUSH
7787: LD_INT 150
7789: ST_TO_ADDR
7790: GO 7946
7792: LD_INT 2100
7794: PUSH
7795: LD_INT 1
7797: PLUS
7798: DOUBLE
7799: GREATEREQUAL
7800: IFFALSE 7808
7802: LD_INT 10500
7804: DOUBLE
7805: LESSEQUAL
7806: IFTRUE 7810
7808: GO 7821
7810: POP
// d := 140 ; 5 5$0 + 1 .. 10 10$0 :
7811: LD_ADDR_VAR 0 2
7815: PUSH
7816: LD_INT 140
7818: ST_TO_ADDR
7819: GO 7946
7821: LD_INT 10500
7823: PUSH
7824: LD_INT 1
7826: PLUS
7827: DOUBLE
7828: GREATEREQUAL
7829: IFFALSE 7837
7831: LD_INT 21000
7833: DOUBLE
7834: LESSEQUAL
7835: IFTRUE 7839
7837: GO 7850
7839: POP
// d := 120 ; 10 10$0 + 1 .. 20 20$0 :
7840: LD_ADDR_VAR 0 2
7844: PUSH
7845: LD_INT 120
7847: ST_TO_ADDR
7848: GO 7946
7850: LD_INT 21000
7852: PUSH
7853: LD_INT 1
7855: PLUS
7856: DOUBLE
7857: GREATEREQUAL
7858: IFFALSE 7866
7860: LD_INT 42000
7862: DOUBLE
7863: LESSEQUAL
7864: IFTRUE 7868
7866: GO 7879
7868: POP
// d := 100 ; 20 20$0 + 1 .. 30 30$0 :
7869: LD_ADDR_VAR 0 2
7873: PUSH
7874: LD_INT 100
7876: ST_TO_ADDR
7877: GO 7946
7879: LD_INT 42000
7881: PUSH
7882: LD_INT 1
7884: PLUS
7885: DOUBLE
7886: GREATEREQUAL
7887: IFFALSE 7895
7889: LD_INT 63000
7891: DOUBLE
7892: LESSEQUAL
7893: IFTRUE 7897
7895: GO 7908
7897: POP
// d := 85 ; 30 30$0 + 1 .. 50 50$0 :
7898: LD_ADDR_VAR 0 2
7902: PUSH
7903: LD_INT 85
7905: ST_TO_ADDR
7906: GO 7946
7908: LD_INT 63000
7910: PUSH
7911: LD_INT 1
7913: PLUS
7914: DOUBLE
7915: GREATEREQUAL
7916: IFFALSE 7924
7918: LD_INT 105000
7920: DOUBLE
7921: LESSEQUAL
7922: IFTRUE 7926
7924: GO 7937
7926: POP
// d := 70 ; else
7927: LD_ADDR_VAR 0 2
7931: PUSH
7932: LD_INT 70
7934: ST_TO_ADDR
7935: GO 7946
7937: POP
// d := 60 ; end ;
7938: LD_ADDR_VAR 0 2
7942: PUSH
7943: LD_INT 60
7945: ST_TO_ADDR
// if GetResourceArea ( all , mat_cans ) < ( cetnost_zasilek * 2.6 ) then
7946: LD_INT 2
7948: PPUSH
7949: LD_INT 1
7951: PPUSH
7952: CALL_OW 287
7956: PUSH
7957: LD_EXP 17
7961: PUSH
7962: LD_REAL  2.60000000000000E+0000
7965: MUL
7966: LESS
7967: IFFALSE 8064
// if rand ( 1 , 10000 ) <= d * cetnost_zasilek then
7969: LD_INT 1
7971: PPUSH
7972: LD_INT 10000
7974: PPUSH
7975: CALL_OW 12
7979: PUSH
7980: LD_VAR 0 2
7984: PUSH
7985: LD_EXP 17
7989: MUL
7990: LESSEQUAL
7991: IFFALSE 8064
// begin for i := 1 to 9 do
7993: LD_ADDR_VAR 0 1
7997: PUSH
7998: DOUBLE
7999: LD_INT 1
8001: DEC
8002: ST_TO_ADDR
8003: LD_INT 9
8005: PUSH
8006: FOR_TO
8007: IFFALSE 8062
// begin wait ( Rand ( 1 , 0 0$4 ) ) ;
8009: LD_INT 1
8011: PPUSH
8012: LD_INT 140
8014: PPUSH
8015: CALL_OW 12
8019: PPUSH
8020: CALL_OW 67
// CreateCratesArea ( Rand ( 3 , 5 ) , pozice_beden [ i ] , true ) ;
8024: LD_INT 3
8026: PPUSH
8027: LD_INT 5
8029: PPUSH
8030: CALL_OW 12
8034: PPUSH
8035: LD_EXP 26
8039: PUSH
8040: LD_VAR 0 1
8044: ARRAY
8045: PPUSH
8046: LD_INT 1
8048: PPUSH
8049: CALL_OW 55
// Wait ( 2 ) ;
8053: LD_INT 2
8055: PPUSH
8056: CALL_OW 67
// end ;
8060: GO 8006
8062: POP
8063: POP
// end ; enable ;
8064: ENABLE
// end ; end_of_file
8065: PPOPN 3
8067: END
// var inqueue , respawn ; export function init_respawn ; begin
8068: LD_INT 0
8070: PPUSH
// respawn = rand ( 1 , 8 ) ;
8071: LD_ADDR_LOC 5
8075: PUSH
8076: LD_INT 1
8078: PPUSH
8079: LD_INT 8
8081: PPUSH
8082: CALL_OW 12
8086: ST_TO_ADDR
// inqueue := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
8087: LD_ADDR_LOC 4
8091: PUSH
8092: LD_INT 0
8094: PUSH
8095: LD_INT 0
8097: PUSH
8098: LD_INT 0
8100: PUSH
8101: LD_INT 0
8103: PUSH
8104: LD_INT 0
8106: PUSH
8107: LD_INT 0
8109: PUSH
8110: LD_INT 0
8112: PUSH
8113: LD_INT 0
8115: PUSH
8116: EMPTY
8117: LIST
8118: LIST
8119: LIST
8120: LIST
8121: LIST
8122: LIST
8123: LIST
8124: LIST
8125: ST_TO_ADDR
// SetRespawningTime ( obnovovaci_cas_min , obnovovaci_cas_max , respawning_time_delay_min , respawning_time_delay_max ) ;
8126: LD_EXP 20
8130: PPUSH
8131: LD_EXP 21
8135: PPUSH
8136: LD_EXP 22
8140: PPUSH
8141: LD_EXP 23
8145: PPUSH
8146: CALL 10033 0 4
// end ;
8150: LD_VAR 0 1
8154: RET
// every 0 0$1 + 0 0$0.5 do var n , building_list , aktresp , b , skills , k ;
8155: GO 8157
8157: DISABLE
8158: LD_INT 0
8160: PPUSH
8161: PPUSH
8162: PPUSH
8163: PPUSH
8164: PPUSH
8165: PPUSH
// begin if obnovovaci_cas_max = 0 then
8166: LD_EXP 21
8170: PUSH
8171: LD_INT 0
8173: EQUAL
8174: IFFALSE 8178
// exit ;
8176: GO 8374
// if respawn = 8 then
8178: LD_LOC 5
8182: PUSH
8183: LD_INT 8
8185: EQUAL
8186: IFFALSE 8198
// respawn := 1 else
8188: LD_ADDR_LOC 5
8192: PUSH
8193: LD_INT 1
8195: ST_TO_ADDR
8196: GO 8212
// respawn := respawn + 1 ;
8198: LD_ADDR_LOC 5
8202: PUSH
8203: LD_LOC 5
8207: PUSH
8208: LD_INT 1
8210: PLUS
8211: ST_TO_ADDR
// if Side_Positions [ respawn ] then
8212: LD_EXP 31
8216: PUSH
8217: LD_LOC 5
8221: ARRAY
8222: IFFALSE 8373
// begin n := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_side , respawn ] , f_not , [ f_nation , nation_nature ] ] ) ;
8224: LD_ADDR_VAR 0 1
8228: PUSH
8229: LD_INT 21
8231: PUSH
8232: LD_INT 1
8234: PUSH
8235: EMPTY
8236: LIST
8237: LIST
8238: PUSH
8239: LD_INT 22
8241: PUSH
8242: LD_LOC 5
8246: PUSH
8247: EMPTY
8248: LIST
8249: LIST
8250: PUSH
8251: LD_INT 3
8253: PUSH
8254: LD_INT 23
8256: PUSH
8257: LD_INT 0
8259: PUSH
8260: EMPTY
8261: LIST
8262: LIST
8263: PUSH
8264: EMPTY
8265: LIST
8266: LIST
8267: LIST
8268: LIST
8269: PPUSH
8270: CALL_OW 69
8274: ST_TO_ADDR
// if ( n + inqueue [ respawn ] ) < pocet_lidi then
8275: LD_VAR 0 1
8279: PUSH
8280: LD_LOC 4
8284: PUSH
8285: LD_LOC 5
8289: ARRAY
8290: PLUS
8291: PUSH
8292: LD_EXP 14
8296: LESS
8297: IFFALSE 8370
// begin aktresp := respawn ;
8299: LD_ADDR_VAR 0 3
8303: PUSH
8304: LD_LOC 5
8308: ST_TO_ADDR
// inqueue := Replace ( inqueue , aktresp , inqueue [ aktresp ] + 1 ) ;
8309: LD_ADDR_LOC 4
8313: PUSH
8314: LD_LOC 4
8318: PPUSH
8319: LD_VAR 0 3
8323: PPUSH
8324: LD_LOC 4
8328: PUSH
8329: LD_VAR 0 3
8333: ARRAY
8334: PUSH
8335: LD_INT 1
8337: PLUS
8338: PPUSH
8339: CALL_OW 1
8343: ST_TO_ADDR
// enable ;
8344: ENABLE
// ObnovCloveka ( aktresp , Side_Nations [ aktresp ] , false ) ;
8345: LD_VAR 0 3
8349: PPUSH
8350: LD_EXP 32
8354: PUSH
8355: LD_VAR 0 3
8359: ARRAY
8360: PPUSH
8361: LD_INT 0
8363: PPUSH
8364: CALL 10147 0 3
// end else
8368: GO 8371
// enable ;
8370: ENABLE
// end else
8371: GO 8374
// enable ;
8373: ENABLE
// end ;
8374: PPOPN 6
8376: END
// export function OnHumanRespawned ( un ) ; begin
8377: LD_INT 0
8379: PPUSH
// wait ( 0 0$30 ) ;
8380: LD_INT 1050
8382: PPUSH
8383: CALL_OW 67
// inqueue := Replace ( inqueue , GetSide ( un ) , inqueue [ GetSide ( un ) ] - 1 ) ;
8387: LD_ADDR_LOC 4
8391: PUSH
8392: LD_LOC 4
8396: PPUSH
8397: LD_VAR 0 1
8401: PPUSH
8402: CALL_OW 255
8406: PPUSH
8407: LD_LOC 4
8411: PUSH
8412: LD_VAR 0 1
8416: PPUSH
8417: CALL_OW 255
8421: ARRAY
8422: PUSH
8423: LD_INT 1
8425: MINUS
8426: PPUSH
8427: CALL_OW 1
8431: ST_TO_ADDR
// end ;
8432: LD_VAR 0 2
8436: RET
// on HumanDestroyed ( identifier , side , nation , x , y , direction , sex , cl ) do begin if nation = nation_nature or side = 0 then
8437: LD_VAR 0 3
8441: PUSH
8442: LD_INT 0
8444: EQUAL
8445: PUSH
8446: LD_VAR 0 2
8450: PUSH
8451: LD_INT 0
8453: EQUAL
8454: OR
8455: IFFALSE 8459
// exit ;
8457: GO 8513
// inqueue := Replace ( inqueue , side , inqueue [ side ] + 1 ) ;
8459: LD_ADDR_LOC 4
8463: PUSH
8464: LD_LOC 4
8468: PPUSH
8469: LD_VAR 0 2
8473: PPUSH
8474: LD_LOC 4
8478: PUSH
8479: LD_VAR 0 2
8483: ARRAY
8484: PUSH
8485: LD_INT 1
8487: PLUS
8488: PPUSH
8489: CALL_OW 1
8493: ST_TO_ADDR
// ObnovCloveka ( side , nation , identifier ) ;
8494: LD_VAR 0 2
8498: PPUSH
8499: LD_VAR 0 3
8503: PPUSH
8504: LD_VAR 0 1
8508: PPUSH
8509: CALL 10147 0 3
// end ; end_of_file
8513: PPOPN 8
8515: END
// export MaxFlags ; export function ShowResources ( FullMapArea , EnableSiberitResurces , Range ) ; var k , k2 , i , d , r , u ; begin
8516: LD_INT 0
8518: PPUSH
8519: PPUSH
8520: PPUSH
8521: PPUSH
8522: PPUSH
8523: PPUSH
8524: PPUSH
// if range = 0 then
8525: LD_VAR 0 3
8529: PUSH
8530: LD_INT 0
8532: EQUAL
8533: IFFALSE 8543
// range = 400 ;
8535: LD_ADDR_VAR 0 3
8539: PUSH
8540: LD_INT 400
8542: ST_TO_ADDR
// r = range ;
8543: LD_ADDR_VAR 0 9
8547: PUSH
8548: LD_VAR 0 3
8552: ST_TO_ADDR
// d = GetListOfResourcesInArea ( FullMapArea ) ;
8553: LD_ADDR_VAR 0 8
8557: PUSH
8558: LD_VAR 0 1
8562: PPUSH
8563: CALL_OW 442
8567: ST_TO_ADDR
// for k = 1 to ( d / 3 ) do
8568: LD_ADDR_VAR 0 5
8572: PUSH
8573: DOUBLE
8574: LD_INT 1
8576: DEC
8577: ST_TO_ADDR
8578: LD_VAR 0 8
8582: PUSH
8583: LD_INT 3
8585: DIVREAL
8586: PUSH
8587: FOR_TO
8588: IFFALSE 8779
// begin k2 = k * 3 ;
8590: LD_ADDR_VAR 0 6
8594: PUSH
8595: LD_VAR 0 5
8599: PUSH
8600: LD_INT 3
8602: MUL
8603: ST_TO_ADDR
// for i = 1 to 8 do
8604: LD_ADDR_VAR 0 7
8608: PUSH
8609: DOUBLE
8610: LD_INT 1
8612: DEC
8613: ST_TO_ADDR
8614: LD_INT 8
8616: PUSH
8617: FOR_TO
8618: IFFALSE 8775
// begin if d [ k2 ] = 1 or ( d [ k2 ] = 2 and EnableSiberitResurces ) then
8620: LD_VAR 0 8
8624: PUSH
8625: LD_VAR 0 6
8629: ARRAY
8630: PUSH
8631: LD_INT 1
8633: EQUAL
8634: PUSH
8635: LD_VAR 0 8
8639: PUSH
8640: LD_VAR 0 6
8644: ARRAY
8645: PUSH
8646: LD_INT 2
8648: EQUAL
8649: PUSH
8650: LD_VAR 0 2
8654: AND
8655: OR
8656: IFFALSE 8773
// begin u = filterAllUnits ( [ [ f_side , i ] , [ f_distxy , d [ k2 - 2 ] , d [ k2 - 1 ] , r ] ] ) ;
8658: LD_ADDR_VAR 0 10
8662: PUSH
8663: LD_INT 22
8665: PUSH
8666: LD_VAR 0 7
8670: PUSH
8671: EMPTY
8672: LIST
8673: LIST
8674: PUSH
8675: LD_INT 92
8677: PUSH
8678: LD_VAR 0 8
8682: PUSH
8683: LD_VAR 0 6
8687: PUSH
8688: LD_INT 2
8690: MINUS
8691: ARRAY
8692: PUSH
8693: LD_VAR 0 8
8697: PUSH
8698: LD_VAR 0 6
8702: PUSH
8703: LD_INT 1
8705: MINUS
8706: ARRAY
8707: PUSH
8708: LD_VAR 0 9
8712: PUSH
8713: EMPTY
8714: LIST
8715: LIST
8716: LIST
8717: LIST
8718: PUSH
8719: EMPTY
8720: LIST
8721: LIST
8722: PPUSH
8723: CALL_OW 69
8727: ST_TO_ADDR
// if u then
8728: LD_VAR 0 10
8732: IFFALSE 8773
// SetResourceVisibility ( d [ k2 - 2 ] , d [ k2 - 1 ] , i ) ;
8734: LD_VAR 0 8
8738: PUSH
8739: LD_VAR 0 6
8743: PUSH
8744: LD_INT 2
8746: MINUS
8747: ARRAY
8748: PPUSH
8749: LD_VAR 0 8
8753: PUSH
8754: LD_VAR 0 6
8758: PUSH
8759: LD_INT 1
8761: MINUS
8762: ARRAY
8763: PPUSH
8764: LD_VAR 0 7
8768: PPUSH
8769: CALL_OW 441
// end ; end ;
8773: GO 8617
8775: POP
8776: POP
// end ;
8777: GO 8587
8779: POP
8780: POP
// end ;
8781: LD_VAR 0 4
8785: RET
// export function randomHumanStats ( init_level ) ; var cl , combat , eng , mech , sci , skills , base_skills , attr ; var i , k , base , n , def , speed ; begin
8786: LD_INT 0
8788: PPUSH
8789: PPUSH
8790: PPUSH
8791: PPUSH
8792: PPUSH
8793: PPUSH
8794: PPUSH
8795: PPUSH
8796: PPUSH
8797: PPUSH
8798: PPUSH
8799: PPUSH
8800: PPUSH
8801: PPUSH
8802: PPUSH
// cl = rand ( 1 , 4 ) ;
8803: LD_ADDR_VAR 0 3
8807: PUSH
8808: LD_INT 1
8810: PPUSH
8811: LD_INT 4
8813: PPUSH
8814: CALL_OW 12
8818: ST_TO_ADDR
// base = init_level ;
8819: LD_ADDR_VAR 0 13
8823: PUSH
8824: LD_VAR 0 1
8828: ST_TO_ADDR
// case tick of 0 .. 5 5$00 :
8829: LD_OWVAR 1
8833: PUSH
8834: LD_INT 0
8836: DOUBLE
8837: GREATEREQUAL
8838: IFFALSE 8846
8840: LD_INT 10500
8842: DOUBLE
8843: LESSEQUAL
8844: IFTRUE 8848
8846: GO 8859
8848: POP
// i = 1 ; 5 5$01 .. 9 9$00 :
8849: LD_ADDR_VAR 0 11
8853: PUSH
8854: LD_INT 1
8856: ST_TO_ADDR
8857: GO 9118
8859: LD_INT 10535
8861: DOUBLE
8862: GREATEREQUAL
8863: IFFALSE 8871
8865: LD_INT 18900
8867: DOUBLE
8868: LESSEQUAL
8869: IFTRUE 8873
8871: GO 8884
8873: POP
// i = 2 ; 9 9$01 .. 15 15$00 :
8874: LD_ADDR_VAR 0 11
8878: PUSH
8879: LD_INT 2
8881: ST_TO_ADDR
8882: GO 9118
8884: LD_INT 18935
8886: DOUBLE
8887: GREATEREQUAL
8888: IFFALSE 8896
8890: LD_INT 31500
8892: DOUBLE
8893: LESSEQUAL
8894: IFTRUE 8898
8896: GO 8909
8898: POP
// i = 3 ; 15 15$01 .. 22 22$00 :
8899: LD_ADDR_VAR 0 11
8903: PUSH
8904: LD_INT 3
8906: ST_TO_ADDR
8907: GO 9118
8909: LD_INT 31535
8911: DOUBLE
8912: GREATEREQUAL
8913: IFFALSE 8921
8915: LD_INT 46200
8917: DOUBLE
8918: LESSEQUAL
8919: IFTRUE 8923
8921: GO 8934
8923: POP
// i = 4 ; 22 22$01 .. 30 30$00 :
8924: LD_ADDR_VAR 0 11
8928: PUSH
8929: LD_INT 4
8931: ST_TO_ADDR
8932: GO 9118
8934: LD_INT 46235
8936: DOUBLE
8937: GREATEREQUAL
8938: IFFALSE 8946
8940: LD_INT 63000
8942: DOUBLE
8943: LESSEQUAL
8944: IFTRUE 8948
8946: GO 8959
8948: POP
// i = 5 ; 30 30$01 .. 40 40$00 :
8949: LD_ADDR_VAR 0 11
8953: PUSH
8954: LD_INT 5
8956: ST_TO_ADDR
8957: GO 9118
8959: LD_INT 63035
8961: DOUBLE
8962: GREATEREQUAL
8963: IFFALSE 8971
8965: LD_INT 84000
8967: DOUBLE
8968: LESSEQUAL
8969: IFTRUE 8973
8971: GO 8984
8973: POP
// i = 6 ; 40 40$01 .. 52 52$00 :
8974: LD_ADDR_VAR 0 11
8978: PUSH
8979: LD_INT 6
8981: ST_TO_ADDR
8982: GO 9118
8984: LD_INT 84035
8986: DOUBLE
8987: GREATEREQUAL
8988: IFFALSE 8996
8990: LD_INT 109200
8992: DOUBLE
8993: LESSEQUAL
8994: IFTRUE 8998
8996: GO 9009
8998: POP
// i = 7 ; 52 52$01 .. 66 66$00 :
8999: LD_ADDR_VAR 0 11
9003: PUSH
9004: LD_INT 7
9006: ST_TO_ADDR
9007: GO 9118
9009: LD_INT 109235
9011: DOUBLE
9012: GREATEREQUAL
9013: IFFALSE 9021
9015: LD_INT 138600
9017: DOUBLE
9018: LESSEQUAL
9019: IFTRUE 9023
9021: GO 9034
9023: POP
// i = 8 ; 66 66$01 .. 88 88$00 :
9024: LD_ADDR_VAR 0 11
9028: PUSH
9029: LD_INT 8
9031: ST_TO_ADDR
9032: GO 9118
9034: LD_INT 138635
9036: DOUBLE
9037: GREATEREQUAL
9038: IFFALSE 9046
9040: LD_INT 184800
9042: DOUBLE
9043: LESSEQUAL
9044: IFTRUE 9048
9046: GO 9059
9048: POP
// i = 9 ; 88 88$01 .. 100 100$00 :
9049: LD_ADDR_VAR 0 11
9053: PUSH
9054: LD_INT 9
9056: ST_TO_ADDR
9057: GO 9118
9059: LD_INT 184835
9061: DOUBLE
9062: GREATEREQUAL
9063: IFFALSE 9071
9065: LD_INT 210000
9067: DOUBLE
9068: LESSEQUAL
9069: IFTRUE 9073
9071: GO 9084
9073: POP
// i = 10 ; 100 100$01 .. 120 120$00 :
9074: LD_ADDR_VAR 0 11
9078: PUSH
9079: LD_INT 10
9081: ST_TO_ADDR
9082: GO 9118
9084: LD_INT 210035
9086: DOUBLE
9087: GREATEREQUAL
9088: IFFALSE 9096
9090: LD_INT 252000
9092: DOUBLE
9093: LESSEQUAL
9094: IFTRUE 9098
9096: GO 9109
9098: POP
// i = 11 ; else
9099: LD_ADDR_VAR 0 11
9103: PUSH
9104: LD_INT 11
9106: ST_TO_ADDR
9107: GO 9118
9109: POP
// i = 12 ; end ;
9110: LD_ADDR_VAR 0 11
9114: PUSH
9115: LD_INT 12
9117: ST_TO_ADDR
// i = i - base div 2 ;
9118: LD_ADDR_VAR 0 11
9122: PUSH
9123: LD_VAR 0 11
9127: PUSH
9128: LD_VAR 0 13
9132: PUSH
9133: LD_INT 2
9135: DIV
9136: MINUS
9137: ST_TO_ADDR
// if i < 0 then
9138: LD_VAR 0 11
9142: PUSH
9143: LD_INT 0
9145: LESS
9146: IFFALSE 9156
// i = 0 ;
9148: LD_ADDR_VAR 0 11
9152: PUSH
9153: LD_INT 0
9155: ST_TO_ADDR
// if cl = 1 then
9156: LD_VAR 0 3
9160: PUSH
9161: LD_INT 1
9163: EQUAL
9164: IFFALSE 9204
// combat = rand ( base + i - 1 , base + i ) else
9166: LD_ADDR_VAR 0 4
9170: PUSH
9171: LD_VAR 0 13
9175: PUSH
9176: LD_VAR 0 11
9180: PLUS
9181: PUSH
9182: LD_INT 1
9184: MINUS
9185: PPUSH
9186: LD_VAR 0 13
9190: PUSH
9191: LD_VAR 0 11
9195: PLUS
9196: PPUSH
9197: CALL_OW 12
9201: ST_TO_ADDR
9202: GO 9244
// combat = rand ( base + i - 4 , base + i - 1 ) ;
9204: LD_ADDR_VAR 0 4
9208: PUSH
9209: LD_VAR 0 13
9213: PUSH
9214: LD_VAR 0 11
9218: PLUS
9219: PUSH
9220: LD_INT 4
9222: MINUS
9223: PPUSH
9224: LD_VAR 0 13
9228: PUSH
9229: LD_VAR 0 11
9233: PLUS
9234: PUSH
9235: LD_INT 1
9237: MINUS
9238: PPUSH
9239: CALL_OW 12
9243: ST_TO_ADDR
// if cl = 2 then
9244: LD_VAR 0 3
9248: PUSH
9249: LD_INT 2
9251: EQUAL
9252: IFFALSE 9292
// eng = rand ( base + i - 1 , base + i ) else
9254: LD_ADDR_VAR 0 5
9258: PUSH
9259: LD_VAR 0 13
9263: PUSH
9264: LD_VAR 0 11
9268: PLUS
9269: PUSH
9270: LD_INT 1
9272: MINUS
9273: PPUSH
9274: LD_VAR 0 13
9278: PUSH
9279: LD_VAR 0 11
9283: PLUS
9284: PPUSH
9285: CALL_OW 12
9289: ST_TO_ADDR
9290: GO 9332
// eng = rand ( base + i - 4 , base + i - 1 ) ;
9292: LD_ADDR_VAR 0 5
9296: PUSH
9297: LD_VAR 0 13
9301: PUSH
9302: LD_VAR 0 11
9306: PLUS
9307: PUSH
9308: LD_INT 4
9310: MINUS
9311: PPUSH
9312: LD_VAR 0 13
9316: PUSH
9317: LD_VAR 0 11
9321: PLUS
9322: PUSH
9323: LD_INT 1
9325: MINUS
9326: PPUSH
9327: CALL_OW 12
9331: ST_TO_ADDR
// if cl = 3 then
9332: LD_VAR 0 3
9336: PUSH
9337: LD_INT 3
9339: EQUAL
9340: IFFALSE 9380
// mech = rand ( base + i - 1 , base + i ) else
9342: LD_ADDR_VAR 0 6
9346: PUSH
9347: LD_VAR 0 13
9351: PUSH
9352: LD_VAR 0 11
9356: PLUS
9357: PUSH
9358: LD_INT 1
9360: MINUS
9361: PPUSH
9362: LD_VAR 0 13
9366: PUSH
9367: LD_VAR 0 11
9371: PLUS
9372: PPUSH
9373: CALL_OW 12
9377: ST_TO_ADDR
9378: GO 9420
// mech = rand ( base + i - 4 , base + i - 1 ) ;
9380: LD_ADDR_VAR 0 6
9384: PUSH
9385: LD_VAR 0 13
9389: PUSH
9390: LD_VAR 0 11
9394: PLUS
9395: PUSH
9396: LD_INT 4
9398: MINUS
9399: PPUSH
9400: LD_VAR 0 13
9404: PUSH
9405: LD_VAR 0 11
9409: PLUS
9410: PUSH
9411: LD_INT 1
9413: MINUS
9414: PPUSH
9415: CALL_OW 12
9419: ST_TO_ADDR
// if cl = 4 then
9420: LD_VAR 0 3
9424: PUSH
9425: LD_INT 4
9427: EQUAL
9428: IFFALSE 9468
// sci = rand ( base + i - 1 , base + i ) else
9430: LD_ADDR_VAR 0 7
9434: PUSH
9435: LD_VAR 0 13
9439: PUSH
9440: LD_VAR 0 11
9444: PLUS
9445: PUSH
9446: LD_INT 1
9448: MINUS
9449: PPUSH
9450: LD_VAR 0 13
9454: PUSH
9455: LD_VAR 0 11
9459: PLUS
9460: PPUSH
9461: CALL_OW 12
9465: ST_TO_ADDR
9466: GO 9508
// sci = rand ( base + i - 4 , base + i - 1 ) ;
9468: LD_ADDR_VAR 0 7
9472: PUSH
9473: LD_VAR 0 13
9477: PUSH
9478: LD_VAR 0 11
9482: PLUS
9483: PUSH
9484: LD_INT 4
9486: MINUS
9487: PPUSH
9488: LD_VAR 0 13
9492: PUSH
9493: LD_VAR 0 11
9497: PLUS
9498: PUSH
9499: LD_INT 1
9501: MINUS
9502: PPUSH
9503: CALL_OW 12
9507: ST_TO_ADDR
// skills = [ combat , eng , mech , sci ] ;
9508: LD_ADDR_VAR 0 8
9512: PUSH
9513: LD_VAR 0 4
9517: PUSH
9518: LD_VAR 0 5
9522: PUSH
9523: LD_VAR 0 6
9527: PUSH
9528: LD_VAR 0 7
9532: PUSH
9533: EMPTY
9534: LIST
9535: LIST
9536: LIST
9537: LIST
9538: ST_TO_ADDR
// for i = 1 to 4 do
9539: LD_ADDR_VAR 0 11
9543: PUSH
9544: DOUBLE
9545: LD_INT 1
9547: DEC
9548: ST_TO_ADDR
9549: LD_INT 4
9551: PUSH
9552: FOR_TO
9553: IFFALSE 9708
// begin if skills [ i ] < 0 then
9555: LD_VAR 0 8
9559: PUSH
9560: LD_VAR 0 11
9564: ARRAY
9565: PUSH
9566: LD_INT 0
9568: LESS
9569: IFFALSE 9594
// skills = replace ( skills , i , 0 ) ;
9571: LD_ADDR_VAR 0 8
9575: PUSH
9576: LD_VAR 0 8
9580: PPUSH
9581: LD_VAR 0 11
9585: PPUSH
9586: LD_INT 0
9588: PPUSH
9589: CALL_OW 1
9593: ST_TO_ADDR
// n = [ 0 , 1 , 0 , 1 , 0 , 2 , 0 , 0 , 1 , 0 ] [ rand ( 1 , 10 ) ] ;
9594: LD_ADDR_VAR 0 14
9598: PUSH
9599: LD_INT 0
9601: PUSH
9602: LD_INT 1
9604: PUSH
9605: LD_INT 0
9607: PUSH
9608: LD_INT 1
9610: PUSH
9611: LD_INT 0
9613: PUSH
9614: LD_INT 2
9616: PUSH
9617: LD_INT 0
9619: PUSH
9620: LD_INT 0
9622: PUSH
9623: LD_INT 1
9625: PUSH
9626: LD_INT 0
9628: PUSH
9629: EMPTY
9630: LIST
9631: LIST
9632: LIST
9633: LIST
9634: LIST
9635: LIST
9636: LIST
9637: LIST
9638: LIST
9639: LIST
9640: PUSH
9641: LD_INT 1
9643: PPUSH
9644: LD_INT 10
9646: PPUSH
9647: CALL_OW 12
9651: ARRAY
9652: ST_TO_ADDR
// if n > skills [ i ] then
9653: LD_VAR 0 14
9657: PUSH
9658: LD_VAR 0 8
9662: PUSH
9663: LD_VAR 0 11
9667: ARRAY
9668: GREATER
9669: IFFALSE 9687
// n = skills [ i ] ;
9671: LD_ADDR_VAR 0 14
9675: PUSH
9676: LD_VAR 0 8
9680: PUSH
9681: LD_VAR 0 11
9685: ARRAY
9686: ST_TO_ADDR
// replace ( base_skills , i , n ) ;
9687: LD_VAR 0 9
9691: PPUSH
9692: LD_VAR 0 11
9696: PPUSH
9697: LD_VAR 0 14
9701: PPUSH
9702: CALL_OW 1
// end ;
9706: GO 9552
9708: POP
9709: POP
// n = rand ( 1 , 100 ) ;
9710: LD_ADDR_VAR 0 14
9714: PUSH
9715: LD_INT 1
9717: PPUSH
9718: LD_INT 100
9720: PPUSH
9721: CALL_OW 12
9725: ST_TO_ADDR
// case n of 1 .. 32 :
9726: LD_VAR 0 14
9730: PUSH
9731: LD_INT 1
9733: DOUBLE
9734: GREATEREQUAL
9735: IFFALSE 9743
9737: LD_INT 32
9739: DOUBLE
9740: LESSEQUAL
9741: IFTRUE 9745
9743: GO 9756
9745: POP
// def = 10 ; 31 .. 54 :
9746: LD_ADDR_VAR 0 15
9750: PUSH
9751: LD_INT 10
9753: ST_TO_ADDR
9754: GO 9857
9756: LD_INT 31
9758: DOUBLE
9759: GREATEREQUAL
9760: IFFALSE 9768
9762: LD_INT 54
9764: DOUBLE
9765: LESSEQUAL
9766: IFTRUE 9770
9768: GO 9781
9770: POP
// def = 9 ; 55 .. 76 :
9771: LD_ADDR_VAR 0 15
9775: PUSH
9776: LD_INT 9
9778: ST_TO_ADDR
9779: GO 9857
9781: LD_INT 55
9783: DOUBLE
9784: GREATEREQUAL
9785: IFFALSE 9793
9787: LD_INT 76
9789: DOUBLE
9790: LESSEQUAL
9791: IFTRUE 9795
9793: GO 9806
9795: POP
// def = 11 ; 77 .. 88 :
9796: LD_ADDR_VAR 0 15
9800: PUSH
9801: LD_INT 11
9803: ST_TO_ADDR
9804: GO 9857
9806: LD_INT 77
9808: DOUBLE
9809: GREATEREQUAL
9810: IFFALSE 9818
9812: LD_INT 88
9814: DOUBLE
9815: LESSEQUAL
9816: IFTRUE 9820
9818: GO 9831
9820: POP
// def = 8 ; 89 .. 100 :
9821: LD_ADDR_VAR 0 15
9825: PUSH
9826: LD_INT 8
9828: ST_TO_ADDR
9829: GO 9857
9831: LD_INT 89
9833: DOUBLE
9834: GREATEREQUAL
9835: IFFALSE 9843
9837: LD_INT 100
9839: DOUBLE
9840: LESSEQUAL
9841: IFTRUE 9845
9843: GO 9856
9845: POP
// def = 12 ; end ;
9846: LD_ADDR_VAR 0 15
9850: PUSH
9851: LD_INT 12
9853: ST_TO_ADDR
9854: GO 9857
9856: POP
// n = rand ( 1 , 100 ) ;
9857: LD_ADDR_VAR 0 14
9861: PUSH
9862: LD_INT 1
9864: PPUSH
9865: LD_INT 100
9867: PPUSH
9868: CALL_OW 12
9872: ST_TO_ADDR
// case n of 1 .. 44 :
9873: LD_VAR 0 14
9877: PUSH
9878: LD_INT 1
9880: DOUBLE
9881: GREATEREQUAL
9882: IFFALSE 9890
9884: LD_INT 44
9886: DOUBLE
9887: LESSEQUAL
9888: IFTRUE 9892
9890: GO 9903
9892: POP
// speed = 10 ; 45 .. 76 :
9893: LD_ADDR_VAR 0 16
9897: PUSH
9898: LD_INT 10
9900: ST_TO_ADDR
9901: GO 9979
9903: LD_INT 45
9905: DOUBLE
9906: GREATEREQUAL
9907: IFFALSE 9915
9909: LD_INT 76
9911: DOUBLE
9912: LESSEQUAL
9913: IFTRUE 9917
9915: GO 9928
9917: POP
// speed = 9 ; 77 .. 94 :
9918: LD_ADDR_VAR 0 16
9922: PUSH
9923: LD_INT 9
9925: ST_TO_ADDR
9926: GO 9979
9928: LD_INT 77
9930: DOUBLE
9931: GREATEREQUAL
9932: IFFALSE 9940
9934: LD_INT 94
9936: DOUBLE
9937: LESSEQUAL
9938: IFTRUE 9942
9940: GO 9953
9942: POP
// speed = 11 ; 95 .. 100 :
9943: LD_ADDR_VAR 0 16
9947: PUSH
9948: LD_INT 11
9950: ST_TO_ADDR
9951: GO 9979
9953: LD_INT 95
9955: DOUBLE
9956: GREATEREQUAL
9957: IFFALSE 9965
9959: LD_INT 100
9961: DOUBLE
9962: LESSEQUAL
9963: IFTRUE 9967
9965: GO 9978
9967: POP
// speed = 12 ; end ;
9968: LD_ADDR_VAR 0 16
9972: PUSH
9973: LD_INT 12
9975: ST_TO_ADDR
9976: GO 9979
9978: POP
// hc_attr = [ def , speed ] ;
9979: LD_ADDR_OWVAR 29
9983: PUSH
9984: LD_VAR 0 15
9988: PUSH
9989: LD_VAR 0 16
9993: PUSH
9994: EMPTY
9995: LIST
9996: LIST
9997: ST_TO_ADDR
// hc_basic_skills = base_skills ;
9998: LD_ADDR_OWVAR 30
10002: PUSH
10003: LD_VAR 0 9
10007: ST_TO_ADDR
// hc_skills := skills ;
10008: LD_ADDR_OWVAR 31
10012: PUSH
10013: LD_VAR 0 8
10017: ST_TO_ADDR
// hc_class = cl ;
10018: LD_ADDR_OWVAR 28
10022: PUSH
10023: LD_VAR 0 3
10027: ST_TO_ADDR
// end ; end_of_file
10028: LD_VAR 0 2
10032: RET
// export ObnovCas , ObnovZpozdeni ; export function SetRespawningTime ( minBTime , maxBTime , MinDelay , MaxDelay ) ; var k ; begin
10033: LD_INT 0
10035: PPUSH
10036: PPUSH
// k = Rand ( minBTime , maxBTime ) ;
10037: LD_ADDR_VAR 0 6
10041: PUSH
10042: LD_VAR 0 1
10046: PPUSH
10047: LD_VAR 0 2
10051: PPUSH
10052: CALL_OW 12
10056: ST_TO_ADDR
// ObnovCas = [ k , k , k , k , k , k , k , k ] ;
10057: LD_ADDR_EXP 42
10061: PUSH
10062: LD_VAR 0 6
10066: PUSH
10067: LD_VAR 0 6
10071: PUSH
10072: LD_VAR 0 6
10076: PUSH
10077: LD_VAR 0 6
10081: PUSH
10082: LD_VAR 0 6
10086: PUSH
10087: LD_VAR 0 6
10091: PUSH
10092: LD_VAR 0 6
10096: PUSH
10097: LD_VAR 0 6
10101: PUSH
10102: EMPTY
10103: LIST
10104: LIST
10105: LIST
10106: LIST
10107: LIST
10108: LIST
10109: LIST
10110: LIST
10111: ST_TO_ADDR
// k = Rand ( minDelay , MaxDelay ) ;
10112: LD_ADDR_VAR 0 6
10116: PUSH
10117: LD_VAR 0 3
10121: PPUSH
10122: LD_VAR 0 4
10126: PPUSH
10127: CALL_OW 12
10131: ST_TO_ADDR
// ObnovZpozdeni = k ;
10132: LD_ADDR_EXP 43
10136: PUSH
10137: LD_VAR 0 6
10141: ST_TO_ADDR
// end ;
10142: LD_VAR 0 5
10146: RET
// export unit_list ; export function ObnovCloveka ( side , nation , restored ) ; var building_list , b , n , un , k , i , base_skills , speed , def ; begin
10147: LD_INT 0
10149: PPUSH
10150: PPUSH
10151: PPUSH
10152: PPUSH
10153: PPUSH
10154: PPUSH
10155: PPUSH
10156: PPUSH
10157: PPUSH
10158: PPUSH
// if ObnovCas [ side ] = 0 then
10159: LD_EXP 42
10163: PUSH
10164: LD_VAR 0 1
10168: ARRAY
10169: PUSH
10170: LD_INT 0
10172: EQUAL
10173: IFFALSE 10177
// exit ;
10175: GO 10802
// uc_nation := nation ;
10177: LD_ADDR_OWVAR 21
10181: PUSH
10182: LD_VAR 0 2
10186: ST_TO_ADDR
// uc_side := side ;
10187: LD_ADDR_OWVAR 20
10191: PUSH
10192: LD_VAR 0 1
10196: ST_TO_ADDR
// uc_direction := Rand ( 0 , 5 ) ;
10197: LD_ADDR_OWVAR 24
10201: PUSH
10202: LD_INT 0
10204: PPUSH
10205: LD_INT 5
10207: PPUSH
10208: CALL_OW 12
10212: ST_TO_ADDR
// if restored then
10213: LD_VAR 0 3
10217: IFFALSE 10300
// begin hc_class = GetClass ( restored ) ;
10219: LD_ADDR_OWVAR 28
10223: PUSH
10224: LD_VAR 0 3
10228: PPUSH
10229: CALL_OW 257
10233: ST_TO_ADDR
// hc_attr = [ GetAttr ( restored , attr_stamina ) , GetAttr ( restored , attr_speed ) ] ;
10234: LD_ADDR_OWVAR 29
10238: PUSH
10239: LD_VAR 0 3
10243: PPUSH
10244: LD_INT 1
10246: PPUSH
10247: CALL_OW 260
10251: PUSH
10252: LD_VAR 0 3
10256: PPUSH
10257: LD_INT 2
10259: PPUSH
10260: CALL_OW 260
10264: PUSH
10265: EMPTY
10266: LIST
10267: LIST
10268: ST_TO_ADDR
// if hc_class in [ class_sniper , class_bazooker , class_mortar ] then
10269: LD_OWVAR 28
10273: PUSH
10274: LD_INT 5
10276: PUSH
10277: LD_INT 9
10279: PUSH
10280: LD_INT 8
10282: PUSH
10283: EMPTY
10284: LIST
10285: LIST
10286: LIST
10287: IN
10288: IFFALSE 10298
// hc_class = class_soldier ;
10290: LD_ADDR_OWVAR 28
10294: PUSH
10295: LD_INT 1
10297: ST_TO_ADDR
// end else
10298: GO 10309
// randomHumanStats ( initial_level ) ;
10300: LD_EXP 16
10304: PPUSH
10305: CALL 8786 0 1
// hc_importance := 0 ;
10309: LD_ADDR_OWVAR 32
10313: PUSH
10314: LD_INT 0
10316: ST_TO_ADDR
// hc_gallery :=  ;
10317: LD_ADDR_OWVAR 33
10321: PUSH
10322: LD_STRING 
10324: ST_TO_ADDR
// hc_face_number := 0 ;
10325: LD_ADDR_OWVAR 34
10329: PUSH
10330: LD_INT 0
10332: ST_TO_ADDR
// un := CreateHuman ;
10333: LD_ADDR_VAR 0 8
10337: PUSH
10338: CALL_OW 44
10342: ST_TO_ADDR
// if restored then
10343: LD_VAR 0 3
10347: IFFALSE 10363
// CopySkills ( restored , un ) ;
10349: LD_VAR 0 3
10353: PPUSH
10354: LD_VAR 0 8
10358: PPUSH
10359: CALL_OW 510
// k = ObnovCas [ side ] + ObnovZpozdeni ;
10363: LD_ADDR_VAR 0 9
10367: PUSH
10368: LD_EXP 42
10372: PUSH
10373: LD_VAR 0 1
10377: ARRAY
10378: PUSH
10379: LD_EXP 43
10383: PLUS
10384: ST_TO_ADDR
// ObnovCas = Replace ( ObnovCas , side , k ) ;
10385: LD_ADDR_EXP 42
10389: PUSH
10390: LD_EXP 42
10394: PPUSH
10395: LD_VAR 0 1
10399: PPUSH
10400: LD_VAR 0 9
10404: PPUSH
10405: CALL_OW 1
10409: ST_TO_ADDR
// wait ( ObnovCas [ side ] - ObnovZpozdeni ) ;
10410: LD_EXP 42
10414: PUSH
10415: LD_VAR 0 1
10419: ARRAY
10420: PUSH
10421: LD_EXP 43
10425: MINUS
10426: PPUSH
10427: CALL_OW 67
// building_list = FilterAllUnits ( [ [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] , [ f_ok ] , [ f_side , side ] , [ f_nation , nation ] ] ) ;
10431: LD_ADDR_VAR 0 5
10435: PUSH
10436: LD_INT 21
10438: PUSH
10439: LD_INT 3
10441: PUSH
10442: EMPTY
10443: LIST
10444: LIST
10445: PUSH
10446: LD_INT 2
10448: PUSH
10449: LD_INT 30
10451: PUSH
10452: LD_INT 0
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: LD_INT 30
10461: PUSH
10462: LD_INT 1
10464: PUSH
10465: EMPTY
10466: LIST
10467: LIST
10468: PUSH
10469: EMPTY
10470: LIST
10471: LIST
10472: LIST
10473: PUSH
10474: LD_INT 50
10476: PUSH
10477: EMPTY
10478: LIST
10479: PUSH
10480: LD_INT 22
10482: PUSH
10483: LD_VAR 0 1
10487: PUSH
10488: EMPTY
10489: LIST
10490: LIST
10491: PUSH
10492: LD_INT 23
10494: PUSH
10495: LD_VAR 0 2
10499: PUSH
10500: EMPTY
10501: LIST
10502: LIST
10503: PUSH
10504: EMPTY
10505: LIST
10506: LIST
10507: LIST
10508: LIST
10509: LIST
10510: PPUSH
10511: CALL_OW 69
10515: ST_TO_ADDR
// if building_list = 0 then
10516: LD_VAR 0 5
10520: PUSH
10521: LD_INT 0
10523: EQUAL
10524: IFFALSE 10598
// building_list = FilterAllUnits ( [ [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] , [ f_ok ] , [ f_side , side ] ] ) ;
10526: LD_ADDR_VAR 0 5
10530: PUSH
10531: LD_INT 21
10533: PUSH
10534: LD_INT 3
10536: PUSH
10537: EMPTY
10538: LIST
10539: LIST
10540: PUSH
10541: LD_INT 2
10543: PUSH
10544: LD_INT 30
10546: PUSH
10547: LD_INT 0
10549: PUSH
10550: EMPTY
10551: LIST
10552: LIST
10553: PUSH
10554: LD_INT 30
10556: PUSH
10557: LD_INT 1
10559: PUSH
10560: EMPTY
10561: LIST
10562: LIST
10563: PUSH
10564: EMPTY
10565: LIST
10566: LIST
10567: LIST
10568: PUSH
10569: LD_INT 50
10571: PUSH
10572: EMPTY
10573: LIST
10574: PUSH
10575: LD_INT 22
10577: PUSH
10578: LD_VAR 0 1
10582: PUSH
10583: EMPTY
10584: LIST
10585: LIST
10586: PUSH
10587: EMPTY
10588: LIST
10589: LIST
10590: LIST
10591: LIST
10592: PPUSH
10593: CALL_OW 69
10597: ST_TO_ADDR
// if building_list > 0 then
10598: LD_VAR 0 5
10602: PUSH
10603: LD_INT 0
10605: GREATER
10606: IFFALSE 10724
// begin b := building_list [ Rand ( 1 , building_list + 0 ) ] ;
10608: LD_ADDR_VAR 0 6
10612: PUSH
10613: LD_VAR 0 5
10617: PUSH
10618: LD_INT 1
10620: PPUSH
10621: LD_VAR 0 5
10625: PUSH
10626: LD_INT 0
10628: PLUS
10629: PPUSH
10630: CALL_OW 12
10634: ARRAY
10635: ST_TO_ADDR
// if GetBType ( b ) in [ b_depot , b_warehouse ] then
10636: LD_VAR 0 6
10640: PPUSH
10641: CALL_OW 266
10645: PUSH
10646: LD_INT 0
10648: PUSH
10649: LD_INT 1
10651: PUSH
10652: EMPTY
10653: LIST
10654: LIST
10655: IN
10656: IFFALSE 10668
// n = 25 else
10658: LD_ADDR_VAR 0 7
10662: PUSH
10663: LD_INT 25
10665: ST_TO_ADDR
10666: GO 10676
// n = 10 ;
10668: LD_ADDR_VAR 0 7
10672: PUSH
10673: LD_INT 10
10675: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( b ) , GetY ( b ) , n , true ) ;
10676: LD_VAR 0 8
10680: PPUSH
10681: LD_VAR 0 6
10685: PPUSH
10686: CALL_OW 250
10690: PPUSH
10691: LD_VAR 0 6
10695: PPUSH
10696: CALL_OW 251
10700: PPUSH
10701: LD_VAR 0 7
10705: PPUSH
10706: LD_INT 1
10708: PPUSH
10709: CALL_OW 50
// OnHumanRespawned ( un ) ;
10713: LD_VAR 0 8
10717: PPUSH
10718: CALL 8377 0 1
// end else
10722: GO 10802
// begin unit_list = FilterAllUnits ( [ [ f_side , side ] , [ f_ok ] ] ) ;
10724: LD_ADDR_EXP 44
10728: PUSH
10729: LD_INT 22
10731: PUSH
10732: LD_VAR 0 1
10736: PUSH
10737: EMPTY
10738: LIST
10739: LIST
10740: PUSH
10741: LD_INT 50
10743: PUSH
10744: EMPTY
10745: LIST
10746: PUSH
10747: EMPTY
10748: LIST
10749: LIST
10750: PPUSH
10751: CALL_OW 69
10755: ST_TO_ADDR
// if unit_list > 0 then
10756: LD_EXP 44
10760: PUSH
10761: LD_INT 0
10763: GREATER
10764: IFFALSE 10800
// begin ObnovOpozdilceCloveka ( un , side , k / 2 ) ;
10766: LD_VAR 0 8
10770: PPUSH
10771: LD_VAR 0 1
10775: PPUSH
10776: LD_VAR 0 9
10780: PUSH
10781: LD_INT 2
10783: DIVREAL
10784: PPUSH
10785: CALL 10807 0 3
// OnHumanRespawned ( un ) ;
10789: LD_VAR 0 8
10793: PPUSH
10794: CALL 8377 0 1
// end else
10798: GO 10802
// exit ;
10800: GO 10802
// end ; end ;
10802: LD_VAR 0 4
10806: RET
// function ObnovOpozdilceCloveka ( un , side , waitTime ) ; var building_list , n , unit_list , b ; begin
10807: LD_INT 0
10809: PPUSH
10810: PPUSH
10811: PPUSH
10812: PPUSH
10813: PPUSH
// wait ( waitTime ) ;
10814: LD_VAR 0 3
10818: PPUSH
10819: CALL_OW 67
// building_list = FilterAllUnits ( [ [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] , [ f_ok ] , [ f_side , side ] , [ f_nation , GetNation ( un ) ] ] ) ;
10823: LD_ADDR_VAR 0 5
10827: PUSH
10828: LD_INT 21
10830: PUSH
10831: LD_INT 3
10833: PUSH
10834: EMPTY
10835: LIST
10836: LIST
10837: PUSH
10838: LD_INT 2
10840: PUSH
10841: LD_INT 30
10843: PUSH
10844: LD_INT 0
10846: PUSH
10847: EMPTY
10848: LIST
10849: LIST
10850: PUSH
10851: LD_INT 30
10853: PUSH
10854: LD_INT 1
10856: PUSH
10857: EMPTY
10858: LIST
10859: LIST
10860: PUSH
10861: EMPTY
10862: LIST
10863: LIST
10864: LIST
10865: PUSH
10866: LD_INT 50
10868: PUSH
10869: EMPTY
10870: LIST
10871: PUSH
10872: LD_INT 22
10874: PUSH
10875: LD_VAR 0 2
10879: PUSH
10880: EMPTY
10881: LIST
10882: LIST
10883: PUSH
10884: LD_INT 23
10886: PUSH
10887: LD_VAR 0 1
10891: PPUSH
10892: CALL_OW 248
10896: PUSH
10897: EMPTY
10898: LIST
10899: LIST
10900: PUSH
10901: EMPTY
10902: LIST
10903: LIST
10904: LIST
10905: LIST
10906: LIST
10907: PPUSH
10908: CALL_OW 69
10912: ST_TO_ADDR
// if building_list = 0 then
10913: LD_VAR 0 5
10917: PUSH
10918: LD_INT 0
10920: EQUAL
10921: IFFALSE 10995
// building_list = FilterAllUnits ( [ [ f_type , unit_building ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] , [ f_ok ] , [ f_side , side ] ] ) ;
10923: LD_ADDR_VAR 0 5
10927: PUSH
10928: LD_INT 21
10930: PUSH
10931: LD_INT 3
10933: PUSH
10934: EMPTY
10935: LIST
10936: LIST
10937: PUSH
10938: LD_INT 2
10940: PUSH
10941: LD_INT 30
10943: PUSH
10944: LD_INT 0
10946: PUSH
10947: EMPTY
10948: LIST
10949: LIST
10950: PUSH
10951: LD_INT 30
10953: PUSH
10954: LD_INT 1
10956: PUSH
10957: EMPTY
10958: LIST
10959: LIST
10960: PUSH
10961: EMPTY
10962: LIST
10963: LIST
10964: LIST
10965: PUSH
10966: LD_INT 50
10968: PUSH
10969: EMPTY
10970: LIST
10971: PUSH
10972: LD_INT 22
10974: PUSH
10975: LD_VAR 0 2
10979: PUSH
10980: EMPTY
10981: LIST
10982: LIST
10983: PUSH
10984: EMPTY
10985: LIST
10986: LIST
10987: LIST
10988: LIST
10989: PPUSH
10990: CALL_OW 69
10994: ST_TO_ADDR
// if building_list > 0 then
10995: LD_VAR 0 5
10999: PUSH
11000: LD_INT 0
11002: GREATER
11003: IFFALSE 11121
// begin b := building_list [ Rand ( 1 , building_list + 0 ) ] ;
11005: LD_ADDR_VAR 0 8
11009: PUSH
11010: LD_VAR 0 5
11014: PUSH
11015: LD_INT 1
11017: PPUSH
11018: LD_VAR 0 5
11022: PUSH
11023: LD_INT 0
11025: PLUS
11026: PPUSH
11027: CALL_OW 12
11031: ARRAY
11032: ST_TO_ADDR
// if GetBType ( b ) in [ b_depot , b_warehouse ] then
11033: LD_VAR 0 8
11037: PPUSH
11038: CALL_OW 266
11042: PUSH
11043: LD_INT 0
11045: PUSH
11046: LD_INT 1
11048: PUSH
11049: EMPTY
11050: LIST
11051: LIST
11052: IN
11053: IFFALSE 11065
// n = 25 else
11055: LD_ADDR_VAR 0 6
11059: PUSH
11060: LD_INT 25
11062: ST_TO_ADDR
11063: GO 11073
// n = 10 ;
11065: LD_ADDR_VAR 0 6
11069: PUSH
11070: LD_INT 10
11072: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( b ) , GetY ( b ) , n , true ) ;
11073: LD_VAR 0 1
11077: PPUSH
11078: LD_VAR 0 8
11082: PPUSH
11083: CALL_OW 250
11087: PPUSH
11088: LD_VAR 0 8
11092: PPUSH
11093: CALL_OW 251
11097: PPUSH
11098: LD_VAR 0 6
11102: PPUSH
11103: LD_INT 1
11105: PPUSH
11106: CALL_OW 50
// OnHumanRespawned ( un ) ;
11110: LD_VAR 0 1
11114: PPUSH
11115: CALL 8377 0 1
// end else
11119: GO 11219
// begin unit_list = FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_type , unit_human ] , [ f_control , control_computer ] , [ f_control , control_apeman ] ] ] ) ;
11121: LD_ADDR_VAR 0 7
11125: PUSH
11126: LD_INT 22
11128: PUSH
11129: LD_VAR 0 2
11133: PUSH
11134: EMPTY
11135: LIST
11136: LIST
11137: PUSH
11138: LD_INT 2
11140: PUSH
11141: LD_INT 21
11143: PUSH
11144: LD_INT 1
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: PUSH
11151: LD_INT 33
11153: PUSH
11154: LD_INT 3
11156: PUSH
11157: EMPTY
11158: LIST
11159: LIST
11160: PUSH
11161: LD_INT 33
11163: PUSH
11164: LD_INT 5
11166: PUSH
11167: EMPTY
11168: LIST
11169: LIST
11170: PUSH
11171: EMPTY
11172: LIST
11173: LIST
11174: LIST
11175: LIST
11176: PUSH
11177: EMPTY
11178: LIST
11179: LIST
11180: PPUSH
11181: CALL_OW 69
11185: ST_TO_ADDR
// if unit_list > 0 then
11186: LD_VAR 0 7
11190: PUSH
11191: LD_INT 0
11193: GREATER
11194: IFFALSE 11217
// ObnovOpozdilceCloveka ( un , side , waitTime ) else
11196: LD_VAR 0 1
11200: PPUSH
11201: LD_VAR 0 2
11205: PPUSH
11206: LD_VAR 0 3
11210: PPUSH
11211: CALL 10807 0 3
11215: GO 11219
// exit ;
11217: GO 11219
// end ; end ; end_of_file
11219: LD_VAR 0 4
11223: RET
// export function SetMpTechs ( ) ; var side , i ; begin
11224: LD_INT 0
11226: PPUSH
11227: PPUSH
11228: PPUSH
// for side = 1 to 8 do
11229: LD_ADDR_VAR 0 2
11233: PUSH
11234: DOUBLE
11235: LD_INT 1
11237: DEC
11238: ST_TO_ADDR
11239: LD_INT 8
11241: PUSH
11242: FOR_TO
11243: IFFALSE 11364
// begin for i = 1 to 72 do
11245: LD_ADDR_VAR 0 3
11249: PUSH
11250: DOUBLE
11251: LD_INT 1
11253: DEC
11254: ST_TO_ADDR
11255: LD_INT 72
11257: PUSH
11258: FOR_TO
11259: IFFALSE 11290
// SetTech ( i , side , GetRestrictions ( false , i ) ) ;
11261: LD_VAR 0 3
11265: PPUSH
11266: LD_VAR 0 2
11270: PPUSH
11271: LD_INT 0
11273: PPUSH
11274: LD_VAR 0 3
11278: PPUSH
11279: CALL_OW 565
11283: PPUSH
11284: CALL_OW 322
11288: GO 11258
11290: POP
11291: POP
// SetTech ( 73 , side , GetRestrictions ( false , 25 ) ) ;
11292: LD_INT 73
11294: PPUSH
11295: LD_VAR 0 2
11299: PPUSH
11300: LD_INT 0
11302: PPUSH
11303: LD_INT 25
11305: PPUSH
11306: CALL_OW 565
11310: PPUSH
11311: CALL_OW 322
// for i = 0 to 40 do
11315: LD_ADDR_VAR 0 3
11319: PUSH
11320: DOUBLE
11321: LD_INT 0
11323: DEC
11324: ST_TO_ADDR
11325: LD_INT 40
11327: PUSH
11328: FOR_TO
11329: IFFALSE 11360
// SetRestrict ( i , side , GetRestrictions ( true , i ) ) ;
11331: LD_VAR 0 3
11335: PPUSH
11336: LD_VAR 0 2
11340: PPUSH
11341: LD_INT 1
11343: PPUSH
11344: LD_VAR 0 3
11348: PPUSH
11349: CALL_OW 565
11353: PPUSH
11354: CALL_OW 324
11358: GO 11328
11360: POP
11361: POP
// end ;
11362: GO 11242
11364: POP
11365: POP
// end ;
11366: LD_VAR 0 1
11370: RET
// export function SetMpTechLevel ( level ) ; var side , i ; begin
11371: LD_INT 0
11373: PPUSH
11374: PPUSH
11375: PPUSH
// for side = 1 to 8 do
11376: LD_ADDR_VAR 0 3
11380: PUSH
11381: DOUBLE
11382: LD_INT 1
11384: DEC
11385: ST_TO_ADDR
11386: LD_INT 8
11388: PUSH
11389: FOR_TO
11390: IFFALSE 15386
// begin for i = 1 to 73 do
11392: LD_ADDR_VAR 0 4
11396: PUSH
11397: DOUBLE
11398: LD_INT 1
11400: DEC
11401: ST_TO_ADDR
11402: LD_INT 73
11404: PUSH
11405: FOR_TO
11406: IFFALSE 11427
// SetTech ( i , side , state_disabled ) ;
11408: LD_VAR 0 4
11412: PPUSH
11413: LD_VAR 0 3
11417: PPUSH
11418: LD_INT 0
11420: PPUSH
11421: CALL_OW 322
11425: GO 11405
11427: POP
11428: POP
// for i = 0 to 40 do
11429: LD_ADDR_VAR 0 4
11433: PUSH
11434: DOUBLE
11435: LD_INT 0
11437: DEC
11438: ST_TO_ADDR
11439: LD_INT 40
11441: PUSH
11442: FOR_TO
11443: IFFALSE 11464
// SetRestrict ( i , side , false ) ;
11445: LD_VAR 0 4
11449: PPUSH
11450: LD_VAR 0 3
11454: PPUSH
11455: LD_INT 0
11457: PPUSH
11458: CALL_OW 324
11462: GO 11442
11464: POP
11465: POP
// case level of 1 :
11466: LD_VAR 0 1
11470: PUSH
11471: LD_INT 1
11473: DOUBLE
11474: EQUAL
11475: IFTRUE 11479
11477: GO 11632
11479: POP
// begin SetTech ( tech_solpow , side , state_enabled ) ;
11480: LD_INT 35
11482: PPUSH
11483: LD_VAR 0 3
11487: PPUSH
11488: LD_INT 1
11490: PPUSH
11491: CALL_OW 322
// SetTech ( tech_soleng , side , state_enabled ) ;
11495: LD_INT 45
11497: PPUSH
11498: LD_VAR 0 3
11502: PPUSH
11503: LD_INT 1
11505: PPUSH
11506: CALL_OW 322
// SetTech ( tech_oilpow , side , state_enabled ) ;
11510: LD_INT 46
11512: PPUSH
11513: LD_VAR 0 3
11517: PPUSH
11518: LD_INT 1
11520: PPUSH
11521: CALL_OW 322
// SetTech ( tech_oileng , side , state_enabled ) ;
11525: LD_INT 47
11527: PPUSH
11528: LD_VAR 0 3
11532: PPUSH
11533: LD_INT 1
11535: PPUSH
11536: CALL_OW 322
// SetRestrict ( b_depot , side , true ) ;
11540: LD_INT 0
11542: PPUSH
11543: LD_VAR 0 3
11547: PPUSH
11548: LD_INT 1
11550: PPUSH
11551: CALL_OW 324
// SetRestrict ( b_workshop , side , true ) ;
11555: LD_INT 2
11557: PPUSH
11558: LD_VAR 0 3
11562: PPUSH
11563: LD_INT 1
11565: PPUSH
11566: CALL_OW 324
// SetRestrict ( b_armoury , side , true ) ;
11570: LD_INT 4
11572: PPUSH
11573: LD_VAR 0 3
11577: PPUSH
11578: LD_INT 1
11580: PPUSH
11581: CALL_OW 324
// SetRestrict ( b_lab , side , true ) ;
11585: LD_INT 6
11587: PPUSH
11588: LD_VAR 0 3
11592: PPUSH
11593: LD_INT 1
11595: PPUSH
11596: CALL_OW 324
// SetRestrict ( b_oil_mine , side , true ) ;
11600: LD_INT 29
11602: PPUSH
11603: LD_VAR 0 3
11607: PPUSH
11608: LD_INT 1
11610: PPUSH
11611: CALL_OW 324
// SetRestrict ( b_breastwork , side , true ) ;
11615: LD_INT 31
11617: PPUSH
11618: LD_VAR 0 3
11622: PPUSH
11623: LD_INT 1
11625: PPUSH
11626: CALL_OW 324
// end ; 2 :
11630: GO 15384
11632: LD_INT 2
11634: DOUBLE
11635: EQUAL
11636: IFTRUE 11640
11638: GO 11838
11640: POP
// begin SetTech ( tech_solpow , side , state_enabled ) ;
11641: LD_INT 35
11643: PPUSH
11644: LD_VAR 0 3
11648: PPUSH
11649: LD_INT 1
11651: PPUSH
11652: CALL_OW 322
// SetTech ( tech_soleng , side , state_enabled ) ;
11656: LD_INT 45
11658: PPUSH
11659: LD_VAR 0 3
11663: PPUSH
11664: LD_INT 1
11666: PPUSH
11667: CALL_OW 322
// SetTech ( tech_oilpow , side , state_enabled ) ;
11671: LD_INT 46
11673: PPUSH
11674: LD_VAR 0 3
11678: PPUSH
11679: LD_INT 1
11681: PPUSH
11682: CALL_OW 322
// SetTech ( tech_oileng , side , state_enabled ) ;
11686: LD_INT 47
11688: PPUSH
11689: LD_VAR 0 3
11693: PPUSH
11694: LD_INT 1
11696: PPUSH
11697: CALL_OW 322
// SetTech ( tech_apelang , side , state_enabled ) ;
11701: LD_INT 1
11703: PPUSH
11704: LD_VAR 0 3
11708: PPUSH
11709: LD_INT 1
11711: PPUSH
11712: CALL_OW 322
// SetTech ( tech_apepsych , side , state_enabled ) ;
11716: LD_INT 2
11718: PPUSH
11719: LD_VAR 0 3
11723: PPUSH
11724: LD_INT 1
11726: PPUSH
11727: CALL_OW 322
// SetTech ( tech_apeagres , side , state_enabled ) ;
11731: LD_INT 11
11733: PPUSH
11734: LD_VAR 0 3
11738: PPUSH
11739: LD_INT 1
11741: PPUSH
11742: CALL_OW 322
// SetRestrict ( b_depot , side , true ) ;
11746: LD_INT 0
11748: PPUSH
11749: LD_VAR 0 3
11753: PPUSH
11754: LD_INT 1
11756: PPUSH
11757: CALL_OW 324
// SetRestrict ( b_workshop , side , true ) ;
11761: LD_INT 2
11763: PPUSH
11764: LD_VAR 0 3
11768: PPUSH
11769: LD_INT 1
11771: PPUSH
11772: CALL_OW 324
// SetRestrict ( b_armoury , side , true ) ;
11776: LD_INT 4
11778: PPUSH
11779: LD_VAR 0 3
11783: PPUSH
11784: LD_INT 1
11786: PPUSH
11787: CALL_OW 324
// SetRestrict ( b_lab , side , true ) ;
11791: LD_INT 6
11793: PPUSH
11794: LD_VAR 0 3
11798: PPUSH
11799: LD_INT 1
11801: PPUSH
11802: CALL_OW 324
// SetRestrict ( b_oil_mine , side , true ) ;
11806: LD_INT 29
11808: PPUSH
11809: LD_VAR 0 3
11813: PPUSH
11814: LD_INT 1
11816: PPUSH
11817: CALL_OW 324
// SetRestrict ( b_breastwork , side , true ) ;
11821: LD_INT 31
11823: PPUSH
11824: LD_VAR 0 3
11828: PPUSH
11829: LD_INT 1
11831: PPUSH
11832: CALL_OW 324
// end ; 3 :
11836: GO 15384
11838: LD_INT 3
11840: DOUBLE
11841: EQUAL
11842: IFTRUE 11846
11844: GO 12299
11846: POP
// begin SetTech ( tech_solpow , side , state_enabled ) ;
11847: LD_INT 35
11849: PPUSH
11850: LD_VAR 0 3
11854: PPUSH
11855: LD_INT 1
11857: PPUSH
11858: CALL_OW 322
// SetTech ( tech_soleng , side , state_enabled ) ;
11862: LD_INT 45
11864: PPUSH
11865: LD_VAR 0 3
11869: PPUSH
11870: LD_INT 1
11872: PPUSH
11873: CALL_OW 322
// SetTech ( tech_oilpow , side , state_enabled ) ;
11877: LD_INT 46
11879: PPUSH
11880: LD_VAR 0 3
11884: PPUSH
11885: LD_INT 1
11887: PPUSH
11888: CALL_OW 322
// SetTech ( tech_oileng , side , state_enabled ) ;
11892: LD_INT 47
11894: PPUSH
11895: LD_VAR 0 3
11899: PPUSH
11900: LD_INT 1
11902: PPUSH
11903: CALL_OW 322
// SetTech ( tech_apelang , side , state_enabled ) ;
11907: LD_INT 1
11909: PPUSH
11910: LD_VAR 0 3
11914: PPUSH
11915: LD_INT 1
11917: PPUSH
11918: CALL_OW 322
// SetTech ( tech_apepsych , side , state_enabled ) ;
11922: LD_INT 2
11924: PPUSH
11925: LD_VAR 0 3
11929: PPUSH
11930: LD_INT 1
11932: PPUSH
11933: CALL_OW 322
// SetTech ( tech_apeagres , side , state_enabled ) ;
11937: LD_INT 11
11939: PPUSH
11940: LD_VAR 0 3
11944: PPUSH
11945: LD_INT 1
11947: PPUSH
11948: CALL_OW 322
// SetTech ( tech_tech1 , side , state_enabled ) ;
11952: LD_INT 48
11954: PPUSH
11955: LD_VAR 0 3
11959: PPUSH
11960: LD_INT 1
11962: PPUSH
11963: CALL_OW 322
// SetTech ( tech_gatling , side , state_enabled ) ;
11967: LD_INT 69
11969: PPUSH
11970: LD_VAR 0 3
11974: PPUSH
11975: LD_INT 1
11977: PPUSH
11978: CALL_OW 322
// SetTech ( tech_gun , side , state_enabled ) ;
11982: LD_INT 39
11984: PPUSH
11985: LD_VAR 0 3
11989: PPUSH
11990: LD_INT 1
11992: PPUSH
11993: CALL_OW 322
// SetTech ( tech_selfdest , side , state_enabled ) ;
11997: LD_INT 43
11999: PPUSH
12000: LD_VAR 0 3
12004: PPUSH
12005: LD_INT 1
12007: PPUSH
12008: CALL_OW 322
// SetTech ( tech_weap1 , side , state_enabled ) ;
12012: LD_INT 51
12014: PPUSH
12015: LD_VAR 0 3
12019: PPUSH
12020: LD_INT 1
12022: PPUSH
12023: CALL_OW 322
// SetTech ( tech_radar , side , state_enabled ) ;
12027: LD_INT 6
12029: PPUSH
12030: LD_VAR 0 3
12034: PPUSH
12035: LD_INT 1
12037: PPUSH
12038: CALL_OW 322
// SetRestrict ( b_depot , side , true ) ;
12042: LD_INT 0
12044: PPUSH
12045: LD_VAR 0 3
12049: PPUSH
12050: LD_INT 1
12052: PPUSH
12053: CALL_OW 324
// SetRestrict ( b_workshop , side , true ) ;
12057: LD_INT 2
12059: PPUSH
12060: LD_VAR 0 3
12064: PPUSH
12065: LD_INT 1
12067: PPUSH
12068: CALL_OW 324
// SetRestrict ( b_factory , side , true ) ;
12072: LD_INT 3
12074: PPUSH
12075: LD_VAR 0 3
12079: PPUSH
12080: LD_INT 1
12082: PPUSH
12083: CALL_OW 324
// SetRestrict ( b_armoury , side , true ) ;
12087: LD_INT 4
12089: PPUSH
12090: LD_VAR 0 3
12094: PPUSH
12095: LD_INT 1
12097: PPUSH
12098: CALL_OW 324
// SetRestrict ( b_lab , side , true ) ;
12102: LD_INT 6
12104: PPUSH
12105: LD_VAR 0 3
12109: PPUSH
12110: LD_INT 1
12112: PPUSH
12113: CALL_OW 324
// SetRestrict ( b_lab_half , side , true ) ;
12117: LD_INT 7
12119: PPUSH
12120: LD_VAR 0 3
12124: PPUSH
12125: LD_INT 1
12127: PPUSH
12128: CALL_OW 324
// SetRestrict ( b_lab_full , side , true ) ;
12132: LD_INT 8
12134: PPUSH
12135: LD_VAR 0 3
12139: PPUSH
12140: LD_INT 1
12142: PPUSH
12143: CALL_OW 324
// SetRestrict ( b_lab_weapon , side , true ) ;
12147: LD_INT 10
12149: PPUSH
12150: LD_VAR 0 3
12154: PPUSH
12155: LD_INT 1
12157: PPUSH
12158: CALL_OW 324
// SetRestrict ( b_lab_opto , side , true ) ;
12162: LD_INT 15
12164: PPUSH
12165: LD_VAR 0 3
12169: PPUSH
12170: LD_INT 1
12172: PPUSH
12173: CALL_OW 324
// SetRestrict ( b_ext_track , side , true ) ;
12177: LD_INT 16
12179: PPUSH
12180: LD_VAR 0 3
12184: PPUSH
12185: LD_INT 1
12187: PPUSH
12188: CALL_OW 324
// SetRestrict ( b_ext_gun , side , true ) ;
12192: LD_INT 17
12194: PPUSH
12195: LD_VAR 0 3
12199: PPUSH
12200: LD_INT 1
12202: PPUSH
12203: CALL_OW 324
// SetRestrict ( b_ext_radar , side , true ) ;
12207: LD_INT 20
12209: PPUSH
12210: LD_VAR 0 3
12214: PPUSH
12215: LD_INT 1
12217: PPUSH
12218: CALL_OW 324
// SetRestrict ( b_oil_power , side , true ) ;
12222: LD_INT 26
12224: PPUSH
12225: LD_VAR 0 3
12229: PPUSH
12230: LD_INT 1
12232: PPUSH
12233: CALL_OW 324
// SetRestrict ( b_solar_power , side , true ) ;
12237: LD_INT 27
12239: PPUSH
12240: LD_VAR 0 3
12244: PPUSH
12245: LD_INT 1
12247: PPUSH
12248: CALL_OW 324
// SetRestrict ( b_oil_mine , side , true ) ;
12252: LD_INT 29
12254: PPUSH
12255: LD_VAR 0 3
12259: PPUSH
12260: LD_INT 1
12262: PPUSH
12263: CALL_OW 324
// SetRestrict ( b_breastwork , side , true ) ;
12267: LD_INT 31
12269: PPUSH
12270: LD_VAR 0 3
12274: PPUSH
12275: LD_INT 1
12277: PPUSH
12278: CALL_OW 324
// SetRestrict ( b_bunker , side , true ) ;
12282: LD_INT 32
12284: PPUSH
12285: LD_VAR 0 3
12289: PPUSH
12290: LD_INT 1
12292: PPUSH
12293: CALL_OW 324
// end ; 4 :
12297: GO 15384
12299: LD_INT 4
12301: DOUBLE
12302: EQUAL
12303: IFTRUE 12307
12305: GO 13255
12307: POP
// begin SetTech ( tech_solpow , side , state_enabled ) ;
12308: LD_INT 35
12310: PPUSH
12311: LD_VAR 0 3
12315: PPUSH
12316: LD_INT 1
12318: PPUSH
12319: CALL_OW 322
// SetTech ( tech_soleng , side , state_enabled ) ;
12323: LD_INT 45
12325: PPUSH
12326: LD_VAR 0 3
12330: PPUSH
12331: LD_INT 1
12333: PPUSH
12334: CALL_OW 322
// SetTech ( tech_oilpow , side , state_enabled ) ;
12338: LD_INT 46
12340: PPUSH
12341: LD_VAR 0 3
12345: PPUSH
12346: LD_INT 1
12348: PPUSH
12349: CALL_OW 322
// SetTech ( tech_oileng , side , state_enabled ) ;
12353: LD_INT 47
12355: PPUSH
12356: LD_VAR 0 3
12360: PPUSH
12361: LD_INT 1
12363: PPUSH
12364: CALL_OW 322
// SetTech ( tech_apelang , side , state_enabled ) ;
12368: LD_INT 1
12370: PPUSH
12371: LD_VAR 0 3
12375: PPUSH
12376: LD_INT 1
12378: PPUSH
12379: CALL_OW 322
// SetTech ( tech_apepsych , side , state_enabled ) ;
12383: LD_INT 2
12385: PPUSH
12386: LD_VAR 0 3
12390: PPUSH
12391: LD_INT 1
12393: PPUSH
12394: CALL_OW 322
// SetTech ( tech_apeagres , side , state_enabled ) ;
12398: LD_INT 11
12400: PPUSH
12401: LD_VAR 0 3
12405: PPUSH
12406: LD_INT 1
12408: PPUSH
12409: CALL_OW 322
// SetTech ( tech_sibdet , side , state_enabled ) ;
12413: LD_INT 20
12415: PPUSH
12416: LD_VAR 0 3
12420: PPUSH
12421: LD_INT 1
12423: PPUSH
12424: CALL_OW 322
// SetTech ( tech_tech1 , side , state_enabled ) ;
12428: LD_INT 48
12430: PPUSH
12431: LD_VAR 0 3
12435: PPUSH
12436: LD_INT 1
12438: PPUSH
12439: CALL_OW 322
// SetTech ( tech_tech2 , side , state_enabled ) ;
12443: LD_INT 49
12445: PPUSH
12446: LD_VAR 0 3
12450: PPUSH
12451: LD_INT 1
12453: PPUSH
12454: CALL_OW 322
// SetTech ( tech_gatling , side , state_enabled ) ;
12458: LD_INT 69
12460: PPUSH
12461: LD_VAR 0 3
12465: PPUSH
12466: LD_INT 1
12468: PPUSH
12469: CALL_OW 322
// SetTech ( tech_gun , side , state_enabled ) ;
12473: LD_INT 39
12475: PPUSH
12476: LD_VAR 0 3
12480: PPUSH
12481: LD_INT 1
12483: PPUSH
12484: CALL_OW 322
// SetTech ( tech_advmet , side , state_enabled ) ;
12488: LD_INT 34
12490: PPUSH
12491: LD_VAR 0 3
12495: PPUSH
12496: LD_INT 1
12498: PPUSH
12499: CALL_OW 322
// SetTech ( tech_explos , side , state_enabled ) ;
12503: LD_INT 42
12505: PPUSH
12506: LD_VAR 0 3
12510: PPUSH
12511: LD_INT 1
12513: PPUSH
12514: CALL_OW 322
// SetTech ( tech_bazooka , side , state_enabled ) ;
12518: LD_INT 44
12520: PPUSH
12521: LD_VAR 0 3
12525: PPUSH
12526: LD_INT 1
12528: PPUSH
12529: CALL_OW 322
// SetTech ( tech_mortar , side , state_enabled ) ;
12533: LD_INT 41
12535: PPUSH
12536: LD_VAR 0 3
12540: PPUSH
12541: LD_INT 1
12543: PPUSH
12544: CALL_OW 322
// SetTech ( tech_selfdest , side , state_enabled ) ;
12548: LD_INT 43
12550: PPUSH
12551: LD_VAR 0 3
12555: PPUSH
12556: LD_INT 1
12558: PPUSH
12559: CALL_OW 322
// SetTech ( tech_flame , side , state_enabled ) ;
12563: LD_INT 70
12565: PPUSH
12566: LD_VAR 0 3
12570: PPUSH
12571: LD_INT 1
12573: PPUSH
12574: CALL_OW 322
// SetTech ( tech_weap1 , side , state_enabled ) ;
12578: LD_INT 51
12580: PPUSH
12581: LD_VAR 0 3
12585: PPUSH
12586: LD_INT 1
12588: PPUSH
12589: CALL_OW 322
// SetTech ( tech_weap2 , side , state_enabled ) ;
12593: LD_INT 52
12595: PPUSH
12596: LD_VAR 0 3
12600: PPUSH
12601: LD_INT 1
12603: PPUSH
12604: CALL_OW 322
// SetTech ( tech_radar , side , state_enabled ) ;
12608: LD_INT 6
12610: PPUSH
12611: LD_VAR 0 3
12615: PPUSH
12616: LD_INT 1
12618: PPUSH
12619: CALL_OW 322
// SetTech ( tech_remcont , side , state_enabled ) ;
12623: LD_INT 15
12625: PPUSH
12626: LD_VAR 0 3
12630: PPUSH
12631: LD_INT 1
12633: PPUSH
12634: CALL_OW 322
// SetTech ( tech_matdet , side , state_enabled ) ;
12638: LD_INT 7
12640: PPUSH
12641: LD_VAR 0 3
12645: PPUSH
12646: LD_INT 1
12648: PPUSH
12649: CALL_OW 322
// SetTech ( tech_lassight , side , state_enabled ) ;
12653: LD_INT 12
12655: PPUSH
12656: LD_VAR 0 3
12660: PPUSH
12661: LD_INT 1
12663: PPUSH
12664: CALL_OW 322
// SetTech ( tech_remcharge , side , state_enabled ) ;
12668: LD_INT 18
12670: PPUSH
12671: LD_VAR 0 3
12675: PPUSH
12676: LD_INT 1
12678: PPUSH
12679: CALL_OW 322
// SetTech ( tech_opto1 , side , state_enabled ) ;
12683: LD_INT 60
12685: PPUSH
12686: LD_VAR 0 3
12690: PPUSH
12691: LD_INT 1
12693: PPUSH
12694: CALL_OW 322
// SetTech ( tech_matpred , side , state_enabled ) ;
12698: LD_INT 9
12700: PPUSH
12701: LD_VAR 0 3
12705: PPUSH
12706: LD_INT 1
12708: PPUSH
12709: CALL_OW 322
// SetTech ( tech_taufield , side , state_enabled ) ;
12713: LD_INT 30
12715: PPUSH
12716: LD_VAR 0 3
12720: PPUSH
12721: LD_INT 1
12723: PPUSH
12724: CALL_OW 322
// SetTech ( tech_limteleport , side , state_enabled ) ;
12728: LD_INT 37
12730: PPUSH
12731: LD_VAR 0 3
12735: PPUSH
12736: LD_INT 1
12738: PPUSH
12739: CALL_OW 322
// SetTech ( tech_stimdrugs , side , state_enabled ) ;
12743: LD_INT 5
12745: PPUSH
12746: LD_VAR 0 3
12750: PPUSH
12751: LD_INT 1
12753: PPUSH
12754: CALL_OW 322
// SetTech ( tech_bio1 , side , state_enabled ) ;
12758: LD_INT 66
12760: PPUSH
12761: LD_VAR 0 3
12765: PPUSH
12766: LD_INT 1
12768: PPUSH
12769: CALL_OW 322
// SetTech ( tech_sibpow , side , state_enabled ) ;
12773: LD_INT 21
12775: PPUSH
12776: LD_VAR 0 3
12780: PPUSH
12781: LD_INT 1
12783: PPUSH
12784: CALL_OW 322
// SetTech ( tech_sibeng , side , state_enabled ) ;
12788: LD_INT 22
12790: PPUSH
12791: LD_VAR 0 3
12795: PPUSH
12796: LD_INT 1
12798: PPUSH
12799: CALL_OW 322
// SetTech ( tech_sib1 , side , state_enabled ) ;
12803: LD_INT 54
12805: PPUSH
12806: LD_VAR 0 3
12810: PPUSH
12811: LD_INT 1
12813: PPUSH
12814: CALL_OW 322
// SetRestrict ( b_depot , side , true ) ;
12818: LD_INT 0
12820: PPUSH
12821: LD_VAR 0 3
12825: PPUSH
12826: LD_INT 1
12828: PPUSH
12829: CALL_OW 324
// SetRestrict ( b_warehouse , side , true ) ;
12833: LD_INT 1
12835: PPUSH
12836: LD_VAR 0 3
12840: PPUSH
12841: LD_INT 1
12843: PPUSH
12844: CALL_OW 324
// SetRestrict ( b_workshop , side , true ) ;
12848: LD_INT 2
12850: PPUSH
12851: LD_VAR 0 3
12855: PPUSH
12856: LD_INT 1
12858: PPUSH
12859: CALL_OW 324
// SetRestrict ( b_factory , side , true ) ;
12863: LD_INT 3
12865: PPUSH
12866: LD_VAR 0 3
12870: PPUSH
12871: LD_INT 1
12873: PPUSH
12874: CALL_OW 324
// SetRestrict ( b_armoury , side , true ) ;
12878: LD_INT 4
12880: PPUSH
12881: LD_VAR 0 3
12885: PPUSH
12886: LD_INT 1
12888: PPUSH
12889: CALL_OW 324
// SetRestrict ( b_barracks , side , true ) ;
12893: LD_INT 5
12895: PPUSH
12896: LD_VAR 0 3
12900: PPUSH
12901: LD_INT 1
12903: PPUSH
12904: CALL_OW 324
// SetRestrict ( b_lab , side , true ) ;
12908: LD_INT 6
12910: PPUSH
12911: LD_VAR 0 3
12915: PPUSH
12916: LD_INT 1
12918: PPUSH
12919: CALL_OW 324
// SetRestrict ( b_lab_half , side , true ) ;
12923: LD_INT 7
12925: PPUSH
12926: LD_VAR 0 3
12930: PPUSH
12931: LD_INT 1
12933: PPUSH
12934: CALL_OW 324
// SetRestrict ( b_lab_full , side , true ) ;
12938: LD_INT 8
12940: PPUSH
12941: LD_VAR 0 3
12945: PPUSH
12946: LD_INT 1
12948: PPUSH
12949: CALL_OW 324
// SetRestrict ( b_lab_weapon , side , true ) ;
12953: LD_INT 10
12955: PPUSH
12956: LD_VAR 0 3
12960: PPUSH
12961: LD_INT 1
12963: PPUSH
12964: CALL_OW 324
// SetRestrict ( b_lab_siberium , side , true ) ;
12968: LD_INT 11
12970: PPUSH
12971: LD_VAR 0 3
12975: PPUSH
12976: LD_INT 1
12978: PPUSH
12979: CALL_OW 324
// SetRestrict ( b_lab_computer , side , true ) ;
12983: LD_INT 12
12985: PPUSH
12986: LD_VAR 0 3
12990: PPUSH
12991: LD_INT 1
12993: PPUSH
12994: CALL_OW 324
// SetRestrict ( b_lab_biological , side , true ) ;
12998: LD_INT 13
13000: PPUSH
13001: LD_VAR 0 3
13005: PPUSH
13006: LD_INT 1
13008: PPUSH
13009: CALL_OW 324
// SetRestrict ( b_lab_spacetime , side , true ) ;
13013: LD_INT 14
13015: PPUSH
13016: LD_VAR 0 3
13020: PPUSH
13021: LD_INT 1
13023: PPUSH
13024: CALL_OW 324
// SetRestrict ( b_lab_opto , side , true ) ;
13028: LD_INT 15
13030: PPUSH
13031: LD_VAR 0 3
13035: PPUSH
13036: LD_INT 1
13038: PPUSH
13039: CALL_OW 324
// SetRestrict ( b_ext_track , side , true ) ;
13043: LD_INT 16
13045: PPUSH
13046: LD_VAR 0 3
13050: PPUSH
13051: LD_INT 1
13053: PPUSH
13054: CALL_OW 324
// SetRestrict ( b_ext_gun , side , true ) ;
13058: LD_INT 17
13060: PPUSH
13061: LD_VAR 0 3
13065: PPUSH
13066: LD_INT 1
13068: PPUSH
13069: CALL_OW 324
// SetRestrict ( b_ext_noncombat , side , true ) ;
13073: LD_INT 19
13075: PPUSH
13076: LD_VAR 0 3
13080: PPUSH
13081: LD_INT 1
13083: PPUSH
13084: CALL_OW 324
// SetRestrict ( b_ext_radar , side , true ) ;
13088: LD_INT 20
13090: PPUSH
13091: LD_VAR 0 3
13095: PPUSH
13096: LD_INT 1
13098: PPUSH
13099: CALL_OW 324
// SetRestrict ( b_ext_siberium , side , true ) ;
13103: LD_INT 21
13105: PPUSH
13106: LD_VAR 0 3
13110: PPUSH
13111: LD_INT 1
13113: PPUSH
13114: CALL_OW 324
// SetRestrict ( b_ext_stitch , side , true ) ;
13118: LD_INT 23
13120: PPUSH
13121: LD_VAR 0 3
13125: PPUSH
13126: LD_INT 1
13128: PPUSH
13129: CALL_OW 324
// SetRestrict ( b_oil_power , side , true ) ;
13133: LD_INT 26
13135: PPUSH
13136: LD_VAR 0 3
13140: PPUSH
13141: LD_INT 1
13143: PPUSH
13144: CALL_OW 324
// SetRestrict ( b_solar_power , side , true ) ;
13148: LD_INT 27
13150: PPUSH
13151: LD_VAR 0 3
13155: PPUSH
13156: LD_INT 1
13158: PPUSH
13159: CALL_OW 324
// SetRestrict ( b_siberite_power , side , true ) ;
13163: LD_INT 28
13165: PPUSH
13166: LD_VAR 0 3
13170: PPUSH
13171: LD_INT 1
13173: PPUSH
13174: CALL_OW 324
// SetRestrict ( b_oil_mine , side , true ) ;
13178: LD_INT 29
13180: PPUSH
13181: LD_VAR 0 3
13185: PPUSH
13186: LD_INT 1
13188: PPUSH
13189: CALL_OW 324
// SetRestrict ( b_siberite_mine , side , true ) ;
13193: LD_INT 30
13195: PPUSH
13196: LD_VAR 0 3
13200: PPUSH
13201: LD_INT 1
13203: PPUSH
13204: CALL_OW 324
// SetRestrict ( b_breastwork , side , true ) ;
13208: LD_INT 31
13210: PPUSH
13211: LD_VAR 0 3
13215: PPUSH
13216: LD_INT 1
13218: PPUSH
13219: CALL_OW 324
// SetRestrict ( b_bunker , side , true ) ;
13223: LD_INT 32
13225: PPUSH
13226: LD_VAR 0 3
13230: PPUSH
13231: LD_INT 1
13233: PPUSH
13234: CALL_OW 324
// SetRestrict ( b_control_tower , side , true ) ;
13238: LD_INT 36
13240: PPUSH
13241: LD_VAR 0 3
13245: PPUSH
13246: LD_INT 1
13248: PPUSH
13249: CALL_OW 324
// end ; 5 :
13253: GO 15384
13255: LD_INT 5
13257: DOUBLE
13258: EQUAL
13259: IFTRUE 13263
13261: GO 14376
13263: POP
// begin SetTech ( tech_solpow , side , state_enabled ) ;
13264: LD_INT 35
13266: PPUSH
13267: LD_VAR 0 3
13271: PPUSH
13272: LD_INT 1
13274: PPUSH
13275: CALL_OW 322
// SetTech ( tech_soleng , side , state_enabled ) ;
13279: LD_INT 45
13281: PPUSH
13282: LD_VAR 0 3
13286: PPUSH
13287: LD_INT 1
13289: PPUSH
13290: CALL_OW 322
// SetTech ( tech_oilpow , side , state_enabled ) ;
13294: LD_INT 46
13296: PPUSH
13297: LD_VAR 0 3
13301: PPUSH
13302: LD_INT 1
13304: PPUSH
13305: CALL_OW 322
// SetTech ( tech_oileng , side , state_enabled ) ;
13309: LD_INT 47
13311: PPUSH
13312: LD_VAR 0 3
13316: PPUSH
13317: LD_INT 1
13319: PPUSH
13320: CALL_OW 322
// SetTech ( tech_apelang , side , state_enabled ) ;
13324: LD_INT 1
13326: PPUSH
13327: LD_VAR 0 3
13331: PPUSH
13332: LD_INT 1
13334: PPUSH
13335: CALL_OW 322
// SetTech ( tech_apepsych , side , state_enabled ) ;
13339: LD_INT 2
13341: PPUSH
13342: LD_VAR 0 3
13346: PPUSH
13347: LD_INT 1
13349: PPUSH
13350: CALL_OW 322
// SetTech ( tech_apeagres , side , state_enabled ) ;
13354: LD_INT 11
13356: PPUSH
13357: LD_VAR 0 3
13361: PPUSH
13362: LD_INT 1
13364: PPUSH
13365: CALL_OW 322
// SetTech ( tech_sibdet , side , state_enabled ) ;
13369: LD_INT 20
13371: PPUSH
13372: LD_VAR 0 3
13376: PPUSH
13377: LD_INT 1
13379: PPUSH
13380: CALL_OW 322
// SetTech ( tech_tech1 , side , state_enabled ) ;
13384: LD_INT 48
13386: PPUSH
13387: LD_VAR 0 3
13391: PPUSH
13392: LD_INT 1
13394: PPUSH
13395: CALL_OW 322
// SetTech ( tech_tech2 , side , state_enabled ) ;
13399: LD_INT 49
13401: PPUSH
13402: LD_VAR 0 3
13406: PPUSH
13407: LD_INT 1
13409: PPUSH
13410: CALL_OW 322
// SetTech ( tech_gatling , side , state_enabled ) ;
13414: LD_INT 69
13416: PPUSH
13417: LD_VAR 0 3
13421: PPUSH
13422: LD_INT 1
13424: PPUSH
13425: CALL_OW 322
// SetTech ( tech_gun , side , state_enabled ) ;
13429: LD_INT 39
13431: PPUSH
13432: LD_VAR 0 3
13436: PPUSH
13437: LD_INT 1
13439: PPUSH
13440: CALL_OW 322
// SetTech ( tech_advmet , side , state_enabled ) ;
13444: LD_INT 34
13446: PPUSH
13447: LD_VAR 0 3
13451: PPUSH
13452: LD_INT 1
13454: PPUSH
13455: CALL_OW 322
// SetTech ( tech_explos , side , state_enabled ) ;
13459: LD_INT 42
13461: PPUSH
13462: LD_VAR 0 3
13466: PPUSH
13467: LD_INT 1
13469: PPUSH
13470: CALL_OW 322
// SetTech ( tech_bazooka , side , state_enabled ) ;
13474: LD_INT 44
13476: PPUSH
13477: LD_VAR 0 3
13481: PPUSH
13482: LD_INT 1
13484: PPUSH
13485: CALL_OW 322
// SetTech ( tech_mortar , side , state_enabled ) ;
13489: LD_INT 41
13491: PPUSH
13492: LD_VAR 0 3
13496: PPUSH
13497: LD_INT 1
13499: PPUSH
13500: CALL_OW 322
// SetTech ( tech_rocket , side , state_enabled ) ;
13504: LD_INT 40
13506: PPUSH
13507: LD_VAR 0 3
13511: PPUSH
13512: LD_INT 1
13514: PPUSH
13515: CALL_OW 322
// SetTech ( tech_selfdest , side , state_enabled ) ;
13519: LD_INT 43
13521: PPUSH
13522: LD_VAR 0 3
13526: PPUSH
13527: LD_INT 1
13529: PPUSH
13530: CALL_OW 322
// SetTech ( tech_flame , side , state_enabled ) ;
13534: LD_INT 70
13536: PPUSH
13537: LD_VAR 0 3
13541: PPUSH
13542: LD_INT 1
13544: PPUSH
13545: CALL_OW 322
// SetTech ( tech_weap1 , side , state_enabled ) ;
13549: LD_INT 51
13551: PPUSH
13552: LD_VAR 0 3
13556: PPUSH
13557: LD_INT 1
13559: PPUSH
13560: CALL_OW 322
// SetTech ( tech_weap2 , side , state_enabled ) ;
13564: LD_INT 52
13566: PPUSH
13567: LD_VAR 0 3
13571: PPUSH
13572: LD_INT 1
13574: PPUSH
13575: CALL_OW 322
// SetTech ( tech_radar , side , state_enabled ) ;
13579: LD_INT 6
13581: PPUSH
13582: LD_VAR 0 3
13586: PPUSH
13587: LD_INT 1
13589: PPUSH
13590: CALL_OW 322
// SetTech ( tech_remcont , side , state_enabled ) ;
13594: LD_INT 15
13596: PPUSH
13597: LD_VAR 0 3
13601: PPUSH
13602: LD_INT 1
13604: PPUSH
13605: CALL_OW 322
// SetTech ( tech_matdet , side , state_enabled ) ;
13609: LD_INT 7
13611: PPUSH
13612: LD_VAR 0 3
13616: PPUSH
13617: LD_INT 1
13619: PPUSH
13620: CALL_OW 322
// SetTech ( tech_lassight , side , state_enabled ) ;
13624: LD_INT 12
13626: PPUSH
13627: LD_VAR 0 3
13631: PPUSH
13632: LD_INT 1
13634: PPUSH
13635: CALL_OW 322
// SetTech ( tech_hidcam , side , state_enabled ) ;
13639: LD_INT 17
13641: PPUSH
13642: LD_VAR 0 3
13646: PPUSH
13647: LD_INT 1
13649: PPUSH
13650: CALL_OW 322
// SetTech ( tech_remcharge , side , state_enabled ) ;
13654: LD_INT 18
13656: PPUSH
13657: LD_VAR 0 3
13661: PPUSH
13662: LD_INT 1
13664: PPUSH
13665: CALL_OW 322
// SetTech ( tech_opto1 , side , state_enabled ) ;
13669: LD_INT 60
13671: PPUSH
13672: LD_VAR 0 3
13676: PPUSH
13677: LD_INT 1
13679: PPUSH
13680: CALL_OW 322
// SetTech ( tech_ai , side , state_enabled ) ;
13684: LD_INT 32
13686: PPUSH
13687: LD_VAR 0 3
13691: PPUSH
13692: LD_INT 1
13694: PPUSH
13695: CALL_OW 322
// SetTech ( tech_matpred , side , state_enabled ) ;
13699: LD_INT 9
13701: PPUSH
13702: LD_VAR 0 3
13706: PPUSH
13707: LD_INT 1
13709: PPUSH
13710: CALL_OW 322
// SetTech ( tech_comp1 , side , state_enabled ) ;
13714: LD_INT 57
13716: PPUSH
13717: LD_VAR 0 3
13721: PPUSH
13722: LD_INT 1
13724: PPUSH
13725: CALL_OW 322
// SetTech ( tech_taufield , side , state_enabled ) ;
13729: LD_INT 30
13731: PPUSH
13732: LD_VAR 0 3
13736: PPUSH
13737: LD_INT 1
13739: PPUSH
13740: CALL_OW 322
// SetTech ( tech_limteleport , side , state_enabled ) ;
13744: LD_INT 37
13746: PPUSH
13747: LD_VAR 0 3
13751: PPUSH
13752: LD_INT 1
13754: PPUSH
13755: CALL_OW 322
// SetTech ( tech_st1 , side , state_enabled ) ;
13759: LD_INT 63
13761: PPUSH
13762: LD_VAR 0 3
13766: PPUSH
13767: LD_INT 1
13769: PPUSH
13770: CALL_OW 322
// SetTech ( tech_apeneural , side , state_enabled ) ;
13774: LD_INT 3
13776: PPUSH
13777: LD_VAR 0 3
13781: PPUSH
13782: LD_INT 1
13784: PPUSH
13785: CALL_OW 322
// SetTech ( tech_apebrain , side , state_enabled ) ;
13789: LD_INT 4
13791: PPUSH
13792: LD_VAR 0 3
13796: PPUSH
13797: LD_INT 1
13799: PPUSH
13800: CALL_OW 322
// SetTech ( tech_stimdrugs , side , state_enabled ) ;
13804: LD_INT 5
13806: PPUSH
13807: LD_VAR 0 3
13811: PPUSH
13812: LD_INT 1
13814: PPUSH
13815: CALL_OW 322
// SetTech ( tech_bio1 , side , state_enabled ) ;
13819: LD_INT 66
13821: PPUSH
13822: LD_VAR 0 3
13826: PPUSH
13827: LD_INT 1
13829: PPUSH
13830: CALL_OW 322
// SetTech ( tech_sibpow , side , state_enabled ) ;
13834: LD_INT 21
13836: PPUSH
13837: LD_VAR 0 3
13841: PPUSH
13842: LD_INT 1
13844: PPUSH
13845: CALL_OW 322
// SetTech ( tech_sibeng , side , state_enabled ) ;
13849: LD_INT 22
13851: PPUSH
13852: LD_VAR 0 3
13856: PPUSH
13857: LD_INT 1
13859: PPUSH
13860: CALL_OW 322
// SetTech ( tech_sibloc , side , state_enabled ) ;
13864: LD_INT 19
13866: PPUSH
13867: LD_VAR 0 3
13871: PPUSH
13872: LD_INT 1
13874: PPUSH
13875: CALL_OW 322
// SetTech ( tech_sib1 , side , state_enabled ) ;
13879: LD_INT 54
13881: PPUSH
13882: LD_VAR 0 3
13886: PPUSH
13887: LD_INT 1
13889: PPUSH
13890: CALL_OW 322
// SetTech ( tech_sib2 , side , state_enabled ) ;
13894: LD_INT 55
13896: PPUSH
13897: LD_VAR 0 3
13901: PPUSH
13902: LD_INT 1
13904: PPUSH
13905: CALL_OW 322
// SetRestrict ( b_depot , side , true ) ;
13909: LD_INT 0
13911: PPUSH
13912: LD_VAR 0 3
13916: PPUSH
13917: LD_INT 1
13919: PPUSH
13920: CALL_OW 324
// SetRestrict ( b_warehouse , side , true ) ;
13924: LD_INT 1
13926: PPUSH
13927: LD_VAR 0 3
13931: PPUSH
13932: LD_INT 1
13934: PPUSH
13935: CALL_OW 324
// SetRestrict ( b_workshop , side , true ) ;
13939: LD_INT 2
13941: PPUSH
13942: LD_VAR 0 3
13946: PPUSH
13947: LD_INT 1
13949: PPUSH
13950: CALL_OW 324
// SetRestrict ( b_factory , side , true ) ;
13954: LD_INT 3
13956: PPUSH
13957: LD_VAR 0 3
13961: PPUSH
13962: LD_INT 1
13964: PPUSH
13965: CALL_OW 324
// SetRestrict ( b_armoury , side , true ) ;
13969: LD_INT 4
13971: PPUSH
13972: LD_VAR 0 3
13976: PPUSH
13977: LD_INT 1
13979: PPUSH
13980: CALL_OW 324
// SetRestrict ( b_barracks , side , true ) ;
13984: LD_INT 5
13986: PPUSH
13987: LD_VAR 0 3
13991: PPUSH
13992: LD_INT 1
13994: PPUSH
13995: CALL_OW 324
// SetRestrict ( b_lab , side , true ) ;
13999: LD_INT 6
14001: PPUSH
14002: LD_VAR 0 3
14006: PPUSH
14007: LD_INT 1
14009: PPUSH
14010: CALL_OW 324
// SetRestrict ( b_lab_half , side , true ) ;
14014: LD_INT 7
14016: PPUSH
14017: LD_VAR 0 3
14021: PPUSH
14022: LD_INT 1
14024: PPUSH
14025: CALL_OW 324
// SetRestrict ( b_lab_full , side , true ) ;
14029: LD_INT 8
14031: PPUSH
14032: LD_VAR 0 3
14036: PPUSH
14037: LD_INT 1
14039: PPUSH
14040: CALL_OW 324
// SetRestrict ( b_lab_weapon , side , true ) ;
14044: LD_INT 10
14046: PPUSH
14047: LD_VAR 0 3
14051: PPUSH
14052: LD_INT 1
14054: PPUSH
14055: CALL_OW 324
// SetRestrict ( b_lab_siberium , side , true ) ;
14059: LD_INT 11
14061: PPUSH
14062: LD_VAR 0 3
14066: PPUSH
14067: LD_INT 1
14069: PPUSH
14070: CALL_OW 324
// SetRestrict ( b_lab_computer , side , true ) ;
14074: LD_INT 12
14076: PPUSH
14077: LD_VAR 0 3
14081: PPUSH
14082: LD_INT 1
14084: PPUSH
14085: CALL_OW 324
// SetRestrict ( b_lab_biological , side , true ) ;
14089: LD_INT 13
14091: PPUSH
14092: LD_VAR 0 3
14096: PPUSH
14097: LD_INT 1
14099: PPUSH
14100: CALL_OW 324
// SetRestrict ( b_lab_spacetime , side , true ) ;
14104: LD_INT 14
14106: PPUSH
14107: LD_VAR 0 3
14111: PPUSH
14112: LD_INT 1
14114: PPUSH
14115: CALL_OW 324
// SetRestrict ( b_lab_opto , side , true ) ;
14119: LD_INT 15
14121: PPUSH
14122: LD_VAR 0 3
14126: PPUSH
14127: LD_INT 1
14129: PPUSH
14130: CALL_OW 324
// SetRestrict ( b_ext_track , side , true ) ;
14134: LD_INT 16
14136: PPUSH
14137: LD_VAR 0 3
14141: PPUSH
14142: LD_INT 1
14144: PPUSH
14145: CALL_OW 324
// SetRestrict ( b_ext_gun , side , true ) ;
14149: LD_INT 17
14151: PPUSH
14152: LD_VAR 0 3
14156: PPUSH
14157: LD_INT 1
14159: PPUSH
14160: CALL_OW 324
// SetRestrict ( b_ext_rocket , side , true ) ;
14164: LD_INT 18
14166: PPUSH
14167: LD_VAR 0 3
14171: PPUSH
14172: LD_INT 1
14174: PPUSH
14175: CALL_OW 324
// SetRestrict ( b_ext_noncombat , side , true ) ;
14179: LD_INT 19
14181: PPUSH
14182: LD_VAR 0 3
14186: PPUSH
14187: LD_INT 1
14189: PPUSH
14190: CALL_OW 324
// SetRestrict ( b_ext_radar , side , true ) ;
14194: LD_INT 20
14196: PPUSH
14197: LD_VAR 0 3
14201: PPUSH
14202: LD_INT 1
14204: PPUSH
14205: CALL_OW 324
// SetRestrict ( b_ext_siberium , side , true ) ;
14209: LD_INT 21
14211: PPUSH
14212: LD_VAR 0 3
14216: PPUSH
14217: LD_INT 1
14219: PPUSH
14220: CALL_OW 324
// SetRestrict ( b_ext_stitch , side , true ) ;
14224: LD_INT 23
14226: PPUSH
14227: LD_VAR 0 3
14231: PPUSH
14232: LD_INT 1
14234: PPUSH
14235: CALL_OW 324
// SetRestrict ( b_oil_power , side , true ) ;
14239: LD_INT 26
14241: PPUSH
14242: LD_VAR 0 3
14246: PPUSH
14247: LD_INT 1
14249: PPUSH
14250: CALL_OW 324
// SetRestrict ( b_solar_power , side , true ) ;
14254: LD_INT 27
14256: PPUSH
14257: LD_VAR 0 3
14261: PPUSH
14262: LD_INT 1
14264: PPUSH
14265: CALL_OW 324
// SetRestrict ( b_siberite_power , side , true ) ;
14269: LD_INT 28
14271: PPUSH
14272: LD_VAR 0 3
14276: PPUSH
14277: LD_INT 1
14279: PPUSH
14280: CALL_OW 324
// SetRestrict ( b_oil_mine , side , true ) ;
14284: LD_INT 29
14286: PPUSH
14287: LD_VAR 0 3
14291: PPUSH
14292: LD_INT 1
14294: PPUSH
14295: CALL_OW 324
// SetRestrict ( b_siberite_mine , side , true ) ;
14299: LD_INT 30
14301: PPUSH
14302: LD_VAR 0 3
14306: PPUSH
14307: LD_INT 1
14309: PPUSH
14310: CALL_OW 324
// SetRestrict ( b_breastwork , side , true ) ;
14314: LD_INT 31
14316: PPUSH
14317: LD_VAR 0 3
14321: PPUSH
14322: LD_INT 1
14324: PPUSH
14325: CALL_OW 324
// SetRestrict ( b_bunker , side , true ) ;
14329: LD_INT 32
14331: PPUSH
14332: LD_VAR 0 3
14336: PPUSH
14337: LD_INT 1
14339: PPUSH
14340: CALL_OW 324
// SetRestrict ( b_turret , side , true ) ;
14344: LD_INT 33
14346: PPUSH
14347: LD_VAR 0 3
14351: PPUSH
14352: LD_INT 1
14354: PPUSH
14355: CALL_OW 324
// SetRestrict ( b_control_tower , side , true ) ;
14359: LD_INT 36
14361: PPUSH
14362: LD_VAR 0 3
14366: PPUSH
14367: LD_INT 1
14369: PPUSH
14370: CALL_OW 324
// end ; 6 :
14374: GO 15384
14376: LD_INT 6
14378: DOUBLE
14379: EQUAL
14380: IFTRUE 14384
14382: GO 15309
14384: POP
// begin SetTech ( tech_solpow , side , state_enabled ) ;
14385: LD_INT 35
14387: PPUSH
14388: LD_VAR 0 3
14392: PPUSH
14393: LD_INT 1
14395: PPUSH
14396: CALL_OW 322
// SetTech ( tech_soleng , side , state_enabled ) ;
14400: LD_INT 45
14402: PPUSH
14403: LD_VAR 0 3
14407: PPUSH
14408: LD_INT 1
14410: PPUSH
14411: CALL_OW 322
// SetTech ( tech_oilpow , side , state_enabled ) ;
14415: LD_INT 46
14417: PPUSH
14418: LD_VAR 0 3
14422: PPUSH
14423: LD_INT 1
14425: PPUSH
14426: CALL_OW 322
// SetTech ( tech_oileng , side , state_enabled ) ;
14430: LD_INT 47
14432: PPUSH
14433: LD_VAR 0 3
14437: PPUSH
14438: LD_INT 1
14440: PPUSH
14441: CALL_OW 322
// SetTech ( tech_apelang , side , state_enabled ) ;
14445: LD_INT 1
14447: PPUSH
14448: LD_VAR 0 3
14452: PPUSH
14453: LD_INT 1
14455: PPUSH
14456: CALL_OW 322
// SetTech ( tech_apepsych , side , state_enabled ) ;
14460: LD_INT 2
14462: PPUSH
14463: LD_VAR 0 3
14467: PPUSH
14468: LD_INT 1
14470: PPUSH
14471: CALL_OW 322
// SetTech ( tech_apeagres , side , state_enabled ) ;
14475: LD_INT 11
14477: PPUSH
14478: LD_VAR 0 3
14482: PPUSH
14483: LD_INT 1
14485: PPUSH
14486: CALL_OW 322
// SetTech ( tech_sibdet , side , state_enabled ) ;
14490: LD_INT 20
14492: PPUSH
14493: LD_VAR 0 3
14497: PPUSH
14498: LD_INT 1
14500: PPUSH
14501: CALL_OW 322
// SetTech ( tech_tech1 , side , state_enabled ) ;
14505: LD_INT 48
14507: PPUSH
14508: LD_VAR 0 3
14512: PPUSH
14513: LD_INT 1
14515: PPUSH
14516: CALL_OW 322
// SetTech ( tech_tech2 , side , state_enabled ) ;
14520: LD_INT 49
14522: PPUSH
14523: LD_VAR 0 3
14527: PPUSH
14528: LD_INT 1
14530: PPUSH
14531: CALL_OW 322
// SetTech ( tech_tech3 , side , state_enabled ) ;
14535: LD_INT 50
14537: PPUSH
14538: LD_VAR 0 3
14542: PPUSH
14543: LD_INT 1
14545: PPUSH
14546: CALL_OW 322
// SetTech ( tech_gatling , side , state_enabled ) ;
14550: LD_INT 69
14552: PPUSH
14553: LD_VAR 0 3
14557: PPUSH
14558: LD_INT 1
14560: PPUSH
14561: CALL_OW 322
// SetTech ( tech_gun , side , state_enabled ) ;
14565: LD_INT 39
14567: PPUSH
14568: LD_VAR 0 3
14572: PPUSH
14573: LD_INT 1
14575: PPUSH
14576: CALL_OW 322
// SetTech ( tech_advmet , side , state_enabled ) ;
14580: LD_INT 34
14582: PPUSH
14583: LD_VAR 0 3
14587: PPUSH
14588: LD_INT 1
14590: PPUSH
14591: CALL_OW 322
// SetTech ( tech_explos , side , state_enabled ) ;
14595: LD_INT 42
14597: PPUSH
14598: LD_VAR 0 3
14602: PPUSH
14603: LD_INT 1
14605: PPUSH
14606: CALL_OW 322
// SetTech ( tech_bazooka , side , state_enabled ) ;
14610: LD_INT 44
14612: PPUSH
14613: LD_VAR 0 3
14617: PPUSH
14618: LD_INT 1
14620: PPUSH
14621: CALL_OW 322
// SetTech ( tech_mortar , side , state_enabled ) ;
14625: LD_INT 41
14627: PPUSH
14628: LD_VAR 0 3
14632: PPUSH
14633: LD_INT 1
14635: PPUSH
14636: CALL_OW 322
// SetTech ( tech_soporific , side , state_enabled ) ;
14640: LD_INT 13
14642: PPUSH
14643: LD_VAR 0 3
14647: PPUSH
14648: LD_INT 1
14650: PPUSH
14651: CALL_OW 322
// SetTech ( tech_rocket , side , state_enabled ) ;
14655: LD_INT 40
14657: PPUSH
14658: LD_VAR 0 3
14662: PPUSH
14663: LD_INT 1
14665: PPUSH
14666: CALL_OW 322
// SetTech ( tech_selfdest , side , state_enabled ) ;
14670: LD_INT 43
14672: PPUSH
14673: LD_VAR 0 3
14677: PPUSH
14678: LD_INT 1
14680: PPUSH
14681: CALL_OW 322
// SetTech ( tech_flame , side , state_enabled ) ;
14685: LD_INT 70
14687: PPUSH
14688: LD_VAR 0 3
14692: PPUSH
14693: LD_INT 1
14695: PPUSH
14696: CALL_OW 322
// SetTech ( tech_behemoth , side , state_enabled ) ;
14700: LD_INT 23
14702: PPUSH
14703: LD_VAR 0 3
14707: PPUSH
14708: LD_INT 1
14710: PPUSH
14711: CALL_OW 322
// SetTech ( tech_weap1 , side , state_enabled ) ;
14715: LD_INT 51
14717: PPUSH
14718: LD_VAR 0 3
14722: PPUSH
14723: LD_INT 1
14725: PPUSH
14726: CALL_OW 322
// SetTech ( tech_weap2 , side , state_enabled ) ;
14730: LD_INT 52
14732: PPUSH
14733: LD_VAR 0 3
14737: PPUSH
14738: LD_INT 1
14740: PPUSH
14741: CALL_OW 322
// SetTech ( tech_radar , side , state_enabled ) ;
14745: LD_INT 6
14747: PPUSH
14748: LD_VAR 0 3
14752: PPUSH
14753: LD_INT 1
14755: PPUSH
14756: CALL_OW 322
// SetTech ( tech_remcont , side , state_enabled ) ;
14760: LD_INT 15
14762: PPUSH
14763: LD_VAR 0 3
14767: PPUSH
14768: LD_INT 1
14770: PPUSH
14771: CALL_OW 322
// SetTech ( tech_matdet , side , state_enabled ) ;
14775: LD_INT 7
14777: PPUSH
14778: LD_VAR 0 3
14782: PPUSH
14783: LD_INT 1
14785: PPUSH
14786: CALL_OW 322
// SetTech ( tech_lassight , side , state_enabled ) ;
14790: LD_INT 12
14792: PPUSH
14793: LD_VAR 0 3
14797: PPUSH
14798: LD_INT 1
14800: PPUSH
14801: CALL_OW 322
// SetTech ( tech_laser , side , state_enabled ) ;
14805: LD_INT 10
14807: PPUSH
14808: LD_VAR 0 3
14812: PPUSH
14813: LD_INT 1
14815: PPUSH
14816: CALL_OW 322
// SetTech ( tech_hidcam , side , state_enabled ) ;
14820: LD_INT 17
14822: PPUSH
14823: LD_VAR 0 3
14827: PPUSH
14828: LD_INT 1
14830: PPUSH
14831: CALL_OW 322
// SetTech ( tech_remcharge , side , state_enabled ) ;
14835: LD_INT 18
14837: PPUSH
14838: LD_VAR 0 3
14842: PPUSH
14843: LD_INT 1
14845: PPUSH
14846: CALL_OW 322
// SetTech ( tech_opto1 , side , state_enabled ) ;
14850: LD_INT 60
14852: PPUSH
14853: LD_VAR 0 3
14857: PPUSH
14858: LD_INT 1
14860: PPUSH
14861: CALL_OW 322
// SetTech ( tech_opto2 , side , state_enabled ) ;
14865: LD_INT 61
14867: PPUSH
14868: LD_VAR 0 3
14872: PPUSH
14873: LD_INT 1
14875: PPUSH
14876: CALL_OW 322
// SetTech ( tech_ai , side , state_enabled ) ;
14880: LD_INT 32
14882: PPUSH
14883: LD_VAR 0 3
14887: PPUSH
14888: LD_INT 1
14890: PPUSH
14891: CALL_OW 322
// SetTech ( tech_advai , side , state_enabled ) ;
14895: LD_INT 27
14897: PPUSH
14898: LD_VAR 0 3
14902: PPUSH
14903: LD_INT 1
14905: PPUSH
14906: CALL_OW 322
// SetTech ( tech_advchassis , side , state_enabled ) ;
14910: LD_INT 36
14912: PPUSH
14913: LD_VAR 0 3
14917: PPUSH
14918: LD_INT 1
14920: PPUSH
14921: CALL_OW 322
// SetTech ( tech_virus , side , state_enabled ) ;
14925: LD_INT 33
14927: PPUSH
14928: LD_VAR 0 3
14932: PPUSH
14933: LD_INT 1
14935: PPUSH
14936: CALL_OW 322
// SetTech ( tech_matpred , side , state_enabled ) ;
14940: LD_INT 9
14942: PPUSH
14943: LD_VAR 0 3
14947: PPUSH
14948: LD_INT 1
14950: PPUSH
14951: CALL_OW 322
// SetTech ( tech_targteleport , side , state_enabled ) ;
14955: LD_INT 38
14957: PPUSH
14958: LD_VAR 0 3
14962: PPUSH
14963: LD_INT 1
14965: PPUSH
14966: CALL_OW 322
// SetTech ( tech_comp1 , side , state_enabled ) ;
14970: LD_INT 57
14972: PPUSH
14973: LD_VAR 0 3
14977: PPUSH
14978: LD_INT 1
14980: PPUSH
14981: CALL_OW 322
// SetTech ( tech_comp2 , side , state_enabled ) ;
14985: LD_INT 58
14987: PPUSH
14988: LD_VAR 0 3
14992: PPUSH
14993: LD_INT 1
14995: PPUSH
14996: CALL_OW 322
// SetTech ( tech_taurad , side , state_enabled ) ;
15000: LD_INT 28
15002: PPUSH
15003: LD_VAR 0 3
15007: PPUSH
15008: LD_INT 1
15010: PPUSH
15011: CALL_OW 322
// SetTech ( tech_spacanom , side , state_enabled ) ;
15015: LD_INT 29
15017: PPUSH
15018: LD_VAR 0 3
15022: PPUSH
15023: LD_INT 1
15025: PPUSH
15026: CALL_OW 322
// SetTech ( tech_taufield , side , state_enabled ) ;
15030: LD_INT 30
15032: PPUSH
15033: LD_VAR 0 3
15037: PPUSH
15038: LD_INT 1
15040: PPUSH
15041: CALL_OW 322
// SetTech ( tech_limteleport , side , state_enabled ) ;
15045: LD_INT 37
15047: PPUSH
15048: LD_VAR 0 3
15052: PPUSH
15053: LD_INT 1
15055: PPUSH
15056: CALL_OW 322
// SetTech ( tech_st1 , side , state_enabled ) ;
15060: LD_INT 63
15062: PPUSH
15063: LD_VAR 0 3
15067: PPUSH
15068: LD_INT 1
15070: PPUSH
15071: CALL_OW 322
// SetTech ( tech_st2 , side , state_enabled ) ;
15075: LD_INT 64
15077: PPUSH
15078: LD_VAR 0 3
15082: PPUSH
15083: LD_INT 1
15085: PPUSH
15086: CALL_OW 322
// SetTech ( tech_apeneural , side , state_enabled ) ;
15090: LD_INT 3
15092: PPUSH
15093: LD_VAR 0 3
15097: PPUSH
15098: LD_INT 1
15100: PPUSH
15101: CALL_OW 322
// SetTech ( tech_apebrain , side , state_enabled ) ;
15105: LD_INT 4
15107: PPUSH
15108: LD_VAR 0 3
15112: PPUSH
15113: LD_INT 1
15115: PPUSH
15116: CALL_OW 322
// SetTech ( tech_stimdrugs , side , state_enabled ) ;
15120: LD_INT 5
15122: PPUSH
15123: LD_VAR 0 3
15127: PPUSH
15128: LD_INT 1
15130: PPUSH
15131: CALL_OW 322
// SetTech ( tech_biodet , side , state_enabled ) ;
15135: LD_INT 8
15137: PPUSH
15138: LD_VAR 0 3
15142: PPUSH
15143: LD_INT 1
15145: PPUSH
15146: CALL_OW 322
// SetTech ( tech_bio1 , side , state_enabled ) ;
15150: LD_INT 66
15152: PPUSH
15153: LD_VAR 0 3
15157: PPUSH
15158: LD_INT 1
15160: PPUSH
15161: CALL_OW 322
// SetTech ( tech_bio2 , side , state_enabled ) ;
15165: LD_INT 67
15167: PPUSH
15168: LD_VAR 0 3
15172: PPUSH
15173: LD_INT 1
15175: PPUSH
15176: CALL_OW 322
// SetTech ( tech_sibpow , side , state_enabled ) ;
15180: LD_INT 21
15182: PPUSH
15183: LD_VAR 0 3
15187: PPUSH
15188: LD_INT 1
15190: PPUSH
15191: CALL_OW 322
// SetTech ( tech_sibeng , side , state_enabled ) ;
15195: LD_INT 22
15197: PPUSH
15198: LD_VAR 0 3
15202: PPUSH
15203: LD_INT 1
15205: PPUSH
15206: CALL_OW 322
// SetTech ( tech_sibloc , side , state_enabled ) ;
15210: LD_INT 19
15212: PPUSH
15213: LD_VAR 0 3
15217: PPUSH
15218: LD_INT 1
15220: PPUSH
15221: CALL_OW 322
// SetTech ( tech_sibcontam , side , state_enabled ) ;
15225: LD_INT 26
15227: PPUSH
15228: LD_VAR 0 3
15232: PPUSH
15233: LD_INT 1
15235: PPUSH
15236: CALL_OW 322
// SetTech ( tech_sib1 , side , state_enabled ) ;
15240: LD_INT 54
15242: PPUSH
15243: LD_VAR 0 3
15247: PPUSH
15248: LD_INT 1
15250: PPUSH
15251: CALL_OW 322
// SetTech ( tech_sib2 , side , state_enabled ) ;
15255: LD_INT 55
15257: PPUSH
15258: LD_VAR 0 3
15262: PPUSH
15263: LD_INT 1
15265: PPUSH
15266: CALL_OW 322
// for i = 0 to 39 do
15270: LD_ADDR_VAR 0 4
15274: PUSH
15275: DOUBLE
15276: LD_INT 0
15278: DEC
15279: ST_TO_ADDR
15280: LD_INT 39
15282: PUSH
15283: FOR_TO
15284: IFFALSE 15305
// SetRestrict ( i , side , true ) ;
15286: LD_VAR 0 4
15290: PPUSH
15291: LD_VAR 0 3
15295: PPUSH
15296: LD_INT 1
15298: PPUSH
15299: CALL_OW 324
15303: GO 15283
15305: POP
15306: POP
// end ; else
15307: GO 15384
15309: POP
// begin for i = 1 to 73 do
15310: LD_ADDR_VAR 0 4
15314: PUSH
15315: DOUBLE
15316: LD_INT 1
15318: DEC
15319: ST_TO_ADDR
15320: LD_INT 73
15322: PUSH
15323: FOR_TO
15324: IFFALSE 15345
// SetTech ( i , side , state_enabled ) ;
15326: LD_VAR 0 4
15330: PPUSH
15331: LD_VAR 0 3
15335: PPUSH
15336: LD_INT 1
15338: PPUSH
15339: CALL_OW 322
15343: GO 15323
15345: POP
15346: POP
// for i = 0 to 39 do
15347: LD_ADDR_VAR 0 4
15351: PUSH
15352: DOUBLE
15353: LD_INT 0
15355: DEC
15356: ST_TO_ADDR
15357: LD_INT 39
15359: PUSH
15360: FOR_TO
15361: IFFALSE 15382
// SetRestrict ( i , side , true ) ;
15363: LD_VAR 0 4
15367: PPUSH
15368: LD_VAR 0 3
15372: PPUSH
15373: LD_INT 1
15375: PPUSH
15376: CALL_OW 324
15380: GO 15360
15382: POP
15383: POP
// end ; end ; end ;
15384: GO 11389
15386: POP
15387: POP
// end ;
15388: LD_VAR 0 2
15392: RET
