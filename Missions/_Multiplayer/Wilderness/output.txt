// export gametype ; starting begin if multiplayer then
   0: LD_OWVAR 4
   4: IFFALSE 18
// gametype = mp_game_type else
   6: LD_ADDR_EXP 1
  10: PUSH
  11: LD_OWVAR 6
  15: ST_TO_ADDR
  16: GO 26
// gametype = 25 ;
  18: LD_ADDR_EXP 1
  22: PUSH
  23: LD_INT 25
  25: ST_TO_ADDR
// case gametype of 15 :
  26: LD_EXP 1
  30: PUSH
  31: LD_INT 15
  33: DOUBLE
  34: EQUAL
  35: IFTRUE 39
  37: GO 55
  39: POP
// begin enable ( 15 ) ;
  40: LD_INT 15
  42: ENABLE_MARKED
// disable ( 25 ) ;
  43: LD_INT 25
  45: DISABLE_MARKED
// disable ( 35 ) ;
  46: LD_INT 35
  48: DISABLE_MARKED
// starting_sheherezad ;
  49: CALL 3956 0 0
// end ; 25 :
  53: GO 110
  55: LD_INT 25
  57: DOUBLE
  58: EQUAL
  59: IFTRUE 63
  61: GO 79
  63: POP
// begin enable ( 25 ) ;
  64: LD_INT 25
  66: ENABLE_MARKED
// disable ( 15 ) ;
  67: LD_INT 15
  69: DISABLE_MARKED
// disable ( 35 ) ;
  70: LD_INT 35
  72: DISABLE_MARKED
// starting_vehicles ;
  73: CALL 7333 0 0
// end ; 35 , 36 :
  77: GO 110
  79: LD_INT 35
  81: DOUBLE
  82: EQUAL
  83: IFTRUE 93
  85: LD_INT 36
  87: DOUBLE
  88: EQUAL
  89: IFTRUE 93
  91: GO 109
  93: POP
// begin enable ( 35 ) ;
  94: LD_INT 35
  96: ENABLE_MARKED
// disable ( 15 ) ;
  97: LD_INT 15
  99: DISABLE_MARKED
// disable ( 25 ) ;
 100: LD_INT 25
 102: DISABLE_MARKED
// starting_hunt ;
 103: CALL 12390 0 0
// end ; end ;
 107: GO 110
 109: POP
// end ; end_of_file
 110: END
// export def_sheherezade_speed , def_sheherezade_stamina , def_sheherezade_skills , def_number_of_sheikhs , def_sheikhs_level , def_number_of_soldiers , def_soldiers_level , def_charges_allowed , def_amount_of_apemen , def_apemen_level , def_apemen_abilities , def_number_of_mastodons , def_number_of_tigers , def_time_to_prepare , def_flags ; export shzd_speed , shzd_stamina , shzd_skills , nsh , sh_skills , nsol , sol_skills , nstart_ape , ape_respawning , ape_skills , nmast1 , nmast2 , nmast3 , ntig , tig_respawning , prep_time , flags ; export coordinates , sheherezades , lastunit ; export Side_Count , Team_Count , Player_Side , Player_Team , Side_Teams , Teams ; export Side_Positions , Side_Nations , Side_Names , Team_Names , Team_Game ; function read_multiplayer_and_game_parameters ; var i ; begin
 111: LD_INT 0
 113: PPUSH
 114: PPUSH
// if MultiPlayer then
 115: LD_OWVAR 4
 119: IFFALSE 183
// begin Player_Side = mp_player_side ;
 121: LD_ADDR_EXP 39
 125: PUSH
 126: LD_OWVAR 7
 130: ST_TO_ADDR
// Player_Team = mp_player_team ;
 131: LD_ADDR_EXP 40
 135: PUSH
 136: LD_OWVAR 8
 140: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
 141: LD_ADDR_EXP 43
 145: PUSH
 146: LD_OWVAR 17
 150: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
 151: LD_ADDR_EXP 41
 155: PUSH
 156: LD_OWVAR 15
 160: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
 161: LD_ADDR_EXP 44
 165: PUSH
 166: LD_OWVAR 16
 170: ST_TO_ADDR
// Teams = mp_teams ;
 171: LD_ADDR_EXP 42
 175: PUSH
 176: LD_OWVAR 12
 180: ST_TO_ADDR
// end else
 181: GO 323
// begin Player_Side = 1 ;
 183: LD_ADDR_EXP 39
 187: PUSH
 188: LD_INT 1
 190: ST_TO_ADDR
// Player_Team = 0 ;
 191: LD_ADDR_EXP 40
 195: PUSH
 196: LD_INT 0
 198: ST_TO_ADDR
// Side_Positions = [ 1 , 2 , 3 , 4 , 5 , 0 , 0 , 0 ] ;
 199: LD_ADDR_EXP 43
 203: PUSH
 204: LD_INT 1
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 4
 215: PUSH
 216: LD_INT 5
 218: PUSH
 219: LD_INT 0
 221: PUSH
 222: LD_INT 0
 224: PUSH
 225: LD_INT 0
 227: PUSH
 228: EMPTY
 229: LIST
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 238: LD_ADDR_EXP 41
 242: PUSH
 243: LD_INT 0
 245: PUSH
 246: LD_INT 0
 248: PUSH
 249: LD_INT 0
 251: PUSH
 252: LD_INT 0
 254: PUSH
 255: LD_INT 0
 257: PUSH
 258: LD_INT 0
 260: PUSH
 261: LD_INT 0
 263: PUSH
 264: LD_INT 0
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// Side_Nations = [ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ] ;
 277: LD_ADDR_EXP 44
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 2
 287: PUSH
 288: LD_INT 2
 290: PUSH
 291: LD_INT 2
 293: PUSH
 294: LD_INT 2
 296: PUSH
 297: LD_INT 2
 299: PUSH
 300: LD_INT 2
 302: PUSH
 303: LD_INT 2
 305: PUSH
 306: EMPTY
 307: LIST
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: LIST
 313: LIST
 314: LIST
 315: ST_TO_ADDR
// Teams = [ ] ;
 316: LD_ADDR_EXP 42
 320: PUSH
 321: EMPTY
 322: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
 323: LD_ADDR_EXP 37
 327: PUSH
 328: LD_EXP 43
 332: PUSH
 333: LD_INT 0
 335: PUSH
 336: EMPTY
 337: LIST
 338: DIFF
 339: PUSH
 340: LD_INT 0
 342: PLUS
 343: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
 344: LD_ADDR_EXP 38
 348: PUSH
 349: LD_EXP 41
 353: PUSH
 354: LD_INT 0
 356: PUSH
 357: EMPTY
 358: LIST
 359: DIFF
 360: PUSH
 361: LD_INT 0
 363: PLUS
 364: ST_TO_ADDR
// if MultiPlayer then
 365: LD_OWVAR 4
 369: IFFALSE 568
// begin def_sheherezade_speed = GetMultiplayerSetting ( 0 ) ;
 371: LD_ADDR_EXP 2
 375: PUSH
 376: LD_INT 0
 378: PPUSH
 379: CALL_OW 426
 383: ST_TO_ADDR
// def_sheherezade_stamina = GetMultiplayerSetting ( 1 ) ;
 384: LD_ADDR_EXP 3
 388: PUSH
 389: LD_INT 1
 391: PPUSH
 392: CALL_OW 426
 396: ST_TO_ADDR
// def_sheherezade_skills = GetMultiplayerSetting ( 2 ) ;
 397: LD_ADDR_EXP 4
 401: PUSH
 402: LD_INT 2
 404: PPUSH
 405: CALL_OW 426
 409: ST_TO_ADDR
// def_number_of_sheikhs = GetMultiplayerSetting ( 3 ) ;
 410: LD_ADDR_EXP 5
 414: PUSH
 415: LD_INT 3
 417: PPUSH
 418: CALL_OW 426
 422: ST_TO_ADDR
// def_sheikhs_level = GetMultiplayerSetting ( 4 ) ;
 423: LD_ADDR_EXP 6
 427: PUSH
 428: LD_INT 4
 430: PPUSH
 431: CALL_OW 426
 435: ST_TO_ADDR
// def_number_of_soldiers = GetMultiplayerSetting ( 5 ) ;
 436: LD_ADDR_EXP 7
 440: PUSH
 441: LD_INT 5
 443: PPUSH
 444: CALL_OW 426
 448: ST_TO_ADDR
// def_soldiers_level = GetMultiplayerSetting ( 6 ) ;
 449: LD_ADDR_EXP 8
 453: PUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 426
 461: ST_TO_ADDR
// def_charges_allowed = GetMultiplayerSetting ( 7 ) ;
 462: LD_ADDR_EXP 9
 466: PUSH
 467: LD_INT 7
 469: PPUSH
 470: CALL_OW 426
 474: ST_TO_ADDR
// def_amount_of_apemen = GetMultiplayerSetting ( 8 ) ;
 475: LD_ADDR_EXP 10
 479: PUSH
 480: LD_INT 8
 482: PPUSH
 483: CALL_OW 426
 487: ST_TO_ADDR
// def_apemen_level = GetMultiplayerSetting ( 9 ) ;
 488: LD_ADDR_EXP 11
 492: PUSH
 493: LD_INT 9
 495: PPUSH
 496: CALL_OW 426
 500: ST_TO_ADDR
// def_apemen_abilities = GetMultiplayerSetting ( 10 ) ;
 501: LD_ADDR_EXP 12
 505: PUSH
 506: LD_INT 10
 508: PPUSH
 509: CALL_OW 426
 513: ST_TO_ADDR
// def_number_of_mastodons = GetMultiplayerSetting ( 11 ) ;
 514: LD_ADDR_EXP 13
 518: PUSH
 519: LD_INT 11
 521: PPUSH
 522: CALL_OW 426
 526: ST_TO_ADDR
// def_number_of_tigers = GetMultiplayerSetting ( 12 ) ;
 527: LD_ADDR_EXP 14
 531: PUSH
 532: LD_INT 12
 534: PPUSH
 535: CALL_OW 426
 539: ST_TO_ADDR
// def_time_to_prepare = GetMultiplayerSetting ( 13 ) ;
 540: LD_ADDR_EXP 15
 544: PUSH
 545: LD_INT 13
 547: PPUSH
 548: CALL_OW 426
 552: ST_TO_ADDR
// def_flags = GetMultiplayerSetting ( 14 ) ;
 553: LD_ADDR_EXP 16
 557: PUSH
 558: LD_INT 14
 560: PPUSH
 561: CALL_OW 426
 565: ST_TO_ADDR
// end else
 566: GO 696
// begin randomize ;
 568: CALL_OW 10
// randomizeAll ;
 572: CALL_OW 11
// def_sheherezade_speed = 1 ;
 576: LD_ADDR_EXP 2
 580: PUSH
 581: LD_INT 1
 583: ST_TO_ADDR
// def_sheherezade_stamina = 1 ;
 584: LD_ADDR_EXP 3
 588: PUSH
 589: LD_INT 1
 591: ST_TO_ADDR
// def_sheherezade_skills = 2 ;
 592: LD_ADDR_EXP 4
 596: PUSH
 597: LD_INT 2
 599: ST_TO_ADDR
// def_number_of_sheikhs = 3 ;
 600: LD_ADDR_EXP 5
 604: PUSH
 605: LD_INT 3
 607: ST_TO_ADDR
// def_sheikhs_level = 2 ;
 608: LD_ADDR_EXP 6
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// def_number_of_soldiers = 3 ;
 616: LD_ADDR_EXP 7
 620: PUSH
 621: LD_INT 3
 623: ST_TO_ADDR
// def_soldiers_level = 1 ;
 624: LD_ADDR_EXP 8
 628: PUSH
 629: LD_INT 1
 631: ST_TO_ADDR
// def_charges_allowed = 3 ;
 632: LD_ADDR_EXP 9
 636: PUSH
 637: LD_INT 3
 639: ST_TO_ADDR
// def_amount_of_apemen = 2 ;
 640: LD_ADDR_EXP 10
 644: PUSH
 645: LD_INT 2
 647: ST_TO_ADDR
// def_apemen_level = 1 ;
 648: LD_ADDR_EXP 11
 652: PUSH
 653: LD_INT 1
 655: ST_TO_ADDR
// def_apemen_abilities = 1 ;
 656: LD_ADDR_EXP 12
 660: PUSH
 661: LD_INT 1
 663: ST_TO_ADDR
// def_number_of_mastodons = 2 ;
 664: LD_ADDR_EXP 13
 668: PUSH
 669: LD_INT 2
 671: ST_TO_ADDR
// def_number_of_tigers = 2 ;
 672: LD_ADDR_EXP 14
 676: PUSH
 677: LD_INT 2
 679: ST_TO_ADDR
// def_time_to_prepare = 2 ;
 680: LD_ADDR_EXP 15
 684: PUSH
 685: LD_INT 2
 687: ST_TO_ADDR
// def_flags = 2 ;
 688: LD_ADDR_EXP 16
 692: PUSH
 693: LD_INT 2
 695: ST_TO_ADDR
// end ; shzd_speed = [ 9 , 12 , 15 ] [ def_sheherezade_speed + 1 ] ;
 696: LD_ADDR_EXP 17
 700: PUSH
 701: LD_INT 9
 703: PUSH
 704: LD_INT 12
 706: PUSH
 707: LD_INT 15
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_EXP 2
 719: PUSH
 720: LD_INT 1
 722: PLUS
 723: ARRAY
 724: ST_TO_ADDR
// shzd_stamina = [ 6 , 10 , 15 ] [ def_sheherezade_stamina + 1 ] ;
 725: LD_ADDR_EXP 18
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 10
 735: PUSH
 736: LD_INT 15
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: PUSH
 744: LD_EXP 3
 748: PUSH
 749: LD_INT 1
 751: PLUS
 752: ARRAY
 753: ST_TO_ADDR
// shzd_skills = [ [ 1 , 0 , 0 , 3 ] , [ 2 , 0 , 0 , 5 ] , [ 3 , 0 , 0 , 7 ] ] [ def_sheherezade_skills + 1 ] ;
 754: LD_ADDR_EXP 19
 758: PUSH
 759: LD_INT 1
 761: PUSH
 762: LD_INT 0
 764: PUSH
 765: LD_INT 0
 767: PUSH
 768: LD_INT 3
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 2
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: LD_INT 5
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 0
 800: PUSH
 801: LD_INT 0
 803: PUSH
 804: LD_INT 7
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: LIST
 817: PUSH
 818: LD_EXP 4
 822: PUSH
 823: LD_INT 1
 825: PLUS
 826: ARRAY
 827: ST_TO_ADDR
// nsh = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_sheikhs + 1 ] ;
 828: LD_ADDR_EXP 20
 832: PUSH
 833: LD_INT 0
 835: PUSH
 836: LD_INT 1
 838: PUSH
 839: LD_INT 2
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 4
 847: PUSH
 848: LD_INT 5
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PUSH
 859: LD_EXP 5
 863: PUSH
 864: LD_INT 1
 866: PLUS
 867: ARRAY
 868: ST_TO_ADDR
// sh_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_sheikhs_level + 1 ] ;
 869: LD_ADDR_EXP 21
 873: PUSH
 874: LD_INT 2
 876: PUSH
 877: LD_INT 1
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 1
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: PUSH
 892: LD_INT 4
 894: PUSH
 895: LD_INT 2
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 2
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: PUSH
 910: LD_INT 6
 912: PUSH
 913: LD_INT 3
 915: PUSH
 916: LD_INT 3
 918: PUSH
 919: LD_INT 3
 921: PUSH
 922: EMPTY
 923: LIST
 924: LIST
 925: LIST
 926: LIST
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: LD_EXP 6
 937: PUSH
 938: LD_INT 1
 940: PLUS
 941: ARRAY
 942: ST_TO_ADDR
// nsol = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_soldiers + 1 ] ;
 943: LD_ADDR_EXP 22
 947: PUSH
 948: LD_INT 0
 950: PUSH
 951: LD_INT 1
 953: PUSH
 954: LD_INT 2
 956: PUSH
 957: LD_INT 3
 959: PUSH
 960: LD_INT 4
 962: PUSH
 963: LD_INT 5
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: LIST
 973: PUSH
 974: LD_EXP 7
 978: PUSH
 979: LD_INT 1
 981: PLUS
 982: ARRAY
 983: ST_TO_ADDR
// sol_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_soldiers_level + 1 ] ;
 984: LD_ADDR_EXP 23
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: LD_INT 1
 994: PUSH
 995: LD_INT 1
 997: PUSH
 998: LD_INT 1
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: LIST
1005: LIST
1006: PUSH
1007: LD_INT 4
1009: PUSH
1010: LD_INT 2
1012: PUSH
1013: LD_INT 2
1015: PUSH
1016: LD_INT 2
1018: PUSH
1019: EMPTY
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: PUSH
1025: LD_INT 6
1027: PUSH
1028: LD_INT 3
1030: PUSH
1031: LD_INT 3
1033: PUSH
1034: LD_INT 3
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PUSH
1043: EMPTY
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: LD_EXP 8
1052: PUSH
1053: LD_INT 1
1055: PLUS
1056: ARRAY
1057: ST_TO_ADDR
// nstart_ape = [ 0 , 2 , 4 , 6 , 8 ] [ def_amount_of_apemen + 1 ] ;
1058: LD_ADDR_EXP 24
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 4
1071: PUSH
1072: LD_INT 6
1074: PUSH
1075: LD_INT 8
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PUSH
1085: LD_EXP 10
1089: PUSH
1090: LD_INT 1
1092: PLUS
1093: ARRAY
1094: ST_TO_ADDR
// ape_respawning = [ 0 , 4 4$00 , 2 2$00 , 1 1$00 , 0 0$30 ] [ def_amount_of_apemen + 1 ] ;
1095: LD_ADDR_EXP 25
1099: PUSH
1100: LD_INT 0
1102: PUSH
1103: LD_INT 8400
1105: PUSH
1106: LD_INT 4200
1108: PUSH
1109: LD_INT 2100
1111: PUSH
1112: LD_INT 1050
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_EXP 10
1126: PUSH
1127: LD_INT 1
1129: PLUS
1130: ARRAY
1131: ST_TO_ADDR
// ape_skills = [ [ 1 , 0 , 0 , 0 ] , [ 3 , 0 , 0 , 0 ] , [ 5 , 0 , 0 , 0 ] ] [ def_apemen_level + 1 ] ;
1132: LD_ADDR_EXP 26
1136: PUSH
1137: LD_INT 1
1139: PUSH
1140: LD_INT 0
1142: PUSH
1143: LD_INT 0
1145: PUSH
1146: LD_INT 0
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 0
1160: PUSH
1161: LD_INT 0
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 0
1178: PUSH
1179: LD_INT 0
1181: PUSH
1182: LD_INT 0
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: LIST
1195: PUSH
1196: LD_EXP 11
1200: PUSH
1201: LD_INT 1
1203: PLUS
1204: ARRAY
1205: ST_TO_ADDR
// nmast1 = [ 0 , 2 , 4 , 6 ] [ def_number_of_mastodons + 1 ] ;
1206: LD_ADDR_EXP 27
1210: PUSH
1211: LD_INT 0
1213: PUSH
1214: LD_INT 2
1216: PUSH
1217: LD_INT 4
1219: PUSH
1220: LD_INT 6
1222: PUSH
1223: EMPTY
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: PUSH
1229: LD_EXP 13
1233: PUSH
1234: LD_INT 1
1236: PLUS
1237: ARRAY
1238: ST_TO_ADDR
// nmast2 = [ 0 , 1 , 2 , 3 ] [ def_number_of_mastodons + 1 ] ;
1239: LD_ADDR_EXP 28
1243: PUSH
1244: LD_INT 0
1246: PUSH
1247: LD_INT 1
1249: PUSH
1250: LD_INT 2
1252: PUSH
1253: LD_INT 3
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: PUSH
1262: LD_EXP 13
1266: PUSH
1267: LD_INT 1
1269: PLUS
1270: ARRAY
1271: ST_TO_ADDR
// nmast3 = [ 0 , 15 , 30 , 45 ] [ def_number_of_mastodons + 1 ] ;
1272: LD_ADDR_EXP 29
1276: PUSH
1277: LD_INT 0
1279: PUSH
1280: LD_INT 15
1282: PUSH
1283: LD_INT 30
1285: PUSH
1286: LD_INT 45
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_EXP 13
1299: PUSH
1300: LD_INT 1
1302: PLUS
1303: ARRAY
1304: ST_TO_ADDR
// ntig = [ 0 , 1 , 3 , 5 ] [ def_number_of_tigers + 1 ] ;
1305: LD_ADDR_EXP 30
1309: PUSH
1310: LD_INT 0
1312: PUSH
1313: LD_INT 1
1315: PUSH
1316: LD_INT 3
1318: PUSH
1319: LD_INT 5
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: PUSH
1328: LD_EXP 14
1332: PUSH
1333: LD_INT 1
1335: PLUS
1336: ARRAY
1337: ST_TO_ADDR
// tig_respawning = [ 0 , 8 8$00 , 4 4$00 , 2 2$00 ] [ def_number_of_tigers + 1 ] ;
1338: LD_ADDR_EXP 31
1342: PUSH
1343: LD_INT 0
1345: PUSH
1346: LD_INT 16800
1348: PUSH
1349: LD_INT 8400
1351: PUSH
1352: LD_INT 4200
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: PUSH
1361: LD_EXP 14
1365: PUSH
1366: LD_INT 1
1368: PLUS
1369: ARRAY
1370: ST_TO_ADDR
// prep_time = [ 0 , 0 0$20 , 0 0$40 , 1 1$20 ] [ def_time_to_prepare + 1 ] ;
1371: LD_ADDR_EXP 32
1375: PUSH
1376: LD_INT 0
1378: PUSH
1379: LD_INT 700
1381: PUSH
1382: LD_INT 1400
1384: PUSH
1385: LD_INT 2800
1387: PUSH
1388: EMPTY
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: PUSH
1394: LD_EXP 15
1398: PUSH
1399: LD_INT 1
1401: PLUS
1402: ARRAY
1403: ST_TO_ADDR
// flags = [ 0 , 25 , 50 , 75 ] [ def_flags + 1 ] ;
1404: LD_ADDR_EXP 33
1408: PUSH
1409: LD_INT 0
1411: PUSH
1412: LD_INT 25
1414: PUSH
1415: LD_INT 50
1417: PUSH
1418: LD_INT 75
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: PUSH
1427: LD_EXP 16
1431: PUSH
1432: LD_INT 1
1434: PLUS
1435: ARRAY
1436: ST_TO_ADDR
// if def_charges_allowed in [ 1 , 3 ] then
1437: LD_EXP 9
1441: PUSH
1442: LD_INT 1
1444: PUSH
1445: LD_INT 3
1447: PUSH
1448: EMPTY
1449: LIST
1450: LIST
1451: IN
1452: IFFALSE 1489
// for i := 1 to 8 do
1454: LD_ADDR_VAR 0 2
1458: PUSH
1459: DOUBLE
1460: LD_INT 1
1462: DEC
1463: ST_TO_ADDR
1464: LD_INT 8
1466: PUSH
1467: FOR_TO
1468: IFFALSE 1487
// SetTech ( tech_RemCharge , i , state_researched ) ;
1470: LD_INT 18
1472: PPUSH
1473: LD_VAR 0 2
1477: PPUSH
1478: LD_INT 2
1480: PPUSH
1481: CALL_OW 322
1485: GO 1467
1487: POP
1488: POP
// if def_charges_allowed in [ 1 , 3 ] then
1489: LD_EXP 9
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 3
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: IN
1504: IFFALSE 1541
// for i := 1 to 8 do
1506: LD_ADDR_VAR 0 2
1510: PUSH
1511: DOUBLE
1512: LD_INT 1
1514: DEC
1515: ST_TO_ADDR
1516: LD_INT 8
1518: PUSH
1519: FOR_TO
1520: IFFALSE 1539
// SetTech ( tech_Explos , i , state_researched ) ;
1522: LD_INT 42
1524: PPUSH
1525: LD_VAR 0 2
1529: PPUSH
1530: LD_INT 2
1532: PPUSH
1533: CALL_OW 322
1537: GO 1519
1539: POP
1540: POP
// for i := 1 to 8 do
1541: LD_ADDR_VAR 0 2
1545: PUSH
1546: DOUBLE
1547: LD_INT 1
1549: DEC
1550: ST_TO_ADDR
1551: LD_INT 8
1553: PUSH
1554: FOR_TO
1555: IFFALSE 1589
// begin SetTech ( tech_ApeLang , i , state_disabled ) ;
1557: LD_INT 1
1559: PPUSH
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 0
1567: PPUSH
1568: CALL_OW 322
// SetTech ( tech_SibContam , i , state_disabled ) ;
1572: LD_INT 26
1574: PPUSH
1575: LD_VAR 0 2
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL_OW 322
// end ;
1587: GO 1554
1589: POP
1590: POP
// end ;
1591: LD_VAR 0 1
1595: RET
// function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
1596: LD_INT 0
1598: PPUSH
1599: PPUSH
1600: PPUSH
1601: PPUSH
1602: PPUSH
1603: PPUSH
1604: PPUSH
1605: PPUSH
// best = 0 ;
1606: LD_ADDR_VAR 0 2
1610: PUSH
1611: LD_INT 0
1613: ST_TO_ADDR
// for n = 1 to 400 do
1614: LD_ADDR_VAR 0 8
1618: PUSH
1619: DOUBLE
1620: LD_INT 1
1622: DEC
1623: ST_TO_ADDR
1624: LD_INT 400
1626: PUSH
1627: FOR_TO
1628: IFFALSE 1924
// begin c = [ ] ;
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: EMPTY
1636: ST_TO_ADDR
// for i = 1 to side_count do
1637: LD_ADDR_VAR 0 6
1641: PUSH
1642: DOUBLE
1643: LD_INT 1
1645: DEC
1646: ST_TO_ADDR
1647: LD_EXP 37
1651: PUSH
1652: FOR_TO
1653: IFFALSE 1682
// c := c ^ [ RandHexArea ( arstart , false ) ] ;
1655: LD_ADDR_VAR 0 3
1659: PUSH
1660: LD_VAR 0 3
1664: PUSH
1665: LD_INT 4
1667: PPUSH
1668: LD_INT 0
1670: PPUSH
1671: CALL_OW 16
1675: PUSH
1676: EMPTY
1677: LIST
1678: ADD
1679: ST_TO_ADDR
1680: GO 1652
1682: POP
1683: POP
// minv = 10000 ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_INT 10000
1691: ST_TO_ADDR
// for i = 1 to side_count do
1692: LD_ADDR_VAR 0 6
1696: PUSH
1697: DOUBLE
1698: LD_INT 1
1700: DEC
1701: ST_TO_ADDR
1702: LD_EXP 37
1706: PUSH
1707: FOR_TO
1708: IFFALSE 1888
// for j = 1 to side_count do
1710: LD_ADDR_VAR 0 7
1714: PUSH
1715: DOUBLE
1716: LD_INT 1
1718: DEC
1719: ST_TO_ADDR
1720: LD_EXP 37
1724: PUSH
1725: FOR_TO
1726: IFFALSE 1884
// if i <> j then
1728: LD_VAR 0 6
1732: PUSH
1733: LD_VAR 0 7
1737: NONEQUAL
1738: IFFALSE 1882
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
1740: LD_VAR 0 3
1744: PUSH
1745: LD_VAR 0 6
1749: ARRAY
1750: PUSH
1751: LD_INT 1
1753: ARRAY
1754: PPUSH
1755: LD_VAR 0 3
1759: PUSH
1760: LD_VAR 0 6
1764: ARRAY
1765: PUSH
1766: LD_INT 2
1768: ARRAY
1769: PPUSH
1770: LD_VAR 0 3
1774: PUSH
1775: LD_VAR 0 7
1779: ARRAY
1780: PUSH
1781: LD_INT 1
1783: ARRAY
1784: PPUSH
1785: LD_VAR 0 3
1789: PUSH
1790: LD_VAR 0 7
1794: ARRAY
1795: PUSH
1796: LD_INT 2
1798: ARRAY
1799: PPUSH
1800: CALL_OW 298
1804: PUSH
1805: LD_VAR 0 5
1809: LESS
1810: IFFALSE 1882
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
1812: LD_ADDR_VAR 0 5
1816: PUSH
1817: LD_VAR 0 3
1821: PUSH
1822: LD_VAR 0 6
1826: ARRAY
1827: PUSH
1828: LD_INT 1
1830: ARRAY
1831: PPUSH
1832: LD_VAR 0 3
1836: PUSH
1837: LD_VAR 0 6
1841: ARRAY
1842: PUSH
1843: LD_INT 2
1845: ARRAY
1846: PPUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_VAR 0 7
1856: ARRAY
1857: PUSH
1858: LD_INT 1
1860: ARRAY
1861: PPUSH
1862: LD_VAR 0 3
1866: PUSH
1867: LD_VAR 0 7
1871: ARRAY
1872: PUSH
1873: LD_INT 2
1875: ARRAY
1876: PPUSH
1877: CALL_OW 298
1881: ST_TO_ADDR
// end ;
1882: GO 1725
1884: POP
1885: POP
1886: GO 1707
1888: POP
1889: POP
// if minv > best then
1890: LD_VAR 0 5
1894: PUSH
1895: LD_VAR 0 2
1899: GREATER
1900: IFFALSE 1922
// begin best := minv ;
1902: LD_ADDR_VAR 0 2
1906: PUSH
1907: LD_VAR 0 5
1911: ST_TO_ADDR
// bestc := c ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 3
1921: ST_TO_ADDR
// end ; end ;
1922: GO 1627
1924: POP
1925: POP
// coordinates := [ ] ;
1926: LD_ADDR_EXP 34
1930: PUSH
1931: EMPTY
1932: ST_TO_ADDR
// for i = 1 to 8 do
1933: LD_ADDR_VAR 0 6
1937: PUSH
1938: DOUBLE
1939: LD_INT 1
1941: DEC
1942: ST_TO_ADDR
1943: LD_INT 8
1945: PUSH
1946: FOR_TO
1947: IFFALSE 2034
// if side_positions [ i ] = 0 then
1949: LD_EXP 43
1953: PUSH
1954: LD_VAR 0 6
1958: ARRAY
1959: PUSH
1960: LD_INT 0
1962: EQUAL
1963: IFFALSE 1991
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
1965: LD_ADDR_EXP 34
1969: PUSH
1970: LD_EXP 34
1974: PUSH
1975: LD_INT 0
1977: PUSH
1978: LD_INT 0
1980: PUSH
1981: EMPTY
1982: LIST
1983: LIST
1984: PUSH
1985: EMPTY
1986: LIST
1987: ADD
1988: ST_TO_ADDR
1989: GO 2032
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
1991: LD_ADDR_EXP 34
1995: PUSH
1996: LD_EXP 34
2000: PUSH
2001: LD_VAR 0 4
2005: PUSH
2006: LD_INT 1
2008: ARRAY
2009: PUSH
2010: EMPTY
2011: LIST
2012: ADD
2013: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
2014: LD_ADDR_VAR 0 4
2018: PUSH
2019: LD_VAR 0 4
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: CALL_OW 3
2031: ST_TO_ADDR
// end ;
2032: GO 1946
2034: POP
2035: POP
// end ;
2036: LD_VAR 0 1
2040: RET
// function set_attitudes ; var i , j ; begin
2041: LD_INT 0
2043: PPUSH
2044: PPUSH
2045: PPUSH
// if not Team_Game then
2046: LD_EXP 47
2050: NOT
2051: IFFALSE 2147
// begin for i = 1 to 8 do
2053: LD_ADDR_VAR 0 2
2057: PUSH
2058: DOUBLE
2059: LD_INT 1
2061: DEC
2062: ST_TO_ADDR
2063: LD_INT 8
2065: PUSH
2066: FOR_TO
2067: IFFALSE 2145
// for j = 1 to 8 do
2069: LD_ADDR_VAR 0 3
2073: PUSH
2074: DOUBLE
2075: LD_INT 1
2077: DEC
2078: ST_TO_ADDR
2079: LD_INT 8
2081: PUSH
2082: FOR_TO
2083: IFFALSE 2141
// if i <> j then
2085: LD_VAR 0 2
2089: PUSH
2090: LD_VAR 0 3
2094: NONEQUAL
2095: IFFALSE 2119
// SetAttitude ( i , j , att_neutral , true ) else
2097: LD_VAR 0 2
2101: PPUSH
2102: LD_VAR 0 3
2106: PPUSH
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: CALL_OW 80
2117: GO 2139
// SetAttitude ( i , j , att_friend , true ) end ;
2119: LD_VAR 0 2
2123: PPUSH
2124: LD_VAR 0 3
2128: PPUSH
2129: LD_INT 1
2131: PPUSH
2132: LD_INT 1
2134: PPUSH
2135: CALL_OW 80
2139: GO 2082
2141: POP
2142: POP
2143: GO 2066
2145: POP
2146: POP
// end ;
2147: LD_VAR 0 1
2151: RET
// function create_sheherezade ( side ) ; var s ; begin
2152: LD_INT 0
2154: PPUSH
2155: PPUSH
// uc_side := side ;
2156: LD_ADDR_OWVAR 20
2160: PUSH
2161: LD_VAR 0 1
2165: ST_TO_ADDR
// uc_nation := nation_arabian ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 2
2173: ST_TO_ADDR
// hc_name = Sheherezade ;
2174: LD_ADDR_OWVAR 26
2178: PUSH
2179: LD_STRING Sheherezade
2181: ST_TO_ADDR
// hc_sex = sex_female ;
2182: LD_ADDR_OWVAR 27
2186: PUSH
2187: LD_INT 2
2189: ST_TO_ADDR
// hc_class = class_scientistic ;
2190: LD_ADDR_OWVAR 28
2194: PUSH
2195: LD_INT 4
2197: ST_TO_ADDR
// hc_basic_skills = shzd_skills ;
2198: LD_ADDR_OWVAR 30
2202: PUSH
2203: LD_EXP 19
2207: ST_TO_ADDR
// hc_skills = shzd_skills ;
2208: LD_ADDR_OWVAR 31
2212: PUSH
2213: LD_EXP 19
2217: ST_TO_ADDR
// hc_attr = [ shzd_stamina , shzd_speed ] ;
2218: LD_ADDR_OWVAR 29
2222: PUSH
2223: LD_EXP 18
2227: PUSH
2228: LD_EXP 17
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: ST_TO_ADDR
// hc_gallery = multi ;
2237: LD_ADDR_OWVAR 33
2241: PUSH
2242: LD_STRING multi
2244: ST_TO_ADDR
// hc_face_number = 18 ;
2245: LD_ADDR_OWVAR 34
2249: PUSH
2250: LD_INT 18
2252: ST_TO_ADDR
// hc_importance = 105 ;
2253: LD_ADDR_OWVAR 32
2257: PUSH
2258: LD_INT 105
2260: ST_TO_ADDR
// s = CreateHuman ;
2261: LD_ADDR_VAR 0 3
2265: PUSH
2266: CALL_OW 44
2270: ST_TO_ADDR
// PlaceUnitXYR ( s , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 1 , false ) ;
2271: LD_VAR 0 3
2275: PPUSH
2276: LD_EXP 34
2280: PUSH
2281: LD_VAR 0 1
2285: ARRAY
2286: PUSH
2287: LD_INT 1
2289: ARRAY
2290: PPUSH
2291: LD_EXP 34
2295: PUSH
2296: LD_VAR 0 1
2300: ARRAY
2301: PUSH
2302: LD_INT 2
2304: ARRAY
2305: PPUSH
2306: LD_INT 1
2308: PPUSH
2309: LD_INT 0
2311: PPUSH
2312: CALL_OW 50
// sheherezades = Replace ( sheherezades , side , s ) ;
2316: LD_ADDR_EXP 35
2320: PUSH
2321: LD_EXP 35
2325: PPUSH
2326: LD_VAR 0 1
2330: PPUSH
2331: LD_VAR 0 3
2335: PPUSH
2336: CALL_OW 1
2340: ST_TO_ADDR
// end ;
2341: LD_VAR 0 2
2345: RET
// function prepare_sides ; var i ; begin
2346: LD_INT 0
2348: PPUSH
2349: PPUSH
// for i := 1 to 8 do
2350: LD_ADDR_VAR 0 2
2354: PUSH
2355: DOUBLE
2356: LD_INT 1
2358: DEC
2359: ST_TO_ADDR
2360: LD_INT 8
2362: PUSH
2363: FOR_TO
2364: IFFALSE 2389
// if side_positions [ i ] then
2366: LD_EXP 43
2370: PUSH
2371: LD_VAR 0 2
2375: ARRAY
2376: IFFALSE 2387
// create_sheherezade ( i ) ;
2378: LD_VAR 0 2
2382: PPUSH
2383: CALL 2152 0 1
2387: GO 2363
2389: POP
2390: POP
// if prep_time = 0 then
2391: LD_EXP 32
2395: PUSH
2396: LD_INT 0
2398: EQUAL
2399: IFFALSE 2405
// sheherezade_start_the_fight ;
2401: CALL 3720 0 0
// end ;
2405: LD_VAR 0 1
2409: RET
// function prepare_side_to_the_fight ( side , materialization ) ; var x , y , i , sh , sol ; begin
2410: LD_INT 0
2412: PPUSH
2413: PPUSH
2414: PPUSH
2415: PPUSH
2416: PPUSH
2417: PPUSH
// SetTech ( tech_ApeLang , side , state_researched ) ;
2418: LD_INT 1
2420: PPUSH
2421: LD_VAR 0 1
2425: PPUSH
2426: LD_INT 2
2428: PPUSH
2429: CALL_OW 322
// x := GetX ( Sheherezades [ side ] ) ;
2433: LD_ADDR_VAR 0 4
2437: PUSH
2438: LD_EXP 35
2442: PUSH
2443: LD_VAR 0 1
2447: ARRAY
2448: PPUSH
2449: CALL_OW 250
2453: ST_TO_ADDR
// y := GetY ( Sheherezades [ side ] ) ;
2454: LD_ADDR_VAR 0 5
2458: PUSH
2459: LD_EXP 35
2463: PUSH
2464: LD_VAR 0 1
2468: ARRAY
2469: PPUSH
2470: CALL_OW 251
2474: ST_TO_ADDR
// coordinates := Replace ( coordinates , side , [ x , y ] ) ;
2475: LD_ADDR_EXP 34
2479: PUSH
2480: LD_EXP 34
2484: PPUSH
2485: LD_VAR 0 1
2489: PPUSH
2490: LD_VAR 0 4
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PPUSH
2504: CALL_OW 1
2508: ST_TO_ADDR
// if flags then
2509: LD_EXP 33
2513: IFFALSE 2592
// begin SetBattleFlag ( side , x , y , [ [ bfo_defend_bonus_human , flags ] , [ bfo_defend_bonus_vehicle , flags ] , [ bfo_defend_bonus_building , flags ] , [ bfo_height , flags + 25 ] ] ) ;
2515: LD_VAR 0 1
2519: PPUSH
2520: LD_VAR 0 4
2524: PPUSH
2525: LD_VAR 0 5
2529: PPUSH
2530: LD_INT 1
2532: PUSH
2533: LD_EXP 33
2537: PUSH
2538: EMPTY
2539: LIST
2540: LIST
2541: PUSH
2542: LD_INT 2
2544: PUSH
2545: LD_EXP 33
2549: PUSH
2550: EMPTY
2551: LIST
2552: LIST
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: LD_EXP 33
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: PUSH
2566: LD_INT 20
2568: PUSH
2569: LD_EXP 33
2573: PUSH
2574: LD_INT 25
2576: PLUS
2577: PUSH
2578: EMPTY
2579: LIST
2580: LIST
2581: PUSH
2582: EMPTY
2583: LIST
2584: LIST
2585: LIST
2586: LIST
2587: PPUSH
2588: CALL_OW 418
// end ; uc_side := side ;
2592: LD_ADDR_OWVAR 20
2596: PUSH
2597: LD_VAR 0 1
2601: ST_TO_ADDR
// uc_nation := nation_arabian ;
2602: LD_ADDR_OWVAR 21
2606: PUSH
2607: LD_INT 2
2609: ST_TO_ADDR
// hc_name :=  ;
2610: LD_ADDR_OWVAR 26
2614: PUSH
2615: LD_STRING 
2617: ST_TO_ADDR
// hc_class := class_desert_warior ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 11
2625: ST_TO_ADDR
// hc_sex := sex_male ;
2626: LD_ADDR_OWVAR 27
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_basic_skills := sh_skills ;
2634: LD_ADDR_OWVAR 30
2638: PUSH
2639: LD_EXP 21
2643: ST_TO_ADDR
// hc_skills := sh_skills ;
2644: LD_ADDR_OWVAR 31
2648: PUSH
2649: LD_EXP 21
2653: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2654: LD_ADDR_OWVAR 29
2658: PUSH
2659: LD_INT 10
2661: PUSH
2662: LD_INT 10
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: ST_TO_ADDR
// hc_importance := 0 ;
2669: LD_ADDR_OWVAR 32
2673: PUSH
2674: LD_INT 0
2676: ST_TO_ADDR
// hc_gallery :=  ;
2677: LD_ADDR_OWVAR 33
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// for i := 1 to nsol do
2685: LD_ADDR_VAR 0 6
2689: PUSH
2690: DOUBLE
2691: LD_INT 1
2693: DEC
2694: ST_TO_ADDR
2695: LD_EXP 22
2699: PUSH
2700: FOR_TO
2701: IFFALSE 2742
// begin sh := CreateHuman ;
2703: LD_ADDR_VAR 0 7
2707: PUSH
2708: CALL_OW 44
2712: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2713: LD_VAR 0 7
2717: PPUSH
2718: LD_VAR 0 4
2722: PPUSH
2723: LD_VAR 0 5
2727: PPUSH
2728: LD_INT 5
2730: PPUSH
2731: LD_VAR 0 2
2735: PPUSH
2736: CALL_OW 50
// end ;
2740: GO 2700
2742: POP
2743: POP
// hc_name :=  ;
2744: LD_ADDR_OWVAR 26
2748: PUSH
2749: LD_STRING 
2751: ST_TO_ADDR
// hc_class := class_soldier ;
2752: LD_ADDR_OWVAR 28
2756: PUSH
2757: LD_INT 1
2759: ST_TO_ADDR
// hc_sex := sex_male ;
2760: LD_ADDR_OWVAR 27
2764: PUSH
2765: LD_INT 1
2767: ST_TO_ADDR
// hc_basic_skills := sol_skills ;
2768: LD_ADDR_OWVAR 30
2772: PUSH
2773: LD_EXP 23
2777: ST_TO_ADDR
// hc_skills := sol_skills ;
2778: LD_ADDR_OWVAR 31
2782: PUSH
2783: LD_EXP 23
2787: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2788: LD_ADDR_OWVAR 29
2792: PUSH
2793: LD_INT 10
2795: PUSH
2796: LD_INT 10
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: ST_TO_ADDR
// hc_importance := 0 ;
2803: LD_ADDR_OWVAR 32
2807: PUSH
2808: LD_INT 0
2810: ST_TO_ADDR
// hc_gallery :=  ;
2811: LD_ADDR_OWVAR 33
2815: PUSH
2816: LD_STRING 
2818: ST_TO_ADDR
// for i := 1 to nsh do
2819: LD_ADDR_VAR 0 6
2823: PUSH
2824: DOUBLE
2825: LD_INT 1
2827: DEC
2828: ST_TO_ADDR
2829: LD_EXP 20
2833: PUSH
2834: FOR_TO
2835: IFFALSE 2876
// begin sh := CreateHuman ;
2837: LD_ADDR_VAR 0 7
2841: PUSH
2842: CALL_OW 44
2846: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2847: LD_VAR 0 7
2851: PPUSH
2852: LD_VAR 0 4
2856: PPUSH
2857: LD_VAR 0 5
2861: PPUSH
2862: LD_INT 5
2864: PPUSH
2865: LD_VAR 0 2
2869: PPUSH
2870: CALL_OW 50
// end ;
2874: GO 2834
2876: POP
2877: POP
// end ;
2878: LD_VAR 0 3
2882: RET
// function find_hidden_hex ( ar ) ; var i , j , seen ; begin
2883: LD_INT 0
2885: PPUSH
2886: PPUSH
2887: PPUSH
2888: PPUSH
// for i := 1 to 100 do
2889: LD_ADDR_VAR 0 3
2893: PUSH
2894: DOUBLE
2895: LD_INT 1
2897: DEC
2898: ST_TO_ADDR
2899: LD_INT 100
2901: PUSH
2902: FOR_TO
2903: IFFALSE 3026
// begin repeat result := RandHexArea ( ar , false ) ;
2905: LD_ADDR_VAR 0 2
2909: PUSH
2910: LD_VAR 0 1
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 16
2922: ST_TO_ADDR
// until not HexInfo ( result [ 1 ] , result [ 2 ] ) ;
2923: LD_VAR 0 2
2927: PUSH
2928: LD_INT 1
2930: ARRAY
2931: PPUSH
2932: LD_VAR 0 2
2936: PUSH
2937: LD_INT 2
2939: ARRAY
2940: PPUSH
2941: CALL_OW 428
2945: NOT
2946: IFFALSE 2905
// seen := false ;
2948: LD_ADDR_VAR 0 5
2952: PUSH
2953: LD_INT 0
2955: ST_TO_ADDR
// for j := 1 to 8 do
2956: LD_ADDR_VAR 0 4
2960: PUSH
2961: DOUBLE
2962: LD_INT 1
2964: DEC
2965: ST_TO_ADDR
2966: LD_INT 8
2968: PUSH
2969: FOR_TO
2970: IFFALSE 3011
// if SeeXY ( j , result [ 1 ] , result [ 2 ] ) then
2972: LD_VAR 0 4
2976: PPUSH
2977: LD_VAR 0 2
2981: PUSH
2982: LD_INT 1
2984: ARRAY
2985: PPUSH
2986: LD_VAR 0 2
2990: PUSH
2991: LD_INT 2
2993: ARRAY
2994: PPUSH
2995: CALL_OW 293
2999: IFFALSE 3009
// seen := true ;
3001: LD_ADDR_VAR 0 5
3005: PUSH
3006: LD_INT 1
3008: ST_TO_ADDR
3009: GO 2969
3011: POP
3012: POP
// if not seen then
3013: LD_VAR 0 5
3017: NOT
3018: IFFALSE 3024
// exit ;
3020: POP
3021: POP
3022: GO 3036
// end ;
3024: GO 2902
3026: POP
3027: POP
// result := 0 ;
3028: LD_ADDR_VAR 0 2
3032: PUSH
3033: LD_INT 0
3035: ST_TO_ADDR
// end ;
3036: LD_VAR 0 2
3040: RET
// function create_ape ; var coord , i ; begin
3041: LD_INT 0
3043: PPUSH
3044: PPUSH
3045: PPUSH
// if lastunit >= 1999 then
3046: LD_EXP 36
3050: PUSH
3051: LD_INT 1999
3053: GREATEREQUAL
3054: IFFALSE 3058
// exit ;
3056: GO 3225
// uc_nation := nation_nature ;
3058: LD_ADDR_OWVAR 21
3062: PUSH
3063: LD_INT 0
3065: ST_TO_ADDR
// uc_side := 0 ;
3066: LD_ADDR_OWVAR 20
3070: PUSH
3071: LD_INT 0
3073: ST_TO_ADDR
// hc_name :=  ;
3074: LD_ADDR_OWVAR 26
3078: PUSH
3079: LD_STRING 
3081: ST_TO_ADDR
// hc_class := class_apeman ;
3082: LD_ADDR_OWVAR 28
3086: PUSH
3087: LD_INT 12
3089: ST_TO_ADDR
// hc_sex := 1 ;
3090: LD_ADDR_OWVAR 27
3094: PUSH
3095: LD_INT 1
3097: ST_TO_ADDR
// hc_basic_skills := ape_skills ;
3098: LD_ADDR_OWVAR 30
3102: PUSH
3103: LD_EXP 26
3107: ST_TO_ADDR
// hc_skills := ape_skills ;
3108: LD_ADDR_OWVAR 31
3112: PUSH
3113: LD_EXP 26
3117: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3118: LD_ADDR_OWVAR 29
3122: PUSH
3123: LD_INT 12
3125: PUSH
3126: LD_INT 12
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: ST_TO_ADDR
// hc_importance := 0 ;
3133: LD_ADDR_OWVAR 32
3137: PUSH
3138: LD_INT 0
3140: ST_TO_ADDR
// hc_gallery :=  ;
3141: LD_ADDR_OWVAR 33
3145: PUSH
3146: LD_STRING 
3148: ST_TO_ADDR
// hc_agressivity := Rand ( - 15 , 15 ) ;
3149: LD_ADDR_OWVAR 35
3153: PUSH
3154: LD_INT 15
3156: NEG
3157: PPUSH
3158: LD_INT 15
3160: PPUSH
3161: CALL_OW 12
3165: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3166: LD_ADDR_VAR 0 2
3170: PUSH
3171: LD_INT 4
3173: PPUSH
3174: CALL 2883 0 1
3178: ST_TO_ADDR
// if coord then
3179: LD_VAR 0 2
3183: IFFALSE 3225
// begin lastunit := CreateHuman ;
3185: LD_ADDR_EXP 36
3189: PUSH
3190: CALL_OW 44
3194: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3195: LD_EXP 36
3199: PPUSH
3200: LD_VAR 0 2
3204: PUSH
3205: LD_INT 1
3207: ARRAY
3208: PPUSH
3209: LD_VAR 0 2
3213: PUSH
3214: LD_INT 2
3216: ARRAY
3217: PPUSH
3218: LD_INT 0
3220: PPUSH
3221: CALL_OW 48
// end ; end ;
3225: LD_VAR 0 1
3229: RET
// function prepare_apes ; var i ; begin
3230: LD_INT 0
3232: PPUSH
3233: PPUSH
// for i := 1 to side_count * nstart_ape do
3234: LD_ADDR_VAR 0 2
3238: PUSH
3239: DOUBLE
3240: LD_INT 1
3242: DEC
3243: ST_TO_ADDR
3244: LD_EXP 37
3248: PUSH
3249: LD_EXP 24
3253: MUL
3254: PUSH
3255: FOR_TO
3256: IFFALSE 3264
// begin create_ape ;
3258: CALL 3041 0 0
// end ;
3262: GO 3255
3264: POP
3265: POP
// end ;
3266: LD_VAR 0 1
3270: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3271: LD_OWVAR 1
3275: PUSH
3276: LD_EXP 32
3280: GREATER
3281: IFFALSE 3365
3283: GO 3285
3285: DISABLE
3286: LD_INT 0
3288: PPUSH
// begin if not ape_respawning then
3289: LD_EXP 25
3293: NOT
3294: IFFALSE 3298
// exit ;
3296: GO 3365
// delay := ape_respawning div side_count ;
3298: LD_ADDR_VAR 0 1
3302: PUSH
3303: LD_EXP 25
3307: PUSH
3308: LD_EXP 37
3312: DIV
3313: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3314: LD_VAR 0 1
3318: PUSH
3319: LD_INT 50
3321: PPUSH
3322: LD_INT 150
3324: PPUSH
3325: CALL_OW 12
3329: MUL
3330: PUSH
3331: LD_INT 100
3333: DIV
3334: PPUSH
3335: CALL_OW 67
// delay := delay * 110 div 100 ;
3339: LD_ADDR_VAR 0 1
3343: PUSH
3344: LD_VAR 0 1
3348: PUSH
3349: LD_INT 110
3351: MUL
3352: PUSH
3353: LD_INT 100
3355: DIV
3356: ST_TO_ADDR
// create_ape ;
3357: CALL 3041 0 0
// until false ;
3361: LD_INT 0
3363: IFFALSE 3314
// end ;
3365: PPOPN 1
3367: END
// function create_tiger ; var coord , i ; begin
3368: LD_INT 0
3370: PPUSH
3371: PPUSH
3372: PPUSH
// if lastunit >= 1999 then
3373: LD_EXP 36
3377: PUSH
3378: LD_INT 1999
3380: GREATEREQUAL
3381: IFFALSE 3385
// exit ;
3383: GO 3577
// uc_nation := nation_nature ;
3385: LD_ADDR_OWVAR 21
3389: PUSH
3390: LD_INT 0
3392: ST_TO_ADDR
// uc_side := 0 ;
3393: LD_ADDR_OWVAR 20
3397: PUSH
3398: LD_INT 0
3400: ST_TO_ADDR
// hc_name :=  ;
3401: LD_ADDR_OWVAR 26
3405: PUSH
3406: LD_STRING 
3408: ST_TO_ADDR
// hc_class := class_tiger ;
3409: LD_ADDR_OWVAR 28
3413: PUSH
3414: LD_INT 14
3416: ST_TO_ADDR
// hc_sex := 1 ;
3417: LD_ADDR_OWVAR 27
3421: PUSH
3422: LD_INT 1
3424: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 2 , 2 ] ;
3425: LD_ADDR_OWVAR 30
3429: PUSH
3430: LD_INT 2
3432: PUSH
3433: LD_INT 2
3435: PUSH
3436: LD_INT 2
3438: PUSH
3439: LD_INT 2
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// hc_skills := [ 2 , 2 , 2 , 2 ] ;
3448: LD_ADDR_OWVAR 31
3452: PUSH
3453: LD_INT 2
3455: PUSH
3456: LD_INT 2
3458: PUSH
3459: LD_INT 2
3461: PUSH
3462: LD_INT 2
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: LIST
3469: LIST
3470: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3471: LD_ADDR_OWVAR 29
3475: PUSH
3476: LD_INT 12
3478: PUSH
3479: LD_INT 12
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: ST_TO_ADDR
// hc_importance := 0 ;
3486: LD_ADDR_OWVAR 32
3490: PUSH
3491: LD_INT 0
3493: ST_TO_ADDR
// hc_gallery :=  ;
3494: LD_ADDR_OWVAR 33
3498: PUSH
3499: LD_STRING 
3501: ST_TO_ADDR
// hc_agressivity := Rand ( 30 , 50 ) ;
3502: LD_ADDR_OWVAR 35
3506: PUSH
3507: LD_INT 30
3509: PPUSH
3510: LD_INT 50
3512: PPUSH
3513: CALL_OW 12
3517: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3518: LD_ADDR_VAR 0 2
3522: PUSH
3523: LD_INT 4
3525: PPUSH
3526: CALL 2883 0 1
3530: ST_TO_ADDR
// if coord then
3531: LD_VAR 0 2
3535: IFFALSE 3577
// begin lastunit := CreateHuman ;
3537: LD_ADDR_EXP 36
3541: PUSH
3542: CALL_OW 44
3546: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3547: LD_EXP 36
3551: PPUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_INT 1
3559: ARRAY
3560: PPUSH
3561: LD_VAR 0 2
3565: PUSH
3566: LD_INT 2
3568: ARRAY
3569: PPUSH
3570: LD_INT 0
3572: PPUSH
3573: CALL_OW 48
// end ; end ;
3577: LD_VAR 0 1
3581: RET
// function prepare_tigers ; var i ; begin
3582: LD_INT 0
3584: PPUSH
3585: PPUSH
// for i := 1 to side_count * ntig do
3586: LD_ADDR_VAR 0 2
3590: PUSH
3591: DOUBLE
3592: LD_INT 1
3594: DEC
3595: ST_TO_ADDR
3596: LD_EXP 37
3600: PUSH
3601: LD_EXP 30
3605: MUL
3606: PUSH
3607: FOR_TO
3608: IFFALSE 3616
// begin create_tiger ;
3610: CALL 3368 0 0
// end ;
3614: GO 3607
3616: POP
3617: POP
// end ;
3618: LD_VAR 0 1
3622: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3623: LD_OWVAR 1
3627: PUSH
3628: LD_EXP 32
3632: GREATER
3633: IFFALSE 3717
3635: GO 3637
3637: DISABLE
3638: LD_INT 0
3640: PPUSH
// begin if not tig_respawning then
3641: LD_EXP 31
3645: NOT
3646: IFFALSE 3650
// exit ;
3648: GO 3717
// delay := tig_respawning div side_count ;
3650: LD_ADDR_VAR 0 1
3654: PUSH
3655: LD_EXP 31
3659: PUSH
3660: LD_EXP 37
3664: DIV
3665: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3666: LD_VAR 0 1
3670: PUSH
3671: LD_INT 50
3673: PPUSH
3674: LD_INT 150
3676: PPUSH
3677: CALL_OW 12
3681: MUL
3682: PUSH
3683: LD_INT 100
3685: DIV
3686: PPUSH
3687: CALL_OW 67
// delay := delay * 110 div 100 ;
3691: LD_ADDR_VAR 0 1
3695: PUSH
3696: LD_VAR 0 1
3700: PUSH
3701: LD_INT 110
3703: MUL
3704: PUSH
3705: LD_INT 100
3707: DIV
3708: ST_TO_ADDR
// create_tiger ;
3709: CALL 3368 0 0
// until false ;
3713: LD_INT 0
3715: IFFALSE 3666
// end ;
3717: PPOPN 1
3719: END
// export function sheherezade_start_the_fight ; var i ; begin
3720: LD_INT 0
3722: PPUSH
3723: PPUSH
// for i := 1 to 8 do
3724: LD_ADDR_VAR 0 2
3728: PUSH
3729: DOUBLE
3730: LD_INT 1
3732: DEC
3733: ST_TO_ADDR
3734: LD_INT 8
3736: PUSH
3737: FOR_TO
3738: IFFALSE 3772
// if side_positions [ i ] then
3740: LD_EXP 43
3744: PUSH
3745: LD_VAR 0 2
3749: ARRAY
3750: IFFALSE 3770
// prepare_side_to_the_fight ( i , prep_time > 0 ) ;
3752: LD_VAR 0 2
3756: PPUSH
3757: LD_EXP 32
3761: PUSH
3762: LD_INT 0
3764: GREATER
3765: PPUSH
3766: CALL 2410 0 2
3770: GO 3737
3772: POP
3773: POP
// end ;
3774: LD_VAR 0 1
3778: RET
// function create_mastodon ; var coord , i ; begin
3779: LD_INT 0
3781: PPUSH
3782: PPUSH
3783: PPUSH
// if lastunit >= 1999 then
3784: LD_EXP 36
3788: PUSH
3789: LD_INT 1999
3791: GREATEREQUAL
3792: IFFALSE 3796
// exit ;
3794: GO 3882
// uc_nation := nation_nature ;
3796: LD_ADDR_OWVAR 21
3800: PUSH
3801: LD_INT 0
3803: ST_TO_ADDR
// uc_side := 0 ;
3804: LD_ADDR_OWVAR 20
3808: PUSH
3809: LD_INT 0
3811: ST_TO_ADDR
// vc_chassis := 31 ;
3812: LD_ADDR_OWVAR 37
3816: PUSH
3817: LD_INT 31
3819: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3820: LD_ADDR_VAR 0 2
3824: PUSH
3825: LD_INT 4
3827: PPUSH
3828: CALL 2883 0 1
3832: ST_TO_ADDR
// if coord then
3833: LD_VAR 0 2
3837: IFFALSE 3882
// begin lastunit := CreateVehicle ;
3839: LD_ADDR_EXP 36
3843: PUSH
3844: CALL_OW 45
3848: ST_TO_ADDR
// PlaceUnitXYR ( lastunit , coord [ 1 ] , coord [ 2 ] , 3 , false ) ;
3849: LD_EXP 36
3853: PPUSH
3854: LD_VAR 0 2
3858: PUSH
3859: LD_INT 1
3861: ARRAY
3862: PPUSH
3863: LD_VAR 0 2
3867: PUSH
3868: LD_INT 2
3870: ARRAY
3871: PPUSH
3872: LD_INT 3
3874: PPUSH
3875: LD_INT 0
3877: PPUSH
3878: CALL_OW 50
// end ; end ;
3882: LD_VAR 0 1
3886: RET
// function prepare_mastodons ; var i ; begin
3887: LD_INT 0
3889: PPUSH
3890: PPUSH
// for i := 1 to nmast1 + side_count * nmast2 + side_count * nsh * nmast3 div 100 do
3891: LD_ADDR_VAR 0 2
3895: PUSH
3896: DOUBLE
3897: LD_INT 1
3899: DEC
3900: ST_TO_ADDR
3901: LD_EXP 27
3905: PUSH
3906: LD_EXP 37
3910: PUSH
3911: LD_EXP 28
3915: MUL
3916: PLUS
3917: PUSH
3918: LD_EXP 37
3922: PUSH
3923: LD_EXP 20
3927: MUL
3928: PUSH
3929: LD_EXP 29
3933: MUL
3934: PUSH
3935: LD_INT 100
3937: DIV
3938: PLUS
3939: PUSH
3940: FOR_TO
3941: IFFALSE 3949
// begin create_mastodon ;
3943: CALL 3779 0 0
// end ;
3947: GO 3940
3949: POP
3950: POP
// end ;
3951: LD_VAR 0 1
3955: RET
// export function starting_sheherezad ; begin
3956: LD_INT 0
3958: PPUSH
// mp_selectmsg := true ;
3959: LD_ADDR_OWVAR 13
3963: PUSH
3964: LD_INT 1
3966: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
3967: CALL 111 0 0
// prepare_map_coordinates ;
3971: CALL 1596 0 0
// set_attitudes ;
3975: CALL 2041 0 0
// prepare_sides ;
3979: CALL 2346 0 0
// prepare_apes ;
3983: CALL 3230 0 0
// prepare_tigers ;
3987: CALL 3582 0 0
// prepare_mastodons ;
3991: CALL 3887 0 0
// your_side := Player_Side ;
3995: LD_ADDR_OWVAR 2
3999: PUSH
4000: LD_EXP 39
4004: ST_TO_ADDR
// ResetFog ;
4005: CALL_OW 335
// music_nat := nation_arabian ;
4009: LD_ADDR_OWVAR 71
4013: PUSH
4014: LD_INT 2
4016: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
4017: LD_EXP 34
4021: PUSH
4022: LD_OWVAR 2
4026: ARRAY
4027: PUSH
4028: LD_INT 1
4030: ARRAY
4031: PPUSH
4032: LD_EXP 34
4036: PUSH
4037: LD_OWVAR 2
4041: ARRAY
4042: PUSH
4043: LD_INT 2
4045: ARRAY
4046: PPUSH
4047: CALL_OW 86
// end ; end_of_file
4051: LD_VAR 0 1
4055: RET
// export def_victory_conditions , def_number_of_people , def_people_respawning , def_vehicles_at_start , def_vehicles_respawning , def_vehicles_nations , def_siberite_rocket , def_vehicles_durability ; export game_time , point_limit , vehresp , vehmax1 , vehmax2 , vehmax , startvehperc , startveh , vehdur , npeop , peopresp , vehnats , sibrock , to_resp ; function read_multiplayer_and_game_parameters ; var i ; begin
4056: LD_INT 0
4058: PPUSH
4059: PPUSH
// if MultiPlayer then
4060: LD_OWVAR 4
4064: IFFALSE 4128
// begin Player_Side = mp_player_side ;
4066: LD_ADDR_EXP 39
4070: PUSH
4071: LD_OWVAR 7
4075: ST_TO_ADDR
// Player_Team = mp_player_team ;
4076: LD_ADDR_EXP 40
4080: PUSH
4081: LD_OWVAR 8
4085: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
4086: LD_ADDR_EXP 43
4090: PUSH
4091: LD_OWVAR 17
4095: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
4096: LD_ADDR_EXP 41
4100: PUSH
4101: LD_OWVAR 15
4105: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
4106: LD_ADDR_EXP 44
4110: PUSH
4111: LD_OWVAR 16
4115: ST_TO_ADDR
// Teams = mp_teams ;
4116: LD_ADDR_EXP 42
4120: PUSH
4121: LD_OWVAR 12
4125: ST_TO_ADDR
// end else
4126: GO 4272
// begin randomize ;
4128: CALL_OW 10
// Player_Side = 1 ;
4132: LD_ADDR_EXP 39
4136: PUSH
4137: LD_INT 1
4139: ST_TO_ADDR
// Player_Team = 0 ;
4140: LD_ADDR_EXP 40
4144: PUSH
4145: LD_INT 0
4147: ST_TO_ADDR
// Side_Positions = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ;
4148: LD_ADDR_EXP 43
4152: PUSH
4153: LD_INT 1
4155: PUSH
4156: LD_INT 2
4158: PUSH
4159: LD_INT 3
4161: PUSH
4162: LD_INT 4
4164: PUSH
4165: LD_INT 5
4167: PUSH
4168: LD_INT 6
4170: PUSH
4171: LD_INT 7
4173: PUSH
4174: LD_INT 8
4176: PUSH
4177: EMPTY
4178: LIST
4179: LIST
4180: LIST
4181: LIST
4182: LIST
4183: LIST
4184: LIST
4185: LIST
4186: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4187: LD_ADDR_EXP 41
4191: PUSH
4192: LD_INT 0
4194: PUSH
4195: LD_INT 0
4197: PUSH
4198: LD_INT 0
4200: PUSH
4201: LD_INT 0
4203: PUSH
4204: LD_INT 0
4206: PUSH
4207: LD_INT 0
4209: PUSH
4210: LD_INT 0
4212: PUSH
4213: LD_INT 0
4215: PUSH
4216: EMPTY
4217: LIST
4218: LIST
4219: LIST
4220: LIST
4221: LIST
4222: LIST
4223: LIST
4224: LIST
4225: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 3 , 2 , 1 , 2 ] ;
4226: LD_ADDR_EXP 44
4230: PUSH
4231: LD_INT 1
4233: PUSH
4234: LD_INT 3
4236: PUSH
4237: LD_INT 1
4239: PUSH
4240: LD_INT 2
4242: PUSH
4243: LD_INT 3
4245: PUSH
4246: LD_INT 2
4248: PUSH
4249: LD_INT 1
4251: PUSH
4252: LD_INT 2
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: LIST
4259: LIST
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: ST_TO_ADDR
// Teams = [ ] ;
4265: LD_ADDR_EXP 42
4269: PUSH
4270: EMPTY
4271: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
4272: LD_ADDR_EXP 37
4276: PUSH
4277: LD_EXP 43
4281: PUSH
4282: LD_INT 0
4284: PUSH
4285: EMPTY
4286: LIST
4287: DIFF
4288: PUSH
4289: LD_INT 0
4291: PLUS
4292: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
4293: LD_ADDR_EXP 38
4297: PUSH
4298: LD_EXP 41
4302: PUSH
4303: LD_INT 0
4305: PUSH
4306: EMPTY
4307: LIST
4308: DIFF
4309: PUSH
4310: LD_INT 0
4312: PLUS
4313: ST_TO_ADDR
// if MultiPlayer then
4314: LD_OWVAR 4
4318: IFFALSE 4426
// begin def_victory_conditions = GetMultiplayerSetting ( 0 ) ;
4320: LD_ADDR_EXP 48
4324: PUSH
4325: LD_INT 0
4327: PPUSH
4328: CALL_OW 426
4332: ST_TO_ADDR
// def_number_of_people = GetMultiplayerSetting ( 1 ) ;
4333: LD_ADDR_EXP 49
4337: PUSH
4338: LD_INT 1
4340: PPUSH
4341: CALL_OW 426
4345: ST_TO_ADDR
// def_people_respawning = GetMultiplayerSetting ( 2 ) ;
4346: LD_ADDR_EXP 50
4350: PUSH
4351: LD_INT 2
4353: PPUSH
4354: CALL_OW 426
4358: ST_TO_ADDR
// def_vehicles_at_start = GetMultiplayerSetting ( 3 ) ;
4359: LD_ADDR_EXP 51
4363: PUSH
4364: LD_INT 3
4366: PPUSH
4367: CALL_OW 426
4371: ST_TO_ADDR
// def_vehicles_respawning = GetMultiplayerSetting ( 4 ) ;
4372: LD_ADDR_EXP 52
4376: PUSH
4377: LD_INT 4
4379: PPUSH
4380: CALL_OW 426
4384: ST_TO_ADDR
// def_vehicles_nations = GetMultiplayerSetting ( 5 ) ;
4385: LD_ADDR_EXP 53
4389: PUSH
4390: LD_INT 5
4392: PPUSH
4393: CALL_OW 426
4397: ST_TO_ADDR
// def_siberite_rocket = GetMultiplayerSetting ( 6 ) ;
4398: LD_ADDR_EXP 54
4402: PUSH
4403: LD_INT 6
4405: PPUSH
4406: CALL_OW 426
4410: ST_TO_ADDR
// def_vehicles_durability = GetMultiplayerSetting ( 7 ) ;
4411: LD_ADDR_EXP 55
4415: PUSH
4416: LD_INT 7
4418: PPUSH
4419: CALL_OW 426
4423: ST_TO_ADDR
// end else
4424: GO 4494
// begin randomize ;
4426: CALL_OW 10
// def_victory_conditions = 2 ;
4430: LD_ADDR_EXP 48
4434: PUSH
4435: LD_INT 2
4437: ST_TO_ADDR
// def_number_of_people = 1 ;
4438: LD_ADDR_EXP 49
4442: PUSH
4443: LD_INT 1
4445: ST_TO_ADDR
// def_people_respawning = 1 ;
4446: LD_ADDR_EXP 50
4450: PUSH
4451: LD_INT 1
4453: ST_TO_ADDR
// def_vehicles_at_start = 1 ;
4454: LD_ADDR_EXP 51
4458: PUSH
4459: LD_INT 1
4461: ST_TO_ADDR
// def_vehicles_respawning = 2 ;
4462: LD_ADDR_EXP 52
4466: PUSH
4467: LD_INT 2
4469: ST_TO_ADDR
// def_vehicles_nations = 0 ;
4470: LD_ADDR_EXP 53
4474: PUSH
4475: LD_INT 0
4477: ST_TO_ADDR
// def_siberite_rocket = 1 ;
4478: LD_ADDR_EXP 54
4482: PUSH
4483: LD_INT 1
4485: ST_TO_ADDR
// def_vehicles_durability = 1 ;
4486: LD_ADDR_EXP 55
4490: PUSH
4491: LD_INT 1
4493: ST_TO_ADDR
// end ; game_time = [ 5 5$0 , 10 10$0 , 15 15$0 , 20 20$0 , 30 30$0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ def_victory_conditions + 1 ] ;
4494: LD_ADDR_EXP 56
4498: PUSH
4499: LD_INT 10500
4501: PUSH
4502: LD_INT 21000
4504: PUSH
4505: LD_INT 31500
4507: PUSH
4508: LD_INT 42000
4510: PUSH
4511: LD_INT 63000
4513: PUSH
4514: LD_INT 0
4516: PUSH
4517: LD_INT 0
4519: PUSH
4520: LD_INT 0
4522: PUSH
4523: LD_INT 0
4525: PUSH
4526: LD_INT 0
4528: PUSH
4529: LD_INT 0
4531: PUSH
4532: EMPTY
4533: LIST
4534: LIST
4535: LIST
4536: LIST
4537: LIST
4538: LIST
4539: LIST
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: PUSH
4545: LD_EXP 48
4549: PUSH
4550: LD_INT 1
4552: PLUS
4553: ARRAY
4554: ST_TO_ADDR
// point_limit = [ 0 , 0 , 0 , 0 , 0 , 0 , 5 , 10 , 15 , 20 , 30 , 50 ] [ def_victory_conditions + 1 ] ;
4555: LD_ADDR_EXP 57
4559: PUSH
4560: LD_INT 0
4562: PUSH
4563: LD_INT 0
4565: PUSH
4566: LD_INT 0
4568: PUSH
4569: LD_INT 0
4571: PUSH
4572: LD_INT 0
4574: PUSH
4575: LD_INT 0
4577: PUSH
4578: LD_INT 5
4580: PUSH
4581: LD_INT 10
4583: PUSH
4584: LD_INT 15
4586: PUSH
4587: LD_INT 20
4589: PUSH
4590: LD_INT 30
4592: PUSH
4593: LD_INT 50
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: LIST
4604: LIST
4605: LIST
4606: LIST
4607: LIST
4608: LIST
4609: PUSH
4610: LD_EXP 48
4614: PUSH
4615: LD_INT 1
4617: PLUS
4618: ARRAY
4619: ST_TO_ADDR
// npeop = [ 4 , 6 , 8 , 10 ] [ def_number_of_people + 1 ] ;
4620: LD_ADDR_EXP 65
4624: PUSH
4625: LD_INT 4
4627: PUSH
4628: LD_INT 6
4630: PUSH
4631: LD_INT 8
4633: PUSH
4634: LD_INT 10
4636: PUSH
4637: EMPTY
4638: LIST
4639: LIST
4640: LIST
4641: LIST
4642: PUSH
4643: LD_EXP 49
4647: PUSH
4648: LD_INT 1
4650: PLUS
4651: ARRAY
4652: ST_TO_ADDR
// peopresp = [ false , [ 0 0$40 , 1 1$20 ] , [ 0 0$20 , 0 0$40 ] , [ 0 0$10 , 0 0$20 ] ] [ def_people_respawning + 1 ] ;
4653: LD_ADDR_EXP 66
4657: PUSH
4658: LD_INT 0
4660: PUSH
4661: LD_INT 1400
4663: PUSH
4664: LD_INT 2800
4666: PUSH
4667: EMPTY
4668: LIST
4669: LIST
4670: PUSH
4671: LD_INT 700
4673: PUSH
4674: LD_INT 1400
4676: PUSH
4677: EMPTY
4678: LIST
4679: LIST
4680: PUSH
4681: LD_INT 350
4683: PUSH
4684: LD_INT 700
4686: PUSH
4687: EMPTY
4688: LIST
4689: LIST
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: LIST
4695: LIST
4696: PUSH
4697: LD_EXP 50
4701: PUSH
4702: LD_INT 1
4704: PLUS
4705: ARRAY
4706: ST_TO_ADDR
// vehmax1 = [ 3 , 6 , 9 ] [ def_vehicles_respawning + 1 ] ;
4707: LD_ADDR_EXP 59
4711: PUSH
4712: LD_INT 3
4714: PUSH
4715: LD_INT 6
4717: PUSH
4718: LD_INT 9
4720: PUSH
4721: EMPTY
4722: LIST
4723: LIST
4724: LIST
4725: PUSH
4726: LD_EXP 52
4730: PUSH
4731: LD_INT 1
4733: PLUS
4734: ARRAY
4735: ST_TO_ADDR
// vehmax2 = [ 2 , 4 , 6 ] [ def_vehicles_respawning + 1 ] ;
4736: LD_ADDR_EXP 60
4740: PUSH
4741: LD_INT 2
4743: PUSH
4744: LD_INT 4
4746: PUSH
4747: LD_INT 6
4749: PUSH
4750: EMPTY
4751: LIST
4752: LIST
4753: LIST
4754: PUSH
4755: LD_EXP 52
4759: PUSH
4760: LD_INT 1
4762: PLUS
4763: ARRAY
4764: ST_TO_ADDR
// vehmax = vehmax1 + side_count * vehmax2 ;
4765: LD_ADDR_EXP 61
4769: PUSH
4770: LD_EXP 59
4774: PUSH
4775: LD_EXP 37
4779: PUSH
4780: LD_EXP 60
4784: MUL
4785: PLUS
4786: ST_TO_ADDR
// vehdur = [ [ 25 , 50 ] , [ 45 , 90 ] , [ 75 , 150 ] ] [ def_vehicles_durability + 1 ] ;
4787: LD_ADDR_EXP 64
4791: PUSH
4792: LD_INT 25
4794: PUSH
4795: LD_INT 50
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: PUSH
4802: LD_INT 45
4804: PUSH
4805: LD_INT 90
4807: PUSH
4808: EMPTY
4809: LIST
4810: LIST
4811: PUSH
4812: LD_INT 75
4814: PUSH
4815: LD_INT 150
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PUSH
4822: EMPTY
4823: LIST
4824: LIST
4825: LIST
4826: PUSH
4827: LD_EXP 55
4831: PUSH
4832: LD_INT 1
4834: PLUS
4835: ARRAY
4836: ST_TO_ADDR
// vehresp = [ [ 0 0$40 , 2 2$00 ] , [ 0 0$20 , 1 1$00 ] , [ 0 0$10 , 0 0$30 ] ] [ def_vehicles_respawning + 1 ] ;
4837: LD_ADDR_EXP 58
4841: PUSH
4842: LD_INT 1400
4844: PUSH
4845: LD_INT 4200
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: LD_INT 700
4854: PUSH
4855: LD_INT 2100
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 350
4864: PUSH
4865: LD_INT 1050
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: LIST
4876: PUSH
4877: LD_EXP 52
4881: PUSH
4882: LD_INT 1
4884: PLUS
4885: ARRAY
4886: ST_TO_ADDR
// startvehperc = [ 0 , 10 , 20 , 40 ] [ def_vehicles_at_start + 1 ] ;
4887: LD_ADDR_EXP 62
4891: PUSH
4892: LD_INT 0
4894: PUSH
4895: LD_INT 10
4897: PUSH
4898: LD_INT 20
4900: PUSH
4901: LD_INT 40
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: LIST
4908: LIST
4909: PUSH
4910: LD_EXP 51
4914: PUSH
4915: LD_INT 1
4917: PLUS
4918: ARRAY
4919: ST_TO_ADDR
// startveh = vehmax * startvehperc div 100 ;
4920: LD_ADDR_EXP 63
4924: PUSH
4925: LD_EXP 61
4929: PUSH
4930: LD_EXP 62
4934: MUL
4935: PUSH
4936: LD_INT 100
4938: DIV
4939: ST_TO_ADDR
// vehnats = [ [ 1 , 2 , 3 ] , [ 1 ] , [ 3 ] , [ 2 ] , [ 1 , 3 ] , [ 3 , 2 ] , [ 2 , 1 ] ] [ def_vehicles_nations + 1 ] ;
4940: LD_ADDR_EXP 67
4944: PUSH
4945: LD_INT 1
4947: PUSH
4948: LD_INT 2
4950: PUSH
4951: LD_INT 3
4953: PUSH
4954: EMPTY
4955: LIST
4956: LIST
4957: LIST
4958: PUSH
4959: LD_INT 1
4961: PUSH
4962: EMPTY
4963: LIST
4964: PUSH
4965: LD_INT 3
4967: PUSH
4968: EMPTY
4969: LIST
4970: PUSH
4971: LD_INT 2
4973: PUSH
4974: EMPTY
4975: LIST
4976: PUSH
4977: LD_INT 1
4979: PUSH
4980: LD_INT 3
4982: PUSH
4983: EMPTY
4984: LIST
4985: LIST
4986: PUSH
4987: LD_INT 3
4989: PUSH
4990: LD_INT 2
4992: PUSH
4993: EMPTY
4994: LIST
4995: LIST
4996: PUSH
4997: LD_INT 2
4999: PUSH
5000: LD_INT 1
5002: PUSH
5003: EMPTY
5004: LIST
5005: LIST
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: PUSH
5016: LD_EXP 53
5020: PUSH
5021: LD_INT 1
5023: PLUS
5024: ARRAY
5025: ST_TO_ADDR
// sibrock = [ 0 , 3 , 7 ] [ def_siberite_rocket + 1 ] ;
5026: LD_ADDR_EXP 68
5030: PUSH
5031: LD_INT 0
5033: PUSH
5034: LD_INT 3
5036: PUSH
5037: LD_INT 7
5039: PUSH
5040: EMPTY
5041: LIST
5042: LIST
5043: LIST
5044: PUSH
5045: LD_EXP 54
5049: PUSH
5050: LD_INT 1
5052: PLUS
5053: ARRAY
5054: ST_TO_ADDR
// for i = 1 to 8 do
5055: LD_ADDR_VAR 0 2
5059: PUSH
5060: DOUBLE
5061: LD_INT 1
5063: DEC
5064: ST_TO_ADDR
5065: LD_INT 8
5067: PUSH
5068: FOR_TO
5069: IFFALSE 5101
// if Side_Positions [ i ] then
5071: LD_EXP 43
5075: PUSH
5076: LD_VAR 0 2
5080: ARRAY
5081: IFFALSE 5099
// to_resp := to_resp ^ i ;
5083: LD_ADDR_EXP 69
5087: PUSH
5088: LD_EXP 69
5092: PUSH
5093: LD_VAR 0 2
5097: ADD
5098: ST_TO_ADDR
5099: GO 5068
5101: POP
5102: POP
// end ;
5103: LD_VAR 0 1
5107: RET
// export chassis , weapons , areas_wheeled , areas_tracked ; function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
5108: LD_INT 0
5110: PPUSH
5111: PPUSH
5112: PPUSH
5113: PPUSH
5114: PPUSH
5115: PPUSH
5116: PPUSH
5117: PPUSH
// areas_wheeled = [ aw1 , aw2 , aw3 , aw4 ] ;
5118: LD_ADDR_EXP 72
5122: PUSH
5123: LD_INT 21
5125: PUSH
5126: LD_INT 19
5128: PUSH
5129: LD_INT 17
5131: PUSH
5132: LD_INT 15
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: LIST
5139: LIST
5140: ST_TO_ADDR
// areas_tracked = [ at1 , at2 , at3 , at4 ] ;
5141: LD_ADDR_EXP 73
5145: PUSH
5146: LD_INT 20
5148: PUSH
5149: LD_INT 18
5151: PUSH
5152: LD_INT 16
5154: PUSH
5155: LD_INT 14
5157: PUSH
5158: EMPTY
5159: LIST
5160: LIST
5161: LIST
5162: LIST
5163: ST_TO_ADDR
// best = 0 ;
5164: LD_ADDR_VAR 0 2
5168: PUSH
5169: LD_INT 0
5171: ST_TO_ADDR
// for n = 1 to 200 do
5172: LD_ADDR_VAR 0 8
5176: PUSH
5177: DOUBLE
5178: LD_INT 1
5180: DEC
5181: ST_TO_ADDR
5182: LD_INT 200
5184: PUSH
5185: FOR_TO
5186: IFFALSE 5482
// begin c = [ ] ;
5188: LD_ADDR_VAR 0 3
5192: PUSH
5193: EMPTY
5194: ST_TO_ADDR
// for i = 1 to side_count do
5195: LD_ADDR_VAR 0 6
5199: PUSH
5200: DOUBLE
5201: LD_INT 1
5203: DEC
5204: ST_TO_ADDR
5205: LD_EXP 37
5209: PUSH
5210: FOR_TO
5211: IFFALSE 5240
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
5213: LD_ADDR_VAR 0 3
5217: PUSH
5218: LD_VAR 0 3
5222: PUSH
5223: LD_INT 22
5225: PPUSH
5226: LD_INT 0
5228: PPUSH
5229: CALL_OW 16
5233: PUSH
5234: EMPTY
5235: LIST
5236: ADD
5237: ST_TO_ADDR
5238: GO 5210
5240: POP
5241: POP
// minv = 10000 ;
5242: LD_ADDR_VAR 0 5
5246: PUSH
5247: LD_INT 10000
5249: ST_TO_ADDR
// for i = 1 to side_count do
5250: LD_ADDR_VAR 0 6
5254: PUSH
5255: DOUBLE
5256: LD_INT 1
5258: DEC
5259: ST_TO_ADDR
5260: LD_EXP 37
5264: PUSH
5265: FOR_TO
5266: IFFALSE 5446
// for j = 1 to side_count do
5268: LD_ADDR_VAR 0 7
5272: PUSH
5273: DOUBLE
5274: LD_INT 1
5276: DEC
5277: ST_TO_ADDR
5278: LD_EXP 37
5282: PUSH
5283: FOR_TO
5284: IFFALSE 5442
// if i <> j then
5286: LD_VAR 0 6
5290: PUSH
5291: LD_VAR 0 7
5295: NONEQUAL
5296: IFFALSE 5440
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
5298: LD_VAR 0 3
5302: PUSH
5303: LD_VAR 0 6
5307: ARRAY
5308: PUSH
5309: LD_INT 1
5311: ARRAY
5312: PPUSH
5313: LD_VAR 0 3
5317: PUSH
5318: LD_VAR 0 6
5322: ARRAY
5323: PUSH
5324: LD_INT 2
5326: ARRAY
5327: PPUSH
5328: LD_VAR 0 3
5332: PUSH
5333: LD_VAR 0 7
5337: ARRAY
5338: PUSH
5339: LD_INT 1
5341: ARRAY
5342: PPUSH
5343: LD_VAR 0 3
5347: PUSH
5348: LD_VAR 0 7
5352: ARRAY
5353: PUSH
5354: LD_INT 2
5356: ARRAY
5357: PPUSH
5358: CALL_OW 298
5362: PUSH
5363: LD_VAR 0 5
5367: LESS
5368: IFFALSE 5440
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
5370: LD_ADDR_VAR 0 5
5374: PUSH
5375: LD_VAR 0 3
5379: PUSH
5380: LD_VAR 0 6
5384: ARRAY
5385: PUSH
5386: LD_INT 1
5388: ARRAY
5389: PPUSH
5390: LD_VAR 0 3
5394: PUSH
5395: LD_VAR 0 6
5399: ARRAY
5400: PUSH
5401: LD_INT 2
5403: ARRAY
5404: PPUSH
5405: LD_VAR 0 3
5409: PUSH
5410: LD_VAR 0 7
5414: ARRAY
5415: PUSH
5416: LD_INT 1
5418: ARRAY
5419: PPUSH
5420: LD_VAR 0 3
5424: PUSH
5425: LD_VAR 0 7
5429: ARRAY
5430: PUSH
5431: LD_INT 2
5433: ARRAY
5434: PPUSH
5435: CALL_OW 298
5439: ST_TO_ADDR
// end ;
5440: GO 5283
5442: POP
5443: POP
5444: GO 5265
5446: POP
5447: POP
// if minv > best then
5448: LD_VAR 0 5
5452: PUSH
5453: LD_VAR 0 2
5457: GREATER
5458: IFFALSE 5480
// begin best := minv ;
5460: LD_ADDR_VAR 0 2
5464: PUSH
5465: LD_VAR 0 5
5469: ST_TO_ADDR
// bestc := c ;
5470: LD_ADDR_VAR 0 4
5474: PUSH
5475: LD_VAR 0 3
5479: ST_TO_ADDR
// end ; end ;
5480: GO 5185
5482: POP
5483: POP
// coordinates := [ ] ;
5484: LD_ADDR_EXP 34
5488: PUSH
5489: EMPTY
5490: ST_TO_ADDR
// for i = 1 to 8 do
5491: LD_ADDR_VAR 0 6
5495: PUSH
5496: DOUBLE
5497: LD_INT 1
5499: DEC
5500: ST_TO_ADDR
5501: LD_INT 8
5503: PUSH
5504: FOR_TO
5505: IFFALSE 5592
// if side_positions [ i ] = 0 then
5507: LD_EXP 43
5511: PUSH
5512: LD_VAR 0 6
5516: ARRAY
5517: PUSH
5518: LD_INT 0
5520: EQUAL
5521: IFFALSE 5549
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
5523: LD_ADDR_EXP 34
5527: PUSH
5528: LD_EXP 34
5532: PUSH
5533: LD_INT 0
5535: PUSH
5536: LD_INT 0
5538: PUSH
5539: EMPTY
5540: LIST
5541: LIST
5542: PUSH
5543: EMPTY
5544: LIST
5545: ADD
5546: ST_TO_ADDR
5547: GO 5590
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
5549: LD_ADDR_EXP 34
5553: PUSH
5554: LD_EXP 34
5558: PUSH
5559: LD_VAR 0 4
5563: PUSH
5564: LD_INT 1
5566: ARRAY
5567: PUSH
5568: EMPTY
5569: LIST
5570: ADD
5571: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
5572: LD_ADDR_VAR 0 4
5576: PUSH
5577: LD_VAR 0 4
5581: PPUSH
5582: LD_INT 1
5584: PPUSH
5585: CALL_OW 3
5589: ST_TO_ADDR
// end ;
5590: GO 5504
5592: POP
5593: POP
// end ;
5594: LD_VAR 0 1
5598: RET
// function prepare_constants ; begin
5599: LD_INT 0
5601: PPUSH
// chassis = [ [ [ [ us_light_wheeled ] , [ ] ] , [ [ us_medium_wheeled ] , [ us_medium_tracked ] ] , [ [ ] , [ us_heavy_tracked , us_morphling ] ] ] , [ [ [ ar_light_trike , ar_hovercraft ] , [ ] ] , [ [ ar_medium_trike ] , [ ar_half_tracked ] ] , [ [ ] , [ ] ] ] , [ [ [ ] , [ ] ] , [ [ ru_medium_wheeled ] , [ ru_medium_tracked ] ] , [ [ ru_heavy_wheeled ] , [ ru_heavy_tracked ] ] ] ] ;
5602: LD_ADDR_EXP 70
5606: PUSH
5607: LD_INT 1
5609: PUSH
5610: EMPTY
5611: LIST
5612: PUSH
5613: EMPTY
5614: PUSH
5615: EMPTY
5616: LIST
5617: LIST
5618: PUSH
5619: LD_INT 2
5621: PUSH
5622: EMPTY
5623: LIST
5624: PUSH
5625: LD_INT 3
5627: PUSH
5628: EMPTY
5629: LIST
5630: PUSH
5631: EMPTY
5632: LIST
5633: LIST
5634: PUSH
5635: EMPTY
5636: PUSH
5637: LD_INT 4
5639: PUSH
5640: LD_INT 5
5642: PUSH
5643: EMPTY
5644: LIST
5645: LIST
5646: PUSH
5647: EMPTY
5648: LIST
5649: LIST
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: PUSH
5656: LD_INT 12
5658: PUSH
5659: LD_INT 11
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: PUSH
5666: EMPTY
5667: PUSH
5668: EMPTY
5669: LIST
5670: LIST
5671: PUSH
5672: LD_INT 13
5674: PUSH
5675: EMPTY
5676: LIST
5677: PUSH
5678: LD_INT 14
5680: PUSH
5681: EMPTY
5682: LIST
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: PUSH
5688: EMPTY
5689: PUSH
5690: EMPTY
5691: PUSH
5692: EMPTY
5693: LIST
5694: LIST
5695: PUSH
5696: EMPTY
5697: LIST
5698: LIST
5699: LIST
5700: PUSH
5701: EMPTY
5702: PUSH
5703: EMPTY
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: PUSH
5709: LD_INT 21
5711: PUSH
5712: EMPTY
5713: LIST
5714: PUSH
5715: LD_INT 22
5717: PUSH
5718: EMPTY
5719: LIST
5720: PUSH
5721: EMPTY
5722: LIST
5723: LIST
5724: PUSH
5725: LD_INT 23
5727: PUSH
5728: EMPTY
5729: LIST
5730: PUSH
5731: LD_INT 24
5733: PUSH
5734: EMPTY
5735: LIST
5736: PUSH
5737: EMPTY
5738: LIST
5739: LIST
5740: PUSH
5741: EMPTY
5742: LIST
5743: LIST
5744: LIST
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: LIST
5750: ST_TO_ADDR
// weapons = [ [ [ us_machine_gun , 1 , 100 ] , [ us_light_gun , 1 , 100 ] , [ us_radar , 1 , 100 ] , [ us_gatling_gun , 2 , 100 ] , [ us_double_gun , 2 , 100 ] , [ us_rocket_launcher , 2 , 100 ] , [ us_laser , 2 , 100 ] , [ us_heavy_gun , 3 , 100 ] , [ us_bulldozer , 3 , 100 ] , [ us_double_laser , 3 , 100 ] ] , [ [ ar_multimissile_ballista , 1 , 100 ] , [ ar_double_machine_gun , 1 , 100 ] , [ ar_light_gun , 1 , 100 ] , [ ar_radar , 1 , 100 ] , [ ar_gatling_gun , 2 , 100 ] , [ ar_gun , 2 , 100 ] , [ ar_rocket_launcher , 2 , 100 ] , [ ar_selfpropelled_bomb , 2 , 100 ] , [ ar_flame_thrower , 2 , 100 ] ] , [ [ ru_heavy_machine_gun , 2 , 100 ] , [ ru_gatling_gun , 2 , 100 ] , [ ru_gun , 2 , 100 ] , [ ru_rocket_launcher , 2 , 100 ] , [ ru_heavy_gun , 3 , 100 ] , [ ru_rocket , 3 , 100 ] , [ ru_bulldozer , 3 , 100 ] ] ] ;
5751: LD_ADDR_EXP 71
5755: PUSH
5756: LD_INT 2
5758: PUSH
5759: LD_INT 1
5761: PUSH
5762: LD_INT 100
5764: PUSH
5765: EMPTY
5766: LIST
5767: LIST
5768: LIST
5769: PUSH
5770: LD_INT 3
5772: PUSH
5773: LD_INT 1
5775: PUSH
5776: LD_INT 100
5778: PUSH
5779: EMPTY
5780: LIST
5781: LIST
5782: LIST
5783: PUSH
5784: LD_INT 11
5786: PUSH
5787: LD_INT 1
5789: PUSH
5790: LD_INT 100
5792: PUSH
5793: EMPTY
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 4
5800: PUSH
5801: LD_INT 2
5803: PUSH
5804: LD_INT 100
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: LIST
5811: PUSH
5812: LD_INT 5
5814: PUSH
5815: LD_INT 2
5817: PUSH
5818: LD_INT 100
5820: PUSH
5821: EMPTY
5822: LIST
5823: LIST
5824: LIST
5825: PUSH
5826: LD_INT 7
5828: PUSH
5829: LD_INT 2
5831: PUSH
5832: LD_INT 100
5834: PUSH
5835: EMPTY
5836: LIST
5837: LIST
5838: LIST
5839: PUSH
5840: LD_INT 9
5842: PUSH
5843: LD_INT 2
5845: PUSH
5846: LD_INT 100
5848: PUSH
5849: EMPTY
5850: LIST
5851: LIST
5852: LIST
5853: PUSH
5854: LD_INT 6
5856: PUSH
5857: LD_INT 3
5859: PUSH
5860: LD_INT 100
5862: PUSH
5863: EMPTY
5864: LIST
5865: LIST
5866: LIST
5867: PUSH
5868: LD_INT 14
5870: PUSH
5871: LD_INT 3
5873: PUSH
5874: LD_INT 100
5876: PUSH
5877: EMPTY
5878: LIST
5879: LIST
5880: LIST
5881: PUSH
5882: LD_INT 10
5884: PUSH
5885: LD_INT 3
5887: PUSH
5888: LD_INT 100
5890: PUSH
5891: EMPTY
5892: LIST
5893: LIST
5894: LIST
5895: PUSH
5896: EMPTY
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: PUSH
5908: LD_INT 22
5910: PUSH
5911: LD_INT 1
5913: PUSH
5914: LD_INT 100
5916: PUSH
5917: EMPTY
5918: LIST
5919: LIST
5920: LIST
5921: PUSH
5922: LD_INT 24
5924: PUSH
5925: LD_INT 1
5927: PUSH
5928: LD_INT 100
5930: PUSH
5931: EMPTY
5932: LIST
5933: LIST
5934: LIST
5935: PUSH
5936: LD_INT 23
5938: PUSH
5939: LD_INT 1
5941: PUSH
5942: LD_INT 100
5944: PUSH
5945: EMPTY
5946: LIST
5947: LIST
5948: LIST
5949: PUSH
5950: LD_INT 30
5952: PUSH
5953: LD_INT 1
5955: PUSH
5956: LD_INT 100
5958: PUSH
5959: EMPTY
5960: LIST
5961: LIST
5962: LIST
5963: PUSH
5964: LD_INT 25
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 100
5972: PUSH
5973: EMPTY
5974: LIST
5975: LIST
5976: LIST
5977: PUSH
5978: LD_INT 27
5980: PUSH
5981: LD_INT 2
5983: PUSH
5984: LD_INT 100
5986: PUSH
5987: EMPTY
5988: LIST
5989: LIST
5990: LIST
5991: PUSH
5992: LD_INT 28
5994: PUSH
5995: LD_INT 2
5997: PUSH
5998: LD_INT 100
6000: PUSH
6001: EMPTY
6002: LIST
6003: LIST
6004: LIST
6005: PUSH
6006: LD_INT 29
6008: PUSH
6009: LD_INT 2
6011: PUSH
6012: LD_INT 100
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: LIST
6019: PUSH
6020: LD_INT 26
6022: PUSH
6023: LD_INT 2
6025: PUSH
6026: LD_INT 100
6028: PUSH
6029: EMPTY
6030: LIST
6031: LIST
6032: LIST
6033: PUSH
6034: EMPTY
6035: LIST
6036: LIST
6037: LIST
6038: LIST
6039: LIST
6040: LIST
6041: LIST
6042: LIST
6043: LIST
6044: PUSH
6045: LD_INT 42
6047: PUSH
6048: LD_INT 2
6050: PUSH
6051: LD_INT 100
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: LD_INT 43
6061: PUSH
6062: LD_INT 2
6064: PUSH
6065: LD_INT 100
6067: PUSH
6068: EMPTY
6069: LIST
6070: LIST
6071: LIST
6072: PUSH
6073: LD_INT 44
6075: PUSH
6076: LD_INT 2
6078: PUSH
6079: LD_INT 100
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: LIST
6086: PUSH
6087: LD_INT 45
6089: PUSH
6090: LD_INT 2
6092: PUSH
6093: LD_INT 100
6095: PUSH
6096: EMPTY
6097: LIST
6098: LIST
6099: LIST
6100: PUSH
6101: LD_INT 46
6103: PUSH
6104: LD_INT 3
6106: PUSH
6107: LD_INT 100
6109: PUSH
6110: EMPTY
6111: LIST
6112: LIST
6113: LIST
6114: PUSH
6115: LD_INT 47
6117: PUSH
6118: LD_INT 3
6120: PUSH
6121: LD_INT 100
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: LIST
6128: PUSH
6129: LD_INT 53
6131: PUSH
6132: LD_INT 3
6134: PUSH
6135: LD_INT 100
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: PUSH
6143: EMPTY
6144: LIST
6145: LIST
6146: LIST
6147: LIST
6148: LIST
6149: LIST
6150: LIST
6151: PUSH
6152: EMPTY
6153: LIST
6154: LIST
6155: LIST
6156: ST_TO_ADDR
// end ;
6157: LD_VAR 0 1
6161: RET
// var is_tracked ; function random_vehicle ( sibrockprob ) ; var nat , wpset , suma , tmp , i , weap , wwght , wght , chs , trck ; begin
6162: LD_INT 0
6164: PPUSH
6165: PPUSH
6166: PPUSH
6167: PPUSH
6168: PPUSH
6169: PPUSH
6170: PPUSH
6171: PPUSH
6172: PPUSH
6173: PPUSH
6174: PPUSH
// nat := vehnats [ rand ( 1 , vehnats ) ] ;
6175: LD_ADDR_VAR 0 3
6179: PUSH
6180: LD_EXP 67
6184: PUSH
6185: LD_INT 1
6187: PPUSH
6188: LD_EXP 67
6192: PPUSH
6193: CALL_OW 12
6197: ARRAY
6198: ST_TO_ADDR
// if ( nat in [ nation_russian , nation_american ] ) and ( Rand ( 1 , 1000 ) <= sibrockprob ) then
6199: LD_VAR 0 3
6203: PUSH
6204: LD_INT 3
6206: PUSH
6207: LD_INT 1
6209: PUSH
6210: EMPTY
6211: LIST
6212: LIST
6213: IN
6214: PUSH
6215: LD_INT 1
6217: PPUSH
6218: LD_INT 1000
6220: PPUSH
6221: CALL_OW 12
6225: PUSH
6226: LD_VAR 0 1
6230: LESSEQUAL
6231: AND
6232: IFFALSE 6288
// begin wght := 3 ;
6234: LD_ADDR_VAR 0 10
6238: PUSH
6239: LD_INT 3
6241: ST_TO_ADDR
// case nat of nation_russian :
6242: LD_VAR 0 3
6246: PUSH
6247: LD_INT 3
6249: DOUBLE
6250: EQUAL
6251: IFTRUE 6255
6253: GO 6266
6255: POP
// weap := ru_siberium_rocket ; nation_american :
6256: LD_ADDR_VAR 0 8
6260: PUSH
6261: LD_INT 48
6263: ST_TO_ADDR
6264: GO 6286
6266: LD_INT 1
6268: DOUBLE
6269: EQUAL
6270: IFTRUE 6274
6272: GO 6285
6274: POP
// weap := us_siberium_rocket ; end ;
6275: LD_ADDR_VAR 0 8
6279: PUSH
6280: LD_INT 8
6282: ST_TO_ADDR
6283: GO 6286
6285: POP
// end else
6286: GO 6490
// begin wpset := weapons [ nat ] ;
6288: LD_ADDR_VAR 0 4
6292: PUSH
6293: LD_EXP 71
6297: PUSH
6298: LD_VAR 0 3
6302: ARRAY
6303: ST_TO_ADDR
// suma := 0 ;
6304: LD_ADDR_VAR 0 5
6308: PUSH
6309: LD_INT 0
6311: ST_TO_ADDR
// for i := 1 to wpset do
6312: LD_ADDR_VAR 0 7
6316: PUSH
6317: DOUBLE
6318: LD_INT 1
6320: DEC
6321: ST_TO_ADDR
6322: LD_VAR 0 4
6326: PUSH
6327: FOR_TO
6328: IFFALSE 6358
// suma := suma + wpset [ i ] [ 3 ] ;
6330: LD_ADDR_VAR 0 5
6334: PUSH
6335: LD_VAR 0 5
6339: PUSH
6340: LD_VAR 0 4
6344: PUSH
6345: LD_VAR 0 7
6349: ARRAY
6350: PUSH
6351: LD_INT 3
6353: ARRAY
6354: PLUS
6355: ST_TO_ADDR
6356: GO 6327
6358: POP
6359: POP
// tmp := rand ( 1 , suma ) ;
6360: LD_ADDR_VAR 0 6
6364: PUSH
6365: LD_INT 1
6367: PPUSH
6368: LD_VAR 0 5
6372: PPUSH
6373: CALL_OW 12
6377: ST_TO_ADDR
// i := 1 ;
6378: LD_ADDR_VAR 0 7
6382: PUSH
6383: LD_INT 1
6385: ST_TO_ADDR
// while wpset [ i ] [ 3 ] < tmp do
6386: LD_VAR 0 4
6390: PUSH
6391: LD_VAR 0 7
6395: ARRAY
6396: PUSH
6397: LD_INT 3
6399: ARRAY
6400: PUSH
6401: LD_VAR 0 6
6405: LESS
6406: IFFALSE 6450
// begin tmp := tmp - wpset [ i ] [ 3 ] ;
6408: LD_ADDR_VAR 0 6
6412: PUSH
6413: LD_VAR 0 6
6417: PUSH
6418: LD_VAR 0 4
6422: PUSH
6423: LD_VAR 0 7
6427: ARRAY
6428: PUSH
6429: LD_INT 3
6431: ARRAY
6432: MINUS
6433: ST_TO_ADDR
// i := i + 1 ;
6434: LD_ADDR_VAR 0 7
6438: PUSH
6439: LD_VAR 0 7
6443: PUSH
6444: LD_INT 1
6446: PLUS
6447: ST_TO_ADDR
// end ;
6448: GO 6386
// weap := wpset [ i ] [ 1 ] ;
6450: LD_ADDR_VAR 0 8
6454: PUSH
6455: LD_VAR 0 4
6459: PUSH
6460: LD_VAR 0 7
6464: ARRAY
6465: PUSH
6466: LD_INT 1
6468: ARRAY
6469: ST_TO_ADDR
// wwght := wpset [ i ] [ 2 ] ;
6470: LD_ADDR_VAR 0 9
6474: PUSH
6475: LD_VAR 0 4
6479: PUSH
6480: LD_VAR 0 7
6484: ARRAY
6485: PUSH
6486: LD_INT 2
6488: ARRAY
6489: ST_TO_ADDR
// end ; repeat trck := Rand ( 1 , 2 ) ;
6490: LD_ADDR_VAR 0 12
6494: PUSH
6495: LD_INT 1
6497: PPUSH
6498: LD_INT 2
6500: PPUSH
6501: CALL_OW 12
6505: ST_TO_ADDR
// case wwght of 3 :
6506: LD_VAR 0 9
6510: PUSH
6511: LD_INT 3
6513: DOUBLE
6514: EQUAL
6515: IFTRUE 6519
6517: GO 6530
6519: POP
// wght := 3 ; 2 :
6520: LD_ADDR_VAR 0 10
6524: PUSH
6525: LD_INT 3
6527: ST_TO_ADDR
6528: GO 6647
6530: LD_INT 2
6532: DOUBLE
6533: EQUAL
6534: IFTRUE 6538
6536: GO 6575
6538: POP
// if Rand ( 1 , 100 ) <= 80 then
6539: LD_INT 1
6541: PPUSH
6542: LD_INT 100
6544: PPUSH
6545: CALL_OW 12
6549: PUSH
6550: LD_INT 80
6552: LESSEQUAL
6553: IFFALSE 6565
// wght := 2 else
6555: LD_ADDR_VAR 0 10
6559: PUSH
6560: LD_INT 2
6562: ST_TO_ADDR
6563: GO 6573
// wght := 3 ; 1 :
6565: LD_ADDR_VAR 0 10
6569: PUSH
6570: LD_INT 3
6572: ST_TO_ADDR
6573: GO 6647
6575: LD_INT 1
6577: DOUBLE
6578: EQUAL
6579: IFTRUE 6583
6581: GO 6646
6583: POP
// if Rand ( 1 , 100 ) <= 80 then
6584: LD_INT 1
6586: PPUSH
6587: LD_INT 100
6589: PPUSH
6590: CALL_OW 12
6594: PUSH
6595: LD_INT 80
6597: LESSEQUAL
6598: IFFALSE 6610
// wght := 1 else
6600: LD_ADDR_VAR 0 10
6604: PUSH
6605: LD_INT 1
6607: ST_TO_ADDR
6608: GO 6644
// if Rand ( 1 , 100 ) <= 80 then
6610: LD_INT 1
6612: PPUSH
6613: LD_INT 100
6615: PPUSH
6616: CALL_OW 12
6620: PUSH
6621: LD_INT 80
6623: LESSEQUAL
6624: IFFALSE 6636
// wght := 2 else
6626: LD_ADDR_VAR 0 10
6630: PUSH
6631: LD_INT 2
6633: ST_TO_ADDR
6634: GO 6644
// wght := 3 ; end ;
6636: LD_ADDR_VAR 0 10
6640: PUSH
6641: LD_INT 3
6643: ST_TO_ADDR
6644: GO 6647
6646: POP
// if chassis [ nat ] [ wght ] [ trck ] then
6647: LD_EXP 70
6651: PUSH
6652: LD_VAR 0 3
6656: ARRAY
6657: PUSH
6658: LD_VAR 0 10
6662: ARRAY
6663: PUSH
6664: LD_VAR 0 12
6668: ARRAY
6669: IFFALSE 6733
// chs := chassis [ nat ] [ wght ] [ trck ] [ Rand ( 1 , chassis [ nat ] [ wght ] [ trck ] ) ] else
6671: LD_ADDR_VAR 0 11
6675: PUSH
6676: LD_EXP 70
6680: PUSH
6681: LD_VAR 0 3
6685: ARRAY
6686: PUSH
6687: LD_VAR 0 10
6691: ARRAY
6692: PUSH
6693: LD_VAR 0 12
6697: ARRAY
6698: PUSH
6699: LD_INT 1
6701: PPUSH
6702: LD_EXP 70
6706: PUSH
6707: LD_VAR 0 3
6711: ARRAY
6712: PUSH
6713: LD_VAR 0 10
6717: ARRAY
6718: PUSH
6719: LD_VAR 0 12
6723: ARRAY
6724: PPUSH
6725: CALL_OW 12
6729: ARRAY
6730: ST_TO_ADDR
6731: GO 6741
// chs := 0 ;
6733: LD_ADDR_VAR 0 11
6737: PUSH
6738: LD_INT 0
6740: ST_TO_ADDR
// until chs ;
6741: LD_VAR 0 11
6745: IFFALSE 6490
// uc_side := 0 ;
6747: LD_ADDR_OWVAR 20
6751: PUSH
6752: LD_INT 0
6754: ST_TO_ADDR
// uc_nation := nat ;
6755: LD_ADDR_OWVAR 21
6759: PUSH
6760: LD_VAR 0 3
6764: ST_TO_ADDR
// uc_direction := rand ( 0 , 5 ) ;
6765: LD_ADDR_OWVAR 24
6769: PUSH
6770: LD_INT 0
6772: PPUSH
6773: LD_INT 5
6775: PPUSH
6776: CALL_OW 12
6780: ST_TO_ADDR
// vc_chassis := chs ;
6781: LD_ADDR_OWVAR 37
6785: PUSH
6786: LD_VAR 0 11
6790: ST_TO_ADDR
// vc_weapon := weap ;
6791: LD_ADDR_OWVAR 40
6795: PUSH
6796: LD_VAR 0 8
6800: ST_TO_ADDR
// vc_control := control_manual ;
6801: LD_ADDR_OWVAR 38
6805: PUSH
6806: LD_INT 1
6808: ST_TO_ADDR
// case wght of 1 :
6809: LD_VAR 0 10
6813: PUSH
6814: LD_INT 1
6816: DOUBLE
6817: EQUAL
6818: IFTRUE 6822
6820: GO 6833
6822: POP
// vc_engine := engine_solar ; 2 , 3 :
6823: LD_ADDR_OWVAR 39
6827: PUSH
6828: LD_INT 2
6830: ST_TO_ADDR
6831: GO 6859
6833: LD_INT 2
6835: DOUBLE
6836: EQUAL
6837: IFTRUE 6847
6839: LD_INT 3
6841: DOUBLE
6842: EQUAL
6843: IFTRUE 6847
6845: GO 6858
6847: POP
// vc_engine := engine_siberite ; end ;
6848: LD_ADDR_OWVAR 39
6852: PUSH
6853: LD_INT 3
6855: ST_TO_ADDR
6856: GO 6859
6858: POP
// is_tracked := trck = 2 ;
6859: LD_ADDR_LOC 1
6863: PUSH
6864: LD_VAR 0 12
6868: PUSH
6869: LD_INT 2
6871: EQUAL
6872: ST_TO_ADDR
// end ;
6873: LD_VAR 0 2
6877: RET
// export function vehicles_create_vehicle ( atstart ) ; var v , ar ; begin
6878: LD_INT 0
6880: PPUSH
6881: PPUSH
6882: PPUSH
// if atstart then
6883: LD_VAR 0 1
6887: IFFALSE 6898
// random_vehicle ( 0 ) else
6889: LD_INT 0
6891: PPUSH
6892: CALL 6162 0 1
6896: GO 6907
// random_vehicle ( sibrock ) ;
6898: LD_EXP 68
6902: PPUSH
6903: CALL 6162 0 1
// v := CreateVehicle ;
6907: LD_ADDR_VAR 0 3
6911: PUSH
6912: CALL_OW 45
6916: ST_TO_ADDR
// if is_tracked then
6917: LD_LOC 1
6921: IFFALSE 6949
// ar := areas_tracked [ Rand ( 1 , areas_tracked ) ] else
6923: LD_ADDR_VAR 0 4
6927: PUSH
6928: LD_EXP 73
6932: PUSH
6933: LD_INT 1
6935: PPUSH
6936: LD_EXP 73
6940: PPUSH
6941: CALL_OW 12
6945: ARRAY
6946: ST_TO_ADDR
6947: GO 6973
// ar := areas_wheeled [ Rand ( 1 , areas_wheeled ) ] ;
6949: LD_ADDR_VAR 0 4
6953: PUSH
6954: LD_EXP 72
6958: PUSH
6959: LD_INT 1
6961: PPUSH
6962: LD_EXP 72
6966: PPUSH
6967: CALL_OW 12
6971: ARRAY
6972: ST_TO_ADDR
// PlaceUnitArea ( v , ar , not atstart ) ;
6973: LD_VAR 0 3
6977: PPUSH
6978: LD_VAR 0 4
6982: PPUSH
6983: LD_VAR 0 1
6987: NOT
6988: PPUSH
6989: CALL_OW 49
// end ;
6993: LD_VAR 0 2
6997: RET
// function prepare_vehicles ; var i ; begin
6998: LD_INT 0
7000: PPUSH
7001: PPUSH
// for i := 1 to startveh do
7002: LD_ADDR_VAR 0 2
7006: PUSH
7007: DOUBLE
7008: LD_INT 1
7010: DEC
7011: ST_TO_ADDR
7012: LD_EXP 63
7016: PUSH
7017: FOR_TO
7018: IFFALSE 7029
// begin vehicles_create_vehicle ( true ) ;
7020: LD_INT 1
7022: PPUSH
7023: CALL 6878 0 1
// end ;
7027: GO 7017
7029: POP
7030: POP
// end ;
7031: LD_VAR 0 1
7035: RET
// function set_attitudes ; var i , j ; begin
7036: LD_INT 0
7038: PPUSH
7039: PPUSH
7040: PPUSH
// if not Team_Game then
7041: LD_EXP 47
7045: NOT
7046: IFFALSE 7142
// begin for i = 1 to 8 do
7048: LD_ADDR_VAR 0 2
7052: PUSH
7053: DOUBLE
7054: LD_INT 1
7056: DEC
7057: ST_TO_ADDR
7058: LD_INT 8
7060: PUSH
7061: FOR_TO
7062: IFFALSE 7140
// for j = 1 to 8 do
7064: LD_ADDR_VAR 0 3
7068: PUSH
7069: DOUBLE
7070: LD_INT 1
7072: DEC
7073: ST_TO_ADDR
7074: LD_INT 8
7076: PUSH
7077: FOR_TO
7078: IFFALSE 7136
// if i <> j then
7080: LD_VAR 0 2
7084: PUSH
7085: LD_VAR 0 3
7089: NONEQUAL
7090: IFFALSE 7114
// SetAttitude ( i , j , att_enemy , true ) else
7092: LD_VAR 0 2
7096: PPUSH
7097: LD_VAR 0 3
7101: PPUSH
7102: LD_INT 2
7104: PPUSH
7105: LD_INT 1
7107: PPUSH
7108: CALL_OW 80
7112: GO 7134
// SetAttitude ( i , j , att_friend , true ) end ;
7114: LD_VAR 0 2
7118: PPUSH
7119: LD_VAR 0 3
7123: PPUSH
7124: LD_INT 1
7126: PPUSH
7127: LD_INT 1
7129: PPUSH
7130: CALL_OW 80
7134: GO 7077
7136: POP
7137: POP
7138: GO 7061
7140: POP
7141: POP
// end ;
7142: LD_VAR 0 1
7146: RET
// function prepare_side ( side ) ; var i ; begin
7147: LD_INT 0
7149: PPUSH
7150: PPUSH
// for i := 1 to npeop do
7151: LD_ADDR_VAR 0 3
7155: PUSH
7156: DOUBLE
7157: LD_INT 1
7159: DEC
7160: ST_TO_ADDR
7161: LD_EXP 65
7165: PUSH
7166: FOR_TO
7167: IFFALSE 7276
// begin uc_side := side ;
7169: LD_ADDR_OWVAR 20
7173: PUSH
7174: LD_VAR 0 1
7178: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
7179: LD_ADDR_OWVAR 21
7183: PUSH
7184: LD_EXP 44
7188: PUSH
7189: LD_VAR 0 1
7193: ARRAY
7194: ST_TO_ADDR
// hc_name :=  ;
7195: LD_ADDR_OWVAR 26
7199: PUSH
7200: LD_STRING 
7202: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
7203: LD_INT 0
7205: PPUSH
7206: LD_INT 4
7208: PPUSH
7209: CALL_OW 383
// hc_importance := 0 ;
7213: LD_ADDR_OWVAR 32
7217: PUSH
7218: LD_INT 0
7220: ST_TO_ADDR
// hc_gallery :=  ;
7221: LD_ADDR_OWVAR 33
7225: PUSH
7226: LD_STRING 
7228: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 4 , false ) ;
7229: CALL_OW 44
7233: PPUSH
7234: LD_EXP 34
7238: PUSH
7239: LD_VAR 0 1
7243: ARRAY
7244: PUSH
7245: LD_INT 1
7247: ARRAY
7248: PPUSH
7249: LD_EXP 34
7253: PUSH
7254: LD_VAR 0 1
7258: ARRAY
7259: PUSH
7260: LD_INT 2
7262: ARRAY
7263: PPUSH
7264: LD_INT 4
7266: PPUSH
7267: LD_INT 0
7269: PPUSH
7270: CALL_OW 50
// end ;
7274: GO 7166
7276: POP
7277: POP
// end ;
7278: LD_VAR 0 2
7282: RET
// function prepare_sides ; var i ; begin
7283: LD_INT 0
7285: PPUSH
7286: PPUSH
// for i := 1 to 8 do
7287: LD_ADDR_VAR 0 2
7291: PUSH
7292: DOUBLE
7293: LD_INT 1
7295: DEC
7296: ST_TO_ADDR
7297: LD_INT 8
7299: PUSH
7300: FOR_TO
7301: IFFALSE 7326
// if side_positions [ i ] then
7303: LD_EXP 43
7307: PUSH
7308: LD_VAR 0 2
7312: ARRAY
7313: IFFALSE 7324
// prepare_side ( i ) ;
7315: LD_VAR 0 2
7319: PPUSH
7320: CALL 7147 0 1
7324: GO 7300
7326: POP
7327: POP
// end ;
7328: LD_VAR 0 1
7332: RET
// export function starting_vehicles ; begin
7333: LD_INT 0
7335: PPUSH
// mp_with_score := true ;
7336: LD_ADDR_OWVAR 14
7340: PUSH
7341: LD_INT 1
7343: ST_TO_ADDR
// mp_selectmsg := true ;
7344: LD_ADDR_OWVAR 13
7348: PUSH
7349: LD_INT 1
7351: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
7352: CALL 4056 0 0
// prepare_map_coordinates ;
7356: CALL 5108 0 0
// prepare_constants ;
7360: CALL 5599 0 0
// set_attitudes ;
7364: CALL 7036 0 0
// prepare_sides ;
7368: CALL 7283 0 0
// prepare_vehicles ;
7372: CALL 6998 0 0
// SetAreaMapShow ( exitarea , 1 ) ;
7376: LD_INT 5
7378: PPUSH
7379: LD_INT 1
7381: PPUSH
7382: CALL_OW 424
// your_side := Player_Side ;
7386: LD_ADDR_OWVAR 2
7390: PUSH
7391: LD_EXP 39
7395: ST_TO_ADDR
// ResetFog ;
7396: CALL_OW 335
// music_nat := Side_Nations [ your_side ] ;
7400: LD_ADDR_OWVAR 71
7404: PUSH
7405: LD_EXP 44
7409: PUSH
7410: LD_OWVAR 2
7414: ARRAY
7415: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
7416: LD_EXP 34
7420: PUSH
7421: LD_OWVAR 2
7425: ARRAY
7426: PUSH
7427: LD_INT 1
7429: ARRAY
7430: PPUSH
7431: LD_EXP 34
7435: PUSH
7436: LD_OWVAR 2
7440: ARRAY
7441: PUSH
7442: LD_INT 2
7444: ARRAY
7445: PPUSH
7446: CALL_OW 86
// end ; end_of_file
7450: LD_VAR 0 1
7454: RET
// every 0 0$0.5 + 2 marked 15 do var t , red ;
7455: GO 7457
7457: DISABLE
7458: LD_INT 0
7460: PPUSH
7461: PPUSH
// begin if not prep_time then
7462: LD_EXP 32
7466: NOT
7467: IFFALSE 7471
// exit ;
7469: GO 7593
// if tick >= prep_time then
7471: LD_OWVAR 1
7475: PUSH
7476: LD_EXP 32
7480: GREATEREQUAL
7481: IFFALSE 7496
// begin display_strings = [ ] ;
7483: LD_ADDR_OWVAR 47
7487: PUSH
7488: EMPTY
7489: ST_TO_ADDR
// sheherezade_start_the_fight ;
7490: CALL 3720 0 0
// end else
7494: GO 7593
// begin t = prep_time - tick ;
7496: LD_ADDR_VAR 0 1
7500: PUSH
7501: LD_EXP 32
7505: PUSH
7506: LD_OWVAR 1
7510: MINUS
7511: ST_TO_ADDR
// if t <= 0 0$5.5 then
7512: LD_VAR 0 1
7516: PUSH
7517: LD_INT 192
7519: LESSEQUAL
7520: IFFALSE 7542
// red := t mod 0 0$1 < 0 0$0.5 else
7522: LD_ADDR_VAR 0 2
7526: PUSH
7527: LD_VAR 0 1
7531: PUSH
7532: LD_INT 35
7534: MOD
7535: PUSH
7536: LD_INT 18
7538: LESS
7539: ST_TO_ADDR
7540: GO 7550
// red := false ;
7542: LD_ADDR_VAR 0 2
7546: PUSH
7547: LD_INT 0
7549: ST_TO_ADDR
// if red then
7550: LD_VAR 0 2
7554: IFFALSE 7575
// display_strings = [ #Sheherezade-Time2 , t ] else
7556: LD_ADDR_OWVAR 47
7560: PUSH
7561: LD_STRING #Sheherezade-Time2
7563: PUSH
7564: LD_VAR 0 1
7568: PUSH
7569: EMPTY
7570: LIST
7571: LIST
7572: ST_TO_ADDR
7573: GO 7592
// display_strings = [ #Sheherezade-Time1 , t ] ;
7575: LD_ADDR_OWVAR 47
7579: PUSH
7580: LD_STRING #Sheherezade-Time1
7582: PUSH
7583: LD_VAR 0 1
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: ST_TO_ADDR
// enable ;
7592: ENABLE
// end ; end ;
7593: PPOPN 2
7595: END
// every 4 marked 15 do
7596: GO 7598
7598: DISABLE
// begin if tick < prep_time then
7599: LD_OWVAR 1
7603: PUSH
7604: LD_EXP 32
7608: LESS
7609: IFFALSE 7624
// begin SetLives ( all_units , 1000 ) ;
7611: LD_OWVAR 3
7615: PPUSH
7616: LD_INT 1000
7618: PPUSH
7619: CALL_OW 234
// enable ;
7623: ENABLE
// end ; end ; end_of_file
7624: END
// on ApemanTamed ( ape , sci ) do begin if gametype = 15 then
7625: LD_EXP 1
7629: PUSH
7630: LD_INT 15
7632: EQUAL
7633: IFFALSE 7657
// begin if not def_apemen_abilities then
7635: LD_EXP 12
7639: NOT
7640: IFFALSE 7645
// disable else
7642: DISABLE
7643: GO 7657
// begin SetClass ( ape , class_apeman_soldier ) ;
7645: LD_VAR 0 1
7649: PPUSH
7650: LD_INT 15
7652: PPUSH
7653: CALL_OW 336
// end ; end ; end ;
7657: PPOPN 2
7659: END
// on UnitGoesToRed ( un ) do var killer , victim , near ;
7660: LD_INT 0
7662: PPUSH
7663: PPUSH
7664: PPUSH
// begin if gametype = 15 then
7665: LD_EXP 1
7669: PUSH
7670: LD_INT 15
7672: EQUAL
7673: IFFALSE 7898
// if un in sheherezades then
7675: LD_VAR 0 1
7679: PUSH
7680: LD_EXP 35
7684: IN
7685: IFFALSE 7898
// begin victim := GetSide ( un ) ;
7687: LD_ADDR_VAR 0 3
7691: PUSH
7692: LD_VAR 0 1
7696: PPUSH
7697: CALL_OW 255
7701: ST_TO_ADDR
// near := NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , victim ] , f_not , [ f_side , 0 ] ] ) , un ) ;
7702: LD_ADDR_VAR 0 4
7706: PUSH
7707: LD_INT 3
7709: PUSH
7710: LD_INT 22
7712: PUSH
7713: LD_VAR 0 3
7717: PUSH
7718: EMPTY
7719: LIST
7720: LIST
7721: PUSH
7722: LD_INT 3
7724: PUSH
7725: LD_INT 22
7727: PUSH
7728: LD_INT 0
7730: PUSH
7731: EMPTY
7732: LIST
7733: LIST
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: LIST
7739: LIST
7740: PPUSH
7741: CALL_OW 69
7745: PPUSH
7746: LD_VAR 0 1
7750: PPUSH
7751: CALL_OW 74
7755: ST_TO_ADDR
// killer := GetSide ( near ) ;
7756: LD_ADDR_VAR 0 2
7760: PUSH
7761: LD_VAR 0 4
7765: PPUSH
7766: CALL_OW 255
7770: ST_TO_ADDR
// if your_side and ( your_side = victim ) then
7771: LD_OWVAR 2
7775: PUSH
7776: LD_OWVAR 2
7780: PUSH
7781: LD_VAR 0 3
7785: EQUAL
7786: AND
7787: IFFALSE 7816
// begin wait ( 0 0$3 ) ;
7789: LD_INT 105
7791: PPUSH
7792: CALL_OW 67
// if not multiplayer then
7796: LD_OWVAR 4
7800: NOT
7801: IFFALSE 7812
// msg ( You Lost ) else
7803: LD_STRING You Lost
7805: PPUSH
7806: CALL_OW 100
7810: GO 7816
// YouLostInMultiplayer ;
7812: CALL_OW 107
// end ; sheherezades := Replace ( sheherezades , victim , 0 ) ;
7816: LD_ADDR_EXP 35
7820: PUSH
7821: LD_EXP 35
7825: PPUSH
7826: LD_VAR 0 3
7830: PPUSH
7831: LD_INT 0
7833: PPUSH
7834: CALL_OW 1
7838: ST_TO_ADDR
// SetSide ( FilterAllUnits ( [ f_side , victim ] ) , killer ) ;
7839: LD_INT 22
7841: PUSH
7842: LD_VAR 0 3
7846: PUSH
7847: EMPTY
7848: LIST
7849: LIST
7850: PPUSH
7851: CALL_OW 69
7855: PPUSH
7856: LD_VAR 0 2
7860: PPUSH
7861: CALL_OW 235
// ComStop ( FilterAllUnits ( [ f_side , killer ] ) ) ;
7865: LD_INT 22
7867: PUSH
7868: LD_VAR 0 2
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: PPUSH
7877: CALL_OW 69
7881: PPUSH
7882: CALL_OW 141
// SetLives ( un , 0 ) ;
7886: LD_VAR 0 1
7890: PPUSH
7891: LD_INT 0
7893: PPUSH
7894: CALL_OW 234
// end ; end ;
7898: PPOPN 4
7900: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if gametype = 25 then
7901: LD_EXP 1
7905: PUSH
7906: LD_INT 25
7908: EQUAL
7909: IFFALSE 8006
// begin if origside = 0 then
7911: LD_VAR 0 3
7915: PUSH
7916: LD_INT 0
7918: EQUAL
7919: IFFALSE 7959
// begin SetTag ( vehnew , Rand ( 30 , 75 ) ) ;
7921: LD_VAR 0 1
7925: PPUSH
7926: LD_INT 30
7928: PPUSH
7929: LD_INT 75
7931: PPUSH
7932: CALL_OW 12
7936: PPUSH
7937: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
7941: LD_ADDR_EXP 90
7945: PUSH
7946: LD_EXP 90
7950: PUSH
7951: LD_VAR 0 1
7955: ADD
7956: ST_TO_ADDR
// end else
7957: GO 8006
// begin SetUnitDisplayNumber ( vehnew , 0 ) ;
7959: LD_VAR 0 1
7963: PPUSH
7964: LD_INT 0
7966: PPUSH
7967: CALL_OW 505
// SetTag ( vehnew , GetTag ( vehold ) ) ;
7971: LD_VAR 0 1
7975: PPUSH
7976: LD_VAR 0 2
7980: PPUSH
7981: CALL_OW 110
7985: PPUSH
7986: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
7990: LD_ADDR_EXP 90
7994: PUSH
7995: LD_EXP 90
7999: PUSH
8000: LD_VAR 0 1
8004: ADD
8005: ST_TO_ADDR
// end ; end end ; end_of_file
8006: PPOPN 4
8008: END
// every 0 0$1 marked 25 do var i , ends , best ;
8009: GO 8011
8011: DISABLE
8012: LD_INT 0
8014: PPUSH
8015: PPUSH
8016: PPUSH
// begin ends := false ;
8017: LD_ADDR_VAR 0 2
8021: PUSH
8022: LD_INT 0
8024: ST_TO_ADDR
// best := 0 ;
8025: LD_ADDR_VAR 0 3
8029: PUSH
8030: LD_INT 0
8032: ST_TO_ADDR
// for i := 1 to 8 do
8033: LD_ADDR_VAR 0 1
8037: PUSH
8038: DOUBLE
8039: LD_INT 1
8041: DEC
8042: ST_TO_ADDR
8043: LD_INT 8
8045: PUSH
8046: FOR_TO
8047: IFFALSE 8083
// if GetMultiScore ( i ) > best then
8049: LD_VAR 0 1
8053: PPUSH
8054: CALL_OW 507
8058: PUSH
8059: LD_VAR 0 3
8063: GREATER
8064: IFFALSE 8081
// best := GetMultiScore ( i ) ;
8066: LD_ADDR_VAR 0 3
8070: PUSH
8071: LD_VAR 0 1
8075: PPUSH
8076: CALL_OW 507
8080: ST_TO_ADDR
8081: GO 8046
8083: POP
8084: POP
// if point_limit then
8085: LD_EXP 57
8089: IFFALSE 8111
// if best > point_limit then
8091: LD_VAR 0 3
8095: PUSH
8096: LD_EXP 57
8100: GREATER
8101: IFFALSE 8111
// ends := true ;
8103: LD_ADDR_VAR 0 2
8107: PUSH
8108: LD_INT 1
8110: ST_TO_ADDR
// if game_time then
8111: LD_EXP 56
8115: IFFALSE 8137
// if game_time <= tick then
8117: LD_EXP 56
8121: PUSH
8122: LD_OWVAR 1
8126: LESSEQUAL
8127: IFFALSE 8137
// ends := true ;
8129: LD_ADDR_VAR 0 2
8133: PUSH
8134: LD_INT 1
8136: ST_TO_ADDR
// if ends then
8137: LD_VAR 0 2
8141: IFFALSE 8212
// begin if GetMultiScore ( your_side ) = best then
8143: LD_OWVAR 2
8147: PPUSH
8148: CALL_OW 507
8152: PUSH
8153: LD_VAR 0 3
8157: EQUAL
8158: IFFALSE 8186
// begin wait ( 0 0$1 ) ;
8160: LD_INT 35
8162: PPUSH
8163: CALL_OW 67
// if IAmServer then
8167: CALL_OW 518
8171: IFFALSE 8180
// wait ( 0 0$1 ) ;
8173: LD_INT 35
8175: PPUSH
8176: CALL_OW 67
// YouWinInMultiplayer ;
8180: CALL_OW 106
// end else
8184: GO 8210
// begin wait ( 0 0$1 ) ;
8186: LD_INT 35
8188: PPUSH
8189: CALL_OW 67
// if IAmServer then
8193: CALL_OW 518
8197: IFFALSE 8206
// wait ( 0 0$1 ) ;
8199: LD_INT 35
8201: PPUSH
8202: CALL_OW 67
// YouLostInMultiplayer ;
8206: CALL_OW 107
// end ; end else
8210: GO 8213
// enable ;
8212: ENABLE
// end ;
8213: PPOPN 3
8215: END
// every 0 0$3 marked 15 do var win , i ;
8216: GO 8218
8218: DISABLE
8219: LD_INT 0
8221: PPUSH
8222: PPUSH
// begin win := true ;
8223: LD_ADDR_VAR 0 1
8227: PUSH
8228: LD_INT 1
8230: ST_TO_ADDR
// for i = 1 to Side_Positions do
8231: LD_ADDR_VAR 0 2
8235: PUSH
8236: DOUBLE
8237: LD_INT 1
8239: DEC
8240: ST_TO_ADDR
8241: LD_EXP 43
8245: PUSH
8246: FOR_TO
8247: IFFALSE 8311
// if Side_Positions [ i ] and ( i <> your_side ) and MultiplayerSideAlive ( i ) then
8249: LD_EXP 43
8253: PUSH
8254: LD_VAR 0 2
8258: ARRAY
8259: PUSH
8260: LD_VAR 0 2
8264: PUSH
8265: LD_OWVAR 2
8269: NONEQUAL
8270: AND
8271: PUSH
8272: LD_VAR 0 2
8276: PPUSH
8277: CALL_OW 108
8281: AND
8282: IFFALSE 8309
// if not AlliedSides ( i , your_side ) then
8284: LD_VAR 0 2
8288: PPUSH
8289: LD_OWVAR 2
8293: PPUSH
8294: CALL 8349 0 2
8298: NOT
8299: IFFALSE 8309
// win := false ;
8301: LD_ADDR_VAR 0 1
8305: PUSH
8306: LD_INT 0
8308: ST_TO_ADDR
8309: GO 8246
8311: POP
8312: POP
// if win then
8313: LD_VAR 0 1
8317: IFFALSE 8345
// begin wait ( 0 0$3 ) ;
8319: LD_INT 105
8321: PPUSH
8322: CALL_OW 67
// YouWinInMultiplayer ;
8326: CALL_OW 106
// if IAmServer then
8330: CALL_OW 518
8334: IFFALSE 8343
// wait ( 0 0$1 ) ;
8336: LD_INT 35
8338: PPUSH
8339: CALL_OW 67
// exit ;
8343: GO 8346
// end ; enable ;
8345: ENABLE
// end ;
8346: PPOPN 2
8348: END
// function AlliedSides ( i , j ) ; var vysledek ; begin
8349: LD_INT 0
8351: PPUSH
8352: PPUSH
// vysledek := false ;
8353: LD_ADDR_VAR 0 4
8357: PUSH
8358: LD_INT 0
8360: ST_TO_ADDR
// if ( GetAttitude ( i , j ) = att_friend ) and ( GetAttitude ( j , i ) = att_friend ) and GetAlliedVictory ( i ) and GetAlliedVictory ( j ) then
8361: LD_VAR 0 1
8365: PPUSH
8366: LD_VAR 0 2
8370: PPUSH
8371: CALL_OW 81
8375: PUSH
8376: LD_INT 1
8378: EQUAL
8379: PUSH
8380: LD_VAR 0 2
8384: PPUSH
8385: LD_VAR 0 1
8389: PPUSH
8390: CALL_OW 81
8394: PUSH
8395: LD_INT 1
8397: EQUAL
8398: AND
8399: PUSH
8400: LD_VAR 0 1
8404: PPUSH
8405: CALL_OW 83
8409: AND
8410: PUSH
8411: LD_VAR 0 2
8415: PPUSH
8416: CALL_OW 83
8420: AND
8421: IFFALSE 8431
// vysledek := true ;
8423: LD_ADDR_VAR 0 4
8427: PUSH
8428: LD_INT 1
8430: ST_TO_ADDR
// result := vysledek ;
8431: LD_ADDR_VAR 0 3
8435: PUSH
8436: LD_VAR 0 4
8440: ST_TO_ADDR
// end ; end_of_file
8441: LD_VAR 0 3
8445: RET
// export def_hunters , def_hunt_size , def_hunt_balance , def_hunt_limit , def_doctors ; export one_hunter , hunt_limit , size_of_ape_team , size_of_hunt_team , doctors_in_team , hunter_level , ape_level , ape_stamina , to_be_alone , people , scorestring ; function read_multiplayer_and_game_parameters ; var i , p1 , p2 ; begin
8446: LD_INT 0
8448: PPUSH
8449: PPUSH
8450: PPUSH
8451: PPUSH
// if MultiPlayer then
8452: LD_OWVAR 4
8456: IFFALSE 8520
// begin Player_Side = mp_player_side ;
8458: LD_ADDR_EXP 39
8462: PUSH
8463: LD_OWVAR 7
8467: ST_TO_ADDR
// Player_Team = mp_player_team ;
8468: LD_ADDR_EXP 40
8472: PUSH
8473: LD_OWVAR 8
8477: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
8478: LD_ADDR_EXP 43
8482: PUSH
8483: LD_OWVAR 17
8487: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
8488: LD_ADDR_EXP 41
8492: PUSH
8493: LD_OWVAR 15
8497: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
8498: LD_ADDR_EXP 44
8502: PUSH
8503: LD_OWVAR 16
8507: ST_TO_ADDR
// Teams = mp_teams ;
8508: LD_ADDR_EXP 42
8512: PUSH
8513: LD_OWVAR 12
8517: ST_TO_ADDR
// end else
8518: GO 8664
// begin randomize ;
8520: CALL_OW 10
// Player_Side = 1 ;
8524: LD_ADDR_EXP 39
8528: PUSH
8529: LD_INT 1
8531: ST_TO_ADDR
// Player_Team = 0 ;
8532: LD_ADDR_EXP 40
8536: PUSH
8537: LD_INT 0
8539: ST_TO_ADDR
// Side_Positions = [ 1 , 3 , 6 , 0 , 0 , 0 , 0 , 7 ] ;
8540: LD_ADDR_EXP 43
8544: PUSH
8545: LD_INT 1
8547: PUSH
8548: LD_INT 3
8550: PUSH
8551: LD_INT 6
8553: PUSH
8554: LD_INT 0
8556: PUSH
8557: LD_INT 0
8559: PUSH
8560: LD_INT 0
8562: PUSH
8563: LD_INT 0
8565: PUSH
8566: LD_INT 7
8568: PUSH
8569: EMPTY
8570: LIST
8571: LIST
8572: LIST
8573: LIST
8574: LIST
8575: LIST
8576: LIST
8577: LIST
8578: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
8579: LD_ADDR_EXP 41
8583: PUSH
8584: LD_INT 0
8586: PUSH
8587: LD_INT 0
8589: PUSH
8590: LD_INT 0
8592: PUSH
8593: LD_INT 0
8595: PUSH
8596: LD_INT 0
8598: PUSH
8599: LD_INT 0
8601: PUSH
8602: LD_INT 0
8604: PUSH
8605: LD_INT 0
8607: PUSH
8608: EMPTY
8609: LIST
8610: LIST
8611: LIST
8612: LIST
8613: LIST
8614: LIST
8615: LIST
8616: LIST
8617: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 2 , 2 , 2 , 2 ] ;
8618: LD_ADDR_EXP 44
8622: PUSH
8623: LD_INT 1
8625: PUSH
8626: LD_INT 3
8628: PUSH
8629: LD_INT 1
8631: PUSH
8632: LD_INT 2
8634: PUSH
8635: LD_INT 2
8637: PUSH
8638: LD_INT 2
8640: PUSH
8641: LD_INT 2
8643: PUSH
8644: LD_INT 2
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: LIST
8651: LIST
8652: LIST
8653: LIST
8654: LIST
8655: LIST
8656: ST_TO_ADDR
// Teams = [ ] ;
8657: LD_ADDR_EXP 42
8661: PUSH
8662: EMPTY
8663: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
8664: LD_ADDR_EXP 37
8668: PUSH
8669: LD_EXP 43
8673: PUSH
8674: LD_INT 0
8676: PUSH
8677: EMPTY
8678: LIST
8679: DIFF
8680: PUSH
8681: LD_INT 0
8683: PLUS
8684: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
8685: LD_ADDR_EXP 38
8689: PUSH
8690: LD_EXP 41
8694: PUSH
8695: LD_INT 0
8697: PUSH
8698: EMPTY
8699: LIST
8700: DIFF
8701: PUSH
8702: LD_INT 0
8704: PLUS
8705: ST_TO_ADDR
// if MultiPlayer then
8706: LD_OWVAR 4
8710: IFFALSE 8766
// begin def_hunt_size = GetMultiplayerSetting ( 1 ) ;
8712: LD_ADDR_EXP 75
8716: PUSH
8717: LD_INT 1
8719: PPUSH
8720: CALL_OW 426
8724: ST_TO_ADDR
// def_hunt_balance = GetMultiplayerSetting ( 2 ) ;
8725: LD_ADDR_EXP 76
8729: PUSH
8730: LD_INT 2
8732: PPUSH
8733: CALL_OW 426
8737: ST_TO_ADDR
// def_hunt_limit = GetMultiplayerSetting ( 3 ) ;
8738: LD_ADDR_EXP 77
8742: PUSH
8743: LD_INT 3
8745: PPUSH
8746: CALL_OW 426
8750: ST_TO_ADDR
// def_doctors = GetMultiplayerSetting ( 4 ) ;
8751: LD_ADDR_EXP 78
8755: PUSH
8756: LD_INT 4
8758: PPUSH
8759: CALL_OW 426
8763: ST_TO_ADDR
// end else
8764: GO 8802
// begin randomize ;
8766: CALL_OW 10
// def_hunt_size = 1 ;
8770: LD_ADDR_EXP 75
8774: PUSH
8775: LD_INT 1
8777: ST_TO_ADDR
// def_hunt_balance = 1 ;
8778: LD_ADDR_EXP 76
8782: PUSH
8783: LD_INT 1
8785: ST_TO_ADDR
// def_hunt_limit = 1 ;
8786: LD_ADDR_EXP 77
8790: PUSH
8791: LD_INT 1
8793: ST_TO_ADDR
// def_doctors = 1 ;
8794: LD_ADDR_EXP 78
8798: PUSH
8799: LD_INT 1
8801: ST_TO_ADDR
// end ; one_hunter = gametype = 36 ;
8802: LD_ADDR_EXP 79
8806: PUSH
8807: LD_EXP 1
8811: PUSH
8812: LD_INT 36
8814: EQUAL
8815: ST_TO_ADDR
// if one_hunter then
8816: LD_EXP 79
8820: IFFALSE 9093
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
8822: LD_ADDR_EXP 80
8826: PUSH
8827: LD_INT 4200
8829: PUSH
8830: LD_INT 6300
8832: PUSH
8833: LD_INT 8400
8835: PUSH
8836: LD_INT 10500
8838: PUSH
8839: EMPTY
8840: LIST
8841: LIST
8842: LIST
8843: LIST
8844: PUSH
8845: LD_EXP 77
8849: PUSH
8850: LD_INT 1
8852: PLUS
8853: ARRAY
8854: ST_TO_ADDR
// p1 = [ 6 , 10 , 12 ] [ def_hunt_size + 1 ] ;
8855: LD_ADDR_VAR 0 3
8859: PUSH
8860: LD_INT 6
8862: PUSH
8863: LD_INT 10
8865: PUSH
8866: LD_INT 12
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: LIST
8873: PUSH
8874: LD_EXP 75
8878: PUSH
8879: LD_INT 1
8881: PLUS
8882: ARRAY
8883: ST_TO_ADDR
// p2 = [ 2 , 4 , 6 ] [ def_hunt_size + 1 ] ;
8884: LD_ADDR_VAR 0 4
8888: PUSH
8889: LD_INT 2
8891: PUSH
8892: LD_INT 4
8894: PUSH
8895: LD_INT 6
8897: PUSH
8898: EMPTY
8899: LIST
8900: LIST
8901: LIST
8902: PUSH
8903: LD_EXP 75
8907: PUSH
8908: LD_INT 1
8910: PLUS
8911: ARRAY
8912: ST_TO_ADDR
// size_of_ape_team = p1 div side_count + p2 ;
8913: LD_ADDR_EXP 81
8917: PUSH
8918: LD_VAR 0 3
8922: PUSH
8923: LD_EXP 37
8927: DIV
8928: PUSH
8929: LD_VAR 0 4
8933: PLUS
8934: ST_TO_ADDR
// size_of_hunt_team = size_of_ape_team * ( side_count - 1 ) ;
8935: LD_ADDR_EXP 82
8939: PUSH
8940: LD_EXP 81
8944: PUSH
8945: LD_EXP 37
8949: PUSH
8950: LD_INT 1
8952: MINUS
8953: MUL
8954: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
8955: LD_ADDR_EXP 83
8959: PUSH
8960: LD_INT 0
8962: PUSH
8963: LD_EXP 82
8967: PUSH
8968: LD_INT 5
8970: PLUS
8971: PUSH
8972: LD_INT 6
8974: DIV
8975: PUSH
8976: LD_EXP 82
8980: PUSH
8981: LD_INT 3
8983: PLUS
8984: PUSH
8985: LD_INT 4
8987: DIV
8988: PUSH
8989: EMPTY
8990: LIST
8991: LIST
8992: LIST
8993: PUSH
8994: LD_EXP 78
8998: PUSH
8999: LD_INT 1
9001: PLUS
9002: ARRAY
9003: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
9004: LD_ADDR_EXP 84
9008: PUSH
9009: LD_INT 5
9011: PUSH
9012: LD_INT 3
9014: PUSH
9015: LD_INT 1
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: LIST
9022: PUSH
9023: LD_EXP 76
9027: PUSH
9028: LD_INT 1
9030: PLUS
9031: ARRAY
9032: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9033: LD_ADDR_EXP 85
9037: PUSH
9038: LD_INT 1
9040: PUSH
9041: LD_INT 2
9043: PUSH
9044: LD_INT 3
9046: PUSH
9047: EMPTY
9048: LIST
9049: LIST
9050: LIST
9051: PUSH
9052: LD_EXP 76
9056: PUSH
9057: LD_INT 1
9059: PLUS
9060: ARRAY
9061: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9062: LD_ADDR_EXP 86
9066: PUSH
9067: LD_INT 6
9069: PUSH
9070: LD_INT 10
9072: PUSH
9073: LD_INT 13
9075: PUSH
9076: EMPTY
9077: LIST
9078: LIST
9079: LIST
9080: PUSH
9081: LD_EXP 76
9085: PUSH
9086: LD_INT 1
9088: PLUS
9089: ARRAY
9090: ST_TO_ADDR
// end else
9091: GO 9372
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
9093: LD_ADDR_EXP 80
9097: PUSH
9098: LD_INT 4200
9100: PUSH
9101: LD_INT 6300
9103: PUSH
9104: LD_INT 8400
9106: PUSH
9107: LD_INT 10500
9109: PUSH
9110: EMPTY
9111: LIST
9112: LIST
9113: LIST
9114: LIST
9115: PUSH
9116: LD_EXP 77
9120: PUSH
9121: LD_INT 1
9123: PLUS
9124: ARRAY
9125: ST_TO_ADDR
// p1 = [ 10 , 15 , 20 ] [ def_hunt_size + 1 ] ;
9126: LD_ADDR_VAR 0 3
9130: PUSH
9131: LD_INT 10
9133: PUSH
9134: LD_INT 15
9136: PUSH
9137: LD_INT 20
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: LIST
9144: PUSH
9145: LD_EXP 75
9149: PUSH
9150: LD_INT 1
9152: PLUS
9153: ARRAY
9154: ST_TO_ADDR
// p2 = [ 3 , 5 , 7 ] [ def_hunt_size + 1 ] ;
9155: LD_ADDR_VAR 0 4
9159: PUSH
9160: LD_INT 3
9162: PUSH
9163: LD_INT 5
9165: PUSH
9166: LD_INT 7
9168: PUSH
9169: EMPTY
9170: LIST
9171: LIST
9172: LIST
9173: PUSH
9174: LD_EXP 75
9178: PUSH
9179: LD_INT 1
9181: PLUS
9182: ARRAY
9183: ST_TO_ADDR
// size_of_hunt_team = p1 div side_count + p2 ;
9184: LD_ADDR_EXP 82
9188: PUSH
9189: LD_VAR 0 3
9193: PUSH
9194: LD_EXP 37
9198: DIV
9199: PUSH
9200: LD_VAR 0 4
9204: PLUS
9205: ST_TO_ADDR
// size_of_ape_team = ( size_of_hunt_team + size_of_hunt_team * ( side_count - 1 ) ) div 2 ;
9206: LD_ADDR_EXP 81
9210: PUSH
9211: LD_EXP 82
9215: PUSH
9216: LD_EXP 82
9220: PUSH
9221: LD_EXP 37
9225: PUSH
9226: LD_INT 1
9228: MINUS
9229: MUL
9230: PLUS
9231: PUSH
9232: LD_INT 2
9234: DIV
9235: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
9236: LD_ADDR_EXP 83
9240: PUSH
9241: LD_INT 0
9243: PUSH
9244: LD_EXP 82
9248: PUSH
9249: LD_INT 5
9251: PLUS
9252: PUSH
9253: LD_INT 6
9255: DIV
9256: PUSH
9257: LD_EXP 82
9261: PUSH
9262: LD_INT 3
9264: PLUS
9265: PUSH
9266: LD_INT 4
9268: DIV
9269: PUSH
9270: EMPTY
9271: LIST
9272: LIST
9273: LIST
9274: PUSH
9275: LD_EXP 78
9279: PUSH
9280: LD_INT 1
9282: PLUS
9283: ARRAY
9284: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
9285: LD_ADDR_EXP 84
9289: PUSH
9290: LD_INT 5
9292: PUSH
9293: LD_INT 3
9295: PUSH
9296: LD_INT 1
9298: PUSH
9299: EMPTY
9300: LIST
9301: LIST
9302: LIST
9303: PUSH
9304: LD_EXP 76
9308: PUSH
9309: LD_INT 1
9311: PLUS
9312: ARRAY
9313: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9314: LD_ADDR_EXP 85
9318: PUSH
9319: LD_INT 1
9321: PUSH
9322: LD_INT 2
9324: PUSH
9325: LD_INT 3
9327: PUSH
9328: EMPTY
9329: LIST
9330: LIST
9331: LIST
9332: PUSH
9333: LD_EXP 76
9337: PUSH
9338: LD_INT 1
9340: PLUS
9341: ARRAY
9342: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9343: LD_ADDR_EXP 86
9347: PUSH
9348: LD_INT 6
9350: PUSH
9351: LD_INT 10
9353: PUSH
9354: LD_INT 13
9356: PUSH
9357: EMPTY
9358: LIST
9359: LIST
9360: LIST
9361: PUSH
9362: LD_EXP 76
9366: PUSH
9367: LD_INT 1
9369: PLUS
9370: ARRAY
9371: ST_TO_ADDR
// end ; for i = 1 to 8 do
9372: LD_ADDR_VAR 0 2
9376: PUSH
9377: DOUBLE
9378: LD_INT 1
9380: DEC
9381: ST_TO_ADDR
9382: LD_INT 8
9384: PUSH
9385: FOR_TO
9386: IFFALSE 9418
// if Side_Positions [ i ] then
9388: LD_EXP 43
9392: PUSH
9393: LD_VAR 0 2
9397: ARRAY
9398: IFFALSE 9416
// to_be_alone := to_be_alone ^ i ;
9400: LD_ADDR_EXP 87
9404: PUSH
9405: LD_EXP 87
9409: PUSH
9410: LD_VAR 0 2
9414: ADD
9415: ST_TO_ADDR
9416: GO 9385
9418: POP
9419: POP
// end ;
9420: LD_VAR 0 1
9424: RET
// function prepare_hunter_team ( side ) ; var i , team ; begin
9425: LD_INT 0
9427: PPUSH
9428: PPUSH
9429: PPUSH
// team := [ ] ;
9430: LD_ADDR_VAR 0 4
9434: PUSH
9435: EMPTY
9436: ST_TO_ADDR
// for i := 1 to size_of_hunt_team do
9437: LD_ADDR_VAR 0 3
9441: PUSH
9442: DOUBLE
9443: LD_INT 1
9445: DEC
9446: ST_TO_ADDR
9447: LD_EXP 82
9451: PUSH
9452: FOR_TO
9453: IFFALSE 9570
// begin uc_nation := side_nations [ side ] ;
9455: LD_ADDR_OWVAR 21
9459: PUSH
9460: LD_EXP 44
9464: PUSH
9465: LD_VAR 0 1
9469: ARRAY
9470: ST_TO_ADDR
// uc_side := side ;
9471: LD_ADDR_OWVAR 20
9475: PUSH
9476: LD_VAR 0 1
9480: ST_TO_ADDR
// hc_name :=  ;
9481: LD_ADDR_OWVAR 26
9485: PUSH
9486: LD_STRING 
9488: ST_TO_ADDR
// if i > size_of_hunt_team - doctors_in_team then
9489: LD_VAR 0 3
9493: PUSH
9494: LD_EXP 82
9498: PUSH
9499: LD_EXP 83
9503: MINUS
9504: GREATER
9505: IFFALSE 9521
// PrepareScientist ( 0 , hunter_level ) else
9507: LD_INT 0
9509: PPUSH
9510: LD_EXP 84
9514: PPUSH
9515: CALL_OW 384
9519: GO 9533
// PrepareSoldier ( 0 , hunter_level ) ;
9521: LD_INT 0
9523: PPUSH
9524: LD_EXP 84
9528: PPUSH
9529: CALL_OW 381
// hc_gallery :=  ;
9533: LD_ADDR_OWVAR 33
9537: PUSH
9538: LD_STRING 
9540: ST_TO_ADDR
// hc_importance := 0 ;
9541: LD_ADDR_OWVAR 32
9545: PUSH
9546: LD_INT 0
9548: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9549: LD_ADDR_VAR 0 4
9553: PUSH
9554: LD_VAR 0 4
9558: PUSH
9559: CALL_OW 44
9563: PUSH
9564: EMPTY
9565: LIST
9566: ADD
9567: ST_TO_ADDR
// end ;
9568: GO 9452
9570: POP
9571: POP
// people := Replace ( people , side , team ) ;
9572: LD_ADDR_EXP 88
9576: PUSH
9577: LD_EXP 88
9581: PPUSH
9582: LD_VAR 0 1
9586: PPUSH
9587: LD_VAR 0 4
9591: PPUSH
9592: CALL_OW 1
9596: ST_TO_ADDR
// end ;
9597: LD_VAR 0 2
9601: RET
// function prepare_ape_team ( side ) ; var i , team ; begin
9602: LD_INT 0
9604: PPUSH
9605: PPUSH
9606: PPUSH
// team := [ ] ;
9607: LD_ADDR_VAR 0 4
9611: PUSH
9612: EMPTY
9613: ST_TO_ADDR
// for i := 1 to size_of_ape_team do
9614: LD_ADDR_VAR 0 3
9618: PUSH
9619: DOUBLE
9620: LD_INT 1
9622: DEC
9623: ST_TO_ADDR
9624: LD_EXP 81
9628: PUSH
9629: FOR_TO
9630: IFFALSE 9753
// begin uc_nation := nation_nature ;
9632: LD_ADDR_OWVAR 21
9636: PUSH
9637: LD_INT 0
9639: ST_TO_ADDR
// uc_side := side ;
9640: LD_ADDR_OWVAR 20
9644: PUSH
9645: LD_VAR 0 1
9649: ST_TO_ADDR
// hc_name :=  ;
9650: LD_ADDR_OWVAR 26
9654: PUSH
9655: LD_STRING 
9657: ST_TO_ADDR
// hc_attr := [ ape_stamina , 14 ] ;
9658: LD_ADDR_OWVAR 29
9662: PUSH
9663: LD_EXP 86
9667: PUSH
9668: LD_INT 14
9670: PUSH
9671: EMPTY
9672: LIST
9673: LIST
9674: ST_TO_ADDR
// hc_skills := [ ape_level , 0 , 0 , 0 ] ;
9675: LD_ADDR_OWVAR 31
9679: PUSH
9680: LD_EXP 85
9684: PUSH
9685: LD_INT 0
9687: PUSH
9688: LD_INT 0
9690: PUSH
9691: LD_INT 0
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: LIST
9698: LIST
9699: ST_TO_ADDR
// hc_sex := sex_male ;
9700: LD_ADDR_OWVAR 27
9704: PUSH
9705: LD_INT 1
9707: ST_TO_ADDR
// hc_class := class_apeman ;
9708: LD_ADDR_OWVAR 28
9712: PUSH
9713: LD_INT 12
9715: ST_TO_ADDR
// hc_gallery :=  ;
9716: LD_ADDR_OWVAR 33
9720: PUSH
9721: LD_STRING 
9723: ST_TO_ADDR
// hc_importance := 0 ;
9724: LD_ADDR_OWVAR 32
9728: PUSH
9729: LD_INT 0
9731: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9732: LD_ADDR_VAR 0 4
9736: PUSH
9737: LD_VAR 0 4
9741: PUSH
9742: CALL_OW 44
9746: PUSH
9747: EMPTY
9748: LIST
9749: ADD
9750: ST_TO_ADDR
// end ;
9751: GO 9629
9753: POP
9754: POP
// people := Replace ( people , side , team ) ;
9755: LD_ADDR_EXP 88
9759: PUSH
9760: LD_EXP 88
9764: PPUSH
9765: LD_VAR 0 1
9769: PPUSH
9770: LD_VAR 0 4
9774: PPUSH
9775: CALL_OW 1
9779: ST_TO_ADDR
// end ;
9780: LD_VAR 0 2
9784: RET
// function display_score ( alone , t ) ; begin
9785: LD_INT 0
9787: PPUSH
// display_strings := scorestring ^  ;
9788: LD_ADDR_OWVAR 47
9792: PUSH
9793: LD_EXP 89
9797: PUSH
9798: LD_STRING 
9800: ADD
9801: ST_TO_ADDR
// if alone then
9802: LD_VAR 0 1
9806: IFFALSE 9886
// if one_hunter then
9808: LD_EXP 79
9812: IFFALSE 9851
// display_strings := display_strings ^ [ #Hunt-prepare2 , alone , alone , t ] else
9814: LD_ADDR_OWVAR 47
9818: PUSH
9819: LD_OWVAR 47
9823: PUSH
9824: LD_STRING #Hunt-prepare2
9826: PUSH
9827: LD_VAR 0 1
9831: PUSH
9832: LD_VAR 0 1
9836: PUSH
9837: LD_VAR 0 2
9841: PUSH
9842: EMPTY
9843: LIST
9844: LIST
9845: LIST
9846: LIST
9847: ADD
9848: ST_TO_ADDR
9849: GO 9886
// display_strings := display_strings ^ [ #Hunt-prepare1 , alone , alone , t ] ;
9851: LD_ADDR_OWVAR 47
9855: PUSH
9856: LD_OWVAR 47
9860: PUSH
9861: LD_STRING #Hunt-prepare1
9863: PUSH
9864: LD_VAR 0 1
9868: PUSH
9869: LD_VAR 0 1
9873: PUSH
9874: LD_VAR 0 2
9878: PUSH
9879: EMPTY
9880: LIST
9881: LIST
9882: LIST
9883: LIST
9884: ADD
9885: ST_TO_ADDR
// end ;
9886: LD_VAR 0 3
9890: RET
// function set_attitudes ( alone ) ; var i , j ; begin
9891: LD_INT 0
9893: PPUSH
9894: PPUSH
9895: PPUSH
// for i := 1 to 8 do
9896: LD_ADDR_VAR 0 3
9900: PUSH
9901: DOUBLE
9902: LD_INT 1
9904: DEC
9905: ST_TO_ADDR
9906: LD_INT 8
9908: PUSH
9909: FOR_TO
9910: IFFALSE 10000
// for j := 1 to 8 do
9912: LD_ADDR_VAR 0 4
9916: PUSH
9917: DOUBLE
9918: LD_INT 1
9920: DEC
9921: ST_TO_ADDR
9922: LD_INT 8
9924: PUSH
9925: FOR_TO
9926: IFFALSE 9996
// if ( i = alone ) = ( j = alone ) then
9928: LD_VAR 0 3
9932: PUSH
9933: LD_VAR 0 1
9937: EQUAL
9938: PUSH
9939: LD_VAR 0 4
9943: PUSH
9944: LD_VAR 0 1
9948: EQUAL
9949: EQUAL
9950: IFFALSE 9974
// SetAttitude ( i , j , att_friend , true ) else
9952: LD_VAR 0 3
9956: PPUSH
9957: LD_VAR 0 4
9961: PPUSH
9962: LD_INT 1
9964: PPUSH
9965: LD_INT 1
9967: PPUSH
9968: CALL_OW 80
9972: GO 9994
// SetAttitude ( i , j , att_enemy , true ) ;
9974: LD_VAR 0 3
9978: PPUSH
9979: LD_VAR 0 4
9983: PPUSH
9984: LD_INT 2
9986: PPUSH
9987: LD_INT 1
9989: PPUSH
9990: CALL_OW 80
9994: GO 9925
9996: POP
9997: POP
9998: GO 9909
10000: POP
10001: POP
// end ;
10002: LD_VAR 0 2
10006: RET
// function set_technologies ( alone ) ; var i ; begin
10007: LD_INT 0
10009: PPUSH
10010: PPUSH
// for i := 1 to 8 do
10011: LD_ADDR_VAR 0 3
10015: PUSH
10016: DOUBLE
10017: LD_INT 1
10019: DEC
10020: ST_TO_ADDR
10021: LD_INT 8
10023: PUSH
10024: FOR_TO
10025: IFFALSE 10214
// begin if ( alone = i ) = one_hunter then
10027: LD_VAR 0 1
10031: PUSH
10032: LD_VAR 0 3
10036: EQUAL
10037: PUSH
10038: LD_EXP 79
10042: EQUAL
10043: IFFALSE 10107
// begin SetTech ( tech_Opto1 , i , state_disabled ) ;
10045: LD_INT 60
10047: PPUSH
10048: LD_VAR 0 3
10052: PPUSH
10053: LD_INT 0
10055: PPUSH
10056: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_disabled ) ;
10060: LD_INT 61
10062: PPUSH
10063: LD_VAR 0 3
10067: PPUSH
10068: LD_INT 0
10070: PPUSH
10071: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_disabled ) ;
10075: LD_INT 62
10077: PPUSH
10078: LD_VAR 0 3
10082: PPUSH
10083: LD_INT 0
10085: PPUSH
10086: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_disabled ) ;
10090: LD_INT 5
10092: PPUSH
10093: LD_VAR 0 3
10097: PPUSH
10098: LD_INT 0
10100: PPUSH
10101: CALL_OW 322
// end else
10105: GO 10167
// begin SetTech ( tech_Opto1 , i , state_researched ) ;
10107: LD_INT 60
10109: PPUSH
10110: LD_VAR 0 3
10114: PPUSH
10115: LD_INT 2
10117: PPUSH
10118: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_researched ) ;
10122: LD_INT 61
10124: PPUSH
10125: LD_VAR 0 3
10129: PPUSH
10130: LD_INT 2
10132: PPUSH
10133: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_researched ) ;
10137: LD_INT 62
10139: PPUSH
10140: LD_VAR 0 3
10144: PPUSH
10145: LD_INT 2
10147: PPUSH
10148: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_researched ) ;
10152: LD_INT 5
10154: PPUSH
10155: LD_VAR 0 3
10159: PPUSH
10160: LD_INT 2
10162: PPUSH
10163: CALL_OW 322
// end ; SetTech ( tech_Weap1 , i , state_disabled ) ;
10167: LD_INT 51
10169: PPUSH
10170: LD_VAR 0 3
10174: PPUSH
10175: LD_INT 0
10177: PPUSH
10178: CALL_OW 322
// SetTech ( tech_Weap2 , i , state_disabled ) ;
10182: LD_INT 52
10184: PPUSH
10185: LD_VAR 0 3
10189: PPUSH
10190: LD_INT 0
10192: PPUSH
10193: CALL_OW 322
// SetTech ( tech_Weap3 , i , state_disabled ) ;
10197: LD_INT 53
10199: PPUSH
10200: LD_VAR 0 3
10204: PPUSH
10205: LD_INT 0
10207: PPUSH
10208: CALL_OW 322
// end ;
10212: GO 10024
10214: POP
10215: POP
// end ;
10216: LD_VAR 0 2
10220: RET
// function prepare_map_coordinates_more_hunters ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10221: LD_INT 0
10223: PPUSH
10224: PPUSH
10225: PPUSH
10226: PPUSH
10227: PPUSH
10228: PPUSH
10229: PPUSH
10230: PPUSH
// best = 0 ;
10231: LD_ADDR_VAR 0 3
10235: PUSH
10236: LD_INT 0
10238: ST_TO_ADDR
// for n = 1 to 40 do
10239: LD_ADDR_VAR 0 9
10243: PUSH
10244: DOUBLE
10245: LD_INT 1
10247: DEC
10248: ST_TO_ADDR
10249: LD_INT 40
10251: PUSH
10252: FOR_TO
10253: IFFALSE 10561
// begin c = [ ] ;
10255: LD_ADDR_VAR 0 4
10259: PUSH
10260: EMPTY
10261: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10262: LD_ADDR_VAR 0 7
10266: PUSH
10267: DOUBLE
10268: LD_INT 1
10270: DEC
10271: ST_TO_ADDR
10272: LD_EXP 37
10276: PUSH
10277: LD_INT 1
10279: MINUS
10280: PUSH
10281: FOR_TO
10282: IFFALSE 10311
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
10284: LD_ADDR_VAR 0 4
10288: PUSH
10289: LD_VAR 0 4
10293: PUSH
10294: LD_INT 22
10296: PPUSH
10297: LD_INT 0
10299: PPUSH
10300: CALL_OW 16
10304: PUSH
10305: EMPTY
10306: LIST
10307: ADD
10308: ST_TO_ADDR
10309: GO 10281
10311: POP
10312: POP
// minv = 10000 ;
10313: LD_ADDR_VAR 0 6
10317: PUSH
10318: LD_INT 10000
10320: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10321: LD_ADDR_VAR 0 7
10325: PUSH
10326: DOUBLE
10327: LD_INT 1
10329: DEC
10330: ST_TO_ADDR
10331: LD_EXP 37
10335: PUSH
10336: LD_INT 1
10338: MINUS
10339: PUSH
10340: FOR_TO
10341: IFFALSE 10525
// for j = 1 to side_count - 1 do
10343: LD_ADDR_VAR 0 8
10347: PUSH
10348: DOUBLE
10349: LD_INT 1
10351: DEC
10352: ST_TO_ADDR
10353: LD_EXP 37
10357: PUSH
10358: LD_INT 1
10360: MINUS
10361: PUSH
10362: FOR_TO
10363: IFFALSE 10521
// if i <> j then
10365: LD_VAR 0 7
10369: PUSH
10370: LD_VAR 0 8
10374: NONEQUAL
10375: IFFALSE 10519
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10377: LD_VAR 0 4
10381: PUSH
10382: LD_VAR 0 7
10386: ARRAY
10387: PUSH
10388: LD_INT 1
10390: ARRAY
10391: PPUSH
10392: LD_VAR 0 4
10396: PUSH
10397: LD_VAR 0 7
10401: ARRAY
10402: PUSH
10403: LD_INT 2
10405: ARRAY
10406: PPUSH
10407: LD_VAR 0 4
10411: PUSH
10412: LD_VAR 0 8
10416: ARRAY
10417: PUSH
10418: LD_INT 1
10420: ARRAY
10421: PPUSH
10422: LD_VAR 0 4
10426: PUSH
10427: LD_VAR 0 8
10431: ARRAY
10432: PUSH
10433: LD_INT 2
10435: ARRAY
10436: PPUSH
10437: CALL_OW 298
10441: PUSH
10442: LD_VAR 0 6
10446: LESS
10447: IFFALSE 10519
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10449: LD_ADDR_VAR 0 6
10453: PUSH
10454: LD_VAR 0 4
10458: PUSH
10459: LD_VAR 0 7
10463: ARRAY
10464: PUSH
10465: LD_INT 1
10467: ARRAY
10468: PPUSH
10469: LD_VAR 0 4
10473: PUSH
10474: LD_VAR 0 7
10478: ARRAY
10479: PUSH
10480: LD_INT 2
10482: ARRAY
10483: PPUSH
10484: LD_VAR 0 4
10488: PUSH
10489: LD_VAR 0 8
10493: ARRAY
10494: PUSH
10495: LD_INT 1
10497: ARRAY
10498: PPUSH
10499: LD_VAR 0 4
10503: PUSH
10504: LD_VAR 0 8
10508: ARRAY
10509: PUSH
10510: LD_INT 2
10512: ARRAY
10513: PPUSH
10514: CALL_OW 298
10518: ST_TO_ADDR
// end ;
10519: GO 10362
10521: POP
10522: POP
10523: GO 10340
10525: POP
10526: POP
// if minv > best then
10527: LD_VAR 0 6
10531: PUSH
10532: LD_VAR 0 3
10536: GREATER
10537: IFFALSE 10559
// begin best := minv ;
10539: LD_ADDR_VAR 0 3
10543: PUSH
10544: LD_VAR 0 6
10548: ST_TO_ADDR
// bestc := c ;
10549: LD_ADDR_VAR 0 5
10553: PUSH
10554: LD_VAR 0 4
10558: ST_TO_ADDR
// end ; end ;
10559: GO 10252
10561: POP
10562: POP
// coordinates := [ ] ;
10563: LD_ADDR_EXP 34
10567: PUSH
10568: EMPTY
10569: ST_TO_ADDR
// for i = 1 to 8 do
10570: LD_ADDR_VAR 0 7
10574: PUSH
10575: DOUBLE
10576: LD_INT 1
10578: DEC
10579: ST_TO_ADDR
10580: LD_INT 8
10582: PUSH
10583: FOR_TO
10584: IFFALSE 10709
// if i = alone then
10586: LD_VAR 0 7
10590: PUSH
10591: LD_VAR 0 1
10595: EQUAL
10596: IFFALSE 10624
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
10598: LD_ADDR_EXP 34
10602: PUSH
10603: LD_EXP 34
10607: PUSH
10608: LD_INT 81
10610: PUSH
10611: LD_INT 57
10613: PUSH
10614: EMPTY
10615: LIST
10616: LIST
10617: PUSH
10618: EMPTY
10619: LIST
10620: ADD
10621: ST_TO_ADDR
10622: GO 10707
// if ( side_positions [ i ] = 0 ) then
10624: LD_EXP 43
10628: PUSH
10629: LD_VAR 0 7
10633: ARRAY
10634: PUSH
10635: LD_INT 0
10637: EQUAL
10638: IFFALSE 10666
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
10640: LD_ADDR_EXP 34
10644: PUSH
10645: LD_EXP 34
10649: PUSH
10650: LD_INT 0
10652: PUSH
10653: LD_INT 0
10655: PUSH
10656: EMPTY
10657: LIST
10658: LIST
10659: PUSH
10660: EMPTY
10661: LIST
10662: ADD
10663: ST_TO_ADDR
10664: GO 10707
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
10666: LD_ADDR_EXP 34
10670: PUSH
10671: LD_EXP 34
10675: PUSH
10676: LD_VAR 0 5
10680: PUSH
10681: LD_INT 1
10683: ARRAY
10684: PUSH
10685: EMPTY
10686: LIST
10687: ADD
10688: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
10689: LD_ADDR_VAR 0 5
10693: PUSH
10694: LD_VAR 0 5
10698: PPUSH
10699: LD_INT 1
10701: PPUSH
10702: CALL_OW 3
10706: ST_TO_ADDR
// end ;
10707: GO 10583
10709: POP
10710: POP
// end ;
10711: LD_VAR 0 2
10715: RET
// function prepare_map_coordinates_one_hunter ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10716: LD_INT 0
10718: PPUSH
10719: PPUSH
10720: PPUSH
10721: PPUSH
10722: PPUSH
10723: PPUSH
10724: PPUSH
10725: PPUSH
// best = 0 ;
10726: LD_ADDR_VAR 0 3
10730: PUSH
10731: LD_INT 0
10733: ST_TO_ADDR
// for n = 1 to 40 do
10734: LD_ADDR_VAR 0 9
10738: PUSH
10739: DOUBLE
10740: LD_INT 1
10742: DEC
10743: ST_TO_ADDR
10744: LD_INT 40
10746: PUSH
10747: FOR_TO
10748: IFFALSE 11056
// begin c = [ ] ;
10750: LD_ADDR_VAR 0 4
10754: PUSH
10755: EMPTY
10756: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10757: LD_ADDR_VAR 0 7
10761: PUSH
10762: DOUBLE
10763: LD_INT 1
10765: DEC
10766: ST_TO_ADDR
10767: LD_EXP 37
10771: PUSH
10772: LD_INT 1
10774: MINUS
10775: PUSH
10776: FOR_TO
10777: IFFALSE 10806
// c := c ^ [ RandHexArea ( arapestart , false ) ] ;
10779: LD_ADDR_VAR 0 4
10783: PUSH
10784: LD_VAR 0 4
10788: PUSH
10789: LD_INT 24
10791: PPUSH
10792: LD_INT 0
10794: PPUSH
10795: CALL_OW 16
10799: PUSH
10800: EMPTY
10801: LIST
10802: ADD
10803: ST_TO_ADDR
10804: GO 10776
10806: POP
10807: POP
// minv = 10000 ;
10808: LD_ADDR_VAR 0 6
10812: PUSH
10813: LD_INT 10000
10815: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10816: LD_ADDR_VAR 0 7
10820: PUSH
10821: DOUBLE
10822: LD_INT 1
10824: DEC
10825: ST_TO_ADDR
10826: LD_EXP 37
10830: PUSH
10831: LD_INT 1
10833: MINUS
10834: PUSH
10835: FOR_TO
10836: IFFALSE 11020
// for j = 1 to side_count - 1 do
10838: LD_ADDR_VAR 0 8
10842: PUSH
10843: DOUBLE
10844: LD_INT 1
10846: DEC
10847: ST_TO_ADDR
10848: LD_EXP 37
10852: PUSH
10853: LD_INT 1
10855: MINUS
10856: PUSH
10857: FOR_TO
10858: IFFALSE 11016
// if i <> j then
10860: LD_VAR 0 7
10864: PUSH
10865: LD_VAR 0 8
10869: NONEQUAL
10870: IFFALSE 11014
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10872: LD_VAR 0 4
10876: PUSH
10877: LD_VAR 0 7
10881: ARRAY
10882: PUSH
10883: LD_INT 1
10885: ARRAY
10886: PPUSH
10887: LD_VAR 0 4
10891: PUSH
10892: LD_VAR 0 7
10896: ARRAY
10897: PUSH
10898: LD_INT 2
10900: ARRAY
10901: PPUSH
10902: LD_VAR 0 4
10906: PUSH
10907: LD_VAR 0 8
10911: ARRAY
10912: PUSH
10913: LD_INT 1
10915: ARRAY
10916: PPUSH
10917: LD_VAR 0 4
10921: PUSH
10922: LD_VAR 0 8
10926: ARRAY
10927: PUSH
10928: LD_INT 2
10930: ARRAY
10931: PPUSH
10932: CALL_OW 298
10936: PUSH
10937: LD_VAR 0 6
10941: LESS
10942: IFFALSE 11014
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10944: LD_ADDR_VAR 0 6
10948: PUSH
10949: LD_VAR 0 4
10953: PUSH
10954: LD_VAR 0 7
10958: ARRAY
10959: PUSH
10960: LD_INT 1
10962: ARRAY
10963: PPUSH
10964: LD_VAR 0 4
10968: PUSH
10969: LD_VAR 0 7
10973: ARRAY
10974: PUSH
10975: LD_INT 2
10977: ARRAY
10978: PPUSH
10979: LD_VAR 0 4
10983: PUSH
10984: LD_VAR 0 8
10988: ARRAY
10989: PUSH
10990: LD_INT 1
10992: ARRAY
10993: PPUSH
10994: LD_VAR 0 4
10998: PUSH
10999: LD_VAR 0 8
11003: ARRAY
11004: PUSH
11005: LD_INT 2
11007: ARRAY
11008: PPUSH
11009: CALL_OW 298
11013: ST_TO_ADDR
// end ;
11014: GO 10857
11016: POP
11017: POP
11018: GO 10835
11020: POP
11021: POP
// if minv > best then
11022: LD_VAR 0 6
11026: PUSH
11027: LD_VAR 0 3
11031: GREATER
11032: IFFALSE 11054
// begin best := minv ;
11034: LD_ADDR_VAR 0 3
11038: PUSH
11039: LD_VAR 0 6
11043: ST_TO_ADDR
// bestc := c ;
11044: LD_ADDR_VAR 0 5
11048: PUSH
11049: LD_VAR 0 4
11053: ST_TO_ADDR
// end ; end ;
11054: GO 10747
11056: POP
11057: POP
// coordinates := [ ] ;
11058: LD_ADDR_EXP 34
11062: PUSH
11063: EMPTY
11064: ST_TO_ADDR
// for i = 1 to 8 do
11065: LD_ADDR_VAR 0 7
11069: PUSH
11070: DOUBLE
11071: LD_INT 1
11073: DEC
11074: ST_TO_ADDR
11075: LD_INT 8
11077: PUSH
11078: FOR_TO
11079: IFFALSE 11204
// if i = alone then
11081: LD_VAR 0 7
11085: PUSH
11086: LD_VAR 0 1
11090: EQUAL
11091: IFFALSE 11119
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
11093: LD_ADDR_EXP 34
11097: PUSH
11098: LD_EXP 34
11102: PUSH
11103: LD_INT 81
11105: PUSH
11106: LD_INT 57
11108: PUSH
11109: EMPTY
11110: LIST
11111: LIST
11112: PUSH
11113: EMPTY
11114: LIST
11115: ADD
11116: ST_TO_ADDR
11117: GO 11202
// if ( side_positions [ i ] = 0 ) then
11119: LD_EXP 43
11123: PUSH
11124: LD_VAR 0 7
11128: ARRAY
11129: PUSH
11130: LD_INT 0
11132: EQUAL
11133: IFFALSE 11161
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
11135: LD_ADDR_EXP 34
11139: PUSH
11140: LD_EXP 34
11144: PUSH
11145: LD_INT 0
11147: PUSH
11148: LD_INT 0
11150: PUSH
11151: EMPTY
11152: LIST
11153: LIST
11154: PUSH
11155: EMPTY
11156: LIST
11157: ADD
11158: ST_TO_ADDR
11159: GO 11202
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
11161: LD_ADDR_EXP 34
11165: PUSH
11166: LD_EXP 34
11170: PUSH
11171: LD_VAR 0 5
11175: PUSH
11176: LD_INT 1
11178: ARRAY
11179: PUSH
11180: EMPTY
11181: LIST
11182: ADD
11183: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
11184: LD_ADDR_VAR 0 5
11188: PUSH
11189: LD_VAR 0 5
11193: PPUSH
11194: LD_INT 1
11196: PPUSH
11197: CALL_OW 3
11201: ST_TO_ADDR
// end ;
11202: GO 11078
11204: POP
11205: POP
// end ;
11206: LD_VAR 0 2
11210: RET
// function prepare_game ( alone ) ; var i , t ; begin
11211: LD_INT 0
11213: PPUSH
11214: PPUSH
11215: PPUSH
// ResetFog ;
11216: CALL_OW 335
// for i := 1 to 8 do
11220: LD_ADDR_VAR 0 3
11224: PUSH
11225: DOUBLE
11226: LD_INT 1
11228: DEC
11229: ST_TO_ADDR
11230: LD_INT 8
11232: PUSH
11233: FOR_TO
11234: IFFALSE 11288
// if Side_Positions [ i ] then
11236: LD_EXP 43
11240: PUSH
11241: LD_VAR 0 3
11245: ARRAY
11246: IFFALSE 11286
// if i = alone then
11248: LD_VAR 0 3
11252: PUSH
11253: LD_VAR 0 1
11257: EQUAL
11258: IFFALSE 11274
// ChangeSideFog ( i , 1 ) else
11260: LD_VAR 0 3
11264: PPUSH
11265: LD_INT 1
11267: PPUSH
11268: CALL_OW 343
11272: GO 11286
// ChangeSideFog ( i , 2 ) ;
11274: LD_VAR 0 3
11278: PPUSH
11279: LD_INT 2
11281: PPUSH
11282: CALL_OW 343
11286: GO 11233
11288: POP
11289: POP
// set_attitudes ( alone ) ;
11290: LD_VAR 0 1
11294: PPUSH
11295: CALL 9891 0 1
// set_technologies ( alone ) ;
11299: LD_VAR 0 1
11303: PPUSH
11304: CALL 10007 0 1
// display_score ( alone , 0 0$8 ) ;
11308: LD_VAR 0 1
11312: PPUSH
11313: LD_INT 280
11315: PPUSH
11316: CALL 9785 0 2
// for i := 1 to 8 do
11320: LD_ADDR_VAR 0 3
11324: PUSH
11325: DOUBLE
11326: LD_INT 1
11328: DEC
11329: ST_TO_ADDR
11330: LD_INT 8
11332: PUSH
11333: FOR_TO
11334: IFFALSE 11388
// if Side_Positions [ i ] then
11336: LD_EXP 43
11340: PUSH
11341: LD_VAR 0 3
11345: ARRAY
11346: IFFALSE 11386
// if ( i = alone ) = ( one_hunter ) then
11348: LD_VAR 0 3
11352: PUSH
11353: LD_VAR 0 1
11357: EQUAL
11358: PUSH
11359: LD_EXP 79
11363: EQUAL
11364: IFFALSE 11377
// prepare_hunter_team ( i ) else
11366: LD_VAR 0 3
11370: PPUSH
11371: CALL 9425 0 1
11375: GO 11386
// prepare_ape_team ( i ) ;
11377: LD_VAR 0 3
11381: PPUSH
11382: CALL 9602 0 1
11386: GO 11333
11388: POP
11389: POP
// t := 8 ;
11390: LD_ADDR_VAR 0 4
11394: PUSH
11395: LD_INT 8
11397: ST_TO_ADDR
// repeat t := t - 1 ;
11398: LD_ADDR_VAR 0 4
11402: PUSH
11403: LD_VAR 0 4
11407: PUSH
11408: LD_INT 1
11410: MINUS
11411: ST_TO_ADDR
// display_score ( alone , t * 0 0$1 ) ;
11412: LD_VAR 0 1
11416: PPUSH
11417: LD_VAR 0 4
11421: PUSH
11422: LD_INT 35
11424: MUL
11425: PPUSH
11426: CALL 9785 0 2
// wait ( 0 0$1 ) ;
11430: LD_INT 35
11432: PPUSH
11433: CALL_OW 67
// until t = 0 ;
11437: LD_VAR 0 4
11441: PUSH
11442: LD_INT 0
11444: EQUAL
11445: IFFALSE 11398
// end ;
11447: LD_VAR 0 2
11451: RET
// function run_game ( alone ) ; var i , un , ape , time , alive , dead , aktsc ; begin
11452: LD_INT 0
11454: PPUSH
11455: PPUSH
11456: PPUSH
11457: PPUSH
11458: PPUSH
11459: PPUSH
11460: PPUSH
11461: PPUSH
// if ( your_side = alone ) <> one_hunter then
11462: LD_OWVAR 2
11466: PUSH
11467: LD_VAR 0 1
11471: EQUAL
11472: PUSH
11473: LD_EXP 79
11477: NONEQUAL
11478: IFFALSE 11490
// music_nat := nation_arabian else
11480: LD_ADDR_OWVAR 71
11484: PUSH
11485: LD_INT 2
11487: ST_TO_ADDR
11488: GO 11506
// music_nat := Side_Nations [ your_side ] ;
11490: LD_ADDR_OWVAR 71
11494: PUSH
11495: LD_EXP 44
11499: PUSH
11500: LD_OWVAR 2
11504: ARRAY
11505: ST_TO_ADDR
// if one_hunter then
11506: LD_EXP 79
11510: IFFALSE 11675
// begin prepare_map_coordinates_one_hunter ( alone ) ;
11512: LD_VAR 0 1
11516: PPUSH
11517: CALL 10716 0 1
// for i := 1 to 8 do
11521: LD_ADDR_VAR 0 3
11525: PUSH
11526: DOUBLE
11527: LD_INT 1
11529: DEC
11530: ST_TO_ADDR
11531: LD_INT 8
11533: PUSH
11534: FOR_TO
11535: IFFALSE 11671
// if side_positions [ i ] then
11537: LD_EXP 43
11541: PUSH
11542: LD_VAR 0 3
11546: ARRAY
11547: IFFALSE 11669
// if i = alone then
11549: LD_VAR 0 3
11553: PUSH
11554: LD_VAR 0 1
11558: EQUAL
11559: IFFALSE 11601
// for un in people [ i ] do
11561: LD_ADDR_VAR 0 4
11565: PUSH
11566: LD_EXP 88
11570: PUSH
11571: LD_VAR 0 3
11575: ARRAY
11576: PUSH
11577: FOR_IN
11578: IFFALSE 11597
// PlaceUnitArea ( un , arstartveh , false ) else
11580: LD_VAR 0 4
11584: PPUSH
11585: LD_INT 22
11587: PPUSH
11588: LD_INT 0
11590: PPUSH
11591: CALL_OW 49
11595: GO 11577
11597: POP
11598: POP
11599: GO 11669
// for un in people [ i ] do
11601: LD_ADDR_VAR 0 4
11605: PUSH
11606: LD_EXP 88
11610: PUSH
11611: LD_VAR 0 3
11615: ARRAY
11616: PUSH
11617: FOR_IN
11618: IFFALSE 11667
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 15 , false ) ;
11620: LD_VAR 0 4
11624: PPUSH
11625: LD_EXP 34
11629: PUSH
11630: LD_VAR 0 3
11634: ARRAY
11635: PUSH
11636: LD_INT 1
11638: ARRAY
11639: PPUSH
11640: LD_EXP 34
11644: PUSH
11645: LD_VAR 0 3
11649: ARRAY
11650: PUSH
11651: LD_INT 2
11653: ARRAY
11654: PPUSH
11655: LD_INT 15
11657: PPUSH
11658: LD_INT 0
11660: PPUSH
11661: CALL_OW 50
11665: GO 11617
11667: POP
11668: POP
11669: GO 11534
11671: POP
11672: POP
// end else
11673: GO 11836
// begin prepare_map_coordinates_more_hunters ( alone ) ;
11675: LD_VAR 0 1
11679: PPUSH
11680: CALL 10221 0 1
// for i := 1 to 8 do
11684: LD_ADDR_VAR 0 3
11688: PUSH
11689: DOUBLE
11690: LD_INT 1
11692: DEC
11693: ST_TO_ADDR
11694: LD_INT 8
11696: PUSH
11697: FOR_TO
11698: IFFALSE 11834
// if side_positions [ i ] then
11700: LD_EXP 43
11704: PUSH
11705: LD_VAR 0 3
11709: ARRAY
11710: IFFALSE 11832
// if i = alone then
11712: LD_VAR 0 3
11716: PUSH
11717: LD_VAR 0 1
11721: EQUAL
11722: IFFALSE 11764
// for un in people [ i ] do
11724: LD_ADDR_VAR 0 4
11728: PUSH
11729: LD_EXP 88
11733: PUSH
11734: LD_VAR 0 3
11738: ARRAY
11739: PUSH
11740: FOR_IN
11741: IFFALSE 11760
// PlaceUnitArea ( un , arapes , false ) else
11743: LD_VAR 0 4
11747: PPUSH
11748: LD_INT 23
11750: PPUSH
11751: LD_INT 0
11753: PPUSH
11754: CALL_OW 49
11758: GO 11740
11760: POP
11761: POP
11762: GO 11832
// for un in people [ i ] do
11764: LD_ADDR_VAR 0 4
11768: PUSH
11769: LD_EXP 88
11773: PUSH
11774: LD_VAR 0 3
11778: ARRAY
11779: PUSH
11780: FOR_IN
11781: IFFALSE 11830
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 4 , false ) ;
11783: LD_VAR 0 4
11787: PPUSH
11788: LD_EXP 34
11792: PUSH
11793: LD_VAR 0 3
11797: ARRAY
11798: PUSH
11799: LD_INT 1
11801: ARRAY
11802: PPUSH
11803: LD_EXP 34
11807: PUSH
11808: LD_VAR 0 3
11812: ARRAY
11813: PUSH
11814: LD_INT 2
11816: ARRAY
11817: PPUSH
11818: LD_INT 4
11820: PPUSH
11821: LD_INT 0
11823: PPUSH
11824: CALL_OW 50
11828: GO 11780
11830: POP
11831: POP
11832: GO 11697
11834: POP
11835: POP
// end ; CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
11836: LD_EXP 34
11840: PUSH
11841: LD_OWVAR 2
11845: ARRAY
11846: PUSH
11847: LD_INT 1
11849: ARRAY
11850: PPUSH
11851: LD_EXP 34
11855: PUSH
11856: LD_OWVAR 2
11860: ARRAY
11861: PUSH
11862: LD_INT 2
11864: ARRAY
11865: PPUSH
11866: CALL_OW 86
// display_score ( 0 , 0 ) ;
11870: LD_INT 0
11872: PPUSH
11873: LD_INT 0
11875: PPUSH
11876: CALL 9785 0 2
// time := hunt_limit div 0 0$1 ;
11880: LD_ADDR_VAR 0 6
11884: PUSH
11885: LD_EXP 80
11889: PUSH
11890: LD_INT 35
11892: DIV
11893: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11894: LD_INT 35
11896: PPUSH
11897: CALL_OW 67
// ape := FilterAllUnits ( [ f_class , class_apeman ] ) + 0 ;
11901: LD_ADDR_VAR 0 5
11905: PUSH
11906: LD_INT 25
11908: PUSH
11909: LD_INT 12
11911: PUSH
11912: EMPTY
11913: LIST
11914: LIST
11915: PPUSH
11916: CALL_OW 69
11920: PUSH
11921: LD_INT 0
11923: PLUS
11924: ST_TO_ADDR
// time := time - 1 ;
11925: LD_ADDR_VAR 0 6
11929: PUSH
11930: LD_VAR 0 6
11934: PUSH
11935: LD_INT 1
11937: MINUS
11938: ST_TO_ADDR
// display_strings := [ #Hunt-Apes , alone , ape , #Hunt-Limit , alone , time * 0 0$1 ] ;
11939: LD_ADDR_OWVAR 47
11943: PUSH
11944: LD_STRING #Hunt-Apes
11946: PUSH
11947: LD_VAR 0 1
11951: PUSH
11952: LD_VAR 0 5
11956: PUSH
11957: LD_STRING #Hunt-Limit
11959: PUSH
11960: LD_VAR 0 1
11964: PUSH
11965: LD_VAR 0 6
11969: PUSH
11970: LD_INT 35
11972: MUL
11973: PUSH
11974: EMPTY
11975: LIST
11976: LIST
11977: LIST
11978: LIST
11979: LIST
11980: LIST
11981: ST_TO_ADDR
// until ( ape = 0 ) or ( time = 0 ) ;
11982: LD_VAR 0 5
11986: PUSH
11987: LD_INT 0
11989: EQUAL
11990: PUSH
11991: LD_VAR 0 6
11995: PUSH
11996: LD_INT 0
11998: EQUAL
11999: OR
12000: IFFALSE 11894
// alive := FilterAllUnits ( [ f_or , [ f_class , class_soldier ] , [ f_class , class_scientistic ] ] ) + 0 ;
12002: LD_ADDR_VAR 0 7
12006: PUSH
12007: LD_INT 2
12009: PUSH
12010: LD_INT 25
12012: PUSH
12013: LD_INT 1
12015: PUSH
12016: EMPTY
12017: LIST
12018: LIST
12019: PUSH
12020: LD_INT 25
12022: PUSH
12023: LD_INT 4
12025: PUSH
12026: EMPTY
12027: LIST
12028: LIST
12029: PUSH
12030: EMPTY
12031: LIST
12032: LIST
12033: LIST
12034: PPUSH
12035: CALL_OW 69
12039: PUSH
12040: LD_INT 0
12042: PLUS
12043: ST_TO_ADDR
// if one_hunter then
12044: LD_EXP 79
12048: IFFALSE 12199
// begin dead := size_of_hunt_team - alive ;
12050: LD_ADDR_VAR 0 8
12054: PUSH
12055: LD_EXP 82
12059: PUSH
12060: LD_VAR 0 7
12064: MINUS
12065: ST_TO_ADDR
// ape := size_of_ape_team * ( side_count - 1 ) - ape ;
12066: LD_ADDR_VAR 0 5
12070: PUSH
12071: LD_EXP 81
12075: PUSH
12076: LD_EXP 37
12080: PUSH
12081: LD_INT 1
12083: MINUS
12084: MUL
12085: PUSH
12086: LD_VAR 0 5
12090: MINUS
12091: ST_TO_ADDR
// aktsc := time + ape * 30 - dead * 20 ;
12092: LD_ADDR_VAR 0 9
12096: PUSH
12097: LD_VAR 0 6
12101: PUSH
12102: LD_VAR 0 5
12106: PUSH
12107: LD_INT 30
12109: MUL
12110: PLUS
12111: PUSH
12112: LD_VAR 0 8
12116: PUSH
12117: LD_INT 20
12119: MUL
12120: MINUS
12121: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score2 , alone , alone , time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12122: LD_ADDR_EXP 89
12126: PUSH
12127: LD_EXP 89
12131: PUSH
12132: LD_STRING #Hunt-score2
12134: PUSH
12135: LD_VAR 0 1
12139: PUSH
12140: LD_VAR 0 1
12144: PUSH
12145: LD_VAR 0 6
12149: PUSH
12150: LD_INT 35
12152: MUL
12153: PUSH
12154: LD_VAR 0 5
12158: PUSH
12159: LD_VAR 0 8
12163: PUSH
12164: LD_INT 0
12166: PUSH
12167: LD_VAR 0 9
12171: PUSH
12172: EMPTY
12173: LIST
12174: LIST
12175: LIST
12176: LIST
12177: LIST
12178: LIST
12179: LIST
12180: LIST
12181: ADD
12182: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12183: LD_VAR 0 1
12187: PPUSH
12188: LD_VAR 0 9
12192: PPUSH
12193: CALL_OW 506
// end else
12197: GO 12346
// begin dead := size_of_hunt_team * ( side_count - 1 ) - alive ;
12199: LD_ADDR_VAR 0 8
12203: PUSH
12204: LD_EXP 82
12208: PUSH
12209: LD_EXP 37
12213: PUSH
12214: LD_INT 1
12216: MINUS
12217: MUL
12218: PUSH
12219: LD_VAR 0 7
12223: MINUS
12224: ST_TO_ADDR
// aktsc := hunt_limit div 0 0$1 - time + ape * 30 + dead * 20 ;
12225: LD_ADDR_VAR 0 9
12229: PUSH
12230: LD_EXP 80
12234: PUSH
12235: LD_INT 35
12237: DIV
12238: PUSH
12239: LD_VAR 0 6
12243: MINUS
12244: PUSH
12245: LD_VAR 0 5
12249: PUSH
12250: LD_INT 30
12252: MUL
12253: PLUS
12254: PUSH
12255: LD_VAR 0 8
12259: PUSH
12260: LD_INT 20
12262: MUL
12263: PLUS
12264: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score1 , alone , alone , hunt_limit - time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12265: LD_ADDR_EXP 89
12269: PUSH
12270: LD_EXP 89
12274: PUSH
12275: LD_STRING #Hunt-score1
12277: PUSH
12278: LD_VAR 0 1
12282: PUSH
12283: LD_VAR 0 1
12287: PUSH
12288: LD_EXP 80
12292: PUSH
12293: LD_VAR 0 6
12297: PUSH
12298: LD_INT 35
12300: MUL
12301: MINUS
12302: PUSH
12303: LD_VAR 0 5
12307: PUSH
12308: LD_VAR 0 8
12312: PUSH
12313: LD_INT 0
12315: PUSH
12316: LD_VAR 0 9
12320: PUSH
12321: EMPTY
12322: LIST
12323: LIST
12324: LIST
12325: LIST
12326: LIST
12327: LIST
12328: LIST
12329: LIST
12330: ADD
12331: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12332: LD_VAR 0 1
12336: PPUSH
12337: LD_VAR 0 9
12341: PPUSH
12342: CALL_OW 506
// end ; end ;
12346: LD_VAR 0 2
12350: RET
// function close_game ( alone ) ; var un ; begin
12351: LD_INT 0
12353: PPUSH
12354: PPUSH
// for un in all_units do
12355: LD_ADDR_VAR 0 3
12359: PUSH
12360: LD_OWVAR 3
12364: PUSH
12365: FOR_IN
12366: IFFALSE 12379
// DestroyUnit ( un ) ;
12368: LD_VAR 0 3
12372: PPUSH
12373: CALL_OW 65
12377: GO 12365
12379: POP
12380: POP
// ResetFog ;
12381: CALL_OW 335
// end ;
12385: LD_VAR 0 2
12389: RET
// export function starting_hunt ; var alone , win , i ; begin
12390: LD_INT 0
12392: PPUSH
12393: PPUSH
12394: PPUSH
12395: PPUSH
// mp_selectmsg := true ;
12396: LD_ADDR_OWVAR 13
12400: PUSH
12401: LD_INT 1
12403: ST_TO_ADDR
// mp_with_score := true ;
12404: LD_ADDR_OWVAR 14
12408: PUSH
12409: LD_INT 1
12411: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
12412: CALL 8446 0 0
// your_side := Player_Side ;
12416: LD_ADDR_OWVAR 2
12420: PUSH
12421: LD_EXP 39
12425: ST_TO_ADDR
// while to_be_alone do
12426: LD_EXP 87
12430: IFFALSE 12501
// begin alone := to_be_alone [ Rand ( 1 , to_be_alone ) ] ;
12432: LD_ADDR_VAR 0 2
12436: PUSH
12437: LD_EXP 87
12441: PUSH
12442: LD_INT 1
12444: PPUSH
12445: LD_EXP 87
12449: PPUSH
12450: CALL_OW 12
12454: ARRAY
12455: ST_TO_ADDR
// to_be_alone := to_be_alone diff alone ;
12456: LD_ADDR_EXP 87
12460: PUSH
12461: LD_EXP 87
12465: PUSH
12466: LD_VAR 0 2
12470: DIFF
12471: ST_TO_ADDR
// prepare_game ( alone ) ;
12472: LD_VAR 0 2
12476: PPUSH
12477: CALL 11211 0 1
// run_game ( alone ) ;
12481: LD_VAR 0 2
12485: PPUSH
12486: CALL 11452 0 1
// close_game ( alone ) ;
12490: LD_VAR 0 2
12494: PPUSH
12495: CALL 12351 0 1
// end ;
12499: GO 12426
// display_score ( 0 , 0 ) ;
12501: LD_INT 0
12503: PPUSH
12504: LD_INT 0
12506: PPUSH
12507: CALL 9785 0 2
// wait ( 0 0$5 ) ;
12511: LD_INT 175
12513: PPUSH
12514: CALL_OW 67
// win := true ;
12518: LD_ADDR_VAR 0 3
12522: PUSH
12523: LD_INT 1
12525: ST_TO_ADDR
// for i := 1 to 8 do
12526: LD_ADDR_VAR 0 4
12530: PUSH
12531: DOUBLE
12532: LD_INT 1
12534: DEC
12535: ST_TO_ADDR
12536: LD_INT 8
12538: PUSH
12539: FOR_TO
12540: IFFALSE 12574
// if GetMultiScore ( i ) > GetMultiScore ( your_side ) then
12542: LD_VAR 0 4
12546: PPUSH
12547: CALL_OW 507
12551: PUSH
12552: LD_OWVAR 2
12556: PPUSH
12557: CALL_OW 507
12561: GREATER
12562: IFFALSE 12572
// win := false ;
12564: LD_ADDR_VAR 0 3
12568: PUSH
12569: LD_INT 0
12571: ST_TO_ADDR
12572: GO 12539
12574: POP
12575: POP
// if win then
12576: LD_VAR 0 3
12580: IFFALSE 12588
// YouWinInMultiplayer else
12582: CALL_OW 106
12586: GO 12592
// YouLostInMultiplayer ;
12588: CALL_OW 107
// end ; end_of_file
12592: LD_VAR 0 1
12596: RET
// export to_be_countdowned ; every 0 0$0.2 trigger to_be_countdowned marked 25 do var who , timer ;
12597: LD_EXP 90
12601: IFFALSE 12772
12603: GO 12605
12605: DISABLE
12606: LD_INT 0
12608: PPUSH
12609: PPUSH
// begin enable ;
12610: ENABLE
// who := to_be_countdowned [ 1 ] ;
12611: LD_ADDR_VAR 0 1
12615: PUSH
12616: LD_EXP 90
12620: PUSH
12621: LD_INT 1
12623: ARRAY
12624: ST_TO_ADDR
// to_be_countdowned := Delete ( to_be_countdowned , 1 ) ;
12625: LD_ADDR_EXP 90
12629: PUSH
12630: LD_EXP 90
12634: PPUSH
12635: LD_INT 1
12637: PPUSH
12638: CALL_OW 3
12642: ST_TO_ADDR
// repeat timer := GetTag ( who ) ;
12643: LD_ADDR_VAR 0 2
12647: PUSH
12648: LD_VAR 0 1
12652: PPUSH
12653: CALL_OW 110
12657: ST_TO_ADDR
// if GetSide ( who ) = your_side then
12658: LD_VAR 0 1
12662: PPUSH
12663: CALL_OW 255
12667: PUSH
12668: LD_OWVAR 2
12672: EQUAL
12673: IFFALSE 12689
// SetUnitDisplayNumber ( who , timer ) ;
12675: LD_VAR 0 1
12679: PPUSH
12680: LD_VAR 0 2
12684: PPUSH
12685: CALL_OW 505
// timer := timer - 1 ;
12689: LD_ADDR_VAR 0 2
12693: PUSH
12694: LD_VAR 0 2
12698: PUSH
12699: LD_INT 1
12701: MINUS
12702: ST_TO_ADDR
// SetTag ( who , timer ) ;
12703: LD_VAR 0 1
12707: PPUSH
12708: LD_VAR 0 2
12712: PPUSH
12713: CALL_OW 109
// wait ( 0 0$1 ) ;
12717: LD_INT 35
12719: PPUSH
12720: CALL_OW 67
// until not IsLive ( who ) or not GetTag ( who ) ;
12724: LD_VAR 0 1
12728: PPUSH
12729: CALL_OW 300
12733: NOT
12734: PUSH
12735: LD_VAR 0 1
12739: PPUSH
12740: CALL_OW 110
12744: NOT
12745: OR
12746: IFFALSE 12643
// if not GetTag ( who ) then
12748: LD_VAR 0 1
12752: PPUSH
12753: CALL_OW 110
12757: NOT
12758: IFFALSE 12772
// SetLives ( who , 0 ) ;
12760: LD_VAR 0 1
12764: PPUSH
12765: LD_INT 0
12767: PPUSH
12768: CALL_OW 234
// end ;
12772: PPOPN 2
12774: END
// every 0 0$0.5 + 0 0$0.05 marked 25 do var un , veh ;
12775: GO 12777
12777: DISABLE
12778: LD_INT 0
12780: PPUSH
12781: PPUSH
// begin veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , f_not , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12782: LD_ADDR_VAR 0 2
12786: PUSH
12787: LD_INT 5
12789: PPUSH
12790: LD_INT 21
12792: PUSH
12793: LD_INT 2
12795: PUSH
12796: EMPTY
12797: LIST
12798: LIST
12799: PUSH
12800: LD_INT 3
12802: PUSH
12803: LD_INT 58
12805: PUSH
12806: EMPTY
12807: LIST
12808: PUSH
12809: LD_INT 3
12811: PUSH
12812: LD_INT 22
12814: PUSH
12815: LD_INT 0
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PUSH
12822: EMPTY
12823: LIST
12824: LIST
12825: LIST
12826: LIST
12827: LIST
12828: PPUSH
12829: CALL_OW 70
12833: ST_TO_ADDR
// for un in veh do
12834: LD_ADDR_VAR 0 1
12838: PUSH
12839: LD_VAR 0 2
12843: PUSH
12844: FOR_IN
12845: IFFALSE 12858
// ComExitVehicle ( veh ) ;
12847: LD_VAR 0 2
12851: PPUSH
12852: CALL_OW 121
12856: GO 12844
12858: POP
12859: POP
// veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12860: LD_ADDR_VAR 0 2
12864: PUSH
12865: LD_INT 5
12867: PPUSH
12868: LD_INT 21
12870: PUSH
12871: LD_INT 2
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: PUSH
12878: LD_INT 58
12880: PUSH
12881: EMPTY
12882: LIST
12883: PUSH
12884: LD_INT 3
12886: PUSH
12887: LD_INT 22
12889: PUSH
12890: LD_INT 0
12892: PUSH
12893: EMPTY
12894: LIST
12895: LIST
12896: PUSH
12897: EMPTY
12898: LIST
12899: LIST
12900: LIST
12901: LIST
12902: PPUSH
12903: CALL_OW 70
12907: ST_TO_ADDR
// for un in veh do
12908: LD_ADDR_VAR 0 1
12912: PUSH
12913: LD_VAR 0 2
12917: PUSH
12918: FOR_IN
12919: IFFALSE 12974
// begin SetMultiScore ( GetSide ( un ) , GetMultiScore ( GetSide ( un ) ) + 1 ) ;
12921: LD_VAR 0 1
12925: PPUSH
12926: CALL_OW 255
12930: PPUSH
12931: LD_VAR 0 1
12935: PPUSH
12936: CALL_OW 255
12940: PPUSH
12941: CALL_OW 507
12945: PUSH
12946: LD_INT 1
12948: PLUS
12949: PPUSH
12950: CALL_OW 506
// RemoveUnit ( un ) ;
12954: LD_VAR 0 1
12958: PPUSH
12959: CALL_OW 64
// DestroyUnit ( un ) ;
12963: LD_VAR 0 1
12967: PPUSH
12968: CALL_OW 65
// end ;
12972: GO 12918
12974: POP
12975: POP
// enable ;
12976: ENABLE
// end ;
12977: PPOPN 2
12979: END
// every 0 0$1 + 0 0$0.1 marked 25 do var i , best , nbest , lastbest , s , first , n ;
12980: GO 12982
12982: DISABLE
12983: LD_INT 0
12985: PPUSH
12986: PPUSH
12987: PPUSH
12988: PPUSH
12989: PPUSH
12990: PPUSH
12991: PPUSH
// begin lastbest := 99999 ;
12992: LD_ADDR_VAR 0 4
12996: PUSH
12997: LD_INT 99999
12999: ST_TO_ADDR
// s := [ ] ;
13000: LD_ADDR_VAR 0 5
13004: PUSH
13005: EMPTY
13006: ST_TO_ADDR
// n := 1 ;
13007: LD_ADDR_VAR 0 7
13011: PUSH
13012: LD_INT 1
13014: ST_TO_ADDR
// repeat best := - 99999 ;
13015: LD_ADDR_VAR 0 2
13019: PUSH
13020: LD_INT 99999
13022: NEG
13023: ST_TO_ADDR
// nbest := 0 ;
13024: LD_ADDR_VAR 0 3
13028: PUSH
13029: LD_INT 0
13031: ST_TO_ADDR
// for i := 1 to 8 do
13032: LD_ADDR_VAR 0 1
13036: PUSH
13037: DOUBLE
13038: LD_INT 1
13040: DEC
13041: ST_TO_ADDR
13042: LD_INT 8
13044: PUSH
13045: FOR_TO
13046: IFFALSE 13152
// if Side_Positions [ i ] then
13048: LD_EXP 43
13052: PUSH
13053: LD_VAR 0 1
13057: ARRAY
13058: IFFALSE 13150
// begin if ( GetMultiScore ( i ) > best ) and ( GetMultiScore ( i ) < lastbest ) then
13060: LD_VAR 0 1
13064: PPUSH
13065: CALL_OW 507
13069: PUSH
13070: LD_VAR 0 2
13074: GREATER
13075: PUSH
13076: LD_VAR 0 1
13080: PPUSH
13081: CALL_OW 507
13085: PUSH
13086: LD_VAR 0 4
13090: LESS
13091: AND
13092: IFFALSE 13119
// begin best := GetMultiScore ( i ) ;
13094: LD_ADDR_VAR 0 2
13098: PUSH
13099: LD_VAR 0 1
13103: PPUSH
13104: CALL_OW 507
13108: ST_TO_ADDR
// nbest := 1 ;
13109: LD_ADDR_VAR 0 3
13113: PUSH
13114: LD_INT 1
13116: ST_TO_ADDR
// end else
13117: GO 13150
// if GetMultiScore ( i ) = best then
13119: LD_VAR 0 1
13123: PPUSH
13124: CALL_OW 507
13128: PUSH
13129: LD_VAR 0 2
13133: EQUAL
13134: IFFALSE 13150
// begin nbest := nbest + 1 ;
13136: LD_ADDR_VAR 0 3
13140: PUSH
13141: LD_VAR 0 3
13145: PUSH
13146: LD_INT 1
13148: PLUS
13149: ST_TO_ADDR
// end ; end ;
13150: GO 13045
13152: POP
13153: POP
// first := true ;
13154: LD_ADDR_VAR 0 6
13158: PUSH
13159: LD_INT 1
13161: ST_TO_ADDR
// if nbest > 0 then
13162: LD_VAR 0 3
13166: PUSH
13167: LD_INT 0
13169: GREATER
13170: IFFALSE 13343
// for i := 1 to 8 do
13172: LD_ADDR_VAR 0 1
13176: PUSH
13177: DOUBLE
13178: LD_INT 1
13180: DEC
13181: ST_TO_ADDR
13182: LD_INT 8
13184: PUSH
13185: FOR_TO
13186: IFFALSE 13341
// if Side_Positions [ i ] then
13188: LD_EXP 43
13192: PUSH
13193: LD_VAR 0 1
13197: ARRAY
13198: IFFALSE 13339
// if GetMultiScore ( i ) = best then
13200: LD_VAR 0 1
13204: PPUSH
13205: CALL_OW 507
13209: PUSH
13210: LD_VAR 0 2
13214: EQUAL
13215: IFFALSE 13339
// if nbest = 1 then
13217: LD_VAR 0 3
13221: PUSH
13222: LD_INT 1
13224: EQUAL
13225: IFFALSE 13276
// s := s ^ [ #Multi-score , n , i , i , i , best ] else
13227: LD_ADDR_VAR 0 5
13231: PUSH
13232: LD_VAR 0 5
13236: PUSH
13237: LD_STRING #Multi-score
13239: PUSH
13240: LD_VAR 0 7
13244: PUSH
13245: LD_VAR 0 1
13249: PUSH
13250: LD_VAR 0 1
13254: PUSH
13255: LD_VAR 0 1
13259: PUSH
13260: LD_VAR 0 2
13264: PUSH
13265: EMPTY
13266: LIST
13267: LIST
13268: LIST
13269: LIST
13270: LIST
13271: LIST
13272: ADD
13273: ST_TO_ADDR
13274: GO 13339
// s := s ^ [ #Multi-score-range , n , n + nbest - 1 , i , i , i , best ] ;
13276: LD_ADDR_VAR 0 5
13280: PUSH
13281: LD_VAR 0 5
13285: PUSH
13286: LD_STRING #Multi-score-range
13288: PUSH
13289: LD_VAR 0 7
13293: PUSH
13294: LD_VAR 0 7
13298: PUSH
13299: LD_VAR 0 3
13303: PLUS
13304: PUSH
13305: LD_INT 1
13307: MINUS
13308: PUSH
13309: LD_VAR 0 1
13313: PUSH
13314: LD_VAR 0 1
13318: PUSH
13319: LD_VAR 0 1
13323: PUSH
13324: LD_VAR 0 2
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: LIST
13333: LIST
13334: LIST
13335: LIST
13336: LIST
13337: ADD
13338: ST_TO_ADDR
13339: GO 13185
13341: POP
13342: POP
// n := n + nbest ;
13343: LD_ADDR_VAR 0 7
13347: PUSH
13348: LD_VAR 0 7
13352: PUSH
13353: LD_VAR 0 3
13357: PLUS
13358: ST_TO_ADDR
// lastbest := best ;
13359: LD_ADDR_VAR 0 4
13363: PUSH
13364: LD_VAR 0 2
13368: ST_TO_ADDR
// until nbest = 0 ;
13369: LD_VAR 0 3
13373: PUSH
13374: LD_INT 0
13376: EQUAL
13377: IFFALSE 13015
// if game_time then
13379: LD_EXP 56
13383: IFFALSE 13418
// s := [ #Hunt-Limit , 0 , game_time - tick ] ^ s ;
13385: LD_ADDR_VAR 0 5
13389: PUSH
13390: LD_STRING #Hunt-Limit
13392: PUSH
13393: LD_INT 0
13395: PUSH
13396: LD_EXP 56
13400: PUSH
13401: LD_OWVAR 1
13405: MINUS
13406: PUSH
13407: EMPTY
13408: LIST
13409: LIST
13410: LIST
13411: PUSH
13412: LD_VAR 0 5
13416: ADD
13417: ST_TO_ADDR
// display_strings := s ;
13418: LD_ADDR_OWVAR 47
13422: PUSH
13423: LD_VAR 0 5
13427: ST_TO_ADDR
// enable ;
13428: ENABLE
// end ;
13429: PPOPN 7
13431: END
// every 0 0$1 marked 25 do var veh ;
13432: GO 13434
13434: DISABLE
13435: LD_INT 0
13437: PPUSH
// begin repeat repeat veh := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
13438: LD_ADDR_VAR 0 1
13442: PUSH
13443: LD_INT 21
13445: PUSH
13446: LD_INT 2
13448: PUSH
13449: EMPTY
13450: LIST
13451: LIST
13452: PPUSH
13453: CALL_OW 69
13457: ST_TO_ADDR
// wait ( 0 0$3 ) ;
13458: LD_INT 105
13460: PPUSH
13461: CALL_OW 67
// until veh < vehmax ;
13465: LD_VAR 0 1
13469: PUSH
13470: LD_EXP 61
13474: LESS
13475: IFFALSE 13438
// wait ( Rand ( vehresp [ 1 ] div side_count , vehresp [ 2 ] div side_count ) ) ;
13477: LD_EXP 58
13481: PUSH
13482: LD_INT 1
13484: ARRAY
13485: PUSH
13486: LD_EXP 37
13490: DIV
13491: PPUSH
13492: LD_EXP 58
13496: PUSH
13497: LD_INT 2
13499: ARRAY
13500: PUSH
13501: LD_EXP 37
13505: DIV
13506: PPUSH
13507: CALL_OW 12
13511: PPUSH
13512: CALL_OW 67
// vehicles_create_vehicle ( false ) ;
13516: LD_INT 0
13518: PPUSH
13519: CALL 6878 0 1
// until false ;
13523: LD_INT 0
13525: IFFALSE 13438
// end ;
13527: PPOPN 1
13529: END
// every 3 marked 25 do var side , peop ;
13530: GO 13532
13532: DISABLE
13533: LD_INT 0
13535: PPUSH
13536: PPUSH
// begin if not to_resp then
13537: LD_EXP 69
13541: NOT
13542: IFFALSE 13546
// exit ;
13544: GO 13747
// enable ;
13546: ENABLE
// side := to_resp [ 1 ] ;
13547: LD_ADDR_VAR 0 1
13551: PUSH
13552: LD_EXP 69
13556: PUSH
13557: LD_INT 1
13559: ARRAY
13560: ST_TO_ADDR
// to_resp := Delete ( to_resp , 1 ) ;
13561: LD_ADDR_EXP 69
13565: PUSH
13566: LD_EXP 69
13570: PPUSH
13571: LD_INT 1
13573: PPUSH
13574: CALL_OW 3
13578: ST_TO_ADDR
// repeat repeat peop := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_side , side ] , [ f_ok ] ] ) ;
13579: LD_ADDR_VAR 0 2
13583: PUSH
13584: LD_INT 21
13586: PUSH
13587: LD_INT 1
13589: PUSH
13590: EMPTY
13591: LIST
13592: LIST
13593: PUSH
13594: LD_INT 22
13596: PUSH
13597: LD_VAR 0 1
13601: PUSH
13602: EMPTY
13603: LIST
13604: LIST
13605: PUSH
13606: LD_INT 50
13608: PUSH
13609: EMPTY
13610: LIST
13611: PUSH
13612: EMPTY
13613: LIST
13614: LIST
13615: LIST
13616: PPUSH
13617: CALL_OW 69
13621: ST_TO_ADDR
// wait ( 0 0$5 ) ;
13622: LD_INT 175
13624: PPUSH
13625: CALL_OW 67
// until peop < npeop ;
13629: LD_VAR 0 2
13633: PUSH
13634: LD_EXP 65
13638: LESS
13639: IFFALSE 13579
// wait ( Rand ( peopresp [ 1 ] , peopresp [ 2 ] ) ) ;
13641: LD_EXP 66
13645: PUSH
13646: LD_INT 1
13648: ARRAY
13649: PPUSH
13650: LD_EXP 66
13654: PUSH
13655: LD_INT 2
13657: ARRAY
13658: PPUSH
13659: CALL_OW 12
13663: PPUSH
13664: CALL_OW 67
// uc_side := side ;
13668: LD_ADDR_OWVAR 20
13672: PUSH
13673: LD_VAR 0 1
13677: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
13678: LD_ADDR_OWVAR 21
13682: PUSH
13683: LD_EXP 44
13687: PUSH
13688: LD_VAR 0 1
13692: ARRAY
13693: ST_TO_ADDR
// hc_name :=  ;
13694: LD_ADDR_OWVAR 26
13698: PUSH
13699: LD_STRING 
13701: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
13702: LD_INT 0
13704: PPUSH
13705: LD_INT 4
13707: PPUSH
13708: CALL_OW 383
// hc_importance := 0 ;
13712: LD_ADDR_OWVAR 32
13716: PUSH
13717: LD_INT 0
13719: ST_TO_ADDR
// hc_gallery :=  ;
13720: LD_ADDR_OWVAR 33
13724: PUSH
13725: LD_STRING 
13727: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , arstartveh , true ) ;
13728: CALL_OW 44
13732: PPUSH
13733: LD_INT 22
13735: PPUSH
13736: LD_INT 1
13738: PPUSH
13739: CALL_OW 49
// until false ;
13743: LD_INT 0
13745: IFFALSE 13579
// end ;
13747: PPOPN 2
13749: END
// on siberiterocketexploded ( un , x , y ) do SA_OnSiberiteRocketExploded ( un , x , y , Your_Side ) ; end_of_file
13750: LD_VAR 0 1
13754: PPUSH
13755: LD_VAR 0 2
13759: PPUSH
13760: LD_VAR 0 3
13764: PPUSH
13765: LD_OWVAR 2
13769: PPUSH
13770: CALL 14727 0 4
13774: PPOPN 3
13776: END
// export Side_Comps ; export nonCombat , siberite_rocket ; every 1 do
13777: GO 13779
13779: DISABLE
// begin if GetMultiplayerSetting ( 49 ) or iseditor then
13780: LD_INT 49
13782: PPUSH
13783: CALL_OW 426
13787: PUSH
13788: LD_OWVAR 84
13792: OR
13793: IFFALSE 13802
// fogoff ( true ) ;
13795: LD_INT 1
13797: PPUSH
13798: CALL_OW 344
// disable ( 125 ) ;
13802: LD_INT 125
13804: DISABLE_MARKED
// Start_VehicleAI ;
13805: CALL 13810 0 0
// end ;
13809: END
// function Start_VehicleAI ; var i , k ; begin
13810: LD_INT 0
13812: PPUSH
13813: PPUSH
13814: PPUSH
// if multiplayer then
13815: LD_OWVAR 4
13819: IFFALSE 13833
// Side_Comps = mp_sides_comps else
13821: LD_ADDR_EXP 91
13825: PUSH
13826: CALL 13975 0 0
13830: ST_TO_ADDR
13831: GO 13872
// side_comps = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ;
13833: LD_ADDR_EXP 91
13837: PUSH
13838: LD_INT 1
13840: PUSH
13841: LD_INT 1
13843: PUSH
13844: LD_INT 1
13846: PUSH
13847: LD_INT 1
13849: PUSH
13850: LD_INT 1
13852: PUSH
13853: LD_INT 1
13855: PUSH
13856: LD_INT 1
13858: PUSH
13859: LD_INT 1
13861: PUSH
13862: EMPTY
13863: LIST
13864: LIST
13865: LIST
13866: LIST
13867: LIST
13868: LIST
13869: LIST
13870: LIST
13871: ST_TO_ADDR
// k = false ;
13872: LD_ADDR_VAR 0 3
13876: PUSH
13877: LD_INT 0
13879: ST_TO_ADDR
// for i in side_comps do
13880: LD_ADDR_VAR 0 2
13884: PUSH
13885: LD_EXP 91
13889: PUSH
13890: FOR_IN
13891: IFFALSE 13909
// if i then
13893: LD_VAR 0 2
13897: IFFALSE 13907
// k = true ;
13899: LD_ADDR_VAR 0 3
13903: PUSH
13904: LD_INT 1
13906: ST_TO_ADDR
13907: GO 13890
13909: POP
13910: POP
// nonCombat = [ us_radar , us_bulldozer , us_siberium_rocket_remainder , ar_radar , ar_selfpropelled_bomb , ru_bulldozer , ru_siberium_rocket_remainder ] ;
13911: LD_ADDR_EXP 92
13915: PUSH
13916: LD_INT 11
13918: PUSH
13919: LD_INT 14
13921: PUSH
13922: LD_INT 15
13924: PUSH
13925: LD_INT 30
13927: PUSH
13928: LD_INT 29
13930: PUSH
13931: LD_INT 53
13933: PUSH
13934: LD_INT 55
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: LIST
13945: ST_TO_ADDR
// Siberite_Rocket = [ us_siberium_rocket , ru_siberium_rocket ] ;
13946: LD_ADDR_EXP 93
13950: PUSH
13951: LD_INT 8
13953: PUSH
13954: LD_INT 48
13956: PUSH
13957: EMPTY
13958: LIST
13959: LIST
13960: ST_TO_ADDR
// if k then
13961: LD_VAR 0 3
13965: IFFALSE 13970
// enable ( 125 ) ;
13967: LD_INT 125
13969: ENABLE_MARKED
// end ;
13970: LD_VAR 0 1
13974: RET
// function mp_sides_comps ; var c , i ; begin
13975: LD_INT 0
13977: PPUSH
13978: PPUSH
13979: PPUSH
// c = [ ] ;
13980: LD_ADDR_VAR 0 2
13984: PUSH
13985: EMPTY
13986: ST_TO_ADDR
// for i = 1 to 8 do
13987: LD_ADDR_VAR 0 3
13991: PUSH
13992: DOUBLE
13993: LD_INT 1
13995: DEC
13996: ST_TO_ADDR
13997: LD_INT 8
13999: PUSH
14000: FOR_TO
14001: IFFALSE 14026
// c = c ^ Multiplayer_GetPlayerIsComp ( i ) ;
14003: LD_ADDR_VAR 0 2
14007: PUSH
14008: LD_VAR 0 2
14012: PUSH
14013: LD_VAR 0 3
14017: PPUSH
14018: CALL_OW 532
14022: ADD
14023: ST_TO_ADDR
14024: GO 14000
14026: POP
14027: POP
// result = c ;
14028: LD_ADDR_VAR 0 1
14032: PUSH
14033: LD_VAR 0 2
14037: ST_TO_ADDR
// end ;
14038: LD_VAR 0 1
14042: RET
// every 0 0$1 marked 125 do var units , u , veh , k , c , i , hex ;
14043: GO 14045
14045: DISABLE
14046: LD_INT 0
14048: PPUSH
14049: PPUSH
14050: PPUSH
14051: PPUSH
14052: PPUSH
14053: PPUSH
14054: PPUSH
// begin units = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_human ] ] ) ;
14055: LD_ADDR_VAR 0 1
14059: PUSH
14060: LD_INT 52
14062: PUSH
14063: EMPTY
14064: LIST
14065: PUSH
14066: LD_INT 50
14068: PUSH
14069: EMPTY
14070: LIST
14071: PUSH
14072: LD_INT 21
14074: PUSH
14075: LD_INT 1
14077: PUSH
14078: EMPTY
14079: LIST
14080: LIST
14081: PUSH
14082: EMPTY
14083: LIST
14084: LIST
14085: LIST
14086: PPUSH
14087: CALL_OW 69
14091: ST_TO_ADDR
// k = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
14092: LD_ADDR_VAR 0 4
14096: PUSH
14097: LD_INT 52
14099: PUSH
14100: EMPTY
14101: LIST
14102: PUSH
14103: LD_INT 50
14105: PUSH
14106: EMPTY
14107: LIST
14108: PUSH
14109: LD_INT 21
14111: PUSH
14112: LD_INT 2
14114: PUSH
14115: EMPTY
14116: LIST
14117: LIST
14118: PUSH
14119: LD_INT 58
14121: PUSH
14122: EMPTY
14123: LIST
14124: PUSH
14125: EMPTY
14126: LIST
14127: LIST
14128: LIST
14129: LIST
14130: PPUSH
14131: CALL_OW 69
14135: ST_TO_ADDR
// for u in units do
14136: LD_ADDR_VAR 0 2
14140: PUSH
14141: LD_VAR 0 1
14145: PUSH
14146: FOR_IN
14147: IFFALSE 14218
// if getSide ( u ) = 0 then
14149: LD_VAR 0 2
14153: PPUSH
14154: CALL_OW 255
14158: PUSH
14159: LD_INT 0
14161: EQUAL
14162: IFFALSE 14182
// units = units diff u else
14164: LD_ADDR_VAR 0 1
14168: PUSH
14169: LD_VAR 0 1
14173: PUSH
14174: LD_VAR 0 2
14178: DIFF
14179: ST_TO_ADDR
14180: GO 14216
// if not Side_Comps [ getSide ( u ) ] then
14182: LD_EXP 91
14186: PUSH
14187: LD_VAR 0 2
14191: PPUSH
14192: CALL_OW 255
14196: ARRAY
14197: NOT
14198: IFFALSE 14216
// units = units diff u ;
14200: LD_ADDR_VAR 0 1
14204: PUSH
14205: LD_VAR 0 1
14209: PUSH
14210: LD_VAR 0 2
14214: DIFF
14215: ST_TO_ADDR
14216: GO 14146
14218: POP
14219: POP
// for u in units do
14220: LD_ADDR_VAR 0 2
14224: PUSH
14225: LD_VAR 0 1
14229: PUSH
14230: FOR_IN
14231: IFFALSE 14651
// begin if isinunit ( u ) then
14233: LD_VAR 0 2
14237: PPUSH
14238: CALL_OW 310
14242: IFFALSE 14459
// begin veh = isinunit ( u ) ;
14244: LD_ADDR_VAR 0 3
14248: PUSH
14249: LD_VAR 0 2
14253: PPUSH
14254: CALL_OW 310
14258: ST_TO_ADDR
// if not HasTask ( veh ) then
14259: LD_VAR 0 3
14263: PPUSH
14264: CALL_OW 314
14268: NOT
14269: IFFALSE 14457
// begin if getWeapon ( veh ) in nonCombat then
14271: LD_VAR 0 3
14275: PPUSH
14276: CALL_OW 264
14280: PUSH
14281: LD_EXP 92
14285: IN
14286: IFFALSE 14302
// comMoveToArea ( veh , exitarea ) else
14288: LD_VAR 0 3
14292: PPUSH
14293: LD_INT 5
14295: PPUSH
14296: CALL_OW 113
14300: GO 14457
// if getWeapon ( veh ) in Siberite_Rocket then
14302: LD_VAR 0 3
14306: PPUSH
14307: CALL_OW 264
14311: PUSH
14312: LD_EXP 93
14316: IN
14317: IFFALSE 14373
// begin hex = RandHex ( false ) ;
14319: LD_ADDR_VAR 0 7
14323: PUSH
14324: LD_INT 0
14326: PPUSH
14327: CALL_OW 15
14331: ST_TO_ADDR
// ComAttackPlace ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14332: LD_VAR 0 3
14336: PPUSH
14337: LD_VAR 0 7
14341: PUSH
14342: LD_INT 1
14344: ARRAY
14345: PPUSH
14346: LD_VAR 0 7
14350: PUSH
14351: LD_INT 2
14353: ARRAY
14354: PPUSH
14355: CALL_OW 116
// AddComMoveToArea ( veh , exitarea ) ;
14359: LD_VAR 0 3
14363: PPUSH
14364: LD_INT 5
14366: PPUSH
14367: CALL_OW 173
// end else
14371: GO 14457
// if getLives ( veh ) <= hranice_zraneni then
14373: LD_VAR 0 3
14377: PPUSH
14378: CALL_OW 256
14382: PUSH
14383: LD_INT 500
14385: LESSEQUAL
14386: IFFALSE 14402
// comMoveToArea ( veh , exitarea ) else
14388: LD_VAR 0 3
14392: PPUSH
14393: LD_INT 5
14395: PPUSH
14396: CALL_OW 113
14400: GO 14457
// begin hex = RandHexArea ( exitarea , false ) ;
14402: LD_ADDR_VAR 0 7
14406: PUSH
14407: LD_INT 5
14409: PPUSH
14410: LD_INT 0
14412: PPUSH
14413: CALL_OW 16
14417: ST_TO_ADDR
// comAgressiveMove ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14418: LD_VAR 0 3
14422: PPUSH
14423: LD_VAR 0 7
14427: PUSH
14428: LD_INT 1
14430: ARRAY
14431: PPUSH
14432: LD_VAR 0 7
14436: PUSH
14437: LD_INT 2
14439: ARRAY
14440: PPUSH
14441: CALL_OW 114
// AddComMoveToArea ( veh , exitarea ) ;
14445: LD_VAR 0 3
14449: PPUSH
14450: LD_INT 5
14452: PPUSH
14453: CALL_OW 173
// end ; end ; end else
14457: GO 14642
// begin if not HasTask ( u ) then
14459: LD_VAR 0 2
14463: PPUSH
14464: CALL_OW 314
14468: NOT
14469: IFFALSE 14513
// begin hex = RandHex ( false ) ;
14471: LD_ADDR_VAR 0 7
14475: PUSH
14476: LD_INT 0
14478: PPUSH
14479: CALL_OW 15
14483: ST_TO_ADDR
// ComMoveXY ( u , hex [ 1 ] , hex [ 2 ] ) ;
14484: LD_VAR 0 2
14488: PPUSH
14489: LD_VAR 0 7
14493: PUSH
14494: LD_INT 1
14496: ARRAY
14497: PPUSH
14498: LD_VAR 0 7
14502: PUSH
14503: LD_INT 2
14505: ARRAY
14506: PPUSH
14507: CALL_OW 111
// end else
14511: GO 14642
// begin c = [ ] ;
14513: LD_ADDR_VAR 0 5
14517: PUSH
14518: EMPTY
14519: ST_TO_ADDR
// for i in k do
14520: LD_ADDR_VAR 0 6
14524: PUSH
14525: LD_VAR 0 4
14529: PUSH
14530: FOR_IN
14531: IFFALSE 14572
// if See ( getSide ( u ) , i ) then
14533: LD_VAR 0 2
14537: PPUSH
14538: CALL_OW 255
14542: PPUSH
14543: LD_VAR 0 6
14547: PPUSH
14548: CALL_OW 292
14552: IFFALSE 14570
// c = c ^ i ;
14554: LD_ADDR_VAR 0 5
14558: PUSH
14559: LD_VAR 0 5
14563: PUSH
14564: LD_VAR 0 6
14568: ADD
14569: ST_TO_ADDR
14570: GO 14530
14572: POP
14573: POP
// if c + 0 > 0 then
14574: LD_VAR 0 5
14578: PUSH
14579: LD_INT 0
14581: PLUS
14582: PUSH
14583: LD_INT 0
14585: GREATER
14586: IFFALSE 14642
// begin c = NearestUnitToUnit ( c , u ) ;
14588: LD_ADDR_VAR 0 5
14592: PUSH
14593: LD_VAR 0 5
14597: PPUSH
14598: LD_VAR 0 2
14602: PPUSH
14603: CALL_OW 74
14607: ST_TO_ADDR
// if GetDistUnits ( u , c ) < 10 then
14608: LD_VAR 0 2
14612: PPUSH
14613: LD_VAR 0 5
14617: PPUSH
14618: CALL_OW 296
14622: PUSH
14623: LD_INT 10
14625: LESS
14626: IFFALSE 14642
// comEnterUnit ( u , c ) ;
14628: LD_VAR 0 2
14632: PPUSH
14633: LD_VAR 0 5
14637: PPUSH
14638: CALL_OW 120
// end ; end ; end ; wait ( 1 ) ;
14642: LD_INT 1
14644: PPUSH
14645: CALL_OW 67
// end ;
14649: GO 14230
14651: POP
14652: POP
// enable ;
14653: ENABLE
// end ; end_of_file
14654: PPOPN 7
14656: END
// every 10 do
14657: GO 14659
14659: DISABLE
// begin if not multiplayer then
14660: LD_OWVAR 4
14664: NOT
14665: IFFALSE 14669
// exit ;
14667: GO 14726
// if ( tick >= 100 ) then
14669: LD_OWVAR 1
14673: PUSH
14674: LD_INT 100
14676: GREATEREQUAL
14677: IFFALSE 14697
// if tick mod 20 = 0 then
14679: LD_OWVAR 1
14683: PUSH
14684: LD_INT 20
14686: MOD
14687: PUSH
14688: LD_INT 0
14690: EQUAL
14691: IFFALSE 14697
// MultiplayerCRC ;
14693: CALL_OW 361
// if ( tick >= 100 ) then
14697: LD_OWVAR 1
14701: PUSH
14702: LD_INT 100
14704: GREATEREQUAL
14705: IFFALSE 14725
// if tick mod 30 = 0 then
14707: LD_OWVAR 1
14711: PUSH
14712: LD_INT 30
14714: MOD
14715: PUSH
14716: LD_INT 0
14718: EQUAL
14719: IFFALSE 14725
// DebugLogAll ;
14721: CALL_OW 360
// enable ;
14725: ENABLE
// end ; end_of_file
14726: END
// export function SA_OnSiberiteRocketExploded ( siberite_rocket_vehicle , target_x , target_y , requestSide ) ; begin
14727: LD_INT 0
14729: PPUSH
// if GetSide ( siberite_rocket_vehicle ) = requestSide then
14730: LD_VAR 0 1
14734: PPUSH
14735: CALL_OW 255
14739: PUSH
14740: LD_VAR 0 4
14744: EQUAL
14745: IFFALSE 14764
// begin SetAchievement ( ACH_RAD ) ;
14747: LD_STRING ACH_RAD
14749: PPUSH
14750: CALL_OW 543
// SetAchievementEx ( ACH_NL , 1 ) ;
14754: LD_STRING ACH_NL
14756: PPUSH
14757: LD_INT 1
14759: PPUSH
14760: CALL_OW 564
// end end ;
14764: LD_VAR 0 5
14768: RET
// export function SA_Win ( side ) ; begin
14769: LD_INT 0
14771: PPUSH
// case side of 1 :
14772: LD_VAR 0 1
14776: PUSH
14777: LD_INT 1
14779: DOUBLE
14780: EQUAL
14781: IFTRUE 14785
14783: GO 14798
14785: POP
// SetAchievementEx ( ACH_AH , 1 ) ; 2 :
14786: LD_STRING ACH_AH
14788: PPUSH
14789: LD_INT 1
14791: PPUSH
14792: CALL_OW 564
14796: GO 14841
14798: LD_INT 2
14800: DOUBLE
14801: EQUAL
14802: IFTRUE 14806
14804: GO 14819
14806: POP
// SetAchievementEx ( ACH_E , 1 ) ; 3 :
14807: LD_STRING ACH_E
14809: PPUSH
14810: LD_INT 1
14812: PPUSH
14813: CALL_OW 564
14817: GO 14841
14819: LD_INT 3
14821: DOUBLE
14822: EQUAL
14823: IFTRUE 14827
14825: GO 14840
14827: POP
// SetAchievementEx ( ACH_OOL , 1 ) ; end ;
14828: LD_STRING ACH_OOL
14830: PPUSH
14831: LD_INT 1
14833: PPUSH
14834: CALL_OW 564
14838: GO 14841
14840: POP
// end ;
14841: LD_VAR 0 2
14845: RET
