// export gametype ; starting begin if multiplayer then
   0: LD_OWVAR 4
   4: IFFALSE 18
// gametype = mp_game_type else
   6: LD_ADDR_EXP 1
  10: PUSH
  11: LD_OWVAR 6
  15: ST_TO_ADDR
  16: GO 26
// gametype = 25 ;
  18: LD_ADDR_EXP 1
  22: PUSH
  23: LD_INT 25
  25: ST_TO_ADDR
// case gametype of 15 :
  26: LD_EXP 1
  30: PUSH
  31: LD_INT 15
  33: DOUBLE
  34: EQUAL
  35: IFTRUE 39
  37: GO 55
  39: POP
// begin enable ( 15 ) ;
  40: LD_INT 15
  42: ENABLE_MARKED
// disable ( 25 ) ;
  43: LD_INT 25
  45: DISABLE_MARKED
// disable ( 35 ) ;
  46: LD_INT 35
  48: DISABLE_MARKED
// starting_sheherezad ;
  49: CALL 3956 0 0
// end ; 25 :
  53: GO 110
  55: LD_INT 25
  57: DOUBLE
  58: EQUAL
  59: IFTRUE 63
  61: GO 79
  63: POP
// begin enable ( 25 ) ;
  64: LD_INT 25
  66: ENABLE_MARKED
// disable ( 15 ) ;
  67: LD_INT 15
  69: DISABLE_MARKED
// disable ( 35 ) ;
  70: LD_INT 35
  72: DISABLE_MARKED
// starting_vehicles ;
  73: CALL 7336 0 0
// end ; 35 , 36 :
  77: GO 110
  79: LD_INT 35
  81: DOUBLE
  82: EQUAL
  83: IFTRUE 93
  85: LD_INT 36
  87: DOUBLE
  88: EQUAL
  89: IFTRUE 93
  91: GO 109
  93: POP
// begin enable ( 35 ) ;
  94: LD_INT 35
  96: ENABLE_MARKED
// disable ( 15 ) ;
  97: LD_INT 15
  99: DISABLE_MARKED
// disable ( 25 ) ;
 100: LD_INT 25
 102: DISABLE_MARKED
// starting_hunt ;
 103: CALL 12407 0 0
// end ; end ;
 107: GO 110
 109: POP
// end ; end_of_file
 110: END
// export def_sheherezade_speed , def_sheherezade_stamina , def_sheherezade_skills , def_number_of_sheikhs , def_sheikhs_level , def_number_of_soldiers , def_soldiers_level , def_charges_allowed , def_amount_of_apemen , def_apemen_level , def_apemen_abilities , def_number_of_mastodons , def_number_of_tigers , def_time_to_prepare , def_flags ; export shzd_speed , shzd_stamina , shzd_skills , nsh , sh_skills , nsol , sol_skills , nstart_ape , ape_respawning , ape_skills , nmast1 , nmast2 , nmast3 , ntig , tig_respawning , prep_time , flags ; export coordinates , sheherezades , lastunit ; export Side_Count , Team_Count , Player_Side , Player_Team , Side_Teams , Teams ; export Side_Positions , Side_Nations , Side_Names , Team_Names , Team_Game ; function read_multiplayer_and_game_parameters ; var i ; begin
 111: LD_INT 0
 113: PPUSH
 114: PPUSH
// if MultiPlayer then
 115: LD_OWVAR 4
 119: IFFALSE 183
// begin Player_Side = mp_player_side ;
 121: LD_ADDR_EXP 39
 125: PUSH
 126: LD_OWVAR 7
 130: ST_TO_ADDR
// Player_Team = mp_player_team ;
 131: LD_ADDR_EXP 40
 135: PUSH
 136: LD_OWVAR 8
 140: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
 141: LD_ADDR_EXP 43
 145: PUSH
 146: LD_OWVAR 17
 150: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
 151: LD_ADDR_EXP 41
 155: PUSH
 156: LD_OWVAR 15
 160: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
 161: LD_ADDR_EXP 44
 165: PUSH
 166: LD_OWVAR 16
 170: ST_TO_ADDR
// Teams = mp_teams ;
 171: LD_ADDR_EXP 42
 175: PUSH
 176: LD_OWVAR 12
 180: ST_TO_ADDR
// end else
 181: GO 323
// begin Player_Side = 1 ;
 183: LD_ADDR_EXP 39
 187: PUSH
 188: LD_INT 1
 190: ST_TO_ADDR
// Player_Team = 0 ;
 191: LD_ADDR_EXP 40
 195: PUSH
 196: LD_INT 0
 198: ST_TO_ADDR
// Side_Positions = [ 1 , 2 , 3 , 4 , 5 , 0 , 0 , 0 ] ;
 199: LD_ADDR_EXP 43
 203: PUSH
 204: LD_INT 1
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 4
 215: PUSH
 216: LD_INT 5
 218: PUSH
 219: LD_INT 0
 221: PUSH
 222: LD_INT 0
 224: PUSH
 225: LD_INT 0
 227: PUSH
 228: EMPTY
 229: LIST
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 238: LD_ADDR_EXP 41
 242: PUSH
 243: LD_INT 0
 245: PUSH
 246: LD_INT 0
 248: PUSH
 249: LD_INT 0
 251: PUSH
 252: LD_INT 0
 254: PUSH
 255: LD_INT 0
 257: PUSH
 258: LD_INT 0
 260: PUSH
 261: LD_INT 0
 263: PUSH
 264: LD_INT 0
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// Side_Nations = [ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ] ;
 277: LD_ADDR_EXP 44
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 2
 287: PUSH
 288: LD_INT 2
 290: PUSH
 291: LD_INT 2
 293: PUSH
 294: LD_INT 2
 296: PUSH
 297: LD_INT 2
 299: PUSH
 300: LD_INT 2
 302: PUSH
 303: LD_INT 2
 305: PUSH
 306: EMPTY
 307: LIST
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: LIST
 313: LIST
 314: LIST
 315: ST_TO_ADDR
// Teams = [ ] ;
 316: LD_ADDR_EXP 42
 320: PUSH
 321: EMPTY
 322: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
 323: LD_ADDR_EXP 37
 327: PUSH
 328: LD_EXP 43
 332: PUSH
 333: LD_INT 0
 335: PUSH
 336: EMPTY
 337: LIST
 338: DIFF
 339: PUSH
 340: LD_INT 0
 342: PLUS
 343: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
 344: LD_ADDR_EXP 38
 348: PUSH
 349: LD_EXP 41
 353: PUSH
 354: LD_INT 0
 356: PUSH
 357: EMPTY
 358: LIST
 359: DIFF
 360: PUSH
 361: LD_INT 0
 363: PLUS
 364: ST_TO_ADDR
// if MultiPlayer then
 365: LD_OWVAR 4
 369: IFFALSE 568
// begin def_sheherezade_speed = GetMultiplayerSetting ( 0 ) ;
 371: LD_ADDR_EXP 2
 375: PUSH
 376: LD_INT 0
 378: PPUSH
 379: CALL_OW 426
 383: ST_TO_ADDR
// def_sheherezade_stamina = GetMultiplayerSetting ( 1 ) ;
 384: LD_ADDR_EXP 3
 388: PUSH
 389: LD_INT 1
 391: PPUSH
 392: CALL_OW 426
 396: ST_TO_ADDR
// def_sheherezade_skills = GetMultiplayerSetting ( 2 ) ;
 397: LD_ADDR_EXP 4
 401: PUSH
 402: LD_INT 2
 404: PPUSH
 405: CALL_OW 426
 409: ST_TO_ADDR
// def_number_of_sheikhs = GetMultiplayerSetting ( 3 ) ;
 410: LD_ADDR_EXP 5
 414: PUSH
 415: LD_INT 3
 417: PPUSH
 418: CALL_OW 426
 422: ST_TO_ADDR
// def_sheikhs_level = GetMultiplayerSetting ( 4 ) ;
 423: LD_ADDR_EXP 6
 427: PUSH
 428: LD_INT 4
 430: PPUSH
 431: CALL_OW 426
 435: ST_TO_ADDR
// def_number_of_soldiers = GetMultiplayerSetting ( 5 ) ;
 436: LD_ADDR_EXP 7
 440: PUSH
 441: LD_INT 5
 443: PPUSH
 444: CALL_OW 426
 448: ST_TO_ADDR
// def_soldiers_level = GetMultiplayerSetting ( 6 ) ;
 449: LD_ADDR_EXP 8
 453: PUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 426
 461: ST_TO_ADDR
// def_charges_allowed = GetMultiplayerSetting ( 7 ) ;
 462: LD_ADDR_EXP 9
 466: PUSH
 467: LD_INT 7
 469: PPUSH
 470: CALL_OW 426
 474: ST_TO_ADDR
// def_amount_of_apemen = GetMultiplayerSetting ( 8 ) ;
 475: LD_ADDR_EXP 10
 479: PUSH
 480: LD_INT 8
 482: PPUSH
 483: CALL_OW 426
 487: ST_TO_ADDR
// def_apemen_level = GetMultiplayerSetting ( 9 ) ;
 488: LD_ADDR_EXP 11
 492: PUSH
 493: LD_INT 9
 495: PPUSH
 496: CALL_OW 426
 500: ST_TO_ADDR
// def_apemen_abilities = GetMultiplayerSetting ( 10 ) ;
 501: LD_ADDR_EXP 12
 505: PUSH
 506: LD_INT 10
 508: PPUSH
 509: CALL_OW 426
 513: ST_TO_ADDR
// def_number_of_mastodons = GetMultiplayerSetting ( 11 ) ;
 514: LD_ADDR_EXP 13
 518: PUSH
 519: LD_INT 11
 521: PPUSH
 522: CALL_OW 426
 526: ST_TO_ADDR
// def_number_of_tigers = GetMultiplayerSetting ( 12 ) ;
 527: LD_ADDR_EXP 14
 531: PUSH
 532: LD_INT 12
 534: PPUSH
 535: CALL_OW 426
 539: ST_TO_ADDR
// def_time_to_prepare = GetMultiplayerSetting ( 13 ) ;
 540: LD_ADDR_EXP 15
 544: PUSH
 545: LD_INT 13
 547: PPUSH
 548: CALL_OW 426
 552: ST_TO_ADDR
// def_flags = GetMultiplayerSetting ( 14 ) ;
 553: LD_ADDR_EXP 16
 557: PUSH
 558: LD_INT 14
 560: PPUSH
 561: CALL_OW 426
 565: ST_TO_ADDR
// end else
 566: GO 696
// begin randomize ;
 568: CALL_OW 10
// randomizeAll ;
 572: CALL_OW 11
// def_sheherezade_speed = 1 ;
 576: LD_ADDR_EXP 2
 580: PUSH
 581: LD_INT 1
 583: ST_TO_ADDR
// def_sheherezade_stamina = 1 ;
 584: LD_ADDR_EXP 3
 588: PUSH
 589: LD_INT 1
 591: ST_TO_ADDR
// def_sheherezade_skills = 2 ;
 592: LD_ADDR_EXP 4
 596: PUSH
 597: LD_INT 2
 599: ST_TO_ADDR
// def_number_of_sheikhs = 3 ;
 600: LD_ADDR_EXP 5
 604: PUSH
 605: LD_INT 3
 607: ST_TO_ADDR
// def_sheikhs_level = 2 ;
 608: LD_ADDR_EXP 6
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// def_number_of_soldiers = 3 ;
 616: LD_ADDR_EXP 7
 620: PUSH
 621: LD_INT 3
 623: ST_TO_ADDR
// def_soldiers_level = 1 ;
 624: LD_ADDR_EXP 8
 628: PUSH
 629: LD_INT 1
 631: ST_TO_ADDR
// def_charges_allowed = 3 ;
 632: LD_ADDR_EXP 9
 636: PUSH
 637: LD_INT 3
 639: ST_TO_ADDR
// def_amount_of_apemen = 2 ;
 640: LD_ADDR_EXP 10
 644: PUSH
 645: LD_INT 2
 647: ST_TO_ADDR
// def_apemen_level = 1 ;
 648: LD_ADDR_EXP 11
 652: PUSH
 653: LD_INT 1
 655: ST_TO_ADDR
// def_apemen_abilities = 1 ;
 656: LD_ADDR_EXP 12
 660: PUSH
 661: LD_INT 1
 663: ST_TO_ADDR
// def_number_of_mastodons = 2 ;
 664: LD_ADDR_EXP 13
 668: PUSH
 669: LD_INT 2
 671: ST_TO_ADDR
// def_number_of_tigers = 2 ;
 672: LD_ADDR_EXP 14
 676: PUSH
 677: LD_INT 2
 679: ST_TO_ADDR
// def_time_to_prepare = 2 ;
 680: LD_ADDR_EXP 15
 684: PUSH
 685: LD_INT 2
 687: ST_TO_ADDR
// def_flags = 2 ;
 688: LD_ADDR_EXP 16
 692: PUSH
 693: LD_INT 2
 695: ST_TO_ADDR
// end ; shzd_speed = [ 9 , 12 , 15 ] [ def_sheherezade_speed + 1 ] ;
 696: LD_ADDR_EXP 17
 700: PUSH
 701: LD_INT 9
 703: PUSH
 704: LD_INT 12
 706: PUSH
 707: LD_INT 15
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_EXP 2
 719: PUSH
 720: LD_INT 1
 722: PLUS
 723: ARRAY
 724: ST_TO_ADDR
// shzd_stamina = [ 6 , 10 , 15 ] [ def_sheherezade_stamina + 1 ] ;
 725: LD_ADDR_EXP 18
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 10
 735: PUSH
 736: LD_INT 15
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: PUSH
 744: LD_EXP 3
 748: PUSH
 749: LD_INT 1
 751: PLUS
 752: ARRAY
 753: ST_TO_ADDR
// shzd_skills = [ [ 1 , 0 , 0 , 3 ] , [ 2 , 0 , 0 , 5 ] , [ 3 , 0 , 0 , 7 ] ] [ def_sheherezade_skills + 1 ] ;
 754: LD_ADDR_EXP 19
 758: PUSH
 759: LD_INT 1
 761: PUSH
 762: LD_INT 0
 764: PUSH
 765: LD_INT 0
 767: PUSH
 768: LD_INT 3
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 2
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: LD_INT 5
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 0
 800: PUSH
 801: LD_INT 0
 803: PUSH
 804: LD_INT 7
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: LIST
 817: PUSH
 818: LD_EXP 4
 822: PUSH
 823: LD_INT 1
 825: PLUS
 826: ARRAY
 827: ST_TO_ADDR
// nsh = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_sheikhs + 1 ] ;
 828: LD_ADDR_EXP 20
 832: PUSH
 833: LD_INT 0
 835: PUSH
 836: LD_INT 1
 838: PUSH
 839: LD_INT 2
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 4
 847: PUSH
 848: LD_INT 5
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PUSH
 859: LD_EXP 5
 863: PUSH
 864: LD_INT 1
 866: PLUS
 867: ARRAY
 868: ST_TO_ADDR
// sh_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_sheikhs_level + 1 ] ;
 869: LD_ADDR_EXP 21
 873: PUSH
 874: LD_INT 2
 876: PUSH
 877: LD_INT 1
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 1
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: PUSH
 892: LD_INT 4
 894: PUSH
 895: LD_INT 2
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 2
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: PUSH
 910: LD_INT 6
 912: PUSH
 913: LD_INT 3
 915: PUSH
 916: LD_INT 3
 918: PUSH
 919: LD_INT 3
 921: PUSH
 922: EMPTY
 923: LIST
 924: LIST
 925: LIST
 926: LIST
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: LD_EXP 6
 937: PUSH
 938: LD_INT 1
 940: PLUS
 941: ARRAY
 942: ST_TO_ADDR
// nsol = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_soldiers + 1 ] ;
 943: LD_ADDR_EXP 22
 947: PUSH
 948: LD_INT 0
 950: PUSH
 951: LD_INT 1
 953: PUSH
 954: LD_INT 2
 956: PUSH
 957: LD_INT 3
 959: PUSH
 960: LD_INT 4
 962: PUSH
 963: LD_INT 5
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: LIST
 973: PUSH
 974: LD_EXP 7
 978: PUSH
 979: LD_INT 1
 981: PLUS
 982: ARRAY
 983: ST_TO_ADDR
// sol_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_soldiers_level + 1 ] ;
 984: LD_ADDR_EXP 23
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: LD_INT 1
 994: PUSH
 995: LD_INT 1
 997: PUSH
 998: LD_INT 1
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: LIST
1005: LIST
1006: PUSH
1007: LD_INT 4
1009: PUSH
1010: LD_INT 2
1012: PUSH
1013: LD_INT 2
1015: PUSH
1016: LD_INT 2
1018: PUSH
1019: EMPTY
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: PUSH
1025: LD_INT 6
1027: PUSH
1028: LD_INT 3
1030: PUSH
1031: LD_INT 3
1033: PUSH
1034: LD_INT 3
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PUSH
1043: EMPTY
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: LD_EXP 8
1052: PUSH
1053: LD_INT 1
1055: PLUS
1056: ARRAY
1057: ST_TO_ADDR
// nstart_ape = [ 0 , 2 , 4 , 6 , 8 ] [ def_amount_of_apemen + 1 ] ;
1058: LD_ADDR_EXP 24
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 4
1071: PUSH
1072: LD_INT 6
1074: PUSH
1075: LD_INT 8
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PUSH
1085: LD_EXP 10
1089: PUSH
1090: LD_INT 1
1092: PLUS
1093: ARRAY
1094: ST_TO_ADDR
// ape_respawning = [ 0 , 4 4$00 , 2 2$00 , 1 1$00 , 0 0$30 ] [ def_amount_of_apemen + 1 ] ;
1095: LD_ADDR_EXP 25
1099: PUSH
1100: LD_INT 0
1102: PUSH
1103: LD_INT 8400
1105: PUSH
1106: LD_INT 4200
1108: PUSH
1109: LD_INT 2100
1111: PUSH
1112: LD_INT 1050
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_EXP 10
1126: PUSH
1127: LD_INT 1
1129: PLUS
1130: ARRAY
1131: ST_TO_ADDR
// ape_skills = [ [ 1 , 0 , 0 , 0 ] , [ 3 , 0 , 0 , 0 ] , [ 5 , 0 , 0 , 0 ] ] [ def_apemen_level + 1 ] ;
1132: LD_ADDR_EXP 26
1136: PUSH
1137: LD_INT 1
1139: PUSH
1140: LD_INT 0
1142: PUSH
1143: LD_INT 0
1145: PUSH
1146: LD_INT 0
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 0
1160: PUSH
1161: LD_INT 0
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 0
1178: PUSH
1179: LD_INT 0
1181: PUSH
1182: LD_INT 0
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: LIST
1195: PUSH
1196: LD_EXP 11
1200: PUSH
1201: LD_INT 1
1203: PLUS
1204: ARRAY
1205: ST_TO_ADDR
// nmast1 = [ 0 , 2 , 4 , 6 ] [ def_number_of_mastodons + 1 ] ;
1206: LD_ADDR_EXP 27
1210: PUSH
1211: LD_INT 0
1213: PUSH
1214: LD_INT 2
1216: PUSH
1217: LD_INT 4
1219: PUSH
1220: LD_INT 6
1222: PUSH
1223: EMPTY
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: PUSH
1229: LD_EXP 13
1233: PUSH
1234: LD_INT 1
1236: PLUS
1237: ARRAY
1238: ST_TO_ADDR
// nmast2 = [ 0 , 1 , 2 , 3 ] [ def_number_of_mastodons + 1 ] ;
1239: LD_ADDR_EXP 28
1243: PUSH
1244: LD_INT 0
1246: PUSH
1247: LD_INT 1
1249: PUSH
1250: LD_INT 2
1252: PUSH
1253: LD_INT 3
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: PUSH
1262: LD_EXP 13
1266: PUSH
1267: LD_INT 1
1269: PLUS
1270: ARRAY
1271: ST_TO_ADDR
// nmast3 = [ 0 , 15 , 30 , 45 ] [ def_number_of_mastodons + 1 ] ;
1272: LD_ADDR_EXP 29
1276: PUSH
1277: LD_INT 0
1279: PUSH
1280: LD_INT 15
1282: PUSH
1283: LD_INT 30
1285: PUSH
1286: LD_INT 45
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_EXP 13
1299: PUSH
1300: LD_INT 1
1302: PLUS
1303: ARRAY
1304: ST_TO_ADDR
// ntig = [ 0 , 1 , 3 , 5 ] [ def_number_of_tigers + 1 ] ;
1305: LD_ADDR_EXP 30
1309: PUSH
1310: LD_INT 0
1312: PUSH
1313: LD_INT 1
1315: PUSH
1316: LD_INT 3
1318: PUSH
1319: LD_INT 5
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: PUSH
1328: LD_EXP 14
1332: PUSH
1333: LD_INT 1
1335: PLUS
1336: ARRAY
1337: ST_TO_ADDR
// tig_respawning = [ 0 , 8 8$00 , 4 4$00 , 2 2$00 ] [ def_number_of_tigers + 1 ] ;
1338: LD_ADDR_EXP 31
1342: PUSH
1343: LD_INT 0
1345: PUSH
1346: LD_INT 16800
1348: PUSH
1349: LD_INT 8400
1351: PUSH
1352: LD_INT 4200
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: PUSH
1361: LD_EXP 14
1365: PUSH
1366: LD_INT 1
1368: PLUS
1369: ARRAY
1370: ST_TO_ADDR
// prep_time = [ 0 , 0 0$20 , 0 0$40 , 1 1$20 ] [ def_time_to_prepare + 1 ] ;
1371: LD_ADDR_EXP 32
1375: PUSH
1376: LD_INT 0
1378: PUSH
1379: LD_INT 700
1381: PUSH
1382: LD_INT 1400
1384: PUSH
1385: LD_INT 2800
1387: PUSH
1388: EMPTY
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: PUSH
1394: LD_EXP 15
1398: PUSH
1399: LD_INT 1
1401: PLUS
1402: ARRAY
1403: ST_TO_ADDR
// flags = [ 0 , 25 , 50 , 75 ] [ def_flags + 1 ] ;
1404: LD_ADDR_EXP 33
1408: PUSH
1409: LD_INT 0
1411: PUSH
1412: LD_INT 25
1414: PUSH
1415: LD_INT 50
1417: PUSH
1418: LD_INT 75
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: PUSH
1427: LD_EXP 16
1431: PUSH
1432: LD_INT 1
1434: PLUS
1435: ARRAY
1436: ST_TO_ADDR
// if def_charges_allowed in [ 1 , 3 ] then
1437: LD_EXP 9
1441: PUSH
1442: LD_INT 1
1444: PUSH
1445: LD_INT 3
1447: PUSH
1448: EMPTY
1449: LIST
1450: LIST
1451: IN
1452: IFFALSE 1489
// for i := 1 to 8 do
1454: LD_ADDR_VAR 0 2
1458: PUSH
1459: DOUBLE
1460: LD_INT 1
1462: DEC
1463: ST_TO_ADDR
1464: LD_INT 8
1466: PUSH
1467: FOR_TO
1468: IFFALSE 1487
// SetTech ( tech_RemCharge , i , state_researched ) ;
1470: LD_INT 18
1472: PPUSH
1473: LD_VAR 0 2
1477: PPUSH
1478: LD_INT 2
1480: PPUSH
1481: CALL_OW 322
1485: GO 1467
1487: POP
1488: POP
// if def_charges_allowed in [ 1 , 3 ] then
1489: LD_EXP 9
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 3
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: IN
1504: IFFALSE 1541
// for i := 1 to 8 do
1506: LD_ADDR_VAR 0 2
1510: PUSH
1511: DOUBLE
1512: LD_INT 1
1514: DEC
1515: ST_TO_ADDR
1516: LD_INT 8
1518: PUSH
1519: FOR_TO
1520: IFFALSE 1539
// SetTech ( tech_Explos , i , state_researched ) ;
1522: LD_INT 42
1524: PPUSH
1525: LD_VAR 0 2
1529: PPUSH
1530: LD_INT 2
1532: PPUSH
1533: CALL_OW 322
1537: GO 1519
1539: POP
1540: POP
// for i := 1 to 8 do
1541: LD_ADDR_VAR 0 2
1545: PUSH
1546: DOUBLE
1547: LD_INT 1
1549: DEC
1550: ST_TO_ADDR
1551: LD_INT 8
1553: PUSH
1554: FOR_TO
1555: IFFALSE 1589
// begin SetTech ( tech_ApeLang , i , state_disabled ) ;
1557: LD_INT 1
1559: PPUSH
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 0
1567: PPUSH
1568: CALL_OW 322
// SetTech ( tech_SibContam , i , state_disabled ) ;
1572: LD_INT 26
1574: PPUSH
1575: LD_VAR 0 2
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL_OW 322
// end ;
1587: GO 1554
1589: POP
1590: POP
// end ;
1591: LD_VAR 0 1
1595: RET
// function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
1596: LD_INT 0
1598: PPUSH
1599: PPUSH
1600: PPUSH
1601: PPUSH
1602: PPUSH
1603: PPUSH
1604: PPUSH
1605: PPUSH
// best = 0 ;
1606: LD_ADDR_VAR 0 2
1610: PUSH
1611: LD_INT 0
1613: ST_TO_ADDR
// for n = 1 to 400 do
1614: LD_ADDR_VAR 0 8
1618: PUSH
1619: DOUBLE
1620: LD_INT 1
1622: DEC
1623: ST_TO_ADDR
1624: LD_INT 400
1626: PUSH
1627: FOR_TO
1628: IFFALSE 1924
// begin c = [ ] ;
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: EMPTY
1636: ST_TO_ADDR
// for i = 1 to side_count do
1637: LD_ADDR_VAR 0 6
1641: PUSH
1642: DOUBLE
1643: LD_INT 1
1645: DEC
1646: ST_TO_ADDR
1647: LD_EXP 37
1651: PUSH
1652: FOR_TO
1653: IFFALSE 1682
// c := c ^ [ RandHexArea ( arstart , false ) ] ;
1655: LD_ADDR_VAR 0 3
1659: PUSH
1660: LD_VAR 0 3
1664: PUSH
1665: LD_INT 4
1667: PPUSH
1668: LD_INT 0
1670: PPUSH
1671: CALL_OW 16
1675: PUSH
1676: EMPTY
1677: LIST
1678: ADD
1679: ST_TO_ADDR
1680: GO 1652
1682: POP
1683: POP
// minv = 10000 ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_INT 10000
1691: ST_TO_ADDR
// for i = 1 to side_count do
1692: LD_ADDR_VAR 0 6
1696: PUSH
1697: DOUBLE
1698: LD_INT 1
1700: DEC
1701: ST_TO_ADDR
1702: LD_EXP 37
1706: PUSH
1707: FOR_TO
1708: IFFALSE 1888
// for j = 1 to side_count do
1710: LD_ADDR_VAR 0 7
1714: PUSH
1715: DOUBLE
1716: LD_INT 1
1718: DEC
1719: ST_TO_ADDR
1720: LD_EXP 37
1724: PUSH
1725: FOR_TO
1726: IFFALSE 1884
// if i <> j then
1728: LD_VAR 0 6
1732: PUSH
1733: LD_VAR 0 7
1737: NONEQUAL
1738: IFFALSE 1882
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
1740: LD_VAR 0 3
1744: PUSH
1745: LD_VAR 0 6
1749: ARRAY
1750: PUSH
1751: LD_INT 1
1753: ARRAY
1754: PPUSH
1755: LD_VAR 0 3
1759: PUSH
1760: LD_VAR 0 6
1764: ARRAY
1765: PUSH
1766: LD_INT 2
1768: ARRAY
1769: PPUSH
1770: LD_VAR 0 3
1774: PUSH
1775: LD_VAR 0 7
1779: ARRAY
1780: PUSH
1781: LD_INT 1
1783: ARRAY
1784: PPUSH
1785: LD_VAR 0 3
1789: PUSH
1790: LD_VAR 0 7
1794: ARRAY
1795: PUSH
1796: LD_INT 2
1798: ARRAY
1799: PPUSH
1800: CALL_OW 298
1804: PUSH
1805: LD_VAR 0 5
1809: LESS
1810: IFFALSE 1882
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
1812: LD_ADDR_VAR 0 5
1816: PUSH
1817: LD_VAR 0 3
1821: PUSH
1822: LD_VAR 0 6
1826: ARRAY
1827: PUSH
1828: LD_INT 1
1830: ARRAY
1831: PPUSH
1832: LD_VAR 0 3
1836: PUSH
1837: LD_VAR 0 6
1841: ARRAY
1842: PUSH
1843: LD_INT 2
1845: ARRAY
1846: PPUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_VAR 0 7
1856: ARRAY
1857: PUSH
1858: LD_INT 1
1860: ARRAY
1861: PPUSH
1862: LD_VAR 0 3
1866: PUSH
1867: LD_VAR 0 7
1871: ARRAY
1872: PUSH
1873: LD_INT 2
1875: ARRAY
1876: PPUSH
1877: CALL_OW 298
1881: ST_TO_ADDR
// end ;
1882: GO 1725
1884: POP
1885: POP
1886: GO 1707
1888: POP
1889: POP
// if minv > best then
1890: LD_VAR 0 5
1894: PUSH
1895: LD_VAR 0 2
1899: GREATER
1900: IFFALSE 1922
// begin best := minv ;
1902: LD_ADDR_VAR 0 2
1906: PUSH
1907: LD_VAR 0 5
1911: ST_TO_ADDR
// bestc := c ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 3
1921: ST_TO_ADDR
// end ; end ;
1922: GO 1627
1924: POP
1925: POP
// coordinates := [ ] ;
1926: LD_ADDR_EXP 34
1930: PUSH
1931: EMPTY
1932: ST_TO_ADDR
// for i = 1 to 8 do
1933: LD_ADDR_VAR 0 6
1937: PUSH
1938: DOUBLE
1939: LD_INT 1
1941: DEC
1942: ST_TO_ADDR
1943: LD_INT 8
1945: PUSH
1946: FOR_TO
1947: IFFALSE 2034
// if side_positions [ i ] = 0 then
1949: LD_EXP 43
1953: PUSH
1954: LD_VAR 0 6
1958: ARRAY
1959: PUSH
1960: LD_INT 0
1962: EQUAL
1963: IFFALSE 1991
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
1965: LD_ADDR_EXP 34
1969: PUSH
1970: LD_EXP 34
1974: PUSH
1975: LD_INT 0
1977: PUSH
1978: LD_INT 0
1980: PUSH
1981: EMPTY
1982: LIST
1983: LIST
1984: PUSH
1985: EMPTY
1986: LIST
1987: ADD
1988: ST_TO_ADDR
1989: GO 2032
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
1991: LD_ADDR_EXP 34
1995: PUSH
1996: LD_EXP 34
2000: PUSH
2001: LD_VAR 0 4
2005: PUSH
2006: LD_INT 1
2008: ARRAY
2009: PUSH
2010: EMPTY
2011: LIST
2012: ADD
2013: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
2014: LD_ADDR_VAR 0 4
2018: PUSH
2019: LD_VAR 0 4
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: CALL_OW 3
2031: ST_TO_ADDR
// end ;
2032: GO 1946
2034: POP
2035: POP
// end ;
2036: LD_VAR 0 1
2040: RET
// function set_attitudes ; var i , j ; begin
2041: LD_INT 0
2043: PPUSH
2044: PPUSH
2045: PPUSH
// if not Team_Game then
2046: LD_EXP 47
2050: NOT
2051: IFFALSE 2147
// begin for i = 1 to 8 do
2053: LD_ADDR_VAR 0 2
2057: PUSH
2058: DOUBLE
2059: LD_INT 1
2061: DEC
2062: ST_TO_ADDR
2063: LD_INT 8
2065: PUSH
2066: FOR_TO
2067: IFFALSE 2145
// for j = 1 to 8 do
2069: LD_ADDR_VAR 0 3
2073: PUSH
2074: DOUBLE
2075: LD_INT 1
2077: DEC
2078: ST_TO_ADDR
2079: LD_INT 8
2081: PUSH
2082: FOR_TO
2083: IFFALSE 2141
// if i <> j then
2085: LD_VAR 0 2
2089: PUSH
2090: LD_VAR 0 3
2094: NONEQUAL
2095: IFFALSE 2119
// SetAttitude ( i , j , att_neutral , true ) else
2097: LD_VAR 0 2
2101: PPUSH
2102: LD_VAR 0 3
2106: PPUSH
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: CALL_OW 80
2117: GO 2139
// SetAttitude ( i , j , att_friend , true ) end ;
2119: LD_VAR 0 2
2123: PPUSH
2124: LD_VAR 0 3
2128: PPUSH
2129: LD_INT 1
2131: PPUSH
2132: LD_INT 1
2134: PPUSH
2135: CALL_OW 80
2139: GO 2082
2141: POP
2142: POP
2143: GO 2066
2145: POP
2146: POP
// end ;
2147: LD_VAR 0 1
2151: RET
// function create_sheherezade ( side ) ; var s ; begin
2152: LD_INT 0
2154: PPUSH
2155: PPUSH
// uc_side := side ;
2156: LD_ADDR_OWVAR 20
2160: PUSH
2161: LD_VAR 0 1
2165: ST_TO_ADDR
// uc_nation := nation_arabian ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 2
2173: ST_TO_ADDR
// hc_name = Sheherezade ;
2174: LD_ADDR_OWVAR 26
2178: PUSH
2179: LD_STRING Sheherezade
2181: ST_TO_ADDR
// hc_sex = sex_female ;
2182: LD_ADDR_OWVAR 27
2186: PUSH
2187: LD_INT 2
2189: ST_TO_ADDR
// hc_class = class_scientistic ;
2190: LD_ADDR_OWVAR 28
2194: PUSH
2195: LD_INT 4
2197: ST_TO_ADDR
// hc_basic_skills = shzd_skills ;
2198: LD_ADDR_OWVAR 30
2202: PUSH
2203: LD_EXP 19
2207: ST_TO_ADDR
// hc_skills = shzd_skills ;
2208: LD_ADDR_OWVAR 31
2212: PUSH
2213: LD_EXP 19
2217: ST_TO_ADDR
// hc_attr = [ shzd_stamina , shzd_speed ] ;
2218: LD_ADDR_OWVAR 29
2222: PUSH
2223: LD_EXP 18
2227: PUSH
2228: LD_EXP 17
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: ST_TO_ADDR
// hc_gallery = multi ;
2237: LD_ADDR_OWVAR 33
2241: PUSH
2242: LD_STRING multi
2244: ST_TO_ADDR
// hc_face_number = 18 ;
2245: LD_ADDR_OWVAR 34
2249: PUSH
2250: LD_INT 18
2252: ST_TO_ADDR
// hc_importance = 105 ;
2253: LD_ADDR_OWVAR 32
2257: PUSH
2258: LD_INT 105
2260: ST_TO_ADDR
// s = CreateHuman ;
2261: LD_ADDR_VAR 0 3
2265: PUSH
2266: CALL_OW 44
2270: ST_TO_ADDR
// PlaceUnitXYR ( s , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 1 , false ) ;
2271: LD_VAR 0 3
2275: PPUSH
2276: LD_EXP 34
2280: PUSH
2281: LD_VAR 0 1
2285: ARRAY
2286: PUSH
2287: LD_INT 1
2289: ARRAY
2290: PPUSH
2291: LD_EXP 34
2295: PUSH
2296: LD_VAR 0 1
2300: ARRAY
2301: PUSH
2302: LD_INT 2
2304: ARRAY
2305: PPUSH
2306: LD_INT 1
2308: PPUSH
2309: LD_INT 0
2311: PPUSH
2312: CALL_OW 50
// sheherezades = Replace ( sheherezades , side , s ) ;
2316: LD_ADDR_EXP 35
2320: PUSH
2321: LD_EXP 35
2325: PPUSH
2326: LD_VAR 0 1
2330: PPUSH
2331: LD_VAR 0 3
2335: PPUSH
2336: CALL_OW 1
2340: ST_TO_ADDR
// end ;
2341: LD_VAR 0 2
2345: RET
// function prepare_sides ; var i ; begin
2346: LD_INT 0
2348: PPUSH
2349: PPUSH
// for i := 1 to 8 do
2350: LD_ADDR_VAR 0 2
2354: PUSH
2355: DOUBLE
2356: LD_INT 1
2358: DEC
2359: ST_TO_ADDR
2360: LD_INT 8
2362: PUSH
2363: FOR_TO
2364: IFFALSE 2389
// if side_positions [ i ] then
2366: LD_EXP 43
2370: PUSH
2371: LD_VAR 0 2
2375: ARRAY
2376: IFFALSE 2387
// create_sheherezade ( i ) ;
2378: LD_VAR 0 2
2382: PPUSH
2383: CALL 2152 0 1
2387: GO 2363
2389: POP
2390: POP
// if prep_time = 0 then
2391: LD_EXP 32
2395: PUSH
2396: LD_INT 0
2398: EQUAL
2399: IFFALSE 2405
// sheherezade_start_the_fight ;
2401: CALL 3720 0 0
// end ;
2405: LD_VAR 0 1
2409: RET
// function prepare_side_to_the_fight ( side , materialization ) ; var x , y , i , sh , sol ; begin
2410: LD_INT 0
2412: PPUSH
2413: PPUSH
2414: PPUSH
2415: PPUSH
2416: PPUSH
2417: PPUSH
// SetTech ( tech_ApeLang , side , state_researched ) ;
2418: LD_INT 1
2420: PPUSH
2421: LD_VAR 0 1
2425: PPUSH
2426: LD_INT 2
2428: PPUSH
2429: CALL_OW 322
// x := GetX ( Sheherezades [ side ] ) ;
2433: LD_ADDR_VAR 0 4
2437: PUSH
2438: LD_EXP 35
2442: PUSH
2443: LD_VAR 0 1
2447: ARRAY
2448: PPUSH
2449: CALL_OW 250
2453: ST_TO_ADDR
// y := GetY ( Sheherezades [ side ] ) ;
2454: LD_ADDR_VAR 0 5
2458: PUSH
2459: LD_EXP 35
2463: PUSH
2464: LD_VAR 0 1
2468: ARRAY
2469: PPUSH
2470: CALL_OW 251
2474: ST_TO_ADDR
// coordinates := Replace ( coordinates , side , [ x , y ] ) ;
2475: LD_ADDR_EXP 34
2479: PUSH
2480: LD_EXP 34
2484: PPUSH
2485: LD_VAR 0 1
2489: PPUSH
2490: LD_VAR 0 4
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PPUSH
2504: CALL_OW 1
2508: ST_TO_ADDR
// if flags then
2509: LD_EXP 33
2513: IFFALSE 2592
// begin SetBattleFlag ( side , x , y , [ [ bfo_defend_bonus_human , flags ] , [ bfo_defend_bonus_vehicle , flags ] , [ bfo_defend_bonus_building , flags ] , [ bfo_height , flags + 25 ] ] ) ;
2515: LD_VAR 0 1
2519: PPUSH
2520: LD_VAR 0 4
2524: PPUSH
2525: LD_VAR 0 5
2529: PPUSH
2530: LD_INT 1
2532: PUSH
2533: LD_EXP 33
2537: PUSH
2538: EMPTY
2539: LIST
2540: LIST
2541: PUSH
2542: LD_INT 2
2544: PUSH
2545: LD_EXP 33
2549: PUSH
2550: EMPTY
2551: LIST
2552: LIST
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: LD_EXP 33
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: PUSH
2566: LD_INT 20
2568: PUSH
2569: LD_EXP 33
2573: PUSH
2574: LD_INT 25
2576: PLUS
2577: PUSH
2578: EMPTY
2579: LIST
2580: LIST
2581: PUSH
2582: EMPTY
2583: LIST
2584: LIST
2585: LIST
2586: LIST
2587: PPUSH
2588: CALL_OW 418
// end ; uc_side := side ;
2592: LD_ADDR_OWVAR 20
2596: PUSH
2597: LD_VAR 0 1
2601: ST_TO_ADDR
// uc_nation := nation_arabian ;
2602: LD_ADDR_OWVAR 21
2606: PUSH
2607: LD_INT 2
2609: ST_TO_ADDR
// hc_name :=  ;
2610: LD_ADDR_OWVAR 26
2614: PUSH
2615: LD_STRING 
2617: ST_TO_ADDR
// hc_class := class_desert_warior ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 11
2625: ST_TO_ADDR
// hc_sex := sex_male ;
2626: LD_ADDR_OWVAR 27
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_basic_skills := sh_skills ;
2634: LD_ADDR_OWVAR 30
2638: PUSH
2639: LD_EXP 21
2643: ST_TO_ADDR
// hc_skills := sh_skills ;
2644: LD_ADDR_OWVAR 31
2648: PUSH
2649: LD_EXP 21
2653: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2654: LD_ADDR_OWVAR 29
2658: PUSH
2659: LD_INT 10
2661: PUSH
2662: LD_INT 10
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: ST_TO_ADDR
// hc_importance := 0 ;
2669: LD_ADDR_OWVAR 32
2673: PUSH
2674: LD_INT 0
2676: ST_TO_ADDR
// hc_gallery :=  ;
2677: LD_ADDR_OWVAR 33
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// for i := 1 to nsol do
2685: LD_ADDR_VAR 0 6
2689: PUSH
2690: DOUBLE
2691: LD_INT 1
2693: DEC
2694: ST_TO_ADDR
2695: LD_EXP 22
2699: PUSH
2700: FOR_TO
2701: IFFALSE 2742
// begin sh := CreateHuman ;
2703: LD_ADDR_VAR 0 7
2707: PUSH
2708: CALL_OW 44
2712: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2713: LD_VAR 0 7
2717: PPUSH
2718: LD_VAR 0 4
2722: PPUSH
2723: LD_VAR 0 5
2727: PPUSH
2728: LD_INT 5
2730: PPUSH
2731: LD_VAR 0 2
2735: PPUSH
2736: CALL_OW 50
// end ;
2740: GO 2700
2742: POP
2743: POP
// hc_name :=  ;
2744: LD_ADDR_OWVAR 26
2748: PUSH
2749: LD_STRING 
2751: ST_TO_ADDR
// hc_class := class_soldier ;
2752: LD_ADDR_OWVAR 28
2756: PUSH
2757: LD_INT 1
2759: ST_TO_ADDR
// hc_sex := sex_male ;
2760: LD_ADDR_OWVAR 27
2764: PUSH
2765: LD_INT 1
2767: ST_TO_ADDR
// hc_basic_skills := sol_skills ;
2768: LD_ADDR_OWVAR 30
2772: PUSH
2773: LD_EXP 23
2777: ST_TO_ADDR
// hc_skills := sol_skills ;
2778: LD_ADDR_OWVAR 31
2782: PUSH
2783: LD_EXP 23
2787: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2788: LD_ADDR_OWVAR 29
2792: PUSH
2793: LD_INT 10
2795: PUSH
2796: LD_INT 10
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: ST_TO_ADDR
// hc_importance := 0 ;
2803: LD_ADDR_OWVAR 32
2807: PUSH
2808: LD_INT 0
2810: ST_TO_ADDR
// hc_gallery :=  ;
2811: LD_ADDR_OWVAR 33
2815: PUSH
2816: LD_STRING 
2818: ST_TO_ADDR
// for i := 1 to nsh do
2819: LD_ADDR_VAR 0 6
2823: PUSH
2824: DOUBLE
2825: LD_INT 1
2827: DEC
2828: ST_TO_ADDR
2829: LD_EXP 20
2833: PUSH
2834: FOR_TO
2835: IFFALSE 2876
// begin sh := CreateHuman ;
2837: LD_ADDR_VAR 0 7
2841: PUSH
2842: CALL_OW 44
2846: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2847: LD_VAR 0 7
2851: PPUSH
2852: LD_VAR 0 4
2856: PPUSH
2857: LD_VAR 0 5
2861: PPUSH
2862: LD_INT 5
2864: PPUSH
2865: LD_VAR 0 2
2869: PPUSH
2870: CALL_OW 50
// end ;
2874: GO 2834
2876: POP
2877: POP
// end ;
2878: LD_VAR 0 3
2882: RET
// function find_hidden_hex ( ar ) ; var i , j , seen ; begin
2883: LD_INT 0
2885: PPUSH
2886: PPUSH
2887: PPUSH
2888: PPUSH
// for i := 1 to 100 do
2889: LD_ADDR_VAR 0 3
2893: PUSH
2894: DOUBLE
2895: LD_INT 1
2897: DEC
2898: ST_TO_ADDR
2899: LD_INT 100
2901: PUSH
2902: FOR_TO
2903: IFFALSE 3026
// begin repeat result := RandHexArea ( ar , false ) ;
2905: LD_ADDR_VAR 0 2
2909: PUSH
2910: LD_VAR 0 1
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 16
2922: ST_TO_ADDR
// until not HexInfo ( result [ 1 ] , result [ 2 ] ) ;
2923: LD_VAR 0 2
2927: PUSH
2928: LD_INT 1
2930: ARRAY
2931: PPUSH
2932: LD_VAR 0 2
2936: PUSH
2937: LD_INT 2
2939: ARRAY
2940: PPUSH
2941: CALL_OW 428
2945: NOT
2946: IFFALSE 2905
// seen := false ;
2948: LD_ADDR_VAR 0 5
2952: PUSH
2953: LD_INT 0
2955: ST_TO_ADDR
// for j := 1 to 8 do
2956: LD_ADDR_VAR 0 4
2960: PUSH
2961: DOUBLE
2962: LD_INT 1
2964: DEC
2965: ST_TO_ADDR
2966: LD_INT 8
2968: PUSH
2969: FOR_TO
2970: IFFALSE 3011
// if SeeXY ( j , result [ 1 ] , result [ 2 ] ) then
2972: LD_VAR 0 4
2976: PPUSH
2977: LD_VAR 0 2
2981: PUSH
2982: LD_INT 1
2984: ARRAY
2985: PPUSH
2986: LD_VAR 0 2
2990: PUSH
2991: LD_INT 2
2993: ARRAY
2994: PPUSH
2995: CALL_OW 293
2999: IFFALSE 3009
// seen := true ;
3001: LD_ADDR_VAR 0 5
3005: PUSH
3006: LD_INT 1
3008: ST_TO_ADDR
3009: GO 2969
3011: POP
3012: POP
// if not seen then
3013: LD_VAR 0 5
3017: NOT
3018: IFFALSE 3024
// exit ;
3020: POP
3021: POP
3022: GO 3036
// end ;
3024: GO 2902
3026: POP
3027: POP
// result := 0 ;
3028: LD_ADDR_VAR 0 2
3032: PUSH
3033: LD_INT 0
3035: ST_TO_ADDR
// end ;
3036: LD_VAR 0 2
3040: RET
// function create_ape ; var coord , i ; begin
3041: LD_INT 0
3043: PPUSH
3044: PPUSH
3045: PPUSH
// if lastunit >= 1999 then
3046: LD_EXP 36
3050: PUSH
3051: LD_INT 1999
3053: GREATEREQUAL
3054: IFFALSE 3058
// exit ;
3056: GO 3225
// uc_nation := nation_nature ;
3058: LD_ADDR_OWVAR 21
3062: PUSH
3063: LD_INT 0
3065: ST_TO_ADDR
// uc_side := 0 ;
3066: LD_ADDR_OWVAR 20
3070: PUSH
3071: LD_INT 0
3073: ST_TO_ADDR
// hc_name :=  ;
3074: LD_ADDR_OWVAR 26
3078: PUSH
3079: LD_STRING 
3081: ST_TO_ADDR
// hc_class := class_apeman ;
3082: LD_ADDR_OWVAR 28
3086: PUSH
3087: LD_INT 12
3089: ST_TO_ADDR
// hc_sex := 1 ;
3090: LD_ADDR_OWVAR 27
3094: PUSH
3095: LD_INT 1
3097: ST_TO_ADDR
// hc_basic_skills := ape_skills ;
3098: LD_ADDR_OWVAR 30
3102: PUSH
3103: LD_EXP 26
3107: ST_TO_ADDR
// hc_skills := ape_skills ;
3108: LD_ADDR_OWVAR 31
3112: PUSH
3113: LD_EXP 26
3117: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3118: LD_ADDR_OWVAR 29
3122: PUSH
3123: LD_INT 12
3125: PUSH
3126: LD_INT 12
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: ST_TO_ADDR
// hc_importance := 0 ;
3133: LD_ADDR_OWVAR 32
3137: PUSH
3138: LD_INT 0
3140: ST_TO_ADDR
// hc_gallery :=  ;
3141: LD_ADDR_OWVAR 33
3145: PUSH
3146: LD_STRING 
3148: ST_TO_ADDR
// hc_agressivity := Rand ( - 15 , 15 ) ;
3149: LD_ADDR_OWVAR 35
3153: PUSH
3154: LD_INT 15
3156: NEG
3157: PPUSH
3158: LD_INT 15
3160: PPUSH
3161: CALL_OW 12
3165: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3166: LD_ADDR_VAR 0 2
3170: PUSH
3171: LD_INT 4
3173: PPUSH
3174: CALL 2883 0 1
3178: ST_TO_ADDR
// if coord then
3179: LD_VAR 0 2
3183: IFFALSE 3225
// begin lastunit := CreateHuman ;
3185: LD_ADDR_EXP 36
3189: PUSH
3190: CALL_OW 44
3194: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3195: LD_EXP 36
3199: PPUSH
3200: LD_VAR 0 2
3204: PUSH
3205: LD_INT 1
3207: ARRAY
3208: PPUSH
3209: LD_VAR 0 2
3213: PUSH
3214: LD_INT 2
3216: ARRAY
3217: PPUSH
3218: LD_INT 0
3220: PPUSH
3221: CALL_OW 48
// end ; end ;
3225: LD_VAR 0 1
3229: RET
// function prepare_apes ; var i ; begin
3230: LD_INT 0
3232: PPUSH
3233: PPUSH
// for i := 1 to side_count * nstart_ape do
3234: LD_ADDR_VAR 0 2
3238: PUSH
3239: DOUBLE
3240: LD_INT 1
3242: DEC
3243: ST_TO_ADDR
3244: LD_EXP 37
3248: PUSH
3249: LD_EXP 24
3253: MUL
3254: PUSH
3255: FOR_TO
3256: IFFALSE 3264
// begin create_ape ;
3258: CALL 3041 0 0
// end ;
3262: GO 3255
3264: POP
3265: POP
// end ;
3266: LD_VAR 0 1
3270: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3271: LD_OWVAR 1
3275: PUSH
3276: LD_EXP 32
3280: GREATER
3281: IFFALSE 3365
3283: GO 3285
3285: DISABLE
3286: LD_INT 0
3288: PPUSH
// begin if not ape_respawning then
3289: LD_EXP 25
3293: NOT
3294: IFFALSE 3298
// exit ;
3296: GO 3365
// delay := ape_respawning div side_count ;
3298: LD_ADDR_VAR 0 1
3302: PUSH
3303: LD_EXP 25
3307: PUSH
3308: LD_EXP 37
3312: DIV
3313: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3314: LD_VAR 0 1
3318: PUSH
3319: LD_INT 50
3321: PPUSH
3322: LD_INT 150
3324: PPUSH
3325: CALL_OW 12
3329: MUL
3330: PUSH
3331: LD_INT 100
3333: DIV
3334: PPUSH
3335: CALL_OW 67
// delay := delay * 110 div 100 ;
3339: LD_ADDR_VAR 0 1
3343: PUSH
3344: LD_VAR 0 1
3348: PUSH
3349: LD_INT 110
3351: MUL
3352: PUSH
3353: LD_INT 100
3355: DIV
3356: ST_TO_ADDR
// create_ape ;
3357: CALL 3041 0 0
// until false ;
3361: LD_INT 0
3363: IFFALSE 3314
// end ;
3365: PPOPN 1
3367: END
// function create_tiger ; var coord , i ; begin
3368: LD_INT 0
3370: PPUSH
3371: PPUSH
3372: PPUSH
// if lastunit >= 1999 then
3373: LD_EXP 36
3377: PUSH
3378: LD_INT 1999
3380: GREATEREQUAL
3381: IFFALSE 3385
// exit ;
3383: GO 3577
// uc_nation := nation_nature ;
3385: LD_ADDR_OWVAR 21
3389: PUSH
3390: LD_INT 0
3392: ST_TO_ADDR
// uc_side := 0 ;
3393: LD_ADDR_OWVAR 20
3397: PUSH
3398: LD_INT 0
3400: ST_TO_ADDR
// hc_name :=  ;
3401: LD_ADDR_OWVAR 26
3405: PUSH
3406: LD_STRING 
3408: ST_TO_ADDR
// hc_class := class_tiger ;
3409: LD_ADDR_OWVAR 28
3413: PUSH
3414: LD_INT 14
3416: ST_TO_ADDR
// hc_sex := 1 ;
3417: LD_ADDR_OWVAR 27
3421: PUSH
3422: LD_INT 1
3424: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 2 , 2 ] ;
3425: LD_ADDR_OWVAR 30
3429: PUSH
3430: LD_INT 2
3432: PUSH
3433: LD_INT 2
3435: PUSH
3436: LD_INT 2
3438: PUSH
3439: LD_INT 2
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// hc_skills := [ 2 , 2 , 2 , 2 ] ;
3448: LD_ADDR_OWVAR 31
3452: PUSH
3453: LD_INT 2
3455: PUSH
3456: LD_INT 2
3458: PUSH
3459: LD_INT 2
3461: PUSH
3462: LD_INT 2
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: LIST
3469: LIST
3470: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3471: LD_ADDR_OWVAR 29
3475: PUSH
3476: LD_INT 12
3478: PUSH
3479: LD_INT 12
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: ST_TO_ADDR
// hc_importance := 0 ;
3486: LD_ADDR_OWVAR 32
3490: PUSH
3491: LD_INT 0
3493: ST_TO_ADDR
// hc_gallery :=  ;
3494: LD_ADDR_OWVAR 33
3498: PUSH
3499: LD_STRING 
3501: ST_TO_ADDR
// hc_agressivity := Rand ( 30 , 50 ) ;
3502: LD_ADDR_OWVAR 35
3506: PUSH
3507: LD_INT 30
3509: PPUSH
3510: LD_INT 50
3512: PPUSH
3513: CALL_OW 12
3517: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3518: LD_ADDR_VAR 0 2
3522: PUSH
3523: LD_INT 4
3525: PPUSH
3526: CALL 2883 0 1
3530: ST_TO_ADDR
// if coord then
3531: LD_VAR 0 2
3535: IFFALSE 3577
// begin lastunit := CreateHuman ;
3537: LD_ADDR_EXP 36
3541: PUSH
3542: CALL_OW 44
3546: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3547: LD_EXP 36
3551: PPUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_INT 1
3559: ARRAY
3560: PPUSH
3561: LD_VAR 0 2
3565: PUSH
3566: LD_INT 2
3568: ARRAY
3569: PPUSH
3570: LD_INT 0
3572: PPUSH
3573: CALL_OW 48
// end ; end ;
3577: LD_VAR 0 1
3581: RET
// function prepare_tigers ; var i ; begin
3582: LD_INT 0
3584: PPUSH
3585: PPUSH
// for i := 1 to side_count * ntig do
3586: LD_ADDR_VAR 0 2
3590: PUSH
3591: DOUBLE
3592: LD_INT 1
3594: DEC
3595: ST_TO_ADDR
3596: LD_EXP 37
3600: PUSH
3601: LD_EXP 30
3605: MUL
3606: PUSH
3607: FOR_TO
3608: IFFALSE 3616
// begin create_tiger ;
3610: CALL 3368 0 0
// end ;
3614: GO 3607
3616: POP
3617: POP
// end ;
3618: LD_VAR 0 1
3622: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3623: LD_OWVAR 1
3627: PUSH
3628: LD_EXP 32
3632: GREATER
3633: IFFALSE 3717
3635: GO 3637
3637: DISABLE
3638: LD_INT 0
3640: PPUSH
// begin if not tig_respawning then
3641: LD_EXP 31
3645: NOT
3646: IFFALSE 3650
// exit ;
3648: GO 3717
// delay := tig_respawning div side_count ;
3650: LD_ADDR_VAR 0 1
3654: PUSH
3655: LD_EXP 31
3659: PUSH
3660: LD_EXP 37
3664: DIV
3665: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3666: LD_VAR 0 1
3670: PUSH
3671: LD_INT 50
3673: PPUSH
3674: LD_INT 150
3676: PPUSH
3677: CALL_OW 12
3681: MUL
3682: PUSH
3683: LD_INT 100
3685: DIV
3686: PPUSH
3687: CALL_OW 67
// delay := delay * 110 div 100 ;
3691: LD_ADDR_VAR 0 1
3695: PUSH
3696: LD_VAR 0 1
3700: PUSH
3701: LD_INT 110
3703: MUL
3704: PUSH
3705: LD_INT 100
3707: DIV
3708: ST_TO_ADDR
// create_tiger ;
3709: CALL 3368 0 0
// until false ;
3713: LD_INT 0
3715: IFFALSE 3666
// end ;
3717: PPOPN 1
3719: END
// export function sheherezade_start_the_fight ; var i ; begin
3720: LD_INT 0
3722: PPUSH
3723: PPUSH
// for i := 1 to 8 do
3724: LD_ADDR_VAR 0 2
3728: PUSH
3729: DOUBLE
3730: LD_INT 1
3732: DEC
3733: ST_TO_ADDR
3734: LD_INT 8
3736: PUSH
3737: FOR_TO
3738: IFFALSE 3772
// if side_positions [ i ] then
3740: LD_EXP 43
3744: PUSH
3745: LD_VAR 0 2
3749: ARRAY
3750: IFFALSE 3770
// prepare_side_to_the_fight ( i , prep_time > 0 ) ;
3752: LD_VAR 0 2
3756: PPUSH
3757: LD_EXP 32
3761: PUSH
3762: LD_INT 0
3764: GREATER
3765: PPUSH
3766: CALL 2410 0 2
3770: GO 3737
3772: POP
3773: POP
// end ;
3774: LD_VAR 0 1
3778: RET
// function create_mastodon ; var coord , i ; begin
3779: LD_INT 0
3781: PPUSH
3782: PPUSH
3783: PPUSH
// if lastunit >= 1999 then
3784: LD_EXP 36
3788: PUSH
3789: LD_INT 1999
3791: GREATEREQUAL
3792: IFFALSE 3796
// exit ;
3794: GO 3882
// uc_nation := nation_nature ;
3796: LD_ADDR_OWVAR 21
3800: PUSH
3801: LD_INT 0
3803: ST_TO_ADDR
// uc_side := 0 ;
3804: LD_ADDR_OWVAR 20
3808: PUSH
3809: LD_INT 0
3811: ST_TO_ADDR
// vc_chassis := 31 ;
3812: LD_ADDR_OWVAR 37
3816: PUSH
3817: LD_INT 31
3819: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3820: LD_ADDR_VAR 0 2
3824: PUSH
3825: LD_INT 4
3827: PPUSH
3828: CALL 2883 0 1
3832: ST_TO_ADDR
// if coord then
3833: LD_VAR 0 2
3837: IFFALSE 3882
// begin lastunit := CreateVehicle ;
3839: LD_ADDR_EXP 36
3843: PUSH
3844: CALL_OW 45
3848: ST_TO_ADDR
// PlaceUnitXYR ( lastunit , coord [ 1 ] , coord [ 2 ] , 3 , false ) ;
3849: LD_EXP 36
3853: PPUSH
3854: LD_VAR 0 2
3858: PUSH
3859: LD_INT 1
3861: ARRAY
3862: PPUSH
3863: LD_VAR 0 2
3867: PUSH
3868: LD_INT 2
3870: ARRAY
3871: PPUSH
3872: LD_INT 3
3874: PPUSH
3875: LD_INT 0
3877: PPUSH
3878: CALL_OW 50
// end ; end ;
3882: LD_VAR 0 1
3886: RET
// function prepare_mastodons ; var i ; begin
3887: LD_INT 0
3889: PPUSH
3890: PPUSH
// for i := 1 to nmast1 + side_count * nmast2 + side_count * nsh * nmast3 div 100 do
3891: LD_ADDR_VAR 0 2
3895: PUSH
3896: DOUBLE
3897: LD_INT 1
3899: DEC
3900: ST_TO_ADDR
3901: LD_EXP 27
3905: PUSH
3906: LD_EXP 37
3910: PUSH
3911: LD_EXP 28
3915: MUL
3916: PLUS
3917: PUSH
3918: LD_EXP 37
3922: PUSH
3923: LD_EXP 20
3927: MUL
3928: PUSH
3929: LD_EXP 29
3933: MUL
3934: PUSH
3935: LD_INT 100
3937: DIV
3938: PLUS
3939: PUSH
3940: FOR_TO
3941: IFFALSE 3949
// begin create_mastodon ;
3943: CALL 3779 0 0
// end ;
3947: GO 3940
3949: POP
3950: POP
// end ;
3951: LD_VAR 0 1
3955: RET
// export function starting_sheherezad ; begin
3956: LD_INT 0
3958: PPUSH
// mp_selectmsg := true ;
3959: LD_ADDR_OWVAR 13
3963: PUSH
3964: LD_INT 1
3966: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
3967: CALL 111 0 0
// prepare_map_coordinates ;
3971: CALL 1596 0 0
// set_attitudes ;
3975: CALL 2041 0 0
// prepare_sides ;
3979: CALL 2346 0 0
// prepare_apes ;
3983: CALL 3230 0 0
// prepare_tigers ;
3987: CALL 3582 0 0
// prepare_mastodons ;
3991: CALL 3887 0 0
// your_side := Player_Side ;
3995: LD_ADDR_OWVAR 2
3999: PUSH
4000: LD_EXP 39
4004: ST_TO_ADDR
// ResetFog ;
4005: CALL_OW 335
// AnimateTrees ( true ) ;
4009: LD_INT 1
4011: PPUSH
4012: CALL_OW 573
// music_nat := nation_arabian ;
4016: LD_ADDR_OWVAR 71
4020: PUSH
4021: LD_INT 2
4023: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
4024: LD_EXP 34
4028: PUSH
4029: LD_OWVAR 2
4033: ARRAY
4034: PUSH
4035: LD_INT 1
4037: ARRAY
4038: PPUSH
4039: LD_EXP 34
4043: PUSH
4044: LD_OWVAR 2
4048: ARRAY
4049: PUSH
4050: LD_INT 2
4052: ARRAY
4053: PPUSH
4054: CALL_OW 86
// end ; end_of_file
4058: LD_VAR 0 1
4062: RET
// export def_victory_conditions , def_number_of_people , def_people_respawning , def_vehicles_at_start , def_vehicles_respawning , def_vehicles_nations , def_siberite_rocket , def_vehicles_durability ; export game_time , point_limit , vehresp , vehmax1 , vehmax2 , vehmax , startvehperc , startveh , vehdur , npeop , peopresp , vehnats , sibrock , to_resp ; function read_multiplayer_and_game_parameters ; var i ; begin
4063: LD_INT 0
4065: PPUSH
4066: PPUSH
// if MultiPlayer then
4067: LD_OWVAR 4
4071: IFFALSE 4135
// begin Player_Side = mp_player_side ;
4073: LD_ADDR_EXP 39
4077: PUSH
4078: LD_OWVAR 7
4082: ST_TO_ADDR
// Player_Team = mp_player_team ;
4083: LD_ADDR_EXP 40
4087: PUSH
4088: LD_OWVAR 8
4092: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
4093: LD_ADDR_EXP 43
4097: PUSH
4098: LD_OWVAR 17
4102: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
4103: LD_ADDR_EXP 41
4107: PUSH
4108: LD_OWVAR 15
4112: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
4113: LD_ADDR_EXP 44
4117: PUSH
4118: LD_OWVAR 16
4122: ST_TO_ADDR
// Teams = mp_teams ;
4123: LD_ADDR_EXP 42
4127: PUSH
4128: LD_OWVAR 12
4132: ST_TO_ADDR
// end else
4133: GO 4279
// begin randomize ;
4135: CALL_OW 10
// Player_Side = 1 ;
4139: LD_ADDR_EXP 39
4143: PUSH
4144: LD_INT 1
4146: ST_TO_ADDR
// Player_Team = 0 ;
4147: LD_ADDR_EXP 40
4151: PUSH
4152: LD_INT 0
4154: ST_TO_ADDR
// Side_Positions = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ;
4155: LD_ADDR_EXP 43
4159: PUSH
4160: LD_INT 1
4162: PUSH
4163: LD_INT 2
4165: PUSH
4166: LD_INT 3
4168: PUSH
4169: LD_INT 4
4171: PUSH
4172: LD_INT 5
4174: PUSH
4175: LD_INT 6
4177: PUSH
4178: LD_INT 7
4180: PUSH
4181: LD_INT 8
4183: PUSH
4184: EMPTY
4185: LIST
4186: LIST
4187: LIST
4188: LIST
4189: LIST
4190: LIST
4191: LIST
4192: LIST
4193: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4194: LD_ADDR_EXP 41
4198: PUSH
4199: LD_INT 0
4201: PUSH
4202: LD_INT 0
4204: PUSH
4205: LD_INT 0
4207: PUSH
4208: LD_INT 0
4210: PUSH
4211: LD_INT 0
4213: PUSH
4214: LD_INT 0
4216: PUSH
4217: LD_INT 0
4219: PUSH
4220: LD_INT 0
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: LIST
4227: LIST
4228: LIST
4229: LIST
4230: LIST
4231: LIST
4232: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 3 , 2 , 1 , 2 ] ;
4233: LD_ADDR_EXP 44
4237: PUSH
4238: LD_INT 1
4240: PUSH
4241: LD_INT 3
4243: PUSH
4244: LD_INT 1
4246: PUSH
4247: LD_INT 2
4249: PUSH
4250: LD_INT 3
4252: PUSH
4253: LD_INT 2
4255: PUSH
4256: LD_INT 1
4258: PUSH
4259: LD_INT 2
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: ST_TO_ADDR
// Teams = [ ] ;
4272: LD_ADDR_EXP 42
4276: PUSH
4277: EMPTY
4278: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
4279: LD_ADDR_EXP 37
4283: PUSH
4284: LD_EXP 43
4288: PUSH
4289: LD_INT 0
4291: PUSH
4292: EMPTY
4293: LIST
4294: DIFF
4295: PUSH
4296: LD_INT 0
4298: PLUS
4299: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
4300: LD_ADDR_EXP 38
4304: PUSH
4305: LD_EXP 41
4309: PUSH
4310: LD_INT 0
4312: PUSH
4313: EMPTY
4314: LIST
4315: DIFF
4316: PUSH
4317: LD_INT 0
4319: PLUS
4320: ST_TO_ADDR
// if MultiPlayer then
4321: LD_OWVAR 4
4325: IFFALSE 4433
// begin def_victory_conditions = GetMultiplayerSetting ( 0 ) ;
4327: LD_ADDR_EXP 48
4331: PUSH
4332: LD_INT 0
4334: PPUSH
4335: CALL_OW 426
4339: ST_TO_ADDR
// def_number_of_people = GetMultiplayerSetting ( 1 ) ;
4340: LD_ADDR_EXP 49
4344: PUSH
4345: LD_INT 1
4347: PPUSH
4348: CALL_OW 426
4352: ST_TO_ADDR
// def_people_respawning = GetMultiplayerSetting ( 2 ) ;
4353: LD_ADDR_EXP 50
4357: PUSH
4358: LD_INT 2
4360: PPUSH
4361: CALL_OW 426
4365: ST_TO_ADDR
// def_vehicles_at_start = GetMultiplayerSetting ( 3 ) ;
4366: LD_ADDR_EXP 51
4370: PUSH
4371: LD_INT 3
4373: PPUSH
4374: CALL_OW 426
4378: ST_TO_ADDR
// def_vehicles_respawning = GetMultiplayerSetting ( 4 ) ;
4379: LD_ADDR_EXP 52
4383: PUSH
4384: LD_INT 4
4386: PPUSH
4387: CALL_OW 426
4391: ST_TO_ADDR
// def_vehicles_nations = GetMultiplayerSetting ( 5 ) ;
4392: LD_ADDR_EXP 53
4396: PUSH
4397: LD_INT 5
4399: PPUSH
4400: CALL_OW 426
4404: ST_TO_ADDR
// def_siberite_rocket = GetMultiplayerSetting ( 6 ) ;
4405: LD_ADDR_EXP 54
4409: PUSH
4410: LD_INT 6
4412: PPUSH
4413: CALL_OW 426
4417: ST_TO_ADDR
// def_vehicles_durability = GetMultiplayerSetting ( 7 ) ;
4418: LD_ADDR_EXP 55
4422: PUSH
4423: LD_INT 7
4425: PPUSH
4426: CALL_OW 426
4430: ST_TO_ADDR
// end else
4431: GO 4501
// begin randomize ;
4433: CALL_OW 10
// def_victory_conditions = 2 ;
4437: LD_ADDR_EXP 48
4441: PUSH
4442: LD_INT 2
4444: ST_TO_ADDR
// def_number_of_people = 1 ;
4445: LD_ADDR_EXP 49
4449: PUSH
4450: LD_INT 1
4452: ST_TO_ADDR
// def_people_respawning = 1 ;
4453: LD_ADDR_EXP 50
4457: PUSH
4458: LD_INT 1
4460: ST_TO_ADDR
// def_vehicles_at_start = 1 ;
4461: LD_ADDR_EXP 51
4465: PUSH
4466: LD_INT 1
4468: ST_TO_ADDR
// def_vehicles_respawning = 2 ;
4469: LD_ADDR_EXP 52
4473: PUSH
4474: LD_INT 2
4476: ST_TO_ADDR
// def_vehicles_nations = 0 ;
4477: LD_ADDR_EXP 53
4481: PUSH
4482: LD_INT 0
4484: ST_TO_ADDR
// def_siberite_rocket = 1 ;
4485: LD_ADDR_EXP 54
4489: PUSH
4490: LD_INT 1
4492: ST_TO_ADDR
// def_vehicles_durability = 1 ;
4493: LD_ADDR_EXP 55
4497: PUSH
4498: LD_INT 1
4500: ST_TO_ADDR
// end ; game_time = [ 5 5$0 , 10 10$0 , 15 15$0 , 20 20$0 , 30 30$0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ def_victory_conditions + 1 ] ;
4501: LD_ADDR_EXP 56
4505: PUSH
4506: LD_INT 10500
4508: PUSH
4509: LD_INT 21000
4511: PUSH
4512: LD_INT 31500
4514: PUSH
4515: LD_INT 42000
4517: PUSH
4518: LD_INT 63000
4520: PUSH
4521: LD_INT 0
4523: PUSH
4524: LD_INT 0
4526: PUSH
4527: LD_INT 0
4529: PUSH
4530: LD_INT 0
4532: PUSH
4533: LD_INT 0
4535: PUSH
4536: LD_INT 0
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: PUSH
4552: LD_EXP 48
4556: PUSH
4557: LD_INT 1
4559: PLUS
4560: ARRAY
4561: ST_TO_ADDR
// point_limit = [ 0 , 0 , 0 , 0 , 0 , 5 , 10 , 15 , 20 , 30 , 50 ] [ def_victory_conditions + 1 ] ;
4562: LD_ADDR_EXP 57
4566: PUSH
4567: LD_INT 0
4569: PUSH
4570: LD_INT 0
4572: PUSH
4573: LD_INT 0
4575: PUSH
4576: LD_INT 0
4578: PUSH
4579: LD_INT 0
4581: PUSH
4582: LD_INT 5
4584: PUSH
4585: LD_INT 10
4587: PUSH
4588: LD_INT 15
4590: PUSH
4591: LD_INT 20
4593: PUSH
4594: LD_INT 30
4596: PUSH
4597: LD_INT 50
4599: PUSH
4600: EMPTY
4601: LIST
4602: LIST
4603: LIST
4604: LIST
4605: LIST
4606: LIST
4607: LIST
4608: LIST
4609: LIST
4610: LIST
4611: LIST
4612: PUSH
4613: LD_EXP 48
4617: PUSH
4618: LD_INT 1
4620: PLUS
4621: ARRAY
4622: ST_TO_ADDR
// npeop = [ 4 , 6 , 8 , 10 ] [ def_number_of_people + 1 ] ;
4623: LD_ADDR_EXP 65
4627: PUSH
4628: LD_INT 4
4630: PUSH
4631: LD_INT 6
4633: PUSH
4634: LD_INT 8
4636: PUSH
4637: LD_INT 10
4639: PUSH
4640: EMPTY
4641: LIST
4642: LIST
4643: LIST
4644: LIST
4645: PUSH
4646: LD_EXP 49
4650: PUSH
4651: LD_INT 1
4653: PLUS
4654: ARRAY
4655: ST_TO_ADDR
// peopresp = [ false , [ 0 0$40 , 1 1$20 ] , [ 0 0$20 , 0 0$40 ] , [ 0 0$10 , 0 0$20 ] ] [ def_people_respawning + 1 ] ;
4656: LD_ADDR_EXP 66
4660: PUSH
4661: LD_INT 0
4663: PUSH
4664: LD_INT 1400
4666: PUSH
4667: LD_INT 2800
4669: PUSH
4670: EMPTY
4671: LIST
4672: LIST
4673: PUSH
4674: LD_INT 700
4676: PUSH
4677: LD_INT 1400
4679: PUSH
4680: EMPTY
4681: LIST
4682: LIST
4683: PUSH
4684: LD_INT 350
4686: PUSH
4687: LD_INT 700
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: LIST
4698: LIST
4699: PUSH
4700: LD_EXP 50
4704: PUSH
4705: LD_INT 1
4707: PLUS
4708: ARRAY
4709: ST_TO_ADDR
// vehmax1 = [ 3 , 6 , 9 ] [ def_vehicles_respawning + 1 ] ;
4710: LD_ADDR_EXP 59
4714: PUSH
4715: LD_INT 3
4717: PUSH
4718: LD_INT 6
4720: PUSH
4721: LD_INT 9
4723: PUSH
4724: EMPTY
4725: LIST
4726: LIST
4727: LIST
4728: PUSH
4729: LD_EXP 52
4733: PUSH
4734: LD_INT 1
4736: PLUS
4737: ARRAY
4738: ST_TO_ADDR
// vehmax2 = [ 2 , 4 , 6 ] [ def_vehicles_respawning + 1 ] ;
4739: LD_ADDR_EXP 60
4743: PUSH
4744: LD_INT 2
4746: PUSH
4747: LD_INT 4
4749: PUSH
4750: LD_INT 6
4752: PUSH
4753: EMPTY
4754: LIST
4755: LIST
4756: LIST
4757: PUSH
4758: LD_EXP 52
4762: PUSH
4763: LD_INT 1
4765: PLUS
4766: ARRAY
4767: ST_TO_ADDR
// vehmax = vehmax1 + side_count * vehmax2 ;
4768: LD_ADDR_EXP 61
4772: PUSH
4773: LD_EXP 59
4777: PUSH
4778: LD_EXP 37
4782: PUSH
4783: LD_EXP 60
4787: MUL
4788: PLUS
4789: ST_TO_ADDR
// vehdur = [ [ 25 , 50 ] , [ 45 , 90 ] , [ 75 , 150 ] ] [ def_vehicles_durability + 1 ] ;
4790: LD_ADDR_EXP 64
4794: PUSH
4795: LD_INT 25
4797: PUSH
4798: LD_INT 50
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PUSH
4805: LD_INT 45
4807: PUSH
4808: LD_INT 90
4810: PUSH
4811: EMPTY
4812: LIST
4813: LIST
4814: PUSH
4815: LD_INT 75
4817: PUSH
4818: LD_INT 150
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: LIST
4829: PUSH
4830: LD_EXP 55
4834: PUSH
4835: LD_INT 1
4837: PLUS
4838: ARRAY
4839: ST_TO_ADDR
// vehresp = [ [ 0 0$40 , 2 2$00 ] , [ 0 0$20 , 1 1$00 ] , [ 0 0$10 , 0 0$30 ] ] [ def_vehicles_respawning + 1 ] ;
4840: LD_ADDR_EXP 58
4844: PUSH
4845: LD_INT 1400
4847: PUSH
4848: LD_INT 4200
4850: PUSH
4851: EMPTY
4852: LIST
4853: LIST
4854: PUSH
4855: LD_INT 700
4857: PUSH
4858: LD_INT 2100
4860: PUSH
4861: EMPTY
4862: LIST
4863: LIST
4864: PUSH
4865: LD_INT 350
4867: PUSH
4868: LD_INT 1050
4870: PUSH
4871: EMPTY
4872: LIST
4873: LIST
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: LIST
4879: PUSH
4880: LD_EXP 52
4884: PUSH
4885: LD_INT 1
4887: PLUS
4888: ARRAY
4889: ST_TO_ADDR
// startvehperc = [ 0 , 10 , 20 , 40 ] [ def_vehicles_at_start + 1 ] ;
4890: LD_ADDR_EXP 62
4894: PUSH
4895: LD_INT 0
4897: PUSH
4898: LD_INT 10
4900: PUSH
4901: LD_INT 20
4903: PUSH
4904: LD_INT 40
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: LIST
4911: LIST
4912: PUSH
4913: LD_EXP 51
4917: PUSH
4918: LD_INT 1
4920: PLUS
4921: ARRAY
4922: ST_TO_ADDR
// startveh = vehmax * startvehperc div 100 ;
4923: LD_ADDR_EXP 63
4927: PUSH
4928: LD_EXP 61
4932: PUSH
4933: LD_EXP 62
4937: MUL
4938: PUSH
4939: LD_INT 100
4941: DIV
4942: ST_TO_ADDR
// vehnats = [ [ 1 , 2 , 3 ] , [ 1 ] , [ 3 ] , [ 2 ] , [ 1 , 3 ] , [ 3 , 2 ] , [ 2 , 1 ] ] [ def_vehicles_nations + 1 ] ;
4943: LD_ADDR_EXP 67
4947: PUSH
4948: LD_INT 1
4950: PUSH
4951: LD_INT 2
4953: PUSH
4954: LD_INT 3
4956: PUSH
4957: EMPTY
4958: LIST
4959: LIST
4960: LIST
4961: PUSH
4962: LD_INT 1
4964: PUSH
4965: EMPTY
4966: LIST
4967: PUSH
4968: LD_INT 3
4970: PUSH
4971: EMPTY
4972: LIST
4973: PUSH
4974: LD_INT 2
4976: PUSH
4977: EMPTY
4978: LIST
4979: PUSH
4980: LD_INT 1
4982: PUSH
4983: LD_INT 3
4985: PUSH
4986: EMPTY
4987: LIST
4988: LIST
4989: PUSH
4990: LD_INT 3
4992: PUSH
4993: LD_INT 2
4995: PUSH
4996: EMPTY
4997: LIST
4998: LIST
4999: PUSH
5000: LD_INT 2
5002: PUSH
5003: LD_INT 1
5005: PUSH
5006: EMPTY
5007: LIST
5008: LIST
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: LIST
5016: LIST
5017: LIST
5018: PUSH
5019: LD_EXP 53
5023: PUSH
5024: LD_INT 1
5026: PLUS
5027: ARRAY
5028: ST_TO_ADDR
// sibrock = [ 0 , 3 , 7 ] [ def_siberite_rocket + 1 ] ;
5029: LD_ADDR_EXP 68
5033: PUSH
5034: LD_INT 0
5036: PUSH
5037: LD_INT 3
5039: PUSH
5040: LD_INT 7
5042: PUSH
5043: EMPTY
5044: LIST
5045: LIST
5046: LIST
5047: PUSH
5048: LD_EXP 54
5052: PUSH
5053: LD_INT 1
5055: PLUS
5056: ARRAY
5057: ST_TO_ADDR
// for i = 1 to 8 do
5058: LD_ADDR_VAR 0 2
5062: PUSH
5063: DOUBLE
5064: LD_INT 1
5066: DEC
5067: ST_TO_ADDR
5068: LD_INT 8
5070: PUSH
5071: FOR_TO
5072: IFFALSE 5104
// if Side_Positions [ i ] then
5074: LD_EXP 43
5078: PUSH
5079: LD_VAR 0 2
5083: ARRAY
5084: IFFALSE 5102
// to_resp := to_resp ^ i ;
5086: LD_ADDR_EXP 69
5090: PUSH
5091: LD_EXP 69
5095: PUSH
5096: LD_VAR 0 2
5100: ADD
5101: ST_TO_ADDR
5102: GO 5071
5104: POP
5105: POP
// end ;
5106: LD_VAR 0 1
5110: RET
// export chassis , weapons , areas_wheeled , areas_tracked ; function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
5111: LD_INT 0
5113: PPUSH
5114: PPUSH
5115: PPUSH
5116: PPUSH
5117: PPUSH
5118: PPUSH
5119: PPUSH
5120: PPUSH
// areas_wheeled = [ aw1 , aw2 , aw3 , aw4 ] ;
5121: LD_ADDR_EXP 72
5125: PUSH
5126: LD_INT 21
5128: PUSH
5129: LD_INT 19
5131: PUSH
5132: LD_INT 17
5134: PUSH
5135: LD_INT 15
5137: PUSH
5138: EMPTY
5139: LIST
5140: LIST
5141: LIST
5142: LIST
5143: ST_TO_ADDR
// areas_tracked = [ at1 , at2 , at3 , at4 ] ;
5144: LD_ADDR_EXP 73
5148: PUSH
5149: LD_INT 20
5151: PUSH
5152: LD_INT 18
5154: PUSH
5155: LD_INT 16
5157: PUSH
5158: LD_INT 14
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: ST_TO_ADDR
// best = 0 ;
5167: LD_ADDR_VAR 0 2
5171: PUSH
5172: LD_INT 0
5174: ST_TO_ADDR
// for n = 1 to 200 do
5175: LD_ADDR_VAR 0 8
5179: PUSH
5180: DOUBLE
5181: LD_INT 1
5183: DEC
5184: ST_TO_ADDR
5185: LD_INT 200
5187: PUSH
5188: FOR_TO
5189: IFFALSE 5485
// begin c = [ ] ;
5191: LD_ADDR_VAR 0 3
5195: PUSH
5196: EMPTY
5197: ST_TO_ADDR
// for i = 1 to side_count do
5198: LD_ADDR_VAR 0 6
5202: PUSH
5203: DOUBLE
5204: LD_INT 1
5206: DEC
5207: ST_TO_ADDR
5208: LD_EXP 37
5212: PUSH
5213: FOR_TO
5214: IFFALSE 5243
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
5216: LD_ADDR_VAR 0 3
5220: PUSH
5221: LD_VAR 0 3
5225: PUSH
5226: LD_INT 22
5228: PPUSH
5229: LD_INT 0
5231: PPUSH
5232: CALL_OW 16
5236: PUSH
5237: EMPTY
5238: LIST
5239: ADD
5240: ST_TO_ADDR
5241: GO 5213
5243: POP
5244: POP
// minv = 10000 ;
5245: LD_ADDR_VAR 0 5
5249: PUSH
5250: LD_INT 10000
5252: ST_TO_ADDR
// for i = 1 to side_count do
5253: LD_ADDR_VAR 0 6
5257: PUSH
5258: DOUBLE
5259: LD_INT 1
5261: DEC
5262: ST_TO_ADDR
5263: LD_EXP 37
5267: PUSH
5268: FOR_TO
5269: IFFALSE 5449
// for j = 1 to side_count do
5271: LD_ADDR_VAR 0 7
5275: PUSH
5276: DOUBLE
5277: LD_INT 1
5279: DEC
5280: ST_TO_ADDR
5281: LD_EXP 37
5285: PUSH
5286: FOR_TO
5287: IFFALSE 5445
// if i <> j then
5289: LD_VAR 0 6
5293: PUSH
5294: LD_VAR 0 7
5298: NONEQUAL
5299: IFFALSE 5443
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
5301: LD_VAR 0 3
5305: PUSH
5306: LD_VAR 0 6
5310: ARRAY
5311: PUSH
5312: LD_INT 1
5314: ARRAY
5315: PPUSH
5316: LD_VAR 0 3
5320: PUSH
5321: LD_VAR 0 6
5325: ARRAY
5326: PUSH
5327: LD_INT 2
5329: ARRAY
5330: PPUSH
5331: LD_VAR 0 3
5335: PUSH
5336: LD_VAR 0 7
5340: ARRAY
5341: PUSH
5342: LD_INT 1
5344: ARRAY
5345: PPUSH
5346: LD_VAR 0 3
5350: PUSH
5351: LD_VAR 0 7
5355: ARRAY
5356: PUSH
5357: LD_INT 2
5359: ARRAY
5360: PPUSH
5361: CALL_OW 298
5365: PUSH
5366: LD_VAR 0 5
5370: LESS
5371: IFFALSE 5443
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
5373: LD_ADDR_VAR 0 5
5377: PUSH
5378: LD_VAR 0 3
5382: PUSH
5383: LD_VAR 0 6
5387: ARRAY
5388: PUSH
5389: LD_INT 1
5391: ARRAY
5392: PPUSH
5393: LD_VAR 0 3
5397: PUSH
5398: LD_VAR 0 6
5402: ARRAY
5403: PUSH
5404: LD_INT 2
5406: ARRAY
5407: PPUSH
5408: LD_VAR 0 3
5412: PUSH
5413: LD_VAR 0 7
5417: ARRAY
5418: PUSH
5419: LD_INT 1
5421: ARRAY
5422: PPUSH
5423: LD_VAR 0 3
5427: PUSH
5428: LD_VAR 0 7
5432: ARRAY
5433: PUSH
5434: LD_INT 2
5436: ARRAY
5437: PPUSH
5438: CALL_OW 298
5442: ST_TO_ADDR
// end ;
5443: GO 5286
5445: POP
5446: POP
5447: GO 5268
5449: POP
5450: POP
// if minv > best then
5451: LD_VAR 0 5
5455: PUSH
5456: LD_VAR 0 2
5460: GREATER
5461: IFFALSE 5483
// begin best := minv ;
5463: LD_ADDR_VAR 0 2
5467: PUSH
5468: LD_VAR 0 5
5472: ST_TO_ADDR
// bestc := c ;
5473: LD_ADDR_VAR 0 4
5477: PUSH
5478: LD_VAR 0 3
5482: ST_TO_ADDR
// end ; end ;
5483: GO 5188
5485: POP
5486: POP
// coordinates := [ ] ;
5487: LD_ADDR_EXP 34
5491: PUSH
5492: EMPTY
5493: ST_TO_ADDR
// for i = 1 to 8 do
5494: LD_ADDR_VAR 0 6
5498: PUSH
5499: DOUBLE
5500: LD_INT 1
5502: DEC
5503: ST_TO_ADDR
5504: LD_INT 8
5506: PUSH
5507: FOR_TO
5508: IFFALSE 5595
// if side_positions [ i ] = 0 then
5510: LD_EXP 43
5514: PUSH
5515: LD_VAR 0 6
5519: ARRAY
5520: PUSH
5521: LD_INT 0
5523: EQUAL
5524: IFFALSE 5552
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
5526: LD_ADDR_EXP 34
5530: PUSH
5531: LD_EXP 34
5535: PUSH
5536: LD_INT 0
5538: PUSH
5539: LD_INT 0
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: PUSH
5546: EMPTY
5547: LIST
5548: ADD
5549: ST_TO_ADDR
5550: GO 5593
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
5552: LD_ADDR_EXP 34
5556: PUSH
5557: LD_EXP 34
5561: PUSH
5562: LD_VAR 0 4
5566: PUSH
5567: LD_INT 1
5569: ARRAY
5570: PUSH
5571: EMPTY
5572: LIST
5573: ADD
5574: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
5575: LD_ADDR_VAR 0 4
5579: PUSH
5580: LD_VAR 0 4
5584: PPUSH
5585: LD_INT 1
5587: PPUSH
5588: CALL_OW 3
5592: ST_TO_ADDR
// end ;
5593: GO 5507
5595: POP
5596: POP
// end ;
5597: LD_VAR 0 1
5601: RET
// function prepare_constants ; begin
5602: LD_INT 0
5604: PPUSH
// chassis = [ [ [ [ us_light_wheeled ] , [ ] ] , [ [ us_medium_wheeled ] , [ us_medium_tracked ] ] , [ [ ] , [ us_heavy_tracked , us_morphling ] ] ] , [ [ [ ar_light_trike , ar_hovercraft ] , [ ] ] , [ [ ar_medium_trike ] , [ ar_half_tracked ] ] , [ [ ] , [ ] ] ] , [ [ [ ] , [ ] ] , [ [ ru_medium_wheeled ] , [ ru_medium_tracked ] ] , [ [ ru_heavy_wheeled ] , [ ru_heavy_tracked ] ] ] ] ;
5605: LD_ADDR_EXP 70
5609: PUSH
5610: LD_INT 1
5612: PUSH
5613: EMPTY
5614: LIST
5615: PUSH
5616: EMPTY
5617: PUSH
5618: EMPTY
5619: LIST
5620: LIST
5621: PUSH
5622: LD_INT 2
5624: PUSH
5625: EMPTY
5626: LIST
5627: PUSH
5628: LD_INT 3
5630: PUSH
5631: EMPTY
5632: LIST
5633: PUSH
5634: EMPTY
5635: LIST
5636: LIST
5637: PUSH
5638: EMPTY
5639: PUSH
5640: LD_INT 4
5642: PUSH
5643: LD_INT 5
5645: PUSH
5646: EMPTY
5647: LIST
5648: LIST
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: LIST
5658: PUSH
5659: LD_INT 12
5661: PUSH
5662: LD_INT 11
5664: PUSH
5665: EMPTY
5666: LIST
5667: LIST
5668: PUSH
5669: EMPTY
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 13
5677: PUSH
5678: EMPTY
5679: LIST
5680: PUSH
5681: LD_INT 14
5683: PUSH
5684: EMPTY
5685: LIST
5686: PUSH
5687: EMPTY
5688: LIST
5689: LIST
5690: PUSH
5691: EMPTY
5692: PUSH
5693: EMPTY
5694: PUSH
5695: EMPTY
5696: LIST
5697: LIST
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: EMPTY
5705: PUSH
5706: EMPTY
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PUSH
5712: LD_INT 21
5714: PUSH
5715: EMPTY
5716: LIST
5717: PUSH
5718: LD_INT 22
5720: PUSH
5721: EMPTY
5722: LIST
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: LD_INT 23
5730: PUSH
5731: EMPTY
5732: LIST
5733: PUSH
5734: LD_INT 24
5736: PUSH
5737: EMPTY
5738: LIST
5739: PUSH
5740: EMPTY
5741: LIST
5742: LIST
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: LIST
5748: PUSH
5749: EMPTY
5750: LIST
5751: LIST
5752: LIST
5753: ST_TO_ADDR
// weapons = [ [ [ us_machine_gun , 1 , 100 ] , [ us_light_gun , 1 , 100 ] , [ us_radar , 1 , 100 ] , [ us_gatling_gun , 2 , 100 ] , [ us_double_gun , 2 , 100 ] , [ us_rocket_launcher , 2 , 100 ] , [ us_laser , 2 , 100 ] , [ us_heavy_gun , 3 , 100 ] , [ us_bulldozer , 3 , 100 ] , [ us_double_laser , 3 , 100 ] ] , [ [ ar_multimissile_ballista , 1 , 100 ] , [ ar_double_machine_gun , 1 , 100 ] , [ ar_light_gun , 1 , 100 ] , [ ar_radar , 1 , 100 ] , [ ar_gatling_gun , 2 , 100 ] , [ ar_gun , 2 , 100 ] , [ ar_rocket_launcher , 2 , 100 ] , [ ar_selfpropelled_bomb , 2 , 100 ] , [ ar_flame_thrower , 2 , 100 ] ] , [ [ ru_heavy_machine_gun , 2 , 100 ] , [ ru_gatling_gun , 2 , 100 ] , [ ru_gun , 2 , 100 ] , [ ru_rocket_launcher , 2 , 100 ] , [ ru_heavy_gun , 3 , 100 ] , [ ru_rocket , 3 , 100 ] , [ ru_bulldozer , 3 , 100 ] ] ] ;
5754: LD_ADDR_EXP 71
5758: PUSH
5759: LD_INT 2
5761: PUSH
5762: LD_INT 1
5764: PUSH
5765: LD_INT 100
5767: PUSH
5768: EMPTY
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 3
5775: PUSH
5776: LD_INT 1
5778: PUSH
5779: LD_INT 100
5781: PUSH
5782: EMPTY
5783: LIST
5784: LIST
5785: LIST
5786: PUSH
5787: LD_INT 11
5789: PUSH
5790: LD_INT 1
5792: PUSH
5793: LD_INT 100
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: LIST
5800: PUSH
5801: LD_INT 4
5803: PUSH
5804: LD_INT 2
5806: PUSH
5807: LD_INT 100
5809: PUSH
5810: EMPTY
5811: LIST
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 5
5817: PUSH
5818: LD_INT 2
5820: PUSH
5821: LD_INT 100
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: LIST
5828: PUSH
5829: LD_INT 7
5831: PUSH
5832: LD_INT 2
5834: PUSH
5835: LD_INT 100
5837: PUSH
5838: EMPTY
5839: LIST
5840: LIST
5841: LIST
5842: PUSH
5843: LD_INT 9
5845: PUSH
5846: LD_INT 2
5848: PUSH
5849: LD_INT 100
5851: PUSH
5852: EMPTY
5853: LIST
5854: LIST
5855: LIST
5856: PUSH
5857: LD_INT 6
5859: PUSH
5860: LD_INT 3
5862: PUSH
5863: LD_INT 100
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: LIST
5870: PUSH
5871: LD_INT 14
5873: PUSH
5874: LD_INT 3
5876: PUSH
5877: LD_INT 100
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: LIST
5884: PUSH
5885: LD_INT 10
5887: PUSH
5888: LD_INT 3
5890: PUSH
5891: LD_INT 100
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: EMPTY
5900: LIST
5901: LIST
5902: LIST
5903: LIST
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: PUSH
5911: LD_INT 22
5913: PUSH
5914: LD_INT 1
5916: PUSH
5917: LD_INT 100
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 24
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 100
5933: PUSH
5934: EMPTY
5935: LIST
5936: LIST
5937: LIST
5938: PUSH
5939: LD_INT 23
5941: PUSH
5942: LD_INT 1
5944: PUSH
5945: LD_INT 100
5947: PUSH
5948: EMPTY
5949: LIST
5950: LIST
5951: LIST
5952: PUSH
5953: LD_INT 30
5955: PUSH
5956: LD_INT 1
5958: PUSH
5959: LD_INT 100
5961: PUSH
5962: EMPTY
5963: LIST
5964: LIST
5965: LIST
5966: PUSH
5967: LD_INT 25
5969: PUSH
5970: LD_INT 2
5972: PUSH
5973: LD_INT 100
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: PUSH
5981: LD_INT 27
5983: PUSH
5984: LD_INT 2
5986: PUSH
5987: LD_INT 100
5989: PUSH
5990: EMPTY
5991: LIST
5992: LIST
5993: LIST
5994: PUSH
5995: LD_INT 28
5997: PUSH
5998: LD_INT 2
6000: PUSH
6001: LD_INT 100
6003: PUSH
6004: EMPTY
6005: LIST
6006: LIST
6007: LIST
6008: PUSH
6009: LD_INT 29
6011: PUSH
6012: LD_INT 2
6014: PUSH
6015: LD_INT 100
6017: PUSH
6018: EMPTY
6019: LIST
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 26
6025: PUSH
6026: LD_INT 2
6028: PUSH
6029: LD_INT 100
6031: PUSH
6032: EMPTY
6033: LIST
6034: LIST
6035: LIST
6036: PUSH
6037: EMPTY
6038: LIST
6039: LIST
6040: LIST
6041: LIST
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 42
6050: PUSH
6051: LD_INT 2
6053: PUSH
6054: LD_INT 100
6056: PUSH
6057: EMPTY
6058: LIST
6059: LIST
6060: LIST
6061: PUSH
6062: LD_INT 43
6064: PUSH
6065: LD_INT 2
6067: PUSH
6068: LD_INT 100
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: PUSH
6076: LD_INT 44
6078: PUSH
6079: LD_INT 2
6081: PUSH
6082: LD_INT 100
6084: PUSH
6085: EMPTY
6086: LIST
6087: LIST
6088: LIST
6089: PUSH
6090: LD_INT 45
6092: PUSH
6093: LD_INT 2
6095: PUSH
6096: LD_INT 100
6098: PUSH
6099: EMPTY
6100: LIST
6101: LIST
6102: LIST
6103: PUSH
6104: LD_INT 46
6106: PUSH
6107: LD_INT 3
6109: PUSH
6110: LD_INT 100
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: PUSH
6118: LD_INT 47
6120: PUSH
6121: LD_INT 3
6123: PUSH
6124: LD_INT 100
6126: PUSH
6127: EMPTY
6128: LIST
6129: LIST
6130: LIST
6131: PUSH
6132: LD_INT 53
6134: PUSH
6135: LD_INT 3
6137: PUSH
6138: LD_INT 100
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: LIST
6145: PUSH
6146: EMPTY
6147: LIST
6148: LIST
6149: LIST
6150: LIST
6151: LIST
6152: LIST
6153: LIST
6154: PUSH
6155: EMPTY
6156: LIST
6157: LIST
6158: LIST
6159: ST_TO_ADDR
// end ;
6160: LD_VAR 0 1
6164: RET
// var is_tracked ; function random_vehicle ( sibrockprob ) ; var nat , wpset , suma , tmp , i , weap , wwght , wght , chs , trck ; begin
6165: LD_INT 0
6167: PPUSH
6168: PPUSH
6169: PPUSH
6170: PPUSH
6171: PPUSH
6172: PPUSH
6173: PPUSH
6174: PPUSH
6175: PPUSH
6176: PPUSH
6177: PPUSH
// nat := vehnats [ rand ( 1 , vehnats ) ] ;
6178: LD_ADDR_VAR 0 3
6182: PUSH
6183: LD_EXP 67
6187: PUSH
6188: LD_INT 1
6190: PPUSH
6191: LD_EXP 67
6195: PPUSH
6196: CALL_OW 12
6200: ARRAY
6201: ST_TO_ADDR
// if ( nat in [ nation_russian , nation_american ] ) and ( Rand ( 1 , 1000 ) <= sibrockprob ) then
6202: LD_VAR 0 3
6206: PUSH
6207: LD_INT 3
6209: PUSH
6210: LD_INT 1
6212: PUSH
6213: EMPTY
6214: LIST
6215: LIST
6216: IN
6217: PUSH
6218: LD_INT 1
6220: PPUSH
6221: LD_INT 1000
6223: PPUSH
6224: CALL_OW 12
6228: PUSH
6229: LD_VAR 0 1
6233: LESSEQUAL
6234: AND
6235: IFFALSE 6291
// begin wght := 3 ;
6237: LD_ADDR_VAR 0 10
6241: PUSH
6242: LD_INT 3
6244: ST_TO_ADDR
// case nat of nation_russian :
6245: LD_VAR 0 3
6249: PUSH
6250: LD_INT 3
6252: DOUBLE
6253: EQUAL
6254: IFTRUE 6258
6256: GO 6269
6258: POP
// weap := ru_siberium_rocket ; nation_american :
6259: LD_ADDR_VAR 0 8
6263: PUSH
6264: LD_INT 48
6266: ST_TO_ADDR
6267: GO 6289
6269: LD_INT 1
6271: DOUBLE
6272: EQUAL
6273: IFTRUE 6277
6275: GO 6288
6277: POP
// weap := us_siberium_rocket ; end ;
6278: LD_ADDR_VAR 0 8
6282: PUSH
6283: LD_INT 8
6285: ST_TO_ADDR
6286: GO 6289
6288: POP
// end else
6289: GO 6493
// begin wpset := weapons [ nat ] ;
6291: LD_ADDR_VAR 0 4
6295: PUSH
6296: LD_EXP 71
6300: PUSH
6301: LD_VAR 0 3
6305: ARRAY
6306: ST_TO_ADDR
// suma := 0 ;
6307: LD_ADDR_VAR 0 5
6311: PUSH
6312: LD_INT 0
6314: ST_TO_ADDR
// for i := 1 to wpset do
6315: LD_ADDR_VAR 0 7
6319: PUSH
6320: DOUBLE
6321: LD_INT 1
6323: DEC
6324: ST_TO_ADDR
6325: LD_VAR 0 4
6329: PUSH
6330: FOR_TO
6331: IFFALSE 6361
// suma := suma + wpset [ i ] [ 3 ] ;
6333: LD_ADDR_VAR 0 5
6337: PUSH
6338: LD_VAR 0 5
6342: PUSH
6343: LD_VAR 0 4
6347: PUSH
6348: LD_VAR 0 7
6352: ARRAY
6353: PUSH
6354: LD_INT 3
6356: ARRAY
6357: PLUS
6358: ST_TO_ADDR
6359: GO 6330
6361: POP
6362: POP
// tmp := rand ( 1 , suma ) ;
6363: LD_ADDR_VAR 0 6
6367: PUSH
6368: LD_INT 1
6370: PPUSH
6371: LD_VAR 0 5
6375: PPUSH
6376: CALL_OW 12
6380: ST_TO_ADDR
// i := 1 ;
6381: LD_ADDR_VAR 0 7
6385: PUSH
6386: LD_INT 1
6388: ST_TO_ADDR
// while wpset [ i ] [ 3 ] < tmp do
6389: LD_VAR 0 4
6393: PUSH
6394: LD_VAR 0 7
6398: ARRAY
6399: PUSH
6400: LD_INT 3
6402: ARRAY
6403: PUSH
6404: LD_VAR 0 6
6408: LESS
6409: IFFALSE 6453
// begin tmp := tmp - wpset [ i ] [ 3 ] ;
6411: LD_ADDR_VAR 0 6
6415: PUSH
6416: LD_VAR 0 6
6420: PUSH
6421: LD_VAR 0 4
6425: PUSH
6426: LD_VAR 0 7
6430: ARRAY
6431: PUSH
6432: LD_INT 3
6434: ARRAY
6435: MINUS
6436: ST_TO_ADDR
// i := i + 1 ;
6437: LD_ADDR_VAR 0 7
6441: PUSH
6442: LD_VAR 0 7
6446: PUSH
6447: LD_INT 1
6449: PLUS
6450: ST_TO_ADDR
// end ;
6451: GO 6389
// weap := wpset [ i ] [ 1 ] ;
6453: LD_ADDR_VAR 0 8
6457: PUSH
6458: LD_VAR 0 4
6462: PUSH
6463: LD_VAR 0 7
6467: ARRAY
6468: PUSH
6469: LD_INT 1
6471: ARRAY
6472: ST_TO_ADDR
// wwght := wpset [ i ] [ 2 ] ;
6473: LD_ADDR_VAR 0 9
6477: PUSH
6478: LD_VAR 0 4
6482: PUSH
6483: LD_VAR 0 7
6487: ARRAY
6488: PUSH
6489: LD_INT 2
6491: ARRAY
6492: ST_TO_ADDR
// end ; repeat trck := Rand ( 1 , 2 ) ;
6493: LD_ADDR_VAR 0 12
6497: PUSH
6498: LD_INT 1
6500: PPUSH
6501: LD_INT 2
6503: PPUSH
6504: CALL_OW 12
6508: ST_TO_ADDR
// case wwght of 3 :
6509: LD_VAR 0 9
6513: PUSH
6514: LD_INT 3
6516: DOUBLE
6517: EQUAL
6518: IFTRUE 6522
6520: GO 6533
6522: POP
// wght := 3 ; 2 :
6523: LD_ADDR_VAR 0 10
6527: PUSH
6528: LD_INT 3
6530: ST_TO_ADDR
6531: GO 6650
6533: LD_INT 2
6535: DOUBLE
6536: EQUAL
6537: IFTRUE 6541
6539: GO 6578
6541: POP
// if Rand ( 1 , 100 ) <= 80 then
6542: LD_INT 1
6544: PPUSH
6545: LD_INT 100
6547: PPUSH
6548: CALL_OW 12
6552: PUSH
6553: LD_INT 80
6555: LESSEQUAL
6556: IFFALSE 6568
// wght := 2 else
6558: LD_ADDR_VAR 0 10
6562: PUSH
6563: LD_INT 2
6565: ST_TO_ADDR
6566: GO 6576
// wght := 3 ; 1 :
6568: LD_ADDR_VAR 0 10
6572: PUSH
6573: LD_INT 3
6575: ST_TO_ADDR
6576: GO 6650
6578: LD_INT 1
6580: DOUBLE
6581: EQUAL
6582: IFTRUE 6586
6584: GO 6649
6586: POP
// if Rand ( 1 , 100 ) <= 80 then
6587: LD_INT 1
6589: PPUSH
6590: LD_INT 100
6592: PPUSH
6593: CALL_OW 12
6597: PUSH
6598: LD_INT 80
6600: LESSEQUAL
6601: IFFALSE 6613
// wght := 1 else
6603: LD_ADDR_VAR 0 10
6607: PUSH
6608: LD_INT 1
6610: ST_TO_ADDR
6611: GO 6647
// if Rand ( 1 , 100 ) <= 80 then
6613: LD_INT 1
6615: PPUSH
6616: LD_INT 100
6618: PPUSH
6619: CALL_OW 12
6623: PUSH
6624: LD_INT 80
6626: LESSEQUAL
6627: IFFALSE 6639
// wght := 2 else
6629: LD_ADDR_VAR 0 10
6633: PUSH
6634: LD_INT 2
6636: ST_TO_ADDR
6637: GO 6647
// wght := 3 ; end ;
6639: LD_ADDR_VAR 0 10
6643: PUSH
6644: LD_INT 3
6646: ST_TO_ADDR
6647: GO 6650
6649: POP
// if chassis [ nat ] [ wght ] [ trck ] then
6650: LD_EXP 70
6654: PUSH
6655: LD_VAR 0 3
6659: ARRAY
6660: PUSH
6661: LD_VAR 0 10
6665: ARRAY
6666: PUSH
6667: LD_VAR 0 12
6671: ARRAY
6672: IFFALSE 6736
// chs := chassis [ nat ] [ wght ] [ trck ] [ Rand ( 1 , chassis [ nat ] [ wght ] [ trck ] ) ] else
6674: LD_ADDR_VAR 0 11
6678: PUSH
6679: LD_EXP 70
6683: PUSH
6684: LD_VAR 0 3
6688: ARRAY
6689: PUSH
6690: LD_VAR 0 10
6694: ARRAY
6695: PUSH
6696: LD_VAR 0 12
6700: ARRAY
6701: PUSH
6702: LD_INT 1
6704: PPUSH
6705: LD_EXP 70
6709: PUSH
6710: LD_VAR 0 3
6714: ARRAY
6715: PUSH
6716: LD_VAR 0 10
6720: ARRAY
6721: PUSH
6722: LD_VAR 0 12
6726: ARRAY
6727: PPUSH
6728: CALL_OW 12
6732: ARRAY
6733: ST_TO_ADDR
6734: GO 6744
// chs := 0 ;
6736: LD_ADDR_VAR 0 11
6740: PUSH
6741: LD_INT 0
6743: ST_TO_ADDR
// until chs ;
6744: LD_VAR 0 11
6748: IFFALSE 6493
// uc_side := 0 ;
6750: LD_ADDR_OWVAR 20
6754: PUSH
6755: LD_INT 0
6757: ST_TO_ADDR
// uc_nation := nat ;
6758: LD_ADDR_OWVAR 21
6762: PUSH
6763: LD_VAR 0 3
6767: ST_TO_ADDR
// uc_direction := rand ( 0 , 5 ) ;
6768: LD_ADDR_OWVAR 24
6772: PUSH
6773: LD_INT 0
6775: PPUSH
6776: LD_INT 5
6778: PPUSH
6779: CALL_OW 12
6783: ST_TO_ADDR
// vc_chassis := chs ;
6784: LD_ADDR_OWVAR 37
6788: PUSH
6789: LD_VAR 0 11
6793: ST_TO_ADDR
// vc_weapon := weap ;
6794: LD_ADDR_OWVAR 40
6798: PUSH
6799: LD_VAR 0 8
6803: ST_TO_ADDR
// vc_control := control_manual ;
6804: LD_ADDR_OWVAR 38
6808: PUSH
6809: LD_INT 1
6811: ST_TO_ADDR
// case wght of 1 :
6812: LD_VAR 0 10
6816: PUSH
6817: LD_INT 1
6819: DOUBLE
6820: EQUAL
6821: IFTRUE 6825
6823: GO 6836
6825: POP
// vc_engine := engine_solar ; 2 , 3 :
6826: LD_ADDR_OWVAR 39
6830: PUSH
6831: LD_INT 2
6833: ST_TO_ADDR
6834: GO 6862
6836: LD_INT 2
6838: DOUBLE
6839: EQUAL
6840: IFTRUE 6850
6842: LD_INT 3
6844: DOUBLE
6845: EQUAL
6846: IFTRUE 6850
6848: GO 6861
6850: POP
// vc_engine := engine_siberite ; end ;
6851: LD_ADDR_OWVAR 39
6855: PUSH
6856: LD_INT 3
6858: ST_TO_ADDR
6859: GO 6862
6861: POP
// is_tracked := trck = 2 ;
6862: LD_ADDR_LOC 1
6866: PUSH
6867: LD_VAR 0 12
6871: PUSH
6872: LD_INT 2
6874: EQUAL
6875: ST_TO_ADDR
// end ;
6876: LD_VAR 0 2
6880: RET
// export function vehicles_create_vehicle ( atstart ) ; var v , ar ; begin
6881: LD_INT 0
6883: PPUSH
6884: PPUSH
6885: PPUSH
// if atstart then
6886: LD_VAR 0 1
6890: IFFALSE 6901
// random_vehicle ( 0 ) else
6892: LD_INT 0
6894: PPUSH
6895: CALL 6165 0 1
6899: GO 6910
// random_vehicle ( sibrock ) ;
6901: LD_EXP 68
6905: PPUSH
6906: CALL 6165 0 1
// v := CreateVehicle ;
6910: LD_ADDR_VAR 0 3
6914: PUSH
6915: CALL_OW 45
6919: ST_TO_ADDR
// if is_tracked then
6920: LD_LOC 1
6924: IFFALSE 6952
// ar := areas_tracked [ Rand ( 1 , areas_tracked ) ] else
6926: LD_ADDR_VAR 0 4
6930: PUSH
6931: LD_EXP 73
6935: PUSH
6936: LD_INT 1
6938: PPUSH
6939: LD_EXP 73
6943: PPUSH
6944: CALL_OW 12
6948: ARRAY
6949: ST_TO_ADDR
6950: GO 6976
// ar := areas_wheeled [ Rand ( 1 , areas_wheeled ) ] ;
6952: LD_ADDR_VAR 0 4
6956: PUSH
6957: LD_EXP 72
6961: PUSH
6962: LD_INT 1
6964: PPUSH
6965: LD_EXP 72
6969: PPUSH
6970: CALL_OW 12
6974: ARRAY
6975: ST_TO_ADDR
// PlaceUnitArea ( v , ar , not atstart ) ;
6976: LD_VAR 0 3
6980: PPUSH
6981: LD_VAR 0 4
6985: PPUSH
6986: LD_VAR 0 1
6990: NOT
6991: PPUSH
6992: CALL_OW 49
// end ;
6996: LD_VAR 0 2
7000: RET
// function prepare_vehicles ; var i ; begin
7001: LD_INT 0
7003: PPUSH
7004: PPUSH
// for i := 1 to startveh do
7005: LD_ADDR_VAR 0 2
7009: PUSH
7010: DOUBLE
7011: LD_INT 1
7013: DEC
7014: ST_TO_ADDR
7015: LD_EXP 63
7019: PUSH
7020: FOR_TO
7021: IFFALSE 7032
// begin vehicles_create_vehicle ( true ) ;
7023: LD_INT 1
7025: PPUSH
7026: CALL 6881 0 1
// end ;
7030: GO 7020
7032: POP
7033: POP
// end ;
7034: LD_VAR 0 1
7038: RET
// function set_attitudes ; var i , j ; begin
7039: LD_INT 0
7041: PPUSH
7042: PPUSH
7043: PPUSH
// if not Team_Game then
7044: LD_EXP 47
7048: NOT
7049: IFFALSE 7145
// begin for i = 1 to 8 do
7051: LD_ADDR_VAR 0 2
7055: PUSH
7056: DOUBLE
7057: LD_INT 1
7059: DEC
7060: ST_TO_ADDR
7061: LD_INT 8
7063: PUSH
7064: FOR_TO
7065: IFFALSE 7143
// for j = 1 to 8 do
7067: LD_ADDR_VAR 0 3
7071: PUSH
7072: DOUBLE
7073: LD_INT 1
7075: DEC
7076: ST_TO_ADDR
7077: LD_INT 8
7079: PUSH
7080: FOR_TO
7081: IFFALSE 7139
// if i <> j then
7083: LD_VAR 0 2
7087: PUSH
7088: LD_VAR 0 3
7092: NONEQUAL
7093: IFFALSE 7117
// SetAttitude ( i , j , att_enemy , true ) else
7095: LD_VAR 0 2
7099: PPUSH
7100: LD_VAR 0 3
7104: PPUSH
7105: LD_INT 2
7107: PPUSH
7108: LD_INT 1
7110: PPUSH
7111: CALL_OW 80
7115: GO 7137
// SetAttitude ( i , j , att_friend , true ) end ;
7117: LD_VAR 0 2
7121: PPUSH
7122: LD_VAR 0 3
7126: PPUSH
7127: LD_INT 1
7129: PPUSH
7130: LD_INT 1
7132: PPUSH
7133: CALL_OW 80
7137: GO 7080
7139: POP
7140: POP
7141: GO 7064
7143: POP
7144: POP
// end ;
7145: LD_VAR 0 1
7149: RET
// function prepare_side ( side ) ; var i ; begin
7150: LD_INT 0
7152: PPUSH
7153: PPUSH
// for i := 1 to npeop do
7154: LD_ADDR_VAR 0 3
7158: PUSH
7159: DOUBLE
7160: LD_INT 1
7162: DEC
7163: ST_TO_ADDR
7164: LD_EXP 65
7168: PUSH
7169: FOR_TO
7170: IFFALSE 7279
// begin uc_side := side ;
7172: LD_ADDR_OWVAR 20
7176: PUSH
7177: LD_VAR 0 1
7181: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
7182: LD_ADDR_OWVAR 21
7186: PUSH
7187: LD_EXP 44
7191: PUSH
7192: LD_VAR 0 1
7196: ARRAY
7197: ST_TO_ADDR
// hc_name :=  ;
7198: LD_ADDR_OWVAR 26
7202: PUSH
7203: LD_STRING 
7205: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
7206: LD_INT 0
7208: PPUSH
7209: LD_INT 4
7211: PPUSH
7212: CALL_OW 383
// hc_importance := 0 ;
7216: LD_ADDR_OWVAR 32
7220: PUSH
7221: LD_INT 0
7223: ST_TO_ADDR
// hc_gallery :=  ;
7224: LD_ADDR_OWVAR 33
7228: PUSH
7229: LD_STRING 
7231: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 4 , false ) ;
7232: CALL_OW 44
7236: PPUSH
7237: LD_EXP 34
7241: PUSH
7242: LD_VAR 0 1
7246: ARRAY
7247: PUSH
7248: LD_INT 1
7250: ARRAY
7251: PPUSH
7252: LD_EXP 34
7256: PUSH
7257: LD_VAR 0 1
7261: ARRAY
7262: PUSH
7263: LD_INT 2
7265: ARRAY
7266: PPUSH
7267: LD_INT 4
7269: PPUSH
7270: LD_INT 0
7272: PPUSH
7273: CALL_OW 50
// end ;
7277: GO 7169
7279: POP
7280: POP
// end ;
7281: LD_VAR 0 2
7285: RET
// function prepare_sides ; var i ; begin
7286: LD_INT 0
7288: PPUSH
7289: PPUSH
// for i := 1 to 8 do
7290: LD_ADDR_VAR 0 2
7294: PUSH
7295: DOUBLE
7296: LD_INT 1
7298: DEC
7299: ST_TO_ADDR
7300: LD_INT 8
7302: PUSH
7303: FOR_TO
7304: IFFALSE 7329
// if side_positions [ i ] then
7306: LD_EXP 43
7310: PUSH
7311: LD_VAR 0 2
7315: ARRAY
7316: IFFALSE 7327
// prepare_side ( i ) ;
7318: LD_VAR 0 2
7322: PPUSH
7323: CALL 7150 0 1
7327: GO 7303
7329: POP
7330: POP
// end ;
7331: LD_VAR 0 1
7335: RET
// export function starting_vehicles ; begin
7336: LD_INT 0
7338: PPUSH
// mp_with_score := true ;
7339: LD_ADDR_OWVAR 14
7343: PUSH
7344: LD_INT 1
7346: ST_TO_ADDR
// mp_selectmsg := true ;
7347: LD_ADDR_OWVAR 13
7351: PUSH
7352: LD_INT 1
7354: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
7355: CALL 4063 0 0
// prepare_map_coordinates ;
7359: CALL 5111 0 0
// prepare_constants ;
7363: CALL 5602 0 0
// set_attitudes ;
7367: CALL 7039 0 0
// prepare_sides ;
7371: CALL 7286 0 0
// prepare_vehicles ;
7375: CALL 7001 0 0
// SetAreaMapShow ( exitarea , 1 ) ;
7379: LD_INT 5
7381: PPUSH
7382: LD_INT 1
7384: PPUSH
7385: CALL_OW 424
// your_side := Player_Side ;
7389: LD_ADDR_OWVAR 2
7393: PUSH
7394: LD_EXP 39
7398: ST_TO_ADDR
// ResetFog ;
7399: CALL_OW 335
// AnimateTrees ( true ) ;
7403: LD_INT 1
7405: PPUSH
7406: CALL_OW 573
// music_nat := Side_Nations [ your_side ] ;
7410: LD_ADDR_OWVAR 71
7414: PUSH
7415: LD_EXP 44
7419: PUSH
7420: LD_OWVAR 2
7424: ARRAY
7425: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
7426: LD_EXP 34
7430: PUSH
7431: LD_OWVAR 2
7435: ARRAY
7436: PUSH
7437: LD_INT 1
7439: ARRAY
7440: PPUSH
7441: LD_EXP 34
7445: PUSH
7446: LD_OWVAR 2
7450: ARRAY
7451: PUSH
7452: LD_INT 2
7454: ARRAY
7455: PPUSH
7456: CALL_OW 86
// end ; end_of_file
7460: LD_VAR 0 1
7464: RET
// every 0 0$0.5 + 2 marked 15 do var t , red ;
7465: GO 7467
7467: DISABLE
7468: LD_INT 0
7470: PPUSH
7471: PPUSH
// begin if not prep_time then
7472: LD_EXP 32
7476: NOT
7477: IFFALSE 7481
// exit ;
7479: GO 7603
// if tick >= prep_time then
7481: LD_OWVAR 1
7485: PUSH
7486: LD_EXP 32
7490: GREATEREQUAL
7491: IFFALSE 7506
// begin display_strings = [ ] ;
7493: LD_ADDR_OWVAR 47
7497: PUSH
7498: EMPTY
7499: ST_TO_ADDR
// sheherezade_start_the_fight ;
7500: CALL 3720 0 0
// end else
7504: GO 7603
// begin t = prep_time - tick ;
7506: LD_ADDR_VAR 0 1
7510: PUSH
7511: LD_EXP 32
7515: PUSH
7516: LD_OWVAR 1
7520: MINUS
7521: ST_TO_ADDR
// if t <= 0 0$5.5 then
7522: LD_VAR 0 1
7526: PUSH
7527: LD_INT 192
7529: LESSEQUAL
7530: IFFALSE 7552
// red := t mod 0 0$1 < 0 0$0.5 else
7532: LD_ADDR_VAR 0 2
7536: PUSH
7537: LD_VAR 0 1
7541: PUSH
7542: LD_INT 35
7544: MOD
7545: PUSH
7546: LD_INT 18
7548: LESS
7549: ST_TO_ADDR
7550: GO 7560
// red := false ;
7552: LD_ADDR_VAR 0 2
7556: PUSH
7557: LD_INT 0
7559: ST_TO_ADDR
// if red then
7560: LD_VAR 0 2
7564: IFFALSE 7585
// display_strings = [ #Sheherezade-Time2 , t ] else
7566: LD_ADDR_OWVAR 47
7570: PUSH
7571: LD_STRING #Sheherezade-Time2
7573: PUSH
7574: LD_VAR 0 1
7578: PUSH
7579: EMPTY
7580: LIST
7581: LIST
7582: ST_TO_ADDR
7583: GO 7602
// display_strings = [ #Sheherezade-Time1 , t ] ;
7585: LD_ADDR_OWVAR 47
7589: PUSH
7590: LD_STRING #Sheherezade-Time1
7592: PUSH
7593: LD_VAR 0 1
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: ST_TO_ADDR
// enable ;
7602: ENABLE
// end ; end ;
7603: PPOPN 2
7605: END
// every 4 marked 15 do
7606: GO 7608
7608: DISABLE
// begin if tick < prep_time then
7609: LD_OWVAR 1
7613: PUSH
7614: LD_EXP 32
7618: LESS
7619: IFFALSE 7634
// begin SetLives ( all_units , 1000 ) ;
7621: LD_OWVAR 3
7625: PPUSH
7626: LD_INT 1000
7628: PPUSH
7629: CALL_OW 234
// enable ;
7633: ENABLE
// end ; end ; end_of_file
7634: END
// on ApemanTamed ( ape , sci ) do begin if gametype = 15 then
7635: LD_EXP 1
7639: PUSH
7640: LD_INT 15
7642: EQUAL
7643: IFFALSE 7667
// begin if not def_apemen_abilities then
7645: LD_EXP 12
7649: NOT
7650: IFFALSE 7655
// disable else
7652: DISABLE
7653: GO 7667
// begin SetClass ( ape , class_apeman_soldier ) ;
7655: LD_VAR 0 1
7659: PPUSH
7660: LD_INT 15
7662: PPUSH
7663: CALL_OW 336
// end ; end ; end ;
7667: PPOPN 2
7669: END
// on UnitGoesToRed ( un ) do var killer , victim , near ;
7670: LD_INT 0
7672: PPUSH
7673: PPUSH
7674: PPUSH
// begin if gametype = 15 then
7675: LD_EXP 1
7679: PUSH
7680: LD_INT 15
7682: EQUAL
7683: IFFALSE 7908
// if un in sheherezades then
7685: LD_VAR 0 1
7689: PUSH
7690: LD_EXP 35
7694: IN
7695: IFFALSE 7908
// begin victim := GetSide ( un ) ;
7697: LD_ADDR_VAR 0 3
7701: PUSH
7702: LD_VAR 0 1
7706: PPUSH
7707: CALL_OW 255
7711: ST_TO_ADDR
// near := NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , victim ] , f_not , [ f_side , 0 ] ] ) , un ) ;
7712: LD_ADDR_VAR 0 4
7716: PUSH
7717: LD_INT 3
7719: PUSH
7720: LD_INT 22
7722: PUSH
7723: LD_VAR 0 3
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: PUSH
7732: LD_INT 3
7734: PUSH
7735: LD_INT 22
7737: PUSH
7738: LD_INT 0
7740: PUSH
7741: EMPTY
7742: LIST
7743: LIST
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: LIST
7749: LIST
7750: PPUSH
7751: CALL_OW 69
7755: PPUSH
7756: LD_VAR 0 1
7760: PPUSH
7761: CALL_OW 74
7765: ST_TO_ADDR
// killer := GetSide ( near ) ;
7766: LD_ADDR_VAR 0 2
7770: PUSH
7771: LD_VAR 0 4
7775: PPUSH
7776: CALL_OW 255
7780: ST_TO_ADDR
// if your_side and ( your_side = victim ) then
7781: LD_OWVAR 2
7785: PUSH
7786: LD_OWVAR 2
7790: PUSH
7791: LD_VAR 0 3
7795: EQUAL
7796: AND
7797: IFFALSE 7826
// begin wait ( 0 0$3 ) ;
7799: LD_INT 105
7801: PPUSH
7802: CALL_OW 67
// if not multiplayer then
7806: LD_OWVAR 4
7810: NOT
7811: IFFALSE 7822
// msg ( You Lost ) else
7813: LD_STRING You Lost
7815: PPUSH
7816: CALL_OW 100
7820: GO 7826
// YouLostInMultiplayer ;
7822: CALL_OW 107
// end ; sheherezades := Replace ( sheherezades , victim , 0 ) ;
7826: LD_ADDR_EXP 35
7830: PUSH
7831: LD_EXP 35
7835: PPUSH
7836: LD_VAR 0 3
7840: PPUSH
7841: LD_INT 0
7843: PPUSH
7844: CALL_OW 1
7848: ST_TO_ADDR
// SetSide ( FilterAllUnits ( [ f_side , victim ] ) , killer ) ;
7849: LD_INT 22
7851: PUSH
7852: LD_VAR 0 3
7856: PUSH
7857: EMPTY
7858: LIST
7859: LIST
7860: PPUSH
7861: CALL_OW 69
7865: PPUSH
7866: LD_VAR 0 2
7870: PPUSH
7871: CALL_OW 235
// ComStop ( FilterAllUnits ( [ f_side , killer ] ) ) ;
7875: LD_INT 22
7877: PUSH
7878: LD_VAR 0 2
7882: PUSH
7883: EMPTY
7884: LIST
7885: LIST
7886: PPUSH
7887: CALL_OW 69
7891: PPUSH
7892: CALL_OW 141
// SetLives ( un , 0 ) ;
7896: LD_VAR 0 1
7900: PPUSH
7901: LD_INT 0
7903: PPUSH
7904: CALL_OW 234
// end ; end ;
7908: PPOPN 4
7910: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if gametype = 25 then
7911: LD_EXP 1
7915: PUSH
7916: LD_INT 25
7918: EQUAL
7919: IFFALSE 8016
// begin if origside = 0 then
7921: LD_VAR 0 3
7925: PUSH
7926: LD_INT 0
7928: EQUAL
7929: IFFALSE 7969
// begin SetTag ( vehnew , Rand ( 30 , 75 ) ) ;
7931: LD_VAR 0 1
7935: PPUSH
7936: LD_INT 30
7938: PPUSH
7939: LD_INT 75
7941: PPUSH
7942: CALL_OW 12
7946: PPUSH
7947: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
7951: LD_ADDR_EXP 90
7955: PUSH
7956: LD_EXP 90
7960: PUSH
7961: LD_VAR 0 1
7965: ADD
7966: ST_TO_ADDR
// end else
7967: GO 8016
// begin SetUnitDisplayNumber ( vehnew , 0 ) ;
7969: LD_VAR 0 1
7973: PPUSH
7974: LD_INT 0
7976: PPUSH
7977: CALL_OW 505
// SetTag ( vehnew , GetTag ( vehold ) ) ;
7981: LD_VAR 0 1
7985: PPUSH
7986: LD_VAR 0 2
7990: PPUSH
7991: CALL_OW 110
7995: PPUSH
7996: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
8000: LD_ADDR_EXP 90
8004: PUSH
8005: LD_EXP 90
8009: PUSH
8010: LD_VAR 0 1
8014: ADD
8015: ST_TO_ADDR
// end ; end end ; end_of_file
8016: PPOPN 4
8018: END
// every 0 0$1 marked 25 do var i , ends , best ;
8019: GO 8021
8021: DISABLE
8022: LD_INT 0
8024: PPUSH
8025: PPUSH
8026: PPUSH
// begin ends := false ;
8027: LD_ADDR_VAR 0 2
8031: PUSH
8032: LD_INT 0
8034: ST_TO_ADDR
// best := 0 ;
8035: LD_ADDR_VAR 0 3
8039: PUSH
8040: LD_INT 0
8042: ST_TO_ADDR
// for i := 1 to 8 do
8043: LD_ADDR_VAR 0 1
8047: PUSH
8048: DOUBLE
8049: LD_INT 1
8051: DEC
8052: ST_TO_ADDR
8053: LD_INT 8
8055: PUSH
8056: FOR_TO
8057: IFFALSE 8093
// if GetMultiScore ( i ) > best then
8059: LD_VAR 0 1
8063: PPUSH
8064: CALL_OW 507
8068: PUSH
8069: LD_VAR 0 3
8073: GREATER
8074: IFFALSE 8091
// best := GetMultiScore ( i ) ;
8076: LD_ADDR_VAR 0 3
8080: PUSH
8081: LD_VAR 0 1
8085: PPUSH
8086: CALL_OW 507
8090: ST_TO_ADDR
8091: GO 8056
8093: POP
8094: POP
// if point_limit then
8095: LD_EXP 57
8099: IFFALSE 8121
// if best > point_limit then
8101: LD_VAR 0 3
8105: PUSH
8106: LD_EXP 57
8110: GREATER
8111: IFFALSE 8121
// ends := true ;
8113: LD_ADDR_VAR 0 2
8117: PUSH
8118: LD_INT 1
8120: ST_TO_ADDR
// if game_time then
8121: LD_EXP 56
8125: IFFALSE 8147
// if game_time <= tick then
8127: LD_EXP 56
8131: PUSH
8132: LD_OWVAR 1
8136: LESSEQUAL
8137: IFFALSE 8147
// ends := true ;
8139: LD_ADDR_VAR 0 2
8143: PUSH
8144: LD_INT 1
8146: ST_TO_ADDR
// if ends then
8147: LD_VAR 0 2
8151: IFFALSE 8222
// begin if GetMultiScore ( your_side ) = best then
8153: LD_OWVAR 2
8157: PPUSH
8158: CALL_OW 507
8162: PUSH
8163: LD_VAR 0 3
8167: EQUAL
8168: IFFALSE 8196
// begin wait ( 0 0$1 ) ;
8170: LD_INT 35
8172: PPUSH
8173: CALL_OW 67
// if IAmServer then
8177: CALL_OW 518
8181: IFFALSE 8190
// wait ( 0 0$1 ) ;
8183: LD_INT 35
8185: PPUSH
8186: CALL_OW 67
// YouWinInMultiplayer ;
8190: CALL_OW 106
// end else
8194: GO 8220
// begin wait ( 0 0$1 ) ;
8196: LD_INT 35
8198: PPUSH
8199: CALL_OW 67
// if IAmServer then
8203: CALL_OW 518
8207: IFFALSE 8216
// wait ( 0 0$1 ) ;
8209: LD_INT 35
8211: PPUSH
8212: CALL_OW 67
// YouLostInMultiplayer ;
8216: CALL_OW 107
// end ; end else
8220: GO 8223
// enable ;
8222: ENABLE
// end ;
8223: PPOPN 3
8225: END
// every 0 0$3 marked 15 do var win , i ;
8226: GO 8228
8228: DISABLE
8229: LD_INT 0
8231: PPUSH
8232: PPUSH
// begin win := true ;
8233: LD_ADDR_VAR 0 1
8237: PUSH
8238: LD_INT 1
8240: ST_TO_ADDR
// for i = 1 to Side_Positions do
8241: LD_ADDR_VAR 0 2
8245: PUSH
8246: DOUBLE
8247: LD_INT 1
8249: DEC
8250: ST_TO_ADDR
8251: LD_EXP 43
8255: PUSH
8256: FOR_TO
8257: IFFALSE 8321
// if Side_Positions [ i ] and ( i <> your_side ) and MultiplayerSideAlive ( i ) then
8259: LD_EXP 43
8263: PUSH
8264: LD_VAR 0 2
8268: ARRAY
8269: PUSH
8270: LD_VAR 0 2
8274: PUSH
8275: LD_OWVAR 2
8279: NONEQUAL
8280: AND
8281: PUSH
8282: LD_VAR 0 2
8286: PPUSH
8287: CALL_OW 108
8291: AND
8292: IFFALSE 8319
// if not AlliedSides ( i , your_side ) then
8294: LD_VAR 0 2
8298: PPUSH
8299: LD_OWVAR 2
8303: PPUSH
8304: CALL 8359 0 2
8308: NOT
8309: IFFALSE 8319
// win := false ;
8311: LD_ADDR_VAR 0 1
8315: PUSH
8316: LD_INT 0
8318: ST_TO_ADDR
8319: GO 8256
8321: POP
8322: POP
// if win then
8323: LD_VAR 0 1
8327: IFFALSE 8355
// begin wait ( 0 0$3 ) ;
8329: LD_INT 105
8331: PPUSH
8332: CALL_OW 67
// YouWinInMultiplayer ;
8336: CALL_OW 106
// if IAmServer then
8340: CALL_OW 518
8344: IFFALSE 8353
// wait ( 0 0$1 ) ;
8346: LD_INT 35
8348: PPUSH
8349: CALL_OW 67
// exit ;
8353: GO 8356
// end ; enable ;
8355: ENABLE
// end ;
8356: PPOPN 2
8358: END
// function AlliedSides ( i , j ) ; var vysledek ; begin
8359: LD_INT 0
8361: PPUSH
8362: PPUSH
// vysledek := false ;
8363: LD_ADDR_VAR 0 4
8367: PUSH
8368: LD_INT 0
8370: ST_TO_ADDR
// if ( GetAttitude ( i , j ) = att_friend ) and ( GetAttitude ( j , i ) = att_friend ) and GetAlliedVictory ( i ) and GetAlliedVictory ( j ) then
8371: LD_VAR 0 1
8375: PPUSH
8376: LD_VAR 0 2
8380: PPUSH
8381: CALL_OW 81
8385: PUSH
8386: LD_INT 1
8388: EQUAL
8389: PUSH
8390: LD_VAR 0 2
8394: PPUSH
8395: LD_VAR 0 1
8399: PPUSH
8400: CALL_OW 81
8404: PUSH
8405: LD_INT 1
8407: EQUAL
8408: AND
8409: PUSH
8410: LD_VAR 0 1
8414: PPUSH
8415: CALL_OW 83
8419: AND
8420: PUSH
8421: LD_VAR 0 2
8425: PPUSH
8426: CALL_OW 83
8430: AND
8431: IFFALSE 8441
// vysledek := true ;
8433: LD_ADDR_VAR 0 4
8437: PUSH
8438: LD_INT 1
8440: ST_TO_ADDR
// result := vysledek ;
8441: LD_ADDR_VAR 0 3
8445: PUSH
8446: LD_VAR 0 4
8450: ST_TO_ADDR
// end ; end_of_file
8451: LD_VAR 0 3
8455: RET
// export def_hunters , def_hunt_size , def_hunt_balance , def_hunt_limit , def_doctors ; export one_hunter , hunt_limit , size_of_ape_team , size_of_hunt_team , doctors_in_team , hunter_level , ape_level , ape_stamina , to_be_alone , people , scorestring ; function read_multiplayer_and_game_parameters ; var i , p1 , p2 ; begin
8456: LD_INT 0
8458: PPUSH
8459: PPUSH
8460: PPUSH
8461: PPUSH
// if MultiPlayer then
8462: LD_OWVAR 4
8466: IFFALSE 8530
// begin Player_Side = mp_player_side ;
8468: LD_ADDR_EXP 39
8472: PUSH
8473: LD_OWVAR 7
8477: ST_TO_ADDR
// Player_Team = mp_player_team ;
8478: LD_ADDR_EXP 40
8482: PUSH
8483: LD_OWVAR 8
8487: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
8488: LD_ADDR_EXP 43
8492: PUSH
8493: LD_OWVAR 17
8497: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
8498: LD_ADDR_EXP 41
8502: PUSH
8503: LD_OWVAR 15
8507: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
8508: LD_ADDR_EXP 44
8512: PUSH
8513: LD_OWVAR 16
8517: ST_TO_ADDR
// Teams = mp_teams ;
8518: LD_ADDR_EXP 42
8522: PUSH
8523: LD_OWVAR 12
8527: ST_TO_ADDR
// end else
8528: GO 8674
// begin randomize ;
8530: CALL_OW 10
// Player_Side = 1 ;
8534: LD_ADDR_EXP 39
8538: PUSH
8539: LD_INT 1
8541: ST_TO_ADDR
// Player_Team = 0 ;
8542: LD_ADDR_EXP 40
8546: PUSH
8547: LD_INT 0
8549: ST_TO_ADDR
// Side_Positions = [ 1 , 3 , 6 , 0 , 0 , 0 , 0 , 7 ] ;
8550: LD_ADDR_EXP 43
8554: PUSH
8555: LD_INT 1
8557: PUSH
8558: LD_INT 3
8560: PUSH
8561: LD_INT 6
8563: PUSH
8564: LD_INT 0
8566: PUSH
8567: LD_INT 0
8569: PUSH
8570: LD_INT 0
8572: PUSH
8573: LD_INT 0
8575: PUSH
8576: LD_INT 7
8578: PUSH
8579: EMPTY
8580: LIST
8581: LIST
8582: LIST
8583: LIST
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
8589: LD_ADDR_EXP 41
8593: PUSH
8594: LD_INT 0
8596: PUSH
8597: LD_INT 0
8599: PUSH
8600: LD_INT 0
8602: PUSH
8603: LD_INT 0
8605: PUSH
8606: LD_INT 0
8608: PUSH
8609: LD_INT 0
8611: PUSH
8612: LD_INT 0
8614: PUSH
8615: LD_INT 0
8617: PUSH
8618: EMPTY
8619: LIST
8620: LIST
8621: LIST
8622: LIST
8623: LIST
8624: LIST
8625: LIST
8626: LIST
8627: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 2 , 2 , 2 , 2 ] ;
8628: LD_ADDR_EXP 44
8632: PUSH
8633: LD_INT 1
8635: PUSH
8636: LD_INT 3
8638: PUSH
8639: LD_INT 1
8641: PUSH
8642: LD_INT 2
8644: PUSH
8645: LD_INT 2
8647: PUSH
8648: LD_INT 2
8650: PUSH
8651: LD_INT 2
8653: PUSH
8654: LD_INT 2
8656: PUSH
8657: EMPTY
8658: LIST
8659: LIST
8660: LIST
8661: LIST
8662: LIST
8663: LIST
8664: LIST
8665: LIST
8666: ST_TO_ADDR
// Teams = [ ] ;
8667: LD_ADDR_EXP 42
8671: PUSH
8672: EMPTY
8673: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
8674: LD_ADDR_EXP 37
8678: PUSH
8679: LD_EXP 43
8683: PUSH
8684: LD_INT 0
8686: PUSH
8687: EMPTY
8688: LIST
8689: DIFF
8690: PUSH
8691: LD_INT 0
8693: PLUS
8694: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
8695: LD_ADDR_EXP 38
8699: PUSH
8700: LD_EXP 41
8704: PUSH
8705: LD_INT 0
8707: PUSH
8708: EMPTY
8709: LIST
8710: DIFF
8711: PUSH
8712: LD_INT 0
8714: PLUS
8715: ST_TO_ADDR
// if MultiPlayer then
8716: LD_OWVAR 4
8720: IFFALSE 8776
// begin def_hunt_size = GetMultiplayerSetting ( 1 ) ;
8722: LD_ADDR_EXP 75
8726: PUSH
8727: LD_INT 1
8729: PPUSH
8730: CALL_OW 426
8734: ST_TO_ADDR
// def_hunt_balance = GetMultiplayerSetting ( 2 ) ;
8735: LD_ADDR_EXP 76
8739: PUSH
8740: LD_INT 2
8742: PPUSH
8743: CALL_OW 426
8747: ST_TO_ADDR
// def_hunt_limit = GetMultiplayerSetting ( 3 ) ;
8748: LD_ADDR_EXP 77
8752: PUSH
8753: LD_INT 3
8755: PPUSH
8756: CALL_OW 426
8760: ST_TO_ADDR
// def_doctors = GetMultiplayerSetting ( 4 ) ;
8761: LD_ADDR_EXP 78
8765: PUSH
8766: LD_INT 4
8768: PPUSH
8769: CALL_OW 426
8773: ST_TO_ADDR
// end else
8774: GO 8812
// begin randomize ;
8776: CALL_OW 10
// def_hunt_size = 1 ;
8780: LD_ADDR_EXP 75
8784: PUSH
8785: LD_INT 1
8787: ST_TO_ADDR
// def_hunt_balance = 1 ;
8788: LD_ADDR_EXP 76
8792: PUSH
8793: LD_INT 1
8795: ST_TO_ADDR
// def_hunt_limit = 1 ;
8796: LD_ADDR_EXP 77
8800: PUSH
8801: LD_INT 1
8803: ST_TO_ADDR
// def_doctors = 1 ;
8804: LD_ADDR_EXP 78
8808: PUSH
8809: LD_INT 1
8811: ST_TO_ADDR
// end ; one_hunter = gametype = 36 ;
8812: LD_ADDR_EXP 79
8816: PUSH
8817: LD_EXP 1
8821: PUSH
8822: LD_INT 36
8824: EQUAL
8825: ST_TO_ADDR
// if one_hunter then
8826: LD_EXP 79
8830: IFFALSE 9103
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
8832: LD_ADDR_EXP 80
8836: PUSH
8837: LD_INT 4200
8839: PUSH
8840: LD_INT 6300
8842: PUSH
8843: LD_INT 8400
8845: PUSH
8846: LD_INT 10500
8848: PUSH
8849: EMPTY
8850: LIST
8851: LIST
8852: LIST
8853: LIST
8854: PUSH
8855: LD_EXP 77
8859: PUSH
8860: LD_INT 1
8862: PLUS
8863: ARRAY
8864: ST_TO_ADDR
// p1 = [ 6 , 10 , 12 ] [ def_hunt_size + 1 ] ;
8865: LD_ADDR_VAR 0 3
8869: PUSH
8870: LD_INT 6
8872: PUSH
8873: LD_INT 10
8875: PUSH
8876: LD_INT 12
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: LIST
8883: PUSH
8884: LD_EXP 75
8888: PUSH
8889: LD_INT 1
8891: PLUS
8892: ARRAY
8893: ST_TO_ADDR
// p2 = [ 2 , 4 , 6 ] [ def_hunt_size + 1 ] ;
8894: LD_ADDR_VAR 0 4
8898: PUSH
8899: LD_INT 2
8901: PUSH
8902: LD_INT 4
8904: PUSH
8905: LD_INT 6
8907: PUSH
8908: EMPTY
8909: LIST
8910: LIST
8911: LIST
8912: PUSH
8913: LD_EXP 75
8917: PUSH
8918: LD_INT 1
8920: PLUS
8921: ARRAY
8922: ST_TO_ADDR
// size_of_ape_team = p1 div side_count + p2 ;
8923: LD_ADDR_EXP 81
8927: PUSH
8928: LD_VAR 0 3
8932: PUSH
8933: LD_EXP 37
8937: DIV
8938: PUSH
8939: LD_VAR 0 4
8943: PLUS
8944: ST_TO_ADDR
// size_of_hunt_team = size_of_ape_team * ( side_count - 1 ) ;
8945: LD_ADDR_EXP 82
8949: PUSH
8950: LD_EXP 81
8954: PUSH
8955: LD_EXP 37
8959: PUSH
8960: LD_INT 1
8962: MINUS
8963: MUL
8964: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
8965: LD_ADDR_EXP 83
8969: PUSH
8970: LD_INT 0
8972: PUSH
8973: LD_EXP 82
8977: PUSH
8978: LD_INT 5
8980: PLUS
8981: PUSH
8982: LD_INT 6
8984: DIV
8985: PUSH
8986: LD_EXP 82
8990: PUSH
8991: LD_INT 3
8993: PLUS
8994: PUSH
8995: LD_INT 4
8997: DIV
8998: PUSH
8999: EMPTY
9000: LIST
9001: LIST
9002: LIST
9003: PUSH
9004: LD_EXP 78
9008: PUSH
9009: LD_INT 1
9011: PLUS
9012: ARRAY
9013: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
9014: LD_ADDR_EXP 84
9018: PUSH
9019: LD_INT 5
9021: PUSH
9022: LD_INT 3
9024: PUSH
9025: LD_INT 1
9027: PUSH
9028: EMPTY
9029: LIST
9030: LIST
9031: LIST
9032: PUSH
9033: LD_EXP 76
9037: PUSH
9038: LD_INT 1
9040: PLUS
9041: ARRAY
9042: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9043: LD_ADDR_EXP 85
9047: PUSH
9048: LD_INT 1
9050: PUSH
9051: LD_INT 2
9053: PUSH
9054: LD_INT 3
9056: PUSH
9057: EMPTY
9058: LIST
9059: LIST
9060: LIST
9061: PUSH
9062: LD_EXP 76
9066: PUSH
9067: LD_INT 1
9069: PLUS
9070: ARRAY
9071: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9072: LD_ADDR_EXP 86
9076: PUSH
9077: LD_INT 6
9079: PUSH
9080: LD_INT 10
9082: PUSH
9083: LD_INT 13
9085: PUSH
9086: EMPTY
9087: LIST
9088: LIST
9089: LIST
9090: PUSH
9091: LD_EXP 76
9095: PUSH
9096: LD_INT 1
9098: PLUS
9099: ARRAY
9100: ST_TO_ADDR
// end else
9101: GO 9382
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
9103: LD_ADDR_EXP 80
9107: PUSH
9108: LD_INT 4200
9110: PUSH
9111: LD_INT 6300
9113: PUSH
9114: LD_INT 8400
9116: PUSH
9117: LD_INT 10500
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: LIST
9124: LIST
9125: PUSH
9126: LD_EXP 77
9130: PUSH
9131: LD_INT 1
9133: PLUS
9134: ARRAY
9135: ST_TO_ADDR
// p1 = [ 10 , 15 , 20 ] [ def_hunt_size + 1 ] ;
9136: LD_ADDR_VAR 0 3
9140: PUSH
9141: LD_INT 10
9143: PUSH
9144: LD_INT 15
9146: PUSH
9147: LD_INT 20
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: LIST
9154: PUSH
9155: LD_EXP 75
9159: PUSH
9160: LD_INT 1
9162: PLUS
9163: ARRAY
9164: ST_TO_ADDR
// p2 = [ 3 , 5 , 7 ] [ def_hunt_size + 1 ] ;
9165: LD_ADDR_VAR 0 4
9169: PUSH
9170: LD_INT 3
9172: PUSH
9173: LD_INT 5
9175: PUSH
9176: LD_INT 7
9178: PUSH
9179: EMPTY
9180: LIST
9181: LIST
9182: LIST
9183: PUSH
9184: LD_EXP 75
9188: PUSH
9189: LD_INT 1
9191: PLUS
9192: ARRAY
9193: ST_TO_ADDR
// size_of_hunt_team = p1 div side_count + p2 ;
9194: LD_ADDR_EXP 82
9198: PUSH
9199: LD_VAR 0 3
9203: PUSH
9204: LD_EXP 37
9208: DIV
9209: PUSH
9210: LD_VAR 0 4
9214: PLUS
9215: ST_TO_ADDR
// size_of_ape_team = ( size_of_hunt_team + size_of_hunt_team * ( side_count - 1 ) ) div 2 ;
9216: LD_ADDR_EXP 81
9220: PUSH
9221: LD_EXP 82
9225: PUSH
9226: LD_EXP 82
9230: PUSH
9231: LD_EXP 37
9235: PUSH
9236: LD_INT 1
9238: MINUS
9239: MUL
9240: PLUS
9241: PUSH
9242: LD_INT 2
9244: DIV
9245: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
9246: LD_ADDR_EXP 83
9250: PUSH
9251: LD_INT 0
9253: PUSH
9254: LD_EXP 82
9258: PUSH
9259: LD_INT 5
9261: PLUS
9262: PUSH
9263: LD_INT 6
9265: DIV
9266: PUSH
9267: LD_EXP 82
9271: PUSH
9272: LD_INT 3
9274: PLUS
9275: PUSH
9276: LD_INT 4
9278: DIV
9279: PUSH
9280: EMPTY
9281: LIST
9282: LIST
9283: LIST
9284: PUSH
9285: LD_EXP 78
9289: PUSH
9290: LD_INT 1
9292: PLUS
9293: ARRAY
9294: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
9295: LD_ADDR_EXP 84
9299: PUSH
9300: LD_INT 5
9302: PUSH
9303: LD_INT 3
9305: PUSH
9306: LD_INT 1
9308: PUSH
9309: EMPTY
9310: LIST
9311: LIST
9312: LIST
9313: PUSH
9314: LD_EXP 76
9318: PUSH
9319: LD_INT 1
9321: PLUS
9322: ARRAY
9323: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9324: LD_ADDR_EXP 85
9328: PUSH
9329: LD_INT 1
9331: PUSH
9332: LD_INT 2
9334: PUSH
9335: LD_INT 3
9337: PUSH
9338: EMPTY
9339: LIST
9340: LIST
9341: LIST
9342: PUSH
9343: LD_EXP 76
9347: PUSH
9348: LD_INT 1
9350: PLUS
9351: ARRAY
9352: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9353: LD_ADDR_EXP 86
9357: PUSH
9358: LD_INT 6
9360: PUSH
9361: LD_INT 10
9363: PUSH
9364: LD_INT 13
9366: PUSH
9367: EMPTY
9368: LIST
9369: LIST
9370: LIST
9371: PUSH
9372: LD_EXP 76
9376: PUSH
9377: LD_INT 1
9379: PLUS
9380: ARRAY
9381: ST_TO_ADDR
// end ; for i = 1 to 8 do
9382: LD_ADDR_VAR 0 2
9386: PUSH
9387: DOUBLE
9388: LD_INT 1
9390: DEC
9391: ST_TO_ADDR
9392: LD_INT 8
9394: PUSH
9395: FOR_TO
9396: IFFALSE 9428
// if Side_Positions [ i ] then
9398: LD_EXP 43
9402: PUSH
9403: LD_VAR 0 2
9407: ARRAY
9408: IFFALSE 9426
// to_be_alone := to_be_alone ^ i ;
9410: LD_ADDR_EXP 87
9414: PUSH
9415: LD_EXP 87
9419: PUSH
9420: LD_VAR 0 2
9424: ADD
9425: ST_TO_ADDR
9426: GO 9395
9428: POP
9429: POP
// end ;
9430: LD_VAR 0 1
9434: RET
// function prepare_hunter_team ( side ) ; var i , team ; begin
9435: LD_INT 0
9437: PPUSH
9438: PPUSH
9439: PPUSH
// team := [ ] ;
9440: LD_ADDR_VAR 0 4
9444: PUSH
9445: EMPTY
9446: ST_TO_ADDR
// for i := 1 to size_of_hunt_team do
9447: LD_ADDR_VAR 0 3
9451: PUSH
9452: DOUBLE
9453: LD_INT 1
9455: DEC
9456: ST_TO_ADDR
9457: LD_EXP 82
9461: PUSH
9462: FOR_TO
9463: IFFALSE 9580
// begin uc_nation := side_nations [ side ] ;
9465: LD_ADDR_OWVAR 21
9469: PUSH
9470: LD_EXP 44
9474: PUSH
9475: LD_VAR 0 1
9479: ARRAY
9480: ST_TO_ADDR
// uc_side := side ;
9481: LD_ADDR_OWVAR 20
9485: PUSH
9486: LD_VAR 0 1
9490: ST_TO_ADDR
// hc_name :=  ;
9491: LD_ADDR_OWVAR 26
9495: PUSH
9496: LD_STRING 
9498: ST_TO_ADDR
// if i > size_of_hunt_team - doctors_in_team then
9499: LD_VAR 0 3
9503: PUSH
9504: LD_EXP 82
9508: PUSH
9509: LD_EXP 83
9513: MINUS
9514: GREATER
9515: IFFALSE 9531
// PrepareScientist ( 0 , hunter_level ) else
9517: LD_INT 0
9519: PPUSH
9520: LD_EXP 84
9524: PPUSH
9525: CALL_OW 384
9529: GO 9543
// PrepareSoldier ( 0 , hunter_level ) ;
9531: LD_INT 0
9533: PPUSH
9534: LD_EXP 84
9538: PPUSH
9539: CALL_OW 381
// hc_gallery :=  ;
9543: LD_ADDR_OWVAR 33
9547: PUSH
9548: LD_STRING 
9550: ST_TO_ADDR
// hc_importance := 0 ;
9551: LD_ADDR_OWVAR 32
9555: PUSH
9556: LD_INT 0
9558: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9559: LD_ADDR_VAR 0 4
9563: PUSH
9564: LD_VAR 0 4
9568: PUSH
9569: CALL_OW 44
9573: PUSH
9574: EMPTY
9575: LIST
9576: ADD
9577: ST_TO_ADDR
// end ;
9578: GO 9462
9580: POP
9581: POP
// people := Replace ( people , side , team ) ;
9582: LD_ADDR_EXP 88
9586: PUSH
9587: LD_EXP 88
9591: PPUSH
9592: LD_VAR 0 1
9596: PPUSH
9597: LD_VAR 0 4
9601: PPUSH
9602: CALL_OW 1
9606: ST_TO_ADDR
// end ;
9607: LD_VAR 0 2
9611: RET
// function prepare_ape_team ( side ) ; var i , team ; begin
9612: LD_INT 0
9614: PPUSH
9615: PPUSH
9616: PPUSH
// team := [ ] ;
9617: LD_ADDR_VAR 0 4
9621: PUSH
9622: EMPTY
9623: ST_TO_ADDR
// for i := 1 to size_of_ape_team do
9624: LD_ADDR_VAR 0 3
9628: PUSH
9629: DOUBLE
9630: LD_INT 1
9632: DEC
9633: ST_TO_ADDR
9634: LD_EXP 81
9638: PUSH
9639: FOR_TO
9640: IFFALSE 9763
// begin uc_nation := nation_nature ;
9642: LD_ADDR_OWVAR 21
9646: PUSH
9647: LD_INT 0
9649: ST_TO_ADDR
// uc_side := side ;
9650: LD_ADDR_OWVAR 20
9654: PUSH
9655: LD_VAR 0 1
9659: ST_TO_ADDR
// hc_name :=  ;
9660: LD_ADDR_OWVAR 26
9664: PUSH
9665: LD_STRING 
9667: ST_TO_ADDR
// hc_attr := [ ape_stamina , 14 ] ;
9668: LD_ADDR_OWVAR 29
9672: PUSH
9673: LD_EXP 86
9677: PUSH
9678: LD_INT 14
9680: PUSH
9681: EMPTY
9682: LIST
9683: LIST
9684: ST_TO_ADDR
// hc_skills := [ ape_level , 0 , 0 , 0 ] ;
9685: LD_ADDR_OWVAR 31
9689: PUSH
9690: LD_EXP 85
9694: PUSH
9695: LD_INT 0
9697: PUSH
9698: LD_INT 0
9700: PUSH
9701: LD_INT 0
9703: PUSH
9704: EMPTY
9705: LIST
9706: LIST
9707: LIST
9708: LIST
9709: ST_TO_ADDR
// hc_sex := sex_male ;
9710: LD_ADDR_OWVAR 27
9714: PUSH
9715: LD_INT 1
9717: ST_TO_ADDR
// hc_class := class_apeman ;
9718: LD_ADDR_OWVAR 28
9722: PUSH
9723: LD_INT 12
9725: ST_TO_ADDR
// hc_gallery :=  ;
9726: LD_ADDR_OWVAR 33
9730: PUSH
9731: LD_STRING 
9733: ST_TO_ADDR
// hc_importance := 0 ;
9734: LD_ADDR_OWVAR 32
9738: PUSH
9739: LD_INT 0
9741: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9742: LD_ADDR_VAR 0 4
9746: PUSH
9747: LD_VAR 0 4
9751: PUSH
9752: CALL_OW 44
9756: PUSH
9757: EMPTY
9758: LIST
9759: ADD
9760: ST_TO_ADDR
// end ;
9761: GO 9639
9763: POP
9764: POP
// people := Replace ( people , side , team ) ;
9765: LD_ADDR_EXP 88
9769: PUSH
9770: LD_EXP 88
9774: PPUSH
9775: LD_VAR 0 1
9779: PPUSH
9780: LD_VAR 0 4
9784: PPUSH
9785: CALL_OW 1
9789: ST_TO_ADDR
// end ;
9790: LD_VAR 0 2
9794: RET
// function display_score ( alone , t ) ; begin
9795: LD_INT 0
9797: PPUSH
// display_strings := scorestring ^  ;
9798: LD_ADDR_OWVAR 47
9802: PUSH
9803: LD_EXP 89
9807: PUSH
9808: LD_STRING 
9810: ADD
9811: ST_TO_ADDR
// if alone then
9812: LD_VAR 0 1
9816: IFFALSE 9896
// if one_hunter then
9818: LD_EXP 79
9822: IFFALSE 9861
// display_strings := display_strings ^ [ #Hunt-prepare2 , alone , alone , t ] else
9824: LD_ADDR_OWVAR 47
9828: PUSH
9829: LD_OWVAR 47
9833: PUSH
9834: LD_STRING #Hunt-prepare2
9836: PUSH
9837: LD_VAR 0 1
9841: PUSH
9842: LD_VAR 0 1
9846: PUSH
9847: LD_VAR 0 2
9851: PUSH
9852: EMPTY
9853: LIST
9854: LIST
9855: LIST
9856: LIST
9857: ADD
9858: ST_TO_ADDR
9859: GO 9896
// display_strings := display_strings ^ [ #Hunt-prepare1 , alone , alone , t ] ;
9861: LD_ADDR_OWVAR 47
9865: PUSH
9866: LD_OWVAR 47
9870: PUSH
9871: LD_STRING #Hunt-prepare1
9873: PUSH
9874: LD_VAR 0 1
9878: PUSH
9879: LD_VAR 0 1
9883: PUSH
9884: LD_VAR 0 2
9888: PUSH
9889: EMPTY
9890: LIST
9891: LIST
9892: LIST
9893: LIST
9894: ADD
9895: ST_TO_ADDR
// end ;
9896: LD_VAR 0 3
9900: RET
// function set_attitudes ( alone ) ; var i , j ; begin
9901: LD_INT 0
9903: PPUSH
9904: PPUSH
9905: PPUSH
// for i := 1 to 8 do
9906: LD_ADDR_VAR 0 3
9910: PUSH
9911: DOUBLE
9912: LD_INT 1
9914: DEC
9915: ST_TO_ADDR
9916: LD_INT 8
9918: PUSH
9919: FOR_TO
9920: IFFALSE 10010
// for j := 1 to 8 do
9922: LD_ADDR_VAR 0 4
9926: PUSH
9927: DOUBLE
9928: LD_INT 1
9930: DEC
9931: ST_TO_ADDR
9932: LD_INT 8
9934: PUSH
9935: FOR_TO
9936: IFFALSE 10006
// if ( i = alone ) = ( j = alone ) then
9938: LD_VAR 0 3
9942: PUSH
9943: LD_VAR 0 1
9947: EQUAL
9948: PUSH
9949: LD_VAR 0 4
9953: PUSH
9954: LD_VAR 0 1
9958: EQUAL
9959: EQUAL
9960: IFFALSE 9984
// SetAttitude ( i , j , att_friend , true ) else
9962: LD_VAR 0 3
9966: PPUSH
9967: LD_VAR 0 4
9971: PPUSH
9972: LD_INT 1
9974: PPUSH
9975: LD_INT 1
9977: PPUSH
9978: CALL_OW 80
9982: GO 10004
// SetAttitude ( i , j , att_enemy , true ) ;
9984: LD_VAR 0 3
9988: PPUSH
9989: LD_VAR 0 4
9993: PPUSH
9994: LD_INT 2
9996: PPUSH
9997: LD_INT 1
9999: PPUSH
10000: CALL_OW 80
10004: GO 9935
10006: POP
10007: POP
10008: GO 9919
10010: POP
10011: POP
// end ;
10012: LD_VAR 0 2
10016: RET
// function set_technologies ( alone ) ; var i ; begin
10017: LD_INT 0
10019: PPUSH
10020: PPUSH
// for i := 1 to 8 do
10021: LD_ADDR_VAR 0 3
10025: PUSH
10026: DOUBLE
10027: LD_INT 1
10029: DEC
10030: ST_TO_ADDR
10031: LD_INT 8
10033: PUSH
10034: FOR_TO
10035: IFFALSE 10224
// begin if ( alone = i ) = one_hunter then
10037: LD_VAR 0 1
10041: PUSH
10042: LD_VAR 0 3
10046: EQUAL
10047: PUSH
10048: LD_EXP 79
10052: EQUAL
10053: IFFALSE 10117
// begin SetTech ( tech_Opto1 , i , state_disabled ) ;
10055: LD_INT 60
10057: PPUSH
10058: LD_VAR 0 3
10062: PPUSH
10063: LD_INT 0
10065: PPUSH
10066: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_disabled ) ;
10070: LD_INT 61
10072: PPUSH
10073: LD_VAR 0 3
10077: PPUSH
10078: LD_INT 0
10080: PPUSH
10081: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_disabled ) ;
10085: LD_INT 62
10087: PPUSH
10088: LD_VAR 0 3
10092: PPUSH
10093: LD_INT 0
10095: PPUSH
10096: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_disabled ) ;
10100: LD_INT 5
10102: PPUSH
10103: LD_VAR 0 3
10107: PPUSH
10108: LD_INT 0
10110: PPUSH
10111: CALL_OW 322
// end else
10115: GO 10177
// begin SetTech ( tech_Opto1 , i , state_researched ) ;
10117: LD_INT 60
10119: PPUSH
10120: LD_VAR 0 3
10124: PPUSH
10125: LD_INT 2
10127: PPUSH
10128: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_researched ) ;
10132: LD_INT 61
10134: PPUSH
10135: LD_VAR 0 3
10139: PPUSH
10140: LD_INT 2
10142: PPUSH
10143: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_researched ) ;
10147: LD_INT 62
10149: PPUSH
10150: LD_VAR 0 3
10154: PPUSH
10155: LD_INT 2
10157: PPUSH
10158: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_researched ) ;
10162: LD_INT 5
10164: PPUSH
10165: LD_VAR 0 3
10169: PPUSH
10170: LD_INT 2
10172: PPUSH
10173: CALL_OW 322
// end ; SetTech ( tech_Weap1 , i , state_disabled ) ;
10177: LD_INT 51
10179: PPUSH
10180: LD_VAR 0 3
10184: PPUSH
10185: LD_INT 0
10187: PPUSH
10188: CALL_OW 322
// SetTech ( tech_Weap2 , i , state_disabled ) ;
10192: LD_INT 52
10194: PPUSH
10195: LD_VAR 0 3
10199: PPUSH
10200: LD_INT 0
10202: PPUSH
10203: CALL_OW 322
// SetTech ( tech_Weap3 , i , state_disabled ) ;
10207: LD_INT 53
10209: PPUSH
10210: LD_VAR 0 3
10214: PPUSH
10215: LD_INT 0
10217: PPUSH
10218: CALL_OW 322
// end ;
10222: GO 10034
10224: POP
10225: POP
// end ;
10226: LD_VAR 0 2
10230: RET
// function prepare_map_coordinates_more_hunters ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10231: LD_INT 0
10233: PPUSH
10234: PPUSH
10235: PPUSH
10236: PPUSH
10237: PPUSH
10238: PPUSH
10239: PPUSH
10240: PPUSH
// best = 0 ;
10241: LD_ADDR_VAR 0 3
10245: PUSH
10246: LD_INT 0
10248: ST_TO_ADDR
// for n = 1 to 40 do
10249: LD_ADDR_VAR 0 9
10253: PUSH
10254: DOUBLE
10255: LD_INT 1
10257: DEC
10258: ST_TO_ADDR
10259: LD_INT 40
10261: PUSH
10262: FOR_TO
10263: IFFALSE 10571
// begin c = [ ] ;
10265: LD_ADDR_VAR 0 4
10269: PUSH
10270: EMPTY
10271: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10272: LD_ADDR_VAR 0 7
10276: PUSH
10277: DOUBLE
10278: LD_INT 1
10280: DEC
10281: ST_TO_ADDR
10282: LD_EXP 37
10286: PUSH
10287: LD_INT 1
10289: MINUS
10290: PUSH
10291: FOR_TO
10292: IFFALSE 10321
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
10294: LD_ADDR_VAR 0 4
10298: PUSH
10299: LD_VAR 0 4
10303: PUSH
10304: LD_INT 22
10306: PPUSH
10307: LD_INT 0
10309: PPUSH
10310: CALL_OW 16
10314: PUSH
10315: EMPTY
10316: LIST
10317: ADD
10318: ST_TO_ADDR
10319: GO 10291
10321: POP
10322: POP
// minv = 10000 ;
10323: LD_ADDR_VAR 0 6
10327: PUSH
10328: LD_INT 10000
10330: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10331: LD_ADDR_VAR 0 7
10335: PUSH
10336: DOUBLE
10337: LD_INT 1
10339: DEC
10340: ST_TO_ADDR
10341: LD_EXP 37
10345: PUSH
10346: LD_INT 1
10348: MINUS
10349: PUSH
10350: FOR_TO
10351: IFFALSE 10535
// for j = 1 to side_count - 1 do
10353: LD_ADDR_VAR 0 8
10357: PUSH
10358: DOUBLE
10359: LD_INT 1
10361: DEC
10362: ST_TO_ADDR
10363: LD_EXP 37
10367: PUSH
10368: LD_INT 1
10370: MINUS
10371: PUSH
10372: FOR_TO
10373: IFFALSE 10531
// if i <> j then
10375: LD_VAR 0 7
10379: PUSH
10380: LD_VAR 0 8
10384: NONEQUAL
10385: IFFALSE 10529
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10387: LD_VAR 0 4
10391: PUSH
10392: LD_VAR 0 7
10396: ARRAY
10397: PUSH
10398: LD_INT 1
10400: ARRAY
10401: PPUSH
10402: LD_VAR 0 4
10406: PUSH
10407: LD_VAR 0 7
10411: ARRAY
10412: PUSH
10413: LD_INT 2
10415: ARRAY
10416: PPUSH
10417: LD_VAR 0 4
10421: PUSH
10422: LD_VAR 0 8
10426: ARRAY
10427: PUSH
10428: LD_INT 1
10430: ARRAY
10431: PPUSH
10432: LD_VAR 0 4
10436: PUSH
10437: LD_VAR 0 8
10441: ARRAY
10442: PUSH
10443: LD_INT 2
10445: ARRAY
10446: PPUSH
10447: CALL_OW 298
10451: PUSH
10452: LD_VAR 0 6
10456: LESS
10457: IFFALSE 10529
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10459: LD_ADDR_VAR 0 6
10463: PUSH
10464: LD_VAR 0 4
10468: PUSH
10469: LD_VAR 0 7
10473: ARRAY
10474: PUSH
10475: LD_INT 1
10477: ARRAY
10478: PPUSH
10479: LD_VAR 0 4
10483: PUSH
10484: LD_VAR 0 7
10488: ARRAY
10489: PUSH
10490: LD_INT 2
10492: ARRAY
10493: PPUSH
10494: LD_VAR 0 4
10498: PUSH
10499: LD_VAR 0 8
10503: ARRAY
10504: PUSH
10505: LD_INT 1
10507: ARRAY
10508: PPUSH
10509: LD_VAR 0 4
10513: PUSH
10514: LD_VAR 0 8
10518: ARRAY
10519: PUSH
10520: LD_INT 2
10522: ARRAY
10523: PPUSH
10524: CALL_OW 298
10528: ST_TO_ADDR
// end ;
10529: GO 10372
10531: POP
10532: POP
10533: GO 10350
10535: POP
10536: POP
// if minv > best then
10537: LD_VAR 0 6
10541: PUSH
10542: LD_VAR 0 3
10546: GREATER
10547: IFFALSE 10569
// begin best := minv ;
10549: LD_ADDR_VAR 0 3
10553: PUSH
10554: LD_VAR 0 6
10558: ST_TO_ADDR
// bestc := c ;
10559: LD_ADDR_VAR 0 5
10563: PUSH
10564: LD_VAR 0 4
10568: ST_TO_ADDR
// end ; end ;
10569: GO 10262
10571: POP
10572: POP
// coordinates := [ ] ;
10573: LD_ADDR_EXP 34
10577: PUSH
10578: EMPTY
10579: ST_TO_ADDR
// for i = 1 to 8 do
10580: LD_ADDR_VAR 0 7
10584: PUSH
10585: DOUBLE
10586: LD_INT 1
10588: DEC
10589: ST_TO_ADDR
10590: LD_INT 8
10592: PUSH
10593: FOR_TO
10594: IFFALSE 10719
// if i = alone then
10596: LD_VAR 0 7
10600: PUSH
10601: LD_VAR 0 1
10605: EQUAL
10606: IFFALSE 10634
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
10608: LD_ADDR_EXP 34
10612: PUSH
10613: LD_EXP 34
10617: PUSH
10618: LD_INT 81
10620: PUSH
10621: LD_INT 57
10623: PUSH
10624: EMPTY
10625: LIST
10626: LIST
10627: PUSH
10628: EMPTY
10629: LIST
10630: ADD
10631: ST_TO_ADDR
10632: GO 10717
// if ( side_positions [ i ] = 0 ) then
10634: LD_EXP 43
10638: PUSH
10639: LD_VAR 0 7
10643: ARRAY
10644: PUSH
10645: LD_INT 0
10647: EQUAL
10648: IFFALSE 10676
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
10650: LD_ADDR_EXP 34
10654: PUSH
10655: LD_EXP 34
10659: PUSH
10660: LD_INT 0
10662: PUSH
10663: LD_INT 0
10665: PUSH
10666: EMPTY
10667: LIST
10668: LIST
10669: PUSH
10670: EMPTY
10671: LIST
10672: ADD
10673: ST_TO_ADDR
10674: GO 10717
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
10676: LD_ADDR_EXP 34
10680: PUSH
10681: LD_EXP 34
10685: PUSH
10686: LD_VAR 0 5
10690: PUSH
10691: LD_INT 1
10693: ARRAY
10694: PUSH
10695: EMPTY
10696: LIST
10697: ADD
10698: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
10699: LD_ADDR_VAR 0 5
10703: PUSH
10704: LD_VAR 0 5
10708: PPUSH
10709: LD_INT 1
10711: PPUSH
10712: CALL_OW 3
10716: ST_TO_ADDR
// end ;
10717: GO 10593
10719: POP
10720: POP
// end ;
10721: LD_VAR 0 2
10725: RET
// function prepare_map_coordinates_one_hunter ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10726: LD_INT 0
10728: PPUSH
10729: PPUSH
10730: PPUSH
10731: PPUSH
10732: PPUSH
10733: PPUSH
10734: PPUSH
10735: PPUSH
// best = 0 ;
10736: LD_ADDR_VAR 0 3
10740: PUSH
10741: LD_INT 0
10743: ST_TO_ADDR
// for n = 1 to 40 do
10744: LD_ADDR_VAR 0 9
10748: PUSH
10749: DOUBLE
10750: LD_INT 1
10752: DEC
10753: ST_TO_ADDR
10754: LD_INT 40
10756: PUSH
10757: FOR_TO
10758: IFFALSE 11066
// begin c = [ ] ;
10760: LD_ADDR_VAR 0 4
10764: PUSH
10765: EMPTY
10766: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10767: LD_ADDR_VAR 0 7
10771: PUSH
10772: DOUBLE
10773: LD_INT 1
10775: DEC
10776: ST_TO_ADDR
10777: LD_EXP 37
10781: PUSH
10782: LD_INT 1
10784: MINUS
10785: PUSH
10786: FOR_TO
10787: IFFALSE 10816
// c := c ^ [ RandHexArea ( arapestart , false ) ] ;
10789: LD_ADDR_VAR 0 4
10793: PUSH
10794: LD_VAR 0 4
10798: PUSH
10799: LD_INT 24
10801: PPUSH
10802: LD_INT 0
10804: PPUSH
10805: CALL_OW 16
10809: PUSH
10810: EMPTY
10811: LIST
10812: ADD
10813: ST_TO_ADDR
10814: GO 10786
10816: POP
10817: POP
// minv = 10000 ;
10818: LD_ADDR_VAR 0 6
10822: PUSH
10823: LD_INT 10000
10825: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10826: LD_ADDR_VAR 0 7
10830: PUSH
10831: DOUBLE
10832: LD_INT 1
10834: DEC
10835: ST_TO_ADDR
10836: LD_EXP 37
10840: PUSH
10841: LD_INT 1
10843: MINUS
10844: PUSH
10845: FOR_TO
10846: IFFALSE 11030
// for j = 1 to side_count - 1 do
10848: LD_ADDR_VAR 0 8
10852: PUSH
10853: DOUBLE
10854: LD_INT 1
10856: DEC
10857: ST_TO_ADDR
10858: LD_EXP 37
10862: PUSH
10863: LD_INT 1
10865: MINUS
10866: PUSH
10867: FOR_TO
10868: IFFALSE 11026
// if i <> j then
10870: LD_VAR 0 7
10874: PUSH
10875: LD_VAR 0 8
10879: NONEQUAL
10880: IFFALSE 11024
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10882: LD_VAR 0 4
10886: PUSH
10887: LD_VAR 0 7
10891: ARRAY
10892: PUSH
10893: LD_INT 1
10895: ARRAY
10896: PPUSH
10897: LD_VAR 0 4
10901: PUSH
10902: LD_VAR 0 7
10906: ARRAY
10907: PUSH
10908: LD_INT 2
10910: ARRAY
10911: PPUSH
10912: LD_VAR 0 4
10916: PUSH
10917: LD_VAR 0 8
10921: ARRAY
10922: PUSH
10923: LD_INT 1
10925: ARRAY
10926: PPUSH
10927: LD_VAR 0 4
10931: PUSH
10932: LD_VAR 0 8
10936: ARRAY
10937: PUSH
10938: LD_INT 2
10940: ARRAY
10941: PPUSH
10942: CALL_OW 298
10946: PUSH
10947: LD_VAR 0 6
10951: LESS
10952: IFFALSE 11024
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10954: LD_ADDR_VAR 0 6
10958: PUSH
10959: LD_VAR 0 4
10963: PUSH
10964: LD_VAR 0 7
10968: ARRAY
10969: PUSH
10970: LD_INT 1
10972: ARRAY
10973: PPUSH
10974: LD_VAR 0 4
10978: PUSH
10979: LD_VAR 0 7
10983: ARRAY
10984: PUSH
10985: LD_INT 2
10987: ARRAY
10988: PPUSH
10989: LD_VAR 0 4
10993: PUSH
10994: LD_VAR 0 8
10998: ARRAY
10999: PUSH
11000: LD_INT 1
11002: ARRAY
11003: PPUSH
11004: LD_VAR 0 4
11008: PUSH
11009: LD_VAR 0 8
11013: ARRAY
11014: PUSH
11015: LD_INT 2
11017: ARRAY
11018: PPUSH
11019: CALL_OW 298
11023: ST_TO_ADDR
// end ;
11024: GO 10867
11026: POP
11027: POP
11028: GO 10845
11030: POP
11031: POP
// if minv > best then
11032: LD_VAR 0 6
11036: PUSH
11037: LD_VAR 0 3
11041: GREATER
11042: IFFALSE 11064
// begin best := minv ;
11044: LD_ADDR_VAR 0 3
11048: PUSH
11049: LD_VAR 0 6
11053: ST_TO_ADDR
// bestc := c ;
11054: LD_ADDR_VAR 0 5
11058: PUSH
11059: LD_VAR 0 4
11063: ST_TO_ADDR
// end ; end ;
11064: GO 10757
11066: POP
11067: POP
// coordinates := [ ] ;
11068: LD_ADDR_EXP 34
11072: PUSH
11073: EMPTY
11074: ST_TO_ADDR
// for i = 1 to 8 do
11075: LD_ADDR_VAR 0 7
11079: PUSH
11080: DOUBLE
11081: LD_INT 1
11083: DEC
11084: ST_TO_ADDR
11085: LD_INT 8
11087: PUSH
11088: FOR_TO
11089: IFFALSE 11214
// if i = alone then
11091: LD_VAR 0 7
11095: PUSH
11096: LD_VAR 0 1
11100: EQUAL
11101: IFFALSE 11129
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
11103: LD_ADDR_EXP 34
11107: PUSH
11108: LD_EXP 34
11112: PUSH
11113: LD_INT 81
11115: PUSH
11116: LD_INT 57
11118: PUSH
11119: EMPTY
11120: LIST
11121: LIST
11122: PUSH
11123: EMPTY
11124: LIST
11125: ADD
11126: ST_TO_ADDR
11127: GO 11212
// if ( side_positions [ i ] = 0 ) then
11129: LD_EXP 43
11133: PUSH
11134: LD_VAR 0 7
11138: ARRAY
11139: PUSH
11140: LD_INT 0
11142: EQUAL
11143: IFFALSE 11171
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
11145: LD_ADDR_EXP 34
11149: PUSH
11150: LD_EXP 34
11154: PUSH
11155: LD_INT 0
11157: PUSH
11158: LD_INT 0
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PUSH
11165: EMPTY
11166: LIST
11167: ADD
11168: ST_TO_ADDR
11169: GO 11212
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
11171: LD_ADDR_EXP 34
11175: PUSH
11176: LD_EXP 34
11180: PUSH
11181: LD_VAR 0 5
11185: PUSH
11186: LD_INT 1
11188: ARRAY
11189: PUSH
11190: EMPTY
11191: LIST
11192: ADD
11193: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
11194: LD_ADDR_VAR 0 5
11198: PUSH
11199: LD_VAR 0 5
11203: PPUSH
11204: LD_INT 1
11206: PPUSH
11207: CALL_OW 3
11211: ST_TO_ADDR
// end ;
11212: GO 11088
11214: POP
11215: POP
// end ;
11216: LD_VAR 0 2
11220: RET
// function prepare_game ( alone ) ; var i , t ; begin
11221: LD_INT 0
11223: PPUSH
11224: PPUSH
11225: PPUSH
// ResetFog ;
11226: CALL_OW 335
// AnimateTrees ( true ) ;
11230: LD_INT 1
11232: PPUSH
11233: CALL_OW 573
// for i := 1 to 8 do
11237: LD_ADDR_VAR 0 3
11241: PUSH
11242: DOUBLE
11243: LD_INT 1
11245: DEC
11246: ST_TO_ADDR
11247: LD_INT 8
11249: PUSH
11250: FOR_TO
11251: IFFALSE 11305
// if Side_Positions [ i ] then
11253: LD_EXP 43
11257: PUSH
11258: LD_VAR 0 3
11262: ARRAY
11263: IFFALSE 11303
// if i = alone then
11265: LD_VAR 0 3
11269: PUSH
11270: LD_VAR 0 1
11274: EQUAL
11275: IFFALSE 11291
// ChangeSideFog ( i , 1 ) else
11277: LD_VAR 0 3
11281: PPUSH
11282: LD_INT 1
11284: PPUSH
11285: CALL_OW 343
11289: GO 11303
// ChangeSideFog ( i , 2 ) ;
11291: LD_VAR 0 3
11295: PPUSH
11296: LD_INT 2
11298: PPUSH
11299: CALL_OW 343
11303: GO 11250
11305: POP
11306: POP
// set_attitudes ( alone ) ;
11307: LD_VAR 0 1
11311: PPUSH
11312: CALL 9901 0 1
// set_technologies ( alone ) ;
11316: LD_VAR 0 1
11320: PPUSH
11321: CALL 10017 0 1
// display_score ( alone , 0 0$8 ) ;
11325: LD_VAR 0 1
11329: PPUSH
11330: LD_INT 280
11332: PPUSH
11333: CALL 9795 0 2
// for i := 1 to 8 do
11337: LD_ADDR_VAR 0 3
11341: PUSH
11342: DOUBLE
11343: LD_INT 1
11345: DEC
11346: ST_TO_ADDR
11347: LD_INT 8
11349: PUSH
11350: FOR_TO
11351: IFFALSE 11405
// if Side_Positions [ i ] then
11353: LD_EXP 43
11357: PUSH
11358: LD_VAR 0 3
11362: ARRAY
11363: IFFALSE 11403
// if ( i = alone ) = ( one_hunter ) then
11365: LD_VAR 0 3
11369: PUSH
11370: LD_VAR 0 1
11374: EQUAL
11375: PUSH
11376: LD_EXP 79
11380: EQUAL
11381: IFFALSE 11394
// prepare_hunter_team ( i ) else
11383: LD_VAR 0 3
11387: PPUSH
11388: CALL 9435 0 1
11392: GO 11403
// prepare_ape_team ( i ) ;
11394: LD_VAR 0 3
11398: PPUSH
11399: CALL 9612 0 1
11403: GO 11350
11405: POP
11406: POP
// t := 8 ;
11407: LD_ADDR_VAR 0 4
11411: PUSH
11412: LD_INT 8
11414: ST_TO_ADDR
// repeat t := t - 1 ;
11415: LD_ADDR_VAR 0 4
11419: PUSH
11420: LD_VAR 0 4
11424: PUSH
11425: LD_INT 1
11427: MINUS
11428: ST_TO_ADDR
// display_score ( alone , t * 0 0$1 ) ;
11429: LD_VAR 0 1
11433: PPUSH
11434: LD_VAR 0 4
11438: PUSH
11439: LD_INT 35
11441: MUL
11442: PPUSH
11443: CALL 9795 0 2
// wait ( 0 0$1 ) ;
11447: LD_INT 35
11449: PPUSH
11450: CALL_OW 67
// until t = 0 ;
11454: LD_VAR 0 4
11458: PUSH
11459: LD_INT 0
11461: EQUAL
11462: IFFALSE 11415
// end ;
11464: LD_VAR 0 2
11468: RET
// function run_game ( alone ) ; var i , un , ape , time , alive , dead , aktsc ; begin
11469: LD_INT 0
11471: PPUSH
11472: PPUSH
11473: PPUSH
11474: PPUSH
11475: PPUSH
11476: PPUSH
11477: PPUSH
11478: PPUSH
// if ( your_side = alone ) <> one_hunter then
11479: LD_OWVAR 2
11483: PUSH
11484: LD_VAR 0 1
11488: EQUAL
11489: PUSH
11490: LD_EXP 79
11494: NONEQUAL
11495: IFFALSE 11507
// music_nat := nation_arabian else
11497: LD_ADDR_OWVAR 71
11501: PUSH
11502: LD_INT 2
11504: ST_TO_ADDR
11505: GO 11523
// music_nat := Side_Nations [ your_side ] ;
11507: LD_ADDR_OWVAR 71
11511: PUSH
11512: LD_EXP 44
11516: PUSH
11517: LD_OWVAR 2
11521: ARRAY
11522: ST_TO_ADDR
// if one_hunter then
11523: LD_EXP 79
11527: IFFALSE 11692
// begin prepare_map_coordinates_one_hunter ( alone ) ;
11529: LD_VAR 0 1
11533: PPUSH
11534: CALL 10726 0 1
// for i := 1 to 8 do
11538: LD_ADDR_VAR 0 3
11542: PUSH
11543: DOUBLE
11544: LD_INT 1
11546: DEC
11547: ST_TO_ADDR
11548: LD_INT 8
11550: PUSH
11551: FOR_TO
11552: IFFALSE 11688
// if side_positions [ i ] then
11554: LD_EXP 43
11558: PUSH
11559: LD_VAR 0 3
11563: ARRAY
11564: IFFALSE 11686
// if i = alone then
11566: LD_VAR 0 3
11570: PUSH
11571: LD_VAR 0 1
11575: EQUAL
11576: IFFALSE 11618
// for un in people [ i ] do
11578: LD_ADDR_VAR 0 4
11582: PUSH
11583: LD_EXP 88
11587: PUSH
11588: LD_VAR 0 3
11592: ARRAY
11593: PUSH
11594: FOR_IN
11595: IFFALSE 11614
// PlaceUnitArea ( un , arstartveh , false ) else
11597: LD_VAR 0 4
11601: PPUSH
11602: LD_INT 22
11604: PPUSH
11605: LD_INT 0
11607: PPUSH
11608: CALL_OW 49
11612: GO 11594
11614: POP
11615: POP
11616: GO 11686
// for un in people [ i ] do
11618: LD_ADDR_VAR 0 4
11622: PUSH
11623: LD_EXP 88
11627: PUSH
11628: LD_VAR 0 3
11632: ARRAY
11633: PUSH
11634: FOR_IN
11635: IFFALSE 11684
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 15 , false ) ;
11637: LD_VAR 0 4
11641: PPUSH
11642: LD_EXP 34
11646: PUSH
11647: LD_VAR 0 3
11651: ARRAY
11652: PUSH
11653: LD_INT 1
11655: ARRAY
11656: PPUSH
11657: LD_EXP 34
11661: PUSH
11662: LD_VAR 0 3
11666: ARRAY
11667: PUSH
11668: LD_INT 2
11670: ARRAY
11671: PPUSH
11672: LD_INT 15
11674: PPUSH
11675: LD_INT 0
11677: PPUSH
11678: CALL_OW 50
11682: GO 11634
11684: POP
11685: POP
11686: GO 11551
11688: POP
11689: POP
// end else
11690: GO 11853
// begin prepare_map_coordinates_more_hunters ( alone ) ;
11692: LD_VAR 0 1
11696: PPUSH
11697: CALL 10231 0 1
// for i := 1 to 8 do
11701: LD_ADDR_VAR 0 3
11705: PUSH
11706: DOUBLE
11707: LD_INT 1
11709: DEC
11710: ST_TO_ADDR
11711: LD_INT 8
11713: PUSH
11714: FOR_TO
11715: IFFALSE 11851
// if side_positions [ i ] then
11717: LD_EXP 43
11721: PUSH
11722: LD_VAR 0 3
11726: ARRAY
11727: IFFALSE 11849
// if i = alone then
11729: LD_VAR 0 3
11733: PUSH
11734: LD_VAR 0 1
11738: EQUAL
11739: IFFALSE 11781
// for un in people [ i ] do
11741: LD_ADDR_VAR 0 4
11745: PUSH
11746: LD_EXP 88
11750: PUSH
11751: LD_VAR 0 3
11755: ARRAY
11756: PUSH
11757: FOR_IN
11758: IFFALSE 11777
// PlaceUnitArea ( un , arapes , false ) else
11760: LD_VAR 0 4
11764: PPUSH
11765: LD_INT 23
11767: PPUSH
11768: LD_INT 0
11770: PPUSH
11771: CALL_OW 49
11775: GO 11757
11777: POP
11778: POP
11779: GO 11849
// for un in people [ i ] do
11781: LD_ADDR_VAR 0 4
11785: PUSH
11786: LD_EXP 88
11790: PUSH
11791: LD_VAR 0 3
11795: ARRAY
11796: PUSH
11797: FOR_IN
11798: IFFALSE 11847
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 4 , false ) ;
11800: LD_VAR 0 4
11804: PPUSH
11805: LD_EXP 34
11809: PUSH
11810: LD_VAR 0 3
11814: ARRAY
11815: PUSH
11816: LD_INT 1
11818: ARRAY
11819: PPUSH
11820: LD_EXP 34
11824: PUSH
11825: LD_VAR 0 3
11829: ARRAY
11830: PUSH
11831: LD_INT 2
11833: ARRAY
11834: PPUSH
11835: LD_INT 4
11837: PPUSH
11838: LD_INT 0
11840: PPUSH
11841: CALL_OW 50
11845: GO 11797
11847: POP
11848: POP
11849: GO 11714
11851: POP
11852: POP
// end ; CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
11853: LD_EXP 34
11857: PUSH
11858: LD_OWVAR 2
11862: ARRAY
11863: PUSH
11864: LD_INT 1
11866: ARRAY
11867: PPUSH
11868: LD_EXP 34
11872: PUSH
11873: LD_OWVAR 2
11877: ARRAY
11878: PUSH
11879: LD_INT 2
11881: ARRAY
11882: PPUSH
11883: CALL_OW 86
// display_score ( 0 , 0 ) ;
11887: LD_INT 0
11889: PPUSH
11890: LD_INT 0
11892: PPUSH
11893: CALL 9795 0 2
// time := hunt_limit div 0 0$1 ;
11897: LD_ADDR_VAR 0 6
11901: PUSH
11902: LD_EXP 80
11906: PUSH
11907: LD_INT 35
11909: DIV
11910: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11911: LD_INT 35
11913: PPUSH
11914: CALL_OW 67
// ape := FilterAllUnits ( [ f_class , class_apeman ] ) + 0 ;
11918: LD_ADDR_VAR 0 5
11922: PUSH
11923: LD_INT 25
11925: PUSH
11926: LD_INT 12
11928: PUSH
11929: EMPTY
11930: LIST
11931: LIST
11932: PPUSH
11933: CALL_OW 69
11937: PUSH
11938: LD_INT 0
11940: PLUS
11941: ST_TO_ADDR
// time := time - 1 ;
11942: LD_ADDR_VAR 0 6
11946: PUSH
11947: LD_VAR 0 6
11951: PUSH
11952: LD_INT 1
11954: MINUS
11955: ST_TO_ADDR
// display_strings := [ #Hunt-Apes , alone , ape , #Hunt-Limit , alone , time * 0 0$1 ] ;
11956: LD_ADDR_OWVAR 47
11960: PUSH
11961: LD_STRING #Hunt-Apes
11963: PUSH
11964: LD_VAR 0 1
11968: PUSH
11969: LD_VAR 0 5
11973: PUSH
11974: LD_STRING #Hunt-Limit
11976: PUSH
11977: LD_VAR 0 1
11981: PUSH
11982: LD_VAR 0 6
11986: PUSH
11987: LD_INT 35
11989: MUL
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: LIST
11995: LIST
11996: LIST
11997: LIST
11998: ST_TO_ADDR
// until ( ape = 0 ) or ( time = 0 ) ;
11999: LD_VAR 0 5
12003: PUSH
12004: LD_INT 0
12006: EQUAL
12007: PUSH
12008: LD_VAR 0 6
12012: PUSH
12013: LD_INT 0
12015: EQUAL
12016: OR
12017: IFFALSE 11911
// alive := FilterAllUnits ( [ f_or , [ f_class , class_soldier ] , [ f_class , class_scientistic ] ] ) + 0 ;
12019: LD_ADDR_VAR 0 7
12023: PUSH
12024: LD_INT 2
12026: PUSH
12027: LD_INT 25
12029: PUSH
12030: LD_INT 1
12032: PUSH
12033: EMPTY
12034: LIST
12035: LIST
12036: PUSH
12037: LD_INT 25
12039: PUSH
12040: LD_INT 4
12042: PUSH
12043: EMPTY
12044: LIST
12045: LIST
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: LIST
12051: PPUSH
12052: CALL_OW 69
12056: PUSH
12057: LD_INT 0
12059: PLUS
12060: ST_TO_ADDR
// if one_hunter then
12061: LD_EXP 79
12065: IFFALSE 12216
// begin dead := size_of_hunt_team - alive ;
12067: LD_ADDR_VAR 0 8
12071: PUSH
12072: LD_EXP 82
12076: PUSH
12077: LD_VAR 0 7
12081: MINUS
12082: ST_TO_ADDR
// ape := size_of_ape_team * ( side_count - 1 ) - ape ;
12083: LD_ADDR_VAR 0 5
12087: PUSH
12088: LD_EXP 81
12092: PUSH
12093: LD_EXP 37
12097: PUSH
12098: LD_INT 1
12100: MINUS
12101: MUL
12102: PUSH
12103: LD_VAR 0 5
12107: MINUS
12108: ST_TO_ADDR
// aktsc := time + ape * 30 - dead * 20 ;
12109: LD_ADDR_VAR 0 9
12113: PUSH
12114: LD_VAR 0 6
12118: PUSH
12119: LD_VAR 0 5
12123: PUSH
12124: LD_INT 30
12126: MUL
12127: PLUS
12128: PUSH
12129: LD_VAR 0 8
12133: PUSH
12134: LD_INT 20
12136: MUL
12137: MINUS
12138: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score2 , alone , alone , time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12139: LD_ADDR_EXP 89
12143: PUSH
12144: LD_EXP 89
12148: PUSH
12149: LD_STRING #Hunt-score2
12151: PUSH
12152: LD_VAR 0 1
12156: PUSH
12157: LD_VAR 0 1
12161: PUSH
12162: LD_VAR 0 6
12166: PUSH
12167: LD_INT 35
12169: MUL
12170: PUSH
12171: LD_VAR 0 5
12175: PUSH
12176: LD_VAR 0 8
12180: PUSH
12181: LD_INT 0
12183: PUSH
12184: LD_VAR 0 9
12188: PUSH
12189: EMPTY
12190: LIST
12191: LIST
12192: LIST
12193: LIST
12194: LIST
12195: LIST
12196: LIST
12197: LIST
12198: ADD
12199: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12200: LD_VAR 0 1
12204: PPUSH
12205: LD_VAR 0 9
12209: PPUSH
12210: CALL_OW 506
// end else
12214: GO 12363
// begin dead := size_of_hunt_team * ( side_count - 1 ) - alive ;
12216: LD_ADDR_VAR 0 8
12220: PUSH
12221: LD_EXP 82
12225: PUSH
12226: LD_EXP 37
12230: PUSH
12231: LD_INT 1
12233: MINUS
12234: MUL
12235: PUSH
12236: LD_VAR 0 7
12240: MINUS
12241: ST_TO_ADDR
// aktsc := hunt_limit div 0 0$1 - time + ape * 30 + dead * 20 ;
12242: LD_ADDR_VAR 0 9
12246: PUSH
12247: LD_EXP 80
12251: PUSH
12252: LD_INT 35
12254: DIV
12255: PUSH
12256: LD_VAR 0 6
12260: MINUS
12261: PUSH
12262: LD_VAR 0 5
12266: PUSH
12267: LD_INT 30
12269: MUL
12270: PLUS
12271: PUSH
12272: LD_VAR 0 8
12276: PUSH
12277: LD_INT 20
12279: MUL
12280: PLUS
12281: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score1 , alone , alone , hunt_limit - time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12282: LD_ADDR_EXP 89
12286: PUSH
12287: LD_EXP 89
12291: PUSH
12292: LD_STRING #Hunt-score1
12294: PUSH
12295: LD_VAR 0 1
12299: PUSH
12300: LD_VAR 0 1
12304: PUSH
12305: LD_EXP 80
12309: PUSH
12310: LD_VAR 0 6
12314: PUSH
12315: LD_INT 35
12317: MUL
12318: MINUS
12319: PUSH
12320: LD_VAR 0 5
12324: PUSH
12325: LD_VAR 0 8
12329: PUSH
12330: LD_INT 0
12332: PUSH
12333: LD_VAR 0 9
12337: PUSH
12338: EMPTY
12339: LIST
12340: LIST
12341: LIST
12342: LIST
12343: LIST
12344: LIST
12345: LIST
12346: LIST
12347: ADD
12348: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12349: LD_VAR 0 1
12353: PPUSH
12354: LD_VAR 0 9
12358: PPUSH
12359: CALL_OW 506
// end ; end ;
12363: LD_VAR 0 2
12367: RET
// function close_game ( alone ) ; var un ; begin
12368: LD_INT 0
12370: PPUSH
12371: PPUSH
// for un in all_units do
12372: LD_ADDR_VAR 0 3
12376: PUSH
12377: LD_OWVAR 3
12381: PUSH
12382: FOR_IN
12383: IFFALSE 12396
// DestroyUnit ( un ) ;
12385: LD_VAR 0 3
12389: PPUSH
12390: CALL_OW 65
12394: GO 12382
12396: POP
12397: POP
// ResetFog ;
12398: CALL_OW 335
// end ;
12402: LD_VAR 0 2
12406: RET
// export function starting_hunt ; var alone , win , i ; begin
12407: LD_INT 0
12409: PPUSH
12410: PPUSH
12411: PPUSH
12412: PPUSH
// mp_selectmsg := true ;
12413: LD_ADDR_OWVAR 13
12417: PUSH
12418: LD_INT 1
12420: ST_TO_ADDR
// mp_with_score := true ;
12421: LD_ADDR_OWVAR 14
12425: PUSH
12426: LD_INT 1
12428: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
12429: CALL 8456 0 0
// your_side := Player_Side ;
12433: LD_ADDR_OWVAR 2
12437: PUSH
12438: LD_EXP 39
12442: ST_TO_ADDR
// while to_be_alone do
12443: LD_EXP 87
12447: IFFALSE 12518
// begin alone := to_be_alone [ Rand ( 1 , to_be_alone ) ] ;
12449: LD_ADDR_VAR 0 2
12453: PUSH
12454: LD_EXP 87
12458: PUSH
12459: LD_INT 1
12461: PPUSH
12462: LD_EXP 87
12466: PPUSH
12467: CALL_OW 12
12471: ARRAY
12472: ST_TO_ADDR
// to_be_alone := to_be_alone diff alone ;
12473: LD_ADDR_EXP 87
12477: PUSH
12478: LD_EXP 87
12482: PUSH
12483: LD_VAR 0 2
12487: DIFF
12488: ST_TO_ADDR
// prepare_game ( alone ) ;
12489: LD_VAR 0 2
12493: PPUSH
12494: CALL 11221 0 1
// run_game ( alone ) ;
12498: LD_VAR 0 2
12502: PPUSH
12503: CALL 11469 0 1
// close_game ( alone ) ;
12507: LD_VAR 0 2
12511: PPUSH
12512: CALL 12368 0 1
// end ;
12516: GO 12443
// display_score ( 0 , 0 ) ;
12518: LD_INT 0
12520: PPUSH
12521: LD_INT 0
12523: PPUSH
12524: CALL 9795 0 2
// wait ( 0 0$5 ) ;
12528: LD_INT 175
12530: PPUSH
12531: CALL_OW 67
// win := true ;
12535: LD_ADDR_VAR 0 3
12539: PUSH
12540: LD_INT 1
12542: ST_TO_ADDR
// for i := 1 to 8 do
12543: LD_ADDR_VAR 0 4
12547: PUSH
12548: DOUBLE
12549: LD_INT 1
12551: DEC
12552: ST_TO_ADDR
12553: LD_INT 8
12555: PUSH
12556: FOR_TO
12557: IFFALSE 12591
// if GetMultiScore ( i ) > GetMultiScore ( your_side ) then
12559: LD_VAR 0 4
12563: PPUSH
12564: CALL_OW 507
12568: PUSH
12569: LD_OWVAR 2
12573: PPUSH
12574: CALL_OW 507
12578: GREATER
12579: IFFALSE 12589
// win := false ;
12581: LD_ADDR_VAR 0 3
12585: PUSH
12586: LD_INT 0
12588: ST_TO_ADDR
12589: GO 12556
12591: POP
12592: POP
// if win then
12593: LD_VAR 0 3
12597: IFFALSE 12605
// YouWinInMultiplayer else
12599: CALL_OW 106
12603: GO 12609
// YouLostInMultiplayer ;
12605: CALL_OW 107
// end ; end_of_file
12609: LD_VAR 0 1
12613: RET
// export to_be_countdowned ; every 0 0$0.2 trigger to_be_countdowned marked 25 do var who , timer ;
12614: LD_EXP 90
12618: IFFALSE 12789
12620: GO 12622
12622: DISABLE
12623: LD_INT 0
12625: PPUSH
12626: PPUSH
// begin enable ;
12627: ENABLE
// who := to_be_countdowned [ 1 ] ;
12628: LD_ADDR_VAR 0 1
12632: PUSH
12633: LD_EXP 90
12637: PUSH
12638: LD_INT 1
12640: ARRAY
12641: ST_TO_ADDR
// to_be_countdowned := Delete ( to_be_countdowned , 1 ) ;
12642: LD_ADDR_EXP 90
12646: PUSH
12647: LD_EXP 90
12651: PPUSH
12652: LD_INT 1
12654: PPUSH
12655: CALL_OW 3
12659: ST_TO_ADDR
// repeat timer := GetTag ( who ) ;
12660: LD_ADDR_VAR 0 2
12664: PUSH
12665: LD_VAR 0 1
12669: PPUSH
12670: CALL_OW 110
12674: ST_TO_ADDR
// if GetSide ( who ) = your_side then
12675: LD_VAR 0 1
12679: PPUSH
12680: CALL_OW 255
12684: PUSH
12685: LD_OWVAR 2
12689: EQUAL
12690: IFFALSE 12706
// SetUnitDisplayNumber ( who , timer ) ;
12692: LD_VAR 0 1
12696: PPUSH
12697: LD_VAR 0 2
12701: PPUSH
12702: CALL_OW 505
// timer := timer - 1 ;
12706: LD_ADDR_VAR 0 2
12710: PUSH
12711: LD_VAR 0 2
12715: PUSH
12716: LD_INT 1
12718: MINUS
12719: ST_TO_ADDR
// SetTag ( who , timer ) ;
12720: LD_VAR 0 1
12724: PPUSH
12725: LD_VAR 0 2
12729: PPUSH
12730: CALL_OW 109
// wait ( 0 0$1 ) ;
12734: LD_INT 35
12736: PPUSH
12737: CALL_OW 67
// until not IsLive ( who ) or not GetTag ( who ) ;
12741: LD_VAR 0 1
12745: PPUSH
12746: CALL_OW 300
12750: NOT
12751: PUSH
12752: LD_VAR 0 1
12756: PPUSH
12757: CALL_OW 110
12761: NOT
12762: OR
12763: IFFALSE 12660
// if not GetTag ( who ) then
12765: LD_VAR 0 1
12769: PPUSH
12770: CALL_OW 110
12774: NOT
12775: IFFALSE 12789
// SetLives ( who , 0 ) ;
12777: LD_VAR 0 1
12781: PPUSH
12782: LD_INT 0
12784: PPUSH
12785: CALL_OW 234
// end ;
12789: PPOPN 2
12791: END
// every 0 0$0.5 + 0 0$0.05 marked 25 do var un , veh ;
12792: GO 12794
12794: DISABLE
12795: LD_INT 0
12797: PPUSH
12798: PPUSH
// begin veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , f_not , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12799: LD_ADDR_VAR 0 2
12803: PUSH
12804: LD_INT 5
12806: PPUSH
12807: LD_INT 21
12809: PUSH
12810: LD_INT 2
12812: PUSH
12813: EMPTY
12814: LIST
12815: LIST
12816: PUSH
12817: LD_INT 3
12819: PUSH
12820: LD_INT 58
12822: PUSH
12823: EMPTY
12824: LIST
12825: PUSH
12826: LD_INT 3
12828: PUSH
12829: LD_INT 22
12831: PUSH
12832: LD_INT 0
12834: PUSH
12835: EMPTY
12836: LIST
12837: LIST
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: LIST
12843: LIST
12844: LIST
12845: PPUSH
12846: CALL_OW 70
12850: ST_TO_ADDR
// for un in veh do
12851: LD_ADDR_VAR 0 1
12855: PUSH
12856: LD_VAR 0 2
12860: PUSH
12861: FOR_IN
12862: IFFALSE 12875
// ComExitVehicle ( veh ) ;
12864: LD_VAR 0 2
12868: PPUSH
12869: CALL_OW 121
12873: GO 12861
12875: POP
12876: POP
// veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12877: LD_ADDR_VAR 0 2
12881: PUSH
12882: LD_INT 5
12884: PPUSH
12885: LD_INT 21
12887: PUSH
12888: LD_INT 2
12890: PUSH
12891: EMPTY
12892: LIST
12893: LIST
12894: PUSH
12895: LD_INT 58
12897: PUSH
12898: EMPTY
12899: LIST
12900: PUSH
12901: LD_INT 3
12903: PUSH
12904: LD_INT 22
12906: PUSH
12907: LD_INT 0
12909: PUSH
12910: EMPTY
12911: LIST
12912: LIST
12913: PUSH
12914: EMPTY
12915: LIST
12916: LIST
12917: LIST
12918: LIST
12919: PPUSH
12920: CALL_OW 70
12924: ST_TO_ADDR
// for un in veh do
12925: LD_ADDR_VAR 0 1
12929: PUSH
12930: LD_VAR 0 2
12934: PUSH
12935: FOR_IN
12936: IFFALSE 12991
// begin SetMultiScore ( GetSide ( un ) , GetMultiScore ( GetSide ( un ) ) + 1 ) ;
12938: LD_VAR 0 1
12942: PPUSH
12943: CALL_OW 255
12947: PPUSH
12948: LD_VAR 0 1
12952: PPUSH
12953: CALL_OW 255
12957: PPUSH
12958: CALL_OW 507
12962: PUSH
12963: LD_INT 1
12965: PLUS
12966: PPUSH
12967: CALL_OW 506
// RemoveUnit ( un ) ;
12971: LD_VAR 0 1
12975: PPUSH
12976: CALL_OW 64
// DestroyUnit ( un ) ;
12980: LD_VAR 0 1
12984: PPUSH
12985: CALL_OW 65
// end ;
12989: GO 12935
12991: POP
12992: POP
// enable ;
12993: ENABLE
// end ;
12994: PPOPN 2
12996: END
// every 0 0$1 + 0 0$0.1 marked 25 do var i , best , nbest , lastbest , s , first , n ;
12997: GO 12999
12999: DISABLE
13000: LD_INT 0
13002: PPUSH
13003: PPUSH
13004: PPUSH
13005: PPUSH
13006: PPUSH
13007: PPUSH
13008: PPUSH
// begin lastbest := 99999 ;
13009: LD_ADDR_VAR 0 4
13013: PUSH
13014: LD_INT 99999
13016: ST_TO_ADDR
// s := [ ] ;
13017: LD_ADDR_VAR 0 5
13021: PUSH
13022: EMPTY
13023: ST_TO_ADDR
// n := 1 ;
13024: LD_ADDR_VAR 0 7
13028: PUSH
13029: LD_INT 1
13031: ST_TO_ADDR
// repeat best := - 99999 ;
13032: LD_ADDR_VAR 0 2
13036: PUSH
13037: LD_INT 99999
13039: NEG
13040: ST_TO_ADDR
// nbest := 0 ;
13041: LD_ADDR_VAR 0 3
13045: PUSH
13046: LD_INT 0
13048: ST_TO_ADDR
// for i := 1 to 8 do
13049: LD_ADDR_VAR 0 1
13053: PUSH
13054: DOUBLE
13055: LD_INT 1
13057: DEC
13058: ST_TO_ADDR
13059: LD_INT 8
13061: PUSH
13062: FOR_TO
13063: IFFALSE 13169
// if Side_Positions [ i ] then
13065: LD_EXP 43
13069: PUSH
13070: LD_VAR 0 1
13074: ARRAY
13075: IFFALSE 13167
// begin if ( GetMultiScore ( i ) > best ) and ( GetMultiScore ( i ) < lastbest ) then
13077: LD_VAR 0 1
13081: PPUSH
13082: CALL_OW 507
13086: PUSH
13087: LD_VAR 0 2
13091: GREATER
13092: PUSH
13093: LD_VAR 0 1
13097: PPUSH
13098: CALL_OW 507
13102: PUSH
13103: LD_VAR 0 4
13107: LESS
13108: AND
13109: IFFALSE 13136
// begin best := GetMultiScore ( i ) ;
13111: LD_ADDR_VAR 0 2
13115: PUSH
13116: LD_VAR 0 1
13120: PPUSH
13121: CALL_OW 507
13125: ST_TO_ADDR
// nbest := 1 ;
13126: LD_ADDR_VAR 0 3
13130: PUSH
13131: LD_INT 1
13133: ST_TO_ADDR
// end else
13134: GO 13167
// if GetMultiScore ( i ) = best then
13136: LD_VAR 0 1
13140: PPUSH
13141: CALL_OW 507
13145: PUSH
13146: LD_VAR 0 2
13150: EQUAL
13151: IFFALSE 13167
// begin nbest := nbest + 1 ;
13153: LD_ADDR_VAR 0 3
13157: PUSH
13158: LD_VAR 0 3
13162: PUSH
13163: LD_INT 1
13165: PLUS
13166: ST_TO_ADDR
// end ; end ;
13167: GO 13062
13169: POP
13170: POP
// first := true ;
13171: LD_ADDR_VAR 0 6
13175: PUSH
13176: LD_INT 1
13178: ST_TO_ADDR
// if nbest > 0 then
13179: LD_VAR 0 3
13183: PUSH
13184: LD_INT 0
13186: GREATER
13187: IFFALSE 13360
// for i := 1 to 8 do
13189: LD_ADDR_VAR 0 1
13193: PUSH
13194: DOUBLE
13195: LD_INT 1
13197: DEC
13198: ST_TO_ADDR
13199: LD_INT 8
13201: PUSH
13202: FOR_TO
13203: IFFALSE 13358
// if Side_Positions [ i ] then
13205: LD_EXP 43
13209: PUSH
13210: LD_VAR 0 1
13214: ARRAY
13215: IFFALSE 13356
// if GetMultiScore ( i ) = best then
13217: LD_VAR 0 1
13221: PPUSH
13222: CALL_OW 507
13226: PUSH
13227: LD_VAR 0 2
13231: EQUAL
13232: IFFALSE 13356
// if nbest = 1 then
13234: LD_VAR 0 3
13238: PUSH
13239: LD_INT 1
13241: EQUAL
13242: IFFALSE 13293
// s := s ^ [ #Multi-score , n , i , i , i , best ] else
13244: LD_ADDR_VAR 0 5
13248: PUSH
13249: LD_VAR 0 5
13253: PUSH
13254: LD_STRING #Multi-score
13256: PUSH
13257: LD_VAR 0 7
13261: PUSH
13262: LD_VAR 0 1
13266: PUSH
13267: LD_VAR 0 1
13271: PUSH
13272: LD_VAR 0 1
13276: PUSH
13277: LD_VAR 0 2
13281: PUSH
13282: EMPTY
13283: LIST
13284: LIST
13285: LIST
13286: LIST
13287: LIST
13288: LIST
13289: ADD
13290: ST_TO_ADDR
13291: GO 13356
// s := s ^ [ #Multi-score-range , n , n + nbest - 1 , i , i , i , best ] ;
13293: LD_ADDR_VAR 0 5
13297: PUSH
13298: LD_VAR 0 5
13302: PUSH
13303: LD_STRING #Multi-score-range
13305: PUSH
13306: LD_VAR 0 7
13310: PUSH
13311: LD_VAR 0 7
13315: PUSH
13316: LD_VAR 0 3
13320: PLUS
13321: PUSH
13322: LD_INT 1
13324: MINUS
13325: PUSH
13326: LD_VAR 0 1
13330: PUSH
13331: LD_VAR 0 1
13335: PUSH
13336: LD_VAR 0 1
13340: PUSH
13341: LD_VAR 0 2
13345: PUSH
13346: EMPTY
13347: LIST
13348: LIST
13349: LIST
13350: LIST
13351: LIST
13352: LIST
13353: LIST
13354: ADD
13355: ST_TO_ADDR
13356: GO 13202
13358: POP
13359: POP
// n := n + nbest ;
13360: LD_ADDR_VAR 0 7
13364: PUSH
13365: LD_VAR 0 7
13369: PUSH
13370: LD_VAR 0 3
13374: PLUS
13375: ST_TO_ADDR
// lastbest := best ;
13376: LD_ADDR_VAR 0 4
13380: PUSH
13381: LD_VAR 0 2
13385: ST_TO_ADDR
// until nbest = 0 ;
13386: LD_VAR 0 3
13390: PUSH
13391: LD_INT 0
13393: EQUAL
13394: IFFALSE 13032
// if game_time then
13396: LD_EXP 56
13400: IFFALSE 13435
// s := [ #Hunt-Limit , 0 , game_time - tick ] ^ s ;
13402: LD_ADDR_VAR 0 5
13406: PUSH
13407: LD_STRING #Hunt-Limit
13409: PUSH
13410: LD_INT 0
13412: PUSH
13413: LD_EXP 56
13417: PUSH
13418: LD_OWVAR 1
13422: MINUS
13423: PUSH
13424: EMPTY
13425: LIST
13426: LIST
13427: LIST
13428: PUSH
13429: LD_VAR 0 5
13433: ADD
13434: ST_TO_ADDR
// display_strings := s ;
13435: LD_ADDR_OWVAR 47
13439: PUSH
13440: LD_VAR 0 5
13444: ST_TO_ADDR
// enable ;
13445: ENABLE
// end ;
13446: PPOPN 7
13448: END
// every 0 0$1 marked 25 do var veh ;
13449: GO 13451
13451: DISABLE
13452: LD_INT 0
13454: PPUSH
// begin repeat repeat veh := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
13455: LD_ADDR_VAR 0 1
13459: PUSH
13460: LD_INT 21
13462: PUSH
13463: LD_INT 2
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PPUSH
13470: CALL_OW 69
13474: ST_TO_ADDR
// wait ( 0 0$3 ) ;
13475: LD_INT 105
13477: PPUSH
13478: CALL_OW 67
// until veh < vehmax ;
13482: LD_VAR 0 1
13486: PUSH
13487: LD_EXP 61
13491: LESS
13492: IFFALSE 13455
// wait ( Rand ( vehresp [ 1 ] div side_count , vehresp [ 2 ] div side_count ) ) ;
13494: LD_EXP 58
13498: PUSH
13499: LD_INT 1
13501: ARRAY
13502: PUSH
13503: LD_EXP 37
13507: DIV
13508: PPUSH
13509: LD_EXP 58
13513: PUSH
13514: LD_INT 2
13516: ARRAY
13517: PUSH
13518: LD_EXP 37
13522: DIV
13523: PPUSH
13524: CALL_OW 12
13528: PPUSH
13529: CALL_OW 67
// vehicles_create_vehicle ( false ) ;
13533: LD_INT 0
13535: PPUSH
13536: CALL 6881 0 1
// until false ;
13540: LD_INT 0
13542: IFFALSE 13455
// end ;
13544: PPOPN 1
13546: END
// every 3 marked 25 do var side , peop ;
13547: GO 13549
13549: DISABLE
13550: LD_INT 0
13552: PPUSH
13553: PPUSH
// begin if not to_resp then
13554: LD_EXP 69
13558: NOT
13559: IFFALSE 13563
// exit ;
13561: GO 13764
// enable ;
13563: ENABLE
// side := to_resp [ 1 ] ;
13564: LD_ADDR_VAR 0 1
13568: PUSH
13569: LD_EXP 69
13573: PUSH
13574: LD_INT 1
13576: ARRAY
13577: ST_TO_ADDR
// to_resp := Delete ( to_resp , 1 ) ;
13578: LD_ADDR_EXP 69
13582: PUSH
13583: LD_EXP 69
13587: PPUSH
13588: LD_INT 1
13590: PPUSH
13591: CALL_OW 3
13595: ST_TO_ADDR
// repeat repeat peop := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_side , side ] , [ f_ok ] ] ) ;
13596: LD_ADDR_VAR 0 2
13600: PUSH
13601: LD_INT 21
13603: PUSH
13604: LD_INT 1
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: LD_INT 22
13613: PUSH
13614: LD_VAR 0 1
13618: PUSH
13619: EMPTY
13620: LIST
13621: LIST
13622: PUSH
13623: LD_INT 50
13625: PUSH
13626: EMPTY
13627: LIST
13628: PUSH
13629: EMPTY
13630: LIST
13631: LIST
13632: LIST
13633: PPUSH
13634: CALL_OW 69
13638: ST_TO_ADDR
// wait ( 0 0$5 ) ;
13639: LD_INT 175
13641: PPUSH
13642: CALL_OW 67
// until peop < npeop ;
13646: LD_VAR 0 2
13650: PUSH
13651: LD_EXP 65
13655: LESS
13656: IFFALSE 13596
// wait ( Rand ( peopresp [ 1 ] , peopresp [ 2 ] ) ) ;
13658: LD_EXP 66
13662: PUSH
13663: LD_INT 1
13665: ARRAY
13666: PPUSH
13667: LD_EXP 66
13671: PUSH
13672: LD_INT 2
13674: ARRAY
13675: PPUSH
13676: CALL_OW 12
13680: PPUSH
13681: CALL_OW 67
// uc_side := side ;
13685: LD_ADDR_OWVAR 20
13689: PUSH
13690: LD_VAR 0 1
13694: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
13695: LD_ADDR_OWVAR 21
13699: PUSH
13700: LD_EXP 44
13704: PUSH
13705: LD_VAR 0 1
13709: ARRAY
13710: ST_TO_ADDR
// hc_name :=  ;
13711: LD_ADDR_OWVAR 26
13715: PUSH
13716: LD_STRING 
13718: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
13719: LD_INT 0
13721: PPUSH
13722: LD_INT 4
13724: PPUSH
13725: CALL_OW 383
// hc_importance := 0 ;
13729: LD_ADDR_OWVAR 32
13733: PUSH
13734: LD_INT 0
13736: ST_TO_ADDR
// hc_gallery :=  ;
13737: LD_ADDR_OWVAR 33
13741: PUSH
13742: LD_STRING 
13744: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , arstartveh , true ) ;
13745: CALL_OW 44
13749: PPUSH
13750: LD_INT 22
13752: PPUSH
13753: LD_INT 1
13755: PPUSH
13756: CALL_OW 49
// until false ;
13760: LD_INT 0
13762: IFFALSE 13596
// end ;
13764: PPOPN 2
13766: END
// on siberiterocketexploded ( un , x , y ) do SA_OnSiberiteRocketExploded ( un , x , y , Your_Side ) ; end_of_file
13767: LD_VAR 0 1
13771: PPUSH
13772: LD_VAR 0 2
13776: PPUSH
13777: LD_VAR 0 3
13781: PPUSH
13782: LD_OWVAR 2
13786: PPUSH
13787: CALL 14744 0 4
13791: PPOPN 3
13793: END
// export Side_Comps ; export nonCombat , siberite_rocket ; every 1 do
13794: GO 13796
13796: DISABLE
// begin if GetMultiplayerSetting ( 49 ) or iseditor then
13797: LD_INT 49
13799: PPUSH
13800: CALL_OW 426
13804: PUSH
13805: LD_OWVAR 84
13809: OR
13810: IFFALSE 13819
// fogoff ( true ) ;
13812: LD_INT 1
13814: PPUSH
13815: CALL_OW 344
// disable ( 125 ) ;
13819: LD_INT 125
13821: DISABLE_MARKED
// Start_VehicleAI ;
13822: CALL 13827 0 0
// end ;
13826: END
// function Start_VehicleAI ; var i , k ; begin
13827: LD_INT 0
13829: PPUSH
13830: PPUSH
13831: PPUSH
// if multiplayer then
13832: LD_OWVAR 4
13836: IFFALSE 13850
// Side_Comps = mp_sides_comps else
13838: LD_ADDR_EXP 91
13842: PUSH
13843: CALL 13992 0 0
13847: ST_TO_ADDR
13848: GO 13889
// side_comps = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ;
13850: LD_ADDR_EXP 91
13854: PUSH
13855: LD_INT 1
13857: PUSH
13858: LD_INT 1
13860: PUSH
13861: LD_INT 1
13863: PUSH
13864: LD_INT 1
13866: PUSH
13867: LD_INT 1
13869: PUSH
13870: LD_INT 1
13872: PUSH
13873: LD_INT 1
13875: PUSH
13876: LD_INT 1
13878: PUSH
13879: EMPTY
13880: LIST
13881: LIST
13882: LIST
13883: LIST
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: ST_TO_ADDR
// k = false ;
13889: LD_ADDR_VAR 0 3
13893: PUSH
13894: LD_INT 0
13896: ST_TO_ADDR
// for i in side_comps do
13897: LD_ADDR_VAR 0 2
13901: PUSH
13902: LD_EXP 91
13906: PUSH
13907: FOR_IN
13908: IFFALSE 13926
// if i then
13910: LD_VAR 0 2
13914: IFFALSE 13924
// k = true ;
13916: LD_ADDR_VAR 0 3
13920: PUSH
13921: LD_INT 1
13923: ST_TO_ADDR
13924: GO 13907
13926: POP
13927: POP
// nonCombat = [ us_radar , us_bulldozer , us_siberium_rocket_remainder , ar_radar , ar_selfpropelled_bomb , ru_bulldozer , ru_siberium_rocket_remainder ] ;
13928: LD_ADDR_EXP 92
13932: PUSH
13933: LD_INT 11
13935: PUSH
13936: LD_INT 14
13938: PUSH
13939: LD_INT 15
13941: PUSH
13942: LD_INT 30
13944: PUSH
13945: LD_INT 29
13947: PUSH
13948: LD_INT 53
13950: PUSH
13951: LD_INT 55
13953: PUSH
13954: EMPTY
13955: LIST
13956: LIST
13957: LIST
13958: LIST
13959: LIST
13960: LIST
13961: LIST
13962: ST_TO_ADDR
// Siberite_Rocket = [ us_siberium_rocket , ru_siberium_rocket ] ;
13963: LD_ADDR_EXP 93
13967: PUSH
13968: LD_INT 8
13970: PUSH
13971: LD_INT 48
13973: PUSH
13974: EMPTY
13975: LIST
13976: LIST
13977: ST_TO_ADDR
// if k then
13978: LD_VAR 0 3
13982: IFFALSE 13987
// enable ( 125 ) ;
13984: LD_INT 125
13986: ENABLE_MARKED
// end ;
13987: LD_VAR 0 1
13991: RET
// function mp_sides_comps ; var c , i ; begin
13992: LD_INT 0
13994: PPUSH
13995: PPUSH
13996: PPUSH
// c = [ ] ;
13997: LD_ADDR_VAR 0 2
14001: PUSH
14002: EMPTY
14003: ST_TO_ADDR
// for i = 1 to 8 do
14004: LD_ADDR_VAR 0 3
14008: PUSH
14009: DOUBLE
14010: LD_INT 1
14012: DEC
14013: ST_TO_ADDR
14014: LD_INT 8
14016: PUSH
14017: FOR_TO
14018: IFFALSE 14043
// c = c ^ Multiplayer_GetPlayerIsComp ( i ) ;
14020: LD_ADDR_VAR 0 2
14024: PUSH
14025: LD_VAR 0 2
14029: PUSH
14030: LD_VAR 0 3
14034: PPUSH
14035: CALL_OW 532
14039: ADD
14040: ST_TO_ADDR
14041: GO 14017
14043: POP
14044: POP
// result = c ;
14045: LD_ADDR_VAR 0 1
14049: PUSH
14050: LD_VAR 0 2
14054: ST_TO_ADDR
// end ;
14055: LD_VAR 0 1
14059: RET
// every 0 0$1 marked 125 do var units , u , veh , k , c , i , hex ;
14060: GO 14062
14062: DISABLE
14063: LD_INT 0
14065: PPUSH
14066: PPUSH
14067: PPUSH
14068: PPUSH
14069: PPUSH
14070: PPUSH
14071: PPUSH
// begin units = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_human ] ] ) ;
14072: LD_ADDR_VAR 0 1
14076: PUSH
14077: LD_INT 52
14079: PUSH
14080: EMPTY
14081: LIST
14082: PUSH
14083: LD_INT 50
14085: PUSH
14086: EMPTY
14087: LIST
14088: PUSH
14089: LD_INT 21
14091: PUSH
14092: LD_INT 1
14094: PUSH
14095: EMPTY
14096: LIST
14097: LIST
14098: PUSH
14099: EMPTY
14100: LIST
14101: LIST
14102: LIST
14103: PPUSH
14104: CALL_OW 69
14108: ST_TO_ADDR
// k = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
14109: LD_ADDR_VAR 0 4
14113: PUSH
14114: LD_INT 52
14116: PUSH
14117: EMPTY
14118: LIST
14119: PUSH
14120: LD_INT 50
14122: PUSH
14123: EMPTY
14124: LIST
14125: PUSH
14126: LD_INT 21
14128: PUSH
14129: LD_INT 2
14131: PUSH
14132: EMPTY
14133: LIST
14134: LIST
14135: PUSH
14136: LD_INT 58
14138: PUSH
14139: EMPTY
14140: LIST
14141: PUSH
14142: EMPTY
14143: LIST
14144: LIST
14145: LIST
14146: LIST
14147: PPUSH
14148: CALL_OW 69
14152: ST_TO_ADDR
// for u in units do
14153: LD_ADDR_VAR 0 2
14157: PUSH
14158: LD_VAR 0 1
14162: PUSH
14163: FOR_IN
14164: IFFALSE 14235
// if getSide ( u ) = 0 then
14166: LD_VAR 0 2
14170: PPUSH
14171: CALL_OW 255
14175: PUSH
14176: LD_INT 0
14178: EQUAL
14179: IFFALSE 14199
// units = units diff u else
14181: LD_ADDR_VAR 0 1
14185: PUSH
14186: LD_VAR 0 1
14190: PUSH
14191: LD_VAR 0 2
14195: DIFF
14196: ST_TO_ADDR
14197: GO 14233
// if not Side_Comps [ getSide ( u ) ] then
14199: LD_EXP 91
14203: PUSH
14204: LD_VAR 0 2
14208: PPUSH
14209: CALL_OW 255
14213: ARRAY
14214: NOT
14215: IFFALSE 14233
// units = units diff u ;
14217: LD_ADDR_VAR 0 1
14221: PUSH
14222: LD_VAR 0 1
14226: PUSH
14227: LD_VAR 0 2
14231: DIFF
14232: ST_TO_ADDR
14233: GO 14163
14235: POP
14236: POP
// for u in units do
14237: LD_ADDR_VAR 0 2
14241: PUSH
14242: LD_VAR 0 1
14246: PUSH
14247: FOR_IN
14248: IFFALSE 14668
// begin if isinunit ( u ) then
14250: LD_VAR 0 2
14254: PPUSH
14255: CALL_OW 310
14259: IFFALSE 14476
// begin veh = isinunit ( u ) ;
14261: LD_ADDR_VAR 0 3
14265: PUSH
14266: LD_VAR 0 2
14270: PPUSH
14271: CALL_OW 310
14275: ST_TO_ADDR
// if not HasTask ( veh ) then
14276: LD_VAR 0 3
14280: PPUSH
14281: CALL_OW 314
14285: NOT
14286: IFFALSE 14474
// begin if getWeapon ( veh ) in nonCombat then
14288: LD_VAR 0 3
14292: PPUSH
14293: CALL_OW 264
14297: PUSH
14298: LD_EXP 92
14302: IN
14303: IFFALSE 14319
// comMoveToArea ( veh , exitarea ) else
14305: LD_VAR 0 3
14309: PPUSH
14310: LD_INT 5
14312: PPUSH
14313: CALL_OW 113
14317: GO 14474
// if getWeapon ( veh ) in Siberite_Rocket then
14319: LD_VAR 0 3
14323: PPUSH
14324: CALL_OW 264
14328: PUSH
14329: LD_EXP 93
14333: IN
14334: IFFALSE 14390
// begin hex = RandHex ( false ) ;
14336: LD_ADDR_VAR 0 7
14340: PUSH
14341: LD_INT 0
14343: PPUSH
14344: CALL_OW 15
14348: ST_TO_ADDR
// ComAttackPlace ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14349: LD_VAR 0 3
14353: PPUSH
14354: LD_VAR 0 7
14358: PUSH
14359: LD_INT 1
14361: ARRAY
14362: PPUSH
14363: LD_VAR 0 7
14367: PUSH
14368: LD_INT 2
14370: ARRAY
14371: PPUSH
14372: CALL_OW 116
// AddComMoveToArea ( veh , exitarea ) ;
14376: LD_VAR 0 3
14380: PPUSH
14381: LD_INT 5
14383: PPUSH
14384: CALL_OW 173
// end else
14388: GO 14474
// if getLives ( veh ) <= hranice_zraneni then
14390: LD_VAR 0 3
14394: PPUSH
14395: CALL_OW 256
14399: PUSH
14400: LD_INT 500
14402: LESSEQUAL
14403: IFFALSE 14419
// comMoveToArea ( veh , exitarea ) else
14405: LD_VAR 0 3
14409: PPUSH
14410: LD_INT 5
14412: PPUSH
14413: CALL_OW 113
14417: GO 14474
// begin hex = RandHexArea ( exitarea , false ) ;
14419: LD_ADDR_VAR 0 7
14423: PUSH
14424: LD_INT 5
14426: PPUSH
14427: LD_INT 0
14429: PPUSH
14430: CALL_OW 16
14434: ST_TO_ADDR
// comAgressiveMove ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14435: LD_VAR 0 3
14439: PPUSH
14440: LD_VAR 0 7
14444: PUSH
14445: LD_INT 1
14447: ARRAY
14448: PPUSH
14449: LD_VAR 0 7
14453: PUSH
14454: LD_INT 2
14456: ARRAY
14457: PPUSH
14458: CALL_OW 114
// AddComMoveToArea ( veh , exitarea ) ;
14462: LD_VAR 0 3
14466: PPUSH
14467: LD_INT 5
14469: PPUSH
14470: CALL_OW 173
// end ; end ; end else
14474: GO 14659
// begin if not HasTask ( u ) then
14476: LD_VAR 0 2
14480: PPUSH
14481: CALL_OW 314
14485: NOT
14486: IFFALSE 14530
// begin hex = RandHex ( false ) ;
14488: LD_ADDR_VAR 0 7
14492: PUSH
14493: LD_INT 0
14495: PPUSH
14496: CALL_OW 15
14500: ST_TO_ADDR
// ComMoveXY ( u , hex [ 1 ] , hex [ 2 ] ) ;
14501: LD_VAR 0 2
14505: PPUSH
14506: LD_VAR 0 7
14510: PUSH
14511: LD_INT 1
14513: ARRAY
14514: PPUSH
14515: LD_VAR 0 7
14519: PUSH
14520: LD_INT 2
14522: ARRAY
14523: PPUSH
14524: CALL_OW 111
// end else
14528: GO 14659
// begin c = [ ] ;
14530: LD_ADDR_VAR 0 5
14534: PUSH
14535: EMPTY
14536: ST_TO_ADDR
// for i in k do
14537: LD_ADDR_VAR 0 6
14541: PUSH
14542: LD_VAR 0 4
14546: PUSH
14547: FOR_IN
14548: IFFALSE 14589
// if See ( getSide ( u ) , i ) then
14550: LD_VAR 0 2
14554: PPUSH
14555: CALL_OW 255
14559: PPUSH
14560: LD_VAR 0 6
14564: PPUSH
14565: CALL_OW 292
14569: IFFALSE 14587
// c = c ^ i ;
14571: LD_ADDR_VAR 0 5
14575: PUSH
14576: LD_VAR 0 5
14580: PUSH
14581: LD_VAR 0 6
14585: ADD
14586: ST_TO_ADDR
14587: GO 14547
14589: POP
14590: POP
// if c + 0 > 0 then
14591: LD_VAR 0 5
14595: PUSH
14596: LD_INT 0
14598: PLUS
14599: PUSH
14600: LD_INT 0
14602: GREATER
14603: IFFALSE 14659
// begin c = NearestUnitToUnit ( c , u ) ;
14605: LD_ADDR_VAR 0 5
14609: PUSH
14610: LD_VAR 0 5
14614: PPUSH
14615: LD_VAR 0 2
14619: PPUSH
14620: CALL_OW 74
14624: ST_TO_ADDR
// if GetDistUnits ( u , c ) < 10 then
14625: LD_VAR 0 2
14629: PPUSH
14630: LD_VAR 0 5
14634: PPUSH
14635: CALL_OW 296
14639: PUSH
14640: LD_INT 10
14642: LESS
14643: IFFALSE 14659
// comEnterUnit ( u , c ) ;
14645: LD_VAR 0 2
14649: PPUSH
14650: LD_VAR 0 5
14654: PPUSH
14655: CALL_OW 120
// end ; end ; end ; wait ( 1 ) ;
14659: LD_INT 1
14661: PPUSH
14662: CALL_OW 67
// end ;
14666: GO 14247
14668: POP
14669: POP
// enable ;
14670: ENABLE
// end ; end_of_file
14671: PPOPN 7
14673: END
// every 10 do
14674: GO 14676
14676: DISABLE
// begin if not multiplayer then
14677: LD_OWVAR 4
14681: NOT
14682: IFFALSE 14686
// exit ;
14684: GO 14743
// if ( tick >= 100 ) then
14686: LD_OWVAR 1
14690: PUSH
14691: LD_INT 100
14693: GREATEREQUAL
14694: IFFALSE 14714
// if tick mod 20 = 0 then
14696: LD_OWVAR 1
14700: PUSH
14701: LD_INT 20
14703: MOD
14704: PUSH
14705: LD_INT 0
14707: EQUAL
14708: IFFALSE 14714
// MultiplayerCRC ;
14710: CALL_OW 361
// if ( tick >= 100 ) then
14714: LD_OWVAR 1
14718: PUSH
14719: LD_INT 100
14721: GREATEREQUAL
14722: IFFALSE 14742
// if tick mod 30 = 0 then
14724: LD_OWVAR 1
14728: PUSH
14729: LD_INT 30
14731: MOD
14732: PUSH
14733: LD_INT 0
14735: EQUAL
14736: IFFALSE 14742
// DebugLogAll ;
14738: CALL_OW 360
// enable ;
14742: ENABLE
// end ; end_of_file
14743: END
// export function SA_OnSiberiteRocketExploded ( siberite_rocket_vehicle , target_x , target_y , requestSide ) ; begin
14744: LD_INT 0
14746: PPUSH
// if GetSide ( siberite_rocket_vehicle ) = requestSide then
14747: LD_VAR 0 1
14751: PPUSH
14752: CALL_OW 255
14756: PUSH
14757: LD_VAR 0 4
14761: EQUAL
14762: IFFALSE 14781
// begin SetAchievement ( ACH_RAD ) ;
14764: LD_STRING ACH_RAD
14766: PPUSH
14767: CALL_OW 543
// SetAchievementEx ( ACH_NL , 1 ) ;
14771: LD_STRING ACH_NL
14773: PPUSH
14774: LD_INT 1
14776: PPUSH
14777: CALL_OW 564
// end end ;
14781: LD_VAR 0 5
14785: RET
// export function SA_Win ( side ) ; begin
14786: LD_INT 0
14788: PPUSH
// case side of 1 :
14789: LD_VAR 0 1
14793: PUSH
14794: LD_INT 1
14796: DOUBLE
14797: EQUAL
14798: IFTRUE 14802
14800: GO 14815
14802: POP
// SetAchievementEx ( ACH_AH , 1 ) ; 2 :
14803: LD_STRING ACH_AH
14805: PPUSH
14806: LD_INT 1
14808: PPUSH
14809: CALL_OW 564
14813: GO 14978
14815: LD_INT 2
14817: DOUBLE
14818: EQUAL
14819: IFTRUE 14823
14821: GO 14836
14823: POP
// SetAchievementEx ( ACH_E , 1 ) ; 3 :
14824: LD_STRING ACH_E
14826: PPUSH
14827: LD_INT 1
14829: PPUSH
14830: CALL_OW 564
14834: GO 14978
14836: LD_INT 3
14838: DOUBLE
14839: EQUAL
14840: IFTRUE 14844
14842: GO 14857
14844: POP
// SetAchievementEx ( ACH_OOL , 1 ) ; [ 1 , 2 ] :
14845: LD_STRING ACH_OOL
14847: PPUSH
14848: LD_INT 1
14850: PPUSH
14851: CALL_OW 564
14855: GO 14978
14857: LD_INT 1
14859: PUSH
14860: LD_INT 2
14862: PUSH
14863: EMPTY
14864: LIST
14865: LIST
14866: DOUBLE
14867: EQUAL
14868: IFTRUE 14872
14870: GO 14897
14872: POP
// begin SetAchievementEx ( ACH_AH , 0.5 ) ;
14873: LD_STRING ACH_AH
14875: PPUSH
14876: LD_REAL  5.00000000000000E-0001
14879: PPUSH
14880: CALL_OW 564
// SetAchievementEx ( ACH_E , 0.5 ) ;
14884: LD_STRING ACH_E
14886: PPUSH
14887: LD_REAL  5.00000000000000E-0001
14890: PPUSH
14891: CALL_OW 564
// end ; [ 2 , 3 ] :
14895: GO 14978
14897: LD_INT 2
14899: PUSH
14900: LD_INT 3
14902: PUSH
14903: EMPTY
14904: LIST
14905: LIST
14906: DOUBLE
14907: EQUAL
14908: IFTRUE 14912
14910: GO 14937
14912: POP
// begin SetAchievementEx ( ACH_OOL , 0.5 ) ;
14913: LD_STRING ACH_OOL
14915: PPUSH
14916: LD_REAL  5.00000000000000E-0001
14919: PPUSH
14920: CALL_OW 564
// SetAchievementEx ( ACH_E , 0.5 ) ;
14924: LD_STRING ACH_E
14926: PPUSH
14927: LD_REAL  5.00000000000000E-0001
14930: PPUSH
14931: CALL_OW 564
// end ; [ 3 , 1 ] :
14935: GO 14978
14937: LD_INT 3
14939: PUSH
14940: LD_INT 1
14942: PUSH
14943: EMPTY
14944: LIST
14945: LIST
14946: DOUBLE
14947: EQUAL
14948: IFTRUE 14952
14950: GO 14977
14952: POP
// begin SetAchievementEx ( ACH_AH , 0.5 ) ;
14953: LD_STRING ACH_AH
14955: PPUSH
14956: LD_REAL  5.00000000000000E-0001
14959: PPUSH
14960: CALL_OW 564
// SetAchievementEx ( ACH_OOL , 0.5 ) ;
14964: LD_STRING ACH_OOL
14966: PPUSH
14967: LD_REAL  5.00000000000000E-0001
14970: PPUSH
14971: CALL_OW 564
// end ; end ;
14975: GO 14978
14977: POP
// end ;
14978: LD_VAR 0 2
14982: RET
