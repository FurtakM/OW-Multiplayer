// export gametype ; starting begin if multiplayer then
   0: LD_OWVAR 4
   4: IFFALSE 18
// gametype = mp_game_type else
   6: LD_ADDR_EXP 1
  10: PUSH
  11: LD_OWVAR 6
  15: ST_TO_ADDR
  16: GO 26
// gametype = 25 ;
  18: LD_ADDR_EXP 1
  22: PUSH
  23: LD_INT 25
  25: ST_TO_ADDR
// case gametype of 15 :
  26: LD_EXP 1
  30: PUSH
  31: LD_INT 15
  33: DOUBLE
  34: EQUAL
  35: IFTRUE 39
  37: GO 55
  39: POP
// begin enable ( 15 ) ;
  40: LD_INT 15
  42: ENABLE_MARKED
// disable ( 25 ) ;
  43: LD_INT 25
  45: DISABLE_MARKED
// disable ( 35 ) ;
  46: LD_INT 35
  48: DISABLE_MARKED
// starting_sheherezad ;
  49: CALL 3956 0 0
// end ; 25 :
  53: GO 110
  55: LD_INT 25
  57: DOUBLE
  58: EQUAL
  59: IFTRUE 63
  61: GO 79
  63: POP
// begin enable ( 25 ) ;
  64: LD_INT 25
  66: ENABLE_MARKED
// disable ( 15 ) ;
  67: LD_INT 15
  69: DISABLE_MARKED
// disable ( 35 ) ;
  70: LD_INT 35
  72: DISABLE_MARKED
// starting_vehicles ;
  73: CALL 7340 0 0
// end ; 35 , 36 :
  77: GO 110
  79: LD_INT 35
  81: DOUBLE
  82: EQUAL
  83: IFTRUE 93
  85: LD_INT 36
  87: DOUBLE
  88: EQUAL
  89: IFTRUE 93
  91: GO 109
  93: POP
// begin enable ( 35 ) ;
  94: LD_INT 35
  96: ENABLE_MARKED
// disable ( 15 ) ;
  97: LD_INT 15
  99: DISABLE_MARKED
// disable ( 25 ) ;
 100: LD_INT 25
 102: DISABLE_MARKED
// starting_hunt ;
 103: CALL 12411 0 0
// end ; end ;
 107: GO 110
 109: POP
// end ; end_of_file
 110: END
// export def_sheherezade_speed , def_sheherezade_stamina , def_sheherezade_skills , def_number_of_sheikhs , def_sheikhs_level , def_number_of_soldiers , def_soldiers_level , def_charges_allowed , def_amount_of_apemen , def_apemen_level , def_apemen_abilities , def_number_of_mastodons , def_number_of_tigers , def_time_to_prepare , def_flags ; export shzd_speed , shzd_stamina , shzd_skills , nsh , sh_skills , nsol , sol_skills , nstart_ape , ape_respawning , ape_skills , nmast1 , nmast2 , nmast3 , ntig , tig_respawning , prep_time , flags ; export coordinates , sheherezades , lastunit ; export Side_Count , Team_Count , Player_Side , Player_Team , Side_Teams , Teams ; export Side_Positions , Side_Nations , Side_Names , Team_Names , Team_Game ; function read_multiplayer_and_game_parameters ; var i ; begin
 111: LD_INT 0
 113: PPUSH
 114: PPUSH
// if MultiPlayer then
 115: LD_OWVAR 4
 119: IFFALSE 183
// begin Player_Side = mp_player_side ;
 121: LD_ADDR_EXP 39
 125: PUSH
 126: LD_OWVAR 7
 130: ST_TO_ADDR
// Player_Team = mp_player_team ;
 131: LD_ADDR_EXP 40
 135: PUSH
 136: LD_OWVAR 8
 140: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
 141: LD_ADDR_EXP 43
 145: PUSH
 146: LD_OWVAR 17
 150: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
 151: LD_ADDR_EXP 41
 155: PUSH
 156: LD_OWVAR 15
 160: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
 161: LD_ADDR_EXP 44
 165: PUSH
 166: LD_OWVAR 16
 170: ST_TO_ADDR
// Teams = mp_teams ;
 171: LD_ADDR_EXP 42
 175: PUSH
 176: LD_OWVAR 12
 180: ST_TO_ADDR
// end else
 181: GO 323
// begin Player_Side = 1 ;
 183: LD_ADDR_EXP 39
 187: PUSH
 188: LD_INT 1
 190: ST_TO_ADDR
// Player_Team = 0 ;
 191: LD_ADDR_EXP 40
 195: PUSH
 196: LD_INT 0
 198: ST_TO_ADDR
// Side_Positions = [ 1 , 2 , 3 , 4 , 5 , 0 , 0 , 0 ] ;
 199: LD_ADDR_EXP 43
 203: PUSH
 204: LD_INT 1
 206: PUSH
 207: LD_INT 2
 209: PUSH
 210: LD_INT 3
 212: PUSH
 213: LD_INT 4
 215: PUSH
 216: LD_INT 5
 218: PUSH
 219: LD_INT 0
 221: PUSH
 222: LD_INT 0
 224: PUSH
 225: LD_INT 0
 227: PUSH
 228: EMPTY
 229: LIST
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: LIST
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
 238: LD_ADDR_EXP 41
 242: PUSH
 243: LD_INT 0
 245: PUSH
 246: LD_INT 0
 248: PUSH
 249: LD_INT 0
 251: PUSH
 252: LD_INT 0
 254: PUSH
 255: LD_INT 0
 257: PUSH
 258: LD_INT 0
 260: PUSH
 261: LD_INT 0
 263: PUSH
 264: LD_INT 0
 266: PUSH
 267: EMPTY
 268: LIST
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: LIST
 274: LIST
 275: LIST
 276: ST_TO_ADDR
// Side_Nations = [ 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 ] ;
 277: LD_ADDR_EXP 44
 281: PUSH
 282: LD_INT 2
 284: PUSH
 285: LD_INT 2
 287: PUSH
 288: LD_INT 2
 290: PUSH
 291: LD_INT 2
 293: PUSH
 294: LD_INT 2
 296: PUSH
 297: LD_INT 2
 299: PUSH
 300: LD_INT 2
 302: PUSH
 303: LD_INT 2
 305: PUSH
 306: EMPTY
 307: LIST
 308: LIST
 309: LIST
 310: LIST
 311: LIST
 312: LIST
 313: LIST
 314: LIST
 315: ST_TO_ADDR
// Teams = [ ] ;
 316: LD_ADDR_EXP 42
 320: PUSH
 321: EMPTY
 322: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
 323: LD_ADDR_EXP 37
 327: PUSH
 328: LD_EXP 43
 332: PUSH
 333: LD_INT 0
 335: PUSH
 336: EMPTY
 337: LIST
 338: DIFF
 339: PUSH
 340: LD_INT 0
 342: PLUS
 343: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
 344: LD_ADDR_EXP 38
 348: PUSH
 349: LD_EXP 41
 353: PUSH
 354: LD_INT 0
 356: PUSH
 357: EMPTY
 358: LIST
 359: DIFF
 360: PUSH
 361: LD_INT 0
 363: PLUS
 364: ST_TO_ADDR
// if MultiPlayer then
 365: LD_OWVAR 4
 369: IFFALSE 568
// begin def_sheherezade_speed = GetMultiplayerSetting ( 0 ) ;
 371: LD_ADDR_EXP 2
 375: PUSH
 376: LD_INT 0
 378: PPUSH
 379: CALL_OW 426
 383: ST_TO_ADDR
// def_sheherezade_stamina = GetMultiplayerSetting ( 1 ) ;
 384: LD_ADDR_EXP 3
 388: PUSH
 389: LD_INT 1
 391: PPUSH
 392: CALL_OW 426
 396: ST_TO_ADDR
// def_sheherezade_skills = GetMultiplayerSetting ( 2 ) ;
 397: LD_ADDR_EXP 4
 401: PUSH
 402: LD_INT 2
 404: PPUSH
 405: CALL_OW 426
 409: ST_TO_ADDR
// def_number_of_sheikhs = GetMultiplayerSetting ( 3 ) ;
 410: LD_ADDR_EXP 5
 414: PUSH
 415: LD_INT 3
 417: PPUSH
 418: CALL_OW 426
 422: ST_TO_ADDR
// def_sheikhs_level = GetMultiplayerSetting ( 4 ) ;
 423: LD_ADDR_EXP 6
 427: PUSH
 428: LD_INT 4
 430: PPUSH
 431: CALL_OW 426
 435: ST_TO_ADDR
// def_number_of_soldiers = GetMultiplayerSetting ( 5 ) ;
 436: LD_ADDR_EXP 7
 440: PUSH
 441: LD_INT 5
 443: PPUSH
 444: CALL_OW 426
 448: ST_TO_ADDR
// def_soldiers_level = GetMultiplayerSetting ( 6 ) ;
 449: LD_ADDR_EXP 8
 453: PUSH
 454: LD_INT 6
 456: PPUSH
 457: CALL_OW 426
 461: ST_TO_ADDR
// def_charges_allowed = GetMultiplayerSetting ( 7 ) ;
 462: LD_ADDR_EXP 9
 466: PUSH
 467: LD_INT 7
 469: PPUSH
 470: CALL_OW 426
 474: ST_TO_ADDR
// def_amount_of_apemen = GetMultiplayerSetting ( 8 ) ;
 475: LD_ADDR_EXP 10
 479: PUSH
 480: LD_INT 8
 482: PPUSH
 483: CALL_OW 426
 487: ST_TO_ADDR
// def_apemen_level = GetMultiplayerSetting ( 9 ) ;
 488: LD_ADDR_EXP 11
 492: PUSH
 493: LD_INT 9
 495: PPUSH
 496: CALL_OW 426
 500: ST_TO_ADDR
// def_apemen_abilities = GetMultiplayerSetting ( 10 ) ;
 501: LD_ADDR_EXP 12
 505: PUSH
 506: LD_INT 10
 508: PPUSH
 509: CALL_OW 426
 513: ST_TO_ADDR
// def_number_of_mastodons = GetMultiplayerSetting ( 11 ) ;
 514: LD_ADDR_EXP 13
 518: PUSH
 519: LD_INT 11
 521: PPUSH
 522: CALL_OW 426
 526: ST_TO_ADDR
// def_number_of_tigers = GetMultiplayerSetting ( 12 ) ;
 527: LD_ADDR_EXP 14
 531: PUSH
 532: LD_INT 12
 534: PPUSH
 535: CALL_OW 426
 539: ST_TO_ADDR
// def_time_to_prepare = GetMultiplayerSetting ( 13 ) ;
 540: LD_ADDR_EXP 15
 544: PUSH
 545: LD_INT 13
 547: PPUSH
 548: CALL_OW 426
 552: ST_TO_ADDR
// def_flags = GetMultiplayerSetting ( 14 ) ;
 553: LD_ADDR_EXP 16
 557: PUSH
 558: LD_INT 14
 560: PPUSH
 561: CALL_OW 426
 565: ST_TO_ADDR
// end else
 566: GO 696
// begin randomize ;
 568: CALL_OW 10
// randomizeAll ;
 572: CALL_OW 11
// def_sheherezade_speed = 1 ;
 576: LD_ADDR_EXP 2
 580: PUSH
 581: LD_INT 1
 583: ST_TO_ADDR
// def_sheherezade_stamina = 1 ;
 584: LD_ADDR_EXP 3
 588: PUSH
 589: LD_INT 1
 591: ST_TO_ADDR
// def_sheherezade_skills = 2 ;
 592: LD_ADDR_EXP 4
 596: PUSH
 597: LD_INT 2
 599: ST_TO_ADDR
// def_number_of_sheikhs = 3 ;
 600: LD_ADDR_EXP 5
 604: PUSH
 605: LD_INT 3
 607: ST_TO_ADDR
// def_sheikhs_level = 2 ;
 608: LD_ADDR_EXP 6
 612: PUSH
 613: LD_INT 2
 615: ST_TO_ADDR
// def_number_of_soldiers = 3 ;
 616: LD_ADDR_EXP 7
 620: PUSH
 621: LD_INT 3
 623: ST_TO_ADDR
// def_soldiers_level = 1 ;
 624: LD_ADDR_EXP 8
 628: PUSH
 629: LD_INT 1
 631: ST_TO_ADDR
// def_charges_allowed = 3 ;
 632: LD_ADDR_EXP 9
 636: PUSH
 637: LD_INT 3
 639: ST_TO_ADDR
// def_amount_of_apemen = 2 ;
 640: LD_ADDR_EXP 10
 644: PUSH
 645: LD_INT 2
 647: ST_TO_ADDR
// def_apemen_level = 1 ;
 648: LD_ADDR_EXP 11
 652: PUSH
 653: LD_INT 1
 655: ST_TO_ADDR
// def_apemen_abilities = 1 ;
 656: LD_ADDR_EXP 12
 660: PUSH
 661: LD_INT 1
 663: ST_TO_ADDR
// def_number_of_mastodons = 2 ;
 664: LD_ADDR_EXP 13
 668: PUSH
 669: LD_INT 2
 671: ST_TO_ADDR
// def_number_of_tigers = 2 ;
 672: LD_ADDR_EXP 14
 676: PUSH
 677: LD_INT 2
 679: ST_TO_ADDR
// def_time_to_prepare = 2 ;
 680: LD_ADDR_EXP 15
 684: PUSH
 685: LD_INT 2
 687: ST_TO_ADDR
// def_flags = 2 ;
 688: LD_ADDR_EXP 16
 692: PUSH
 693: LD_INT 2
 695: ST_TO_ADDR
// end ; shzd_speed = [ 9 , 12 , 15 ] [ def_sheherezade_speed + 1 ] ;
 696: LD_ADDR_EXP 17
 700: PUSH
 701: LD_INT 9
 703: PUSH
 704: LD_INT 12
 706: PUSH
 707: LD_INT 15
 709: PUSH
 710: EMPTY
 711: LIST
 712: LIST
 713: LIST
 714: PUSH
 715: LD_EXP 2
 719: PUSH
 720: LD_INT 1
 722: PLUS
 723: ARRAY
 724: ST_TO_ADDR
// shzd_stamina = [ 6 , 10 , 15 ] [ def_sheherezade_stamina + 1 ] ;
 725: LD_ADDR_EXP 18
 729: PUSH
 730: LD_INT 6
 732: PUSH
 733: LD_INT 10
 735: PUSH
 736: LD_INT 15
 738: PUSH
 739: EMPTY
 740: LIST
 741: LIST
 742: LIST
 743: PUSH
 744: LD_EXP 3
 748: PUSH
 749: LD_INT 1
 751: PLUS
 752: ARRAY
 753: ST_TO_ADDR
// shzd_skills = [ [ 1 , 0 , 0 , 3 ] , [ 2 , 0 , 0 , 5 ] , [ 3 , 0 , 0 , 7 ] ] [ def_sheherezade_skills + 1 ] ;
 754: LD_ADDR_EXP 19
 758: PUSH
 759: LD_INT 1
 761: PUSH
 762: LD_INT 0
 764: PUSH
 765: LD_INT 0
 767: PUSH
 768: LD_INT 3
 770: PUSH
 771: EMPTY
 772: LIST
 773: LIST
 774: LIST
 775: LIST
 776: PUSH
 777: LD_INT 2
 779: PUSH
 780: LD_INT 0
 782: PUSH
 783: LD_INT 0
 785: PUSH
 786: LD_INT 5
 788: PUSH
 789: EMPTY
 790: LIST
 791: LIST
 792: LIST
 793: LIST
 794: PUSH
 795: LD_INT 3
 797: PUSH
 798: LD_INT 0
 800: PUSH
 801: LD_INT 0
 803: PUSH
 804: LD_INT 7
 806: PUSH
 807: EMPTY
 808: LIST
 809: LIST
 810: LIST
 811: LIST
 812: PUSH
 813: EMPTY
 814: LIST
 815: LIST
 816: LIST
 817: PUSH
 818: LD_EXP 4
 822: PUSH
 823: LD_INT 1
 825: PLUS
 826: ARRAY
 827: ST_TO_ADDR
// nsh = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_sheikhs + 1 ] ;
 828: LD_ADDR_EXP 20
 832: PUSH
 833: LD_INT 0
 835: PUSH
 836: LD_INT 1
 838: PUSH
 839: LD_INT 2
 841: PUSH
 842: LD_INT 3
 844: PUSH
 845: LD_INT 4
 847: PUSH
 848: LD_INT 5
 850: PUSH
 851: EMPTY
 852: LIST
 853: LIST
 854: LIST
 855: LIST
 856: LIST
 857: LIST
 858: PUSH
 859: LD_EXP 5
 863: PUSH
 864: LD_INT 1
 866: PLUS
 867: ARRAY
 868: ST_TO_ADDR
// sh_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_sheikhs_level + 1 ] ;
 869: LD_ADDR_EXP 21
 873: PUSH
 874: LD_INT 2
 876: PUSH
 877: LD_INT 1
 879: PUSH
 880: LD_INT 1
 882: PUSH
 883: LD_INT 1
 885: PUSH
 886: EMPTY
 887: LIST
 888: LIST
 889: LIST
 890: LIST
 891: PUSH
 892: LD_INT 4
 894: PUSH
 895: LD_INT 2
 897: PUSH
 898: LD_INT 2
 900: PUSH
 901: LD_INT 2
 903: PUSH
 904: EMPTY
 905: LIST
 906: LIST
 907: LIST
 908: LIST
 909: PUSH
 910: LD_INT 6
 912: PUSH
 913: LD_INT 3
 915: PUSH
 916: LD_INT 3
 918: PUSH
 919: LD_INT 3
 921: PUSH
 922: EMPTY
 923: LIST
 924: LIST
 925: LIST
 926: LIST
 927: PUSH
 928: EMPTY
 929: LIST
 930: LIST
 931: LIST
 932: PUSH
 933: LD_EXP 6
 937: PUSH
 938: LD_INT 1
 940: PLUS
 941: ARRAY
 942: ST_TO_ADDR
// nsol = [ 0 , 1 , 2 , 3 , 4 , 5 ] [ def_number_of_soldiers + 1 ] ;
 943: LD_ADDR_EXP 22
 947: PUSH
 948: LD_INT 0
 950: PUSH
 951: LD_INT 1
 953: PUSH
 954: LD_INT 2
 956: PUSH
 957: LD_INT 3
 959: PUSH
 960: LD_INT 4
 962: PUSH
 963: LD_INT 5
 965: PUSH
 966: EMPTY
 967: LIST
 968: LIST
 969: LIST
 970: LIST
 971: LIST
 972: LIST
 973: PUSH
 974: LD_EXP 7
 978: PUSH
 979: LD_INT 1
 981: PLUS
 982: ARRAY
 983: ST_TO_ADDR
// sol_skills = [ [ 2 , 1 , 1 , 1 ] , [ 4 , 2 , 2 , 2 ] , [ 6 , 3 , 3 , 3 ] ] [ def_soldiers_level + 1 ] ;
 984: LD_ADDR_EXP 23
 988: PUSH
 989: LD_INT 2
 991: PUSH
 992: LD_INT 1
 994: PUSH
 995: LD_INT 1
 997: PUSH
 998: LD_INT 1
1000: PUSH
1001: EMPTY
1002: LIST
1003: LIST
1004: LIST
1005: LIST
1006: PUSH
1007: LD_INT 4
1009: PUSH
1010: LD_INT 2
1012: PUSH
1013: LD_INT 2
1015: PUSH
1016: LD_INT 2
1018: PUSH
1019: EMPTY
1020: LIST
1021: LIST
1022: LIST
1023: LIST
1024: PUSH
1025: LD_INT 6
1027: PUSH
1028: LD_INT 3
1030: PUSH
1031: LD_INT 3
1033: PUSH
1034: LD_INT 3
1036: PUSH
1037: EMPTY
1038: LIST
1039: LIST
1040: LIST
1041: LIST
1042: PUSH
1043: EMPTY
1044: LIST
1045: LIST
1046: LIST
1047: PUSH
1048: LD_EXP 8
1052: PUSH
1053: LD_INT 1
1055: PLUS
1056: ARRAY
1057: ST_TO_ADDR
// nstart_ape = [ 0 , 2 , 4 , 6 , 8 ] [ def_amount_of_apemen + 1 ] ;
1058: LD_ADDR_EXP 24
1062: PUSH
1063: LD_INT 0
1065: PUSH
1066: LD_INT 2
1068: PUSH
1069: LD_INT 4
1071: PUSH
1072: LD_INT 6
1074: PUSH
1075: LD_INT 8
1077: PUSH
1078: EMPTY
1079: LIST
1080: LIST
1081: LIST
1082: LIST
1083: LIST
1084: PUSH
1085: LD_EXP 10
1089: PUSH
1090: LD_INT 1
1092: PLUS
1093: ARRAY
1094: ST_TO_ADDR
// ape_respawning = [ 0 , 4 4$00 , 2 2$00 , 1 1$00 , 0 0$30 ] [ def_amount_of_apemen + 1 ] ;
1095: LD_ADDR_EXP 25
1099: PUSH
1100: LD_INT 0
1102: PUSH
1103: LD_INT 8400
1105: PUSH
1106: LD_INT 4200
1108: PUSH
1109: LD_INT 2100
1111: PUSH
1112: LD_INT 1050
1114: PUSH
1115: EMPTY
1116: LIST
1117: LIST
1118: LIST
1119: LIST
1120: LIST
1121: PUSH
1122: LD_EXP 10
1126: PUSH
1127: LD_INT 1
1129: PLUS
1130: ARRAY
1131: ST_TO_ADDR
// ape_skills = [ [ 1 , 0 , 0 , 0 ] , [ 3 , 0 , 0 , 0 ] , [ 5 , 0 , 0 , 0 ] ] [ def_apemen_level + 1 ] ;
1132: LD_ADDR_EXP 26
1136: PUSH
1137: LD_INT 1
1139: PUSH
1140: LD_INT 0
1142: PUSH
1143: LD_INT 0
1145: PUSH
1146: LD_INT 0
1148: PUSH
1149: EMPTY
1150: LIST
1151: LIST
1152: LIST
1153: LIST
1154: PUSH
1155: LD_INT 3
1157: PUSH
1158: LD_INT 0
1160: PUSH
1161: LD_INT 0
1163: PUSH
1164: LD_INT 0
1166: PUSH
1167: EMPTY
1168: LIST
1169: LIST
1170: LIST
1171: LIST
1172: PUSH
1173: LD_INT 5
1175: PUSH
1176: LD_INT 0
1178: PUSH
1179: LD_INT 0
1181: PUSH
1182: LD_INT 0
1184: PUSH
1185: EMPTY
1186: LIST
1187: LIST
1188: LIST
1189: LIST
1190: PUSH
1191: EMPTY
1192: LIST
1193: LIST
1194: LIST
1195: PUSH
1196: LD_EXP 11
1200: PUSH
1201: LD_INT 1
1203: PLUS
1204: ARRAY
1205: ST_TO_ADDR
// nmast1 = [ 0 , 2 , 4 , 6 ] [ def_number_of_mastodons + 1 ] ;
1206: LD_ADDR_EXP 27
1210: PUSH
1211: LD_INT 0
1213: PUSH
1214: LD_INT 2
1216: PUSH
1217: LD_INT 4
1219: PUSH
1220: LD_INT 6
1222: PUSH
1223: EMPTY
1224: LIST
1225: LIST
1226: LIST
1227: LIST
1228: PUSH
1229: LD_EXP 13
1233: PUSH
1234: LD_INT 1
1236: PLUS
1237: ARRAY
1238: ST_TO_ADDR
// nmast2 = [ 0 , 1 , 2 , 3 ] [ def_number_of_mastodons + 1 ] ;
1239: LD_ADDR_EXP 28
1243: PUSH
1244: LD_INT 0
1246: PUSH
1247: LD_INT 1
1249: PUSH
1250: LD_INT 2
1252: PUSH
1253: LD_INT 3
1255: PUSH
1256: EMPTY
1257: LIST
1258: LIST
1259: LIST
1260: LIST
1261: PUSH
1262: LD_EXP 13
1266: PUSH
1267: LD_INT 1
1269: PLUS
1270: ARRAY
1271: ST_TO_ADDR
// nmast3 = [ 0 , 15 , 30 , 45 ] [ def_number_of_mastodons + 1 ] ;
1272: LD_ADDR_EXP 29
1276: PUSH
1277: LD_INT 0
1279: PUSH
1280: LD_INT 15
1282: PUSH
1283: LD_INT 30
1285: PUSH
1286: LD_INT 45
1288: PUSH
1289: EMPTY
1290: LIST
1291: LIST
1292: LIST
1293: LIST
1294: PUSH
1295: LD_EXP 13
1299: PUSH
1300: LD_INT 1
1302: PLUS
1303: ARRAY
1304: ST_TO_ADDR
// ntig = [ 0 , 1 , 3 , 5 ] [ def_number_of_tigers + 1 ] ;
1305: LD_ADDR_EXP 30
1309: PUSH
1310: LD_INT 0
1312: PUSH
1313: LD_INT 1
1315: PUSH
1316: LD_INT 3
1318: PUSH
1319: LD_INT 5
1321: PUSH
1322: EMPTY
1323: LIST
1324: LIST
1325: LIST
1326: LIST
1327: PUSH
1328: LD_EXP 14
1332: PUSH
1333: LD_INT 1
1335: PLUS
1336: ARRAY
1337: ST_TO_ADDR
// tig_respawning = [ 0 , 8 8$00 , 4 4$00 , 2 2$00 ] [ def_number_of_tigers + 1 ] ;
1338: LD_ADDR_EXP 31
1342: PUSH
1343: LD_INT 0
1345: PUSH
1346: LD_INT 16800
1348: PUSH
1349: LD_INT 8400
1351: PUSH
1352: LD_INT 4200
1354: PUSH
1355: EMPTY
1356: LIST
1357: LIST
1358: LIST
1359: LIST
1360: PUSH
1361: LD_EXP 14
1365: PUSH
1366: LD_INT 1
1368: PLUS
1369: ARRAY
1370: ST_TO_ADDR
// prep_time = [ 0 , 0 0$20 , 0 0$40 , 1 1$20 ] [ def_time_to_prepare + 1 ] ;
1371: LD_ADDR_EXP 32
1375: PUSH
1376: LD_INT 0
1378: PUSH
1379: LD_INT 700
1381: PUSH
1382: LD_INT 1400
1384: PUSH
1385: LD_INT 2800
1387: PUSH
1388: EMPTY
1389: LIST
1390: LIST
1391: LIST
1392: LIST
1393: PUSH
1394: LD_EXP 15
1398: PUSH
1399: LD_INT 1
1401: PLUS
1402: ARRAY
1403: ST_TO_ADDR
// flags = [ 0 , 25 , 50 , 75 ] [ def_flags + 1 ] ;
1404: LD_ADDR_EXP 33
1408: PUSH
1409: LD_INT 0
1411: PUSH
1412: LD_INT 25
1414: PUSH
1415: LD_INT 50
1417: PUSH
1418: LD_INT 75
1420: PUSH
1421: EMPTY
1422: LIST
1423: LIST
1424: LIST
1425: LIST
1426: PUSH
1427: LD_EXP 16
1431: PUSH
1432: LD_INT 1
1434: PLUS
1435: ARRAY
1436: ST_TO_ADDR
// if def_charges_allowed in [ 1 , 3 ] then
1437: LD_EXP 9
1441: PUSH
1442: LD_INT 1
1444: PUSH
1445: LD_INT 3
1447: PUSH
1448: EMPTY
1449: LIST
1450: LIST
1451: IN
1452: IFFALSE 1489
// for i := 1 to 8 do
1454: LD_ADDR_VAR 0 2
1458: PUSH
1459: DOUBLE
1460: LD_INT 1
1462: DEC
1463: ST_TO_ADDR
1464: LD_INT 8
1466: PUSH
1467: FOR_TO
1468: IFFALSE 1487
// SetTech ( tech_RemCharge , i , state_researched ) ;
1470: LD_INT 18
1472: PPUSH
1473: LD_VAR 0 2
1477: PPUSH
1478: LD_INT 2
1480: PPUSH
1481: CALL_OW 322
1485: GO 1467
1487: POP
1488: POP
// if def_charges_allowed in [ 1 , 3 ] then
1489: LD_EXP 9
1493: PUSH
1494: LD_INT 1
1496: PUSH
1497: LD_INT 3
1499: PUSH
1500: EMPTY
1501: LIST
1502: LIST
1503: IN
1504: IFFALSE 1541
// for i := 1 to 8 do
1506: LD_ADDR_VAR 0 2
1510: PUSH
1511: DOUBLE
1512: LD_INT 1
1514: DEC
1515: ST_TO_ADDR
1516: LD_INT 8
1518: PUSH
1519: FOR_TO
1520: IFFALSE 1539
// SetTech ( tech_Explos , i , state_researched ) ;
1522: LD_INT 42
1524: PPUSH
1525: LD_VAR 0 2
1529: PPUSH
1530: LD_INT 2
1532: PPUSH
1533: CALL_OW 322
1537: GO 1519
1539: POP
1540: POP
// for i := 1 to 8 do
1541: LD_ADDR_VAR 0 2
1545: PUSH
1546: DOUBLE
1547: LD_INT 1
1549: DEC
1550: ST_TO_ADDR
1551: LD_INT 8
1553: PUSH
1554: FOR_TO
1555: IFFALSE 1589
// begin SetTech ( tech_ApeLang , i , state_disabled ) ;
1557: LD_INT 1
1559: PPUSH
1560: LD_VAR 0 2
1564: PPUSH
1565: LD_INT 0
1567: PPUSH
1568: CALL_OW 322
// SetTech ( tech_SibContam , i , state_disabled ) ;
1572: LD_INT 26
1574: PPUSH
1575: LD_VAR 0 2
1579: PPUSH
1580: LD_INT 0
1582: PPUSH
1583: CALL_OW 322
// end ;
1587: GO 1554
1589: POP
1590: POP
// end ;
1591: LD_VAR 0 1
1595: RET
// function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
1596: LD_INT 0
1598: PPUSH
1599: PPUSH
1600: PPUSH
1601: PPUSH
1602: PPUSH
1603: PPUSH
1604: PPUSH
1605: PPUSH
// best = 0 ;
1606: LD_ADDR_VAR 0 2
1610: PUSH
1611: LD_INT 0
1613: ST_TO_ADDR
// for n = 1 to 400 do
1614: LD_ADDR_VAR 0 8
1618: PUSH
1619: DOUBLE
1620: LD_INT 1
1622: DEC
1623: ST_TO_ADDR
1624: LD_INT 400
1626: PUSH
1627: FOR_TO
1628: IFFALSE 1924
// begin c = [ ] ;
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: EMPTY
1636: ST_TO_ADDR
// for i = 1 to side_count do
1637: LD_ADDR_VAR 0 6
1641: PUSH
1642: DOUBLE
1643: LD_INT 1
1645: DEC
1646: ST_TO_ADDR
1647: LD_EXP 37
1651: PUSH
1652: FOR_TO
1653: IFFALSE 1682
// c := c ^ [ RandHexArea ( arstart , false ) ] ;
1655: LD_ADDR_VAR 0 3
1659: PUSH
1660: LD_VAR 0 3
1664: PUSH
1665: LD_INT 4
1667: PPUSH
1668: LD_INT 0
1670: PPUSH
1671: CALL_OW 16
1675: PUSH
1676: EMPTY
1677: LIST
1678: ADD
1679: ST_TO_ADDR
1680: GO 1652
1682: POP
1683: POP
// minv = 10000 ;
1684: LD_ADDR_VAR 0 5
1688: PUSH
1689: LD_INT 10000
1691: ST_TO_ADDR
// for i = 1 to side_count do
1692: LD_ADDR_VAR 0 6
1696: PUSH
1697: DOUBLE
1698: LD_INT 1
1700: DEC
1701: ST_TO_ADDR
1702: LD_EXP 37
1706: PUSH
1707: FOR_TO
1708: IFFALSE 1888
// for j = 1 to side_count do
1710: LD_ADDR_VAR 0 7
1714: PUSH
1715: DOUBLE
1716: LD_INT 1
1718: DEC
1719: ST_TO_ADDR
1720: LD_EXP 37
1724: PUSH
1725: FOR_TO
1726: IFFALSE 1884
// if i <> j then
1728: LD_VAR 0 6
1732: PUSH
1733: LD_VAR 0 7
1737: NONEQUAL
1738: IFFALSE 1882
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
1740: LD_VAR 0 3
1744: PUSH
1745: LD_VAR 0 6
1749: ARRAY
1750: PUSH
1751: LD_INT 1
1753: ARRAY
1754: PPUSH
1755: LD_VAR 0 3
1759: PUSH
1760: LD_VAR 0 6
1764: ARRAY
1765: PUSH
1766: LD_INT 2
1768: ARRAY
1769: PPUSH
1770: LD_VAR 0 3
1774: PUSH
1775: LD_VAR 0 7
1779: ARRAY
1780: PUSH
1781: LD_INT 1
1783: ARRAY
1784: PPUSH
1785: LD_VAR 0 3
1789: PUSH
1790: LD_VAR 0 7
1794: ARRAY
1795: PUSH
1796: LD_INT 2
1798: ARRAY
1799: PPUSH
1800: CALL_OW 298
1804: PUSH
1805: LD_VAR 0 5
1809: LESS
1810: IFFALSE 1882
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
1812: LD_ADDR_VAR 0 5
1816: PUSH
1817: LD_VAR 0 3
1821: PUSH
1822: LD_VAR 0 6
1826: ARRAY
1827: PUSH
1828: LD_INT 1
1830: ARRAY
1831: PPUSH
1832: LD_VAR 0 3
1836: PUSH
1837: LD_VAR 0 6
1841: ARRAY
1842: PUSH
1843: LD_INT 2
1845: ARRAY
1846: PPUSH
1847: LD_VAR 0 3
1851: PUSH
1852: LD_VAR 0 7
1856: ARRAY
1857: PUSH
1858: LD_INT 1
1860: ARRAY
1861: PPUSH
1862: LD_VAR 0 3
1866: PUSH
1867: LD_VAR 0 7
1871: ARRAY
1872: PUSH
1873: LD_INT 2
1875: ARRAY
1876: PPUSH
1877: CALL_OW 298
1881: ST_TO_ADDR
// end ;
1882: GO 1725
1884: POP
1885: POP
1886: GO 1707
1888: POP
1889: POP
// if minv > best then
1890: LD_VAR 0 5
1894: PUSH
1895: LD_VAR 0 2
1899: GREATER
1900: IFFALSE 1922
// begin best := minv ;
1902: LD_ADDR_VAR 0 2
1906: PUSH
1907: LD_VAR 0 5
1911: ST_TO_ADDR
// bestc := c ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: LD_VAR 0 3
1921: ST_TO_ADDR
// end ; end ;
1922: GO 1627
1924: POP
1925: POP
// coordinates := [ ] ;
1926: LD_ADDR_EXP 34
1930: PUSH
1931: EMPTY
1932: ST_TO_ADDR
// for i = 1 to 8 do
1933: LD_ADDR_VAR 0 6
1937: PUSH
1938: DOUBLE
1939: LD_INT 1
1941: DEC
1942: ST_TO_ADDR
1943: LD_INT 8
1945: PUSH
1946: FOR_TO
1947: IFFALSE 2034
// if side_positions [ i ] = 0 then
1949: LD_EXP 43
1953: PUSH
1954: LD_VAR 0 6
1958: ARRAY
1959: PUSH
1960: LD_INT 0
1962: EQUAL
1963: IFFALSE 1991
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
1965: LD_ADDR_EXP 34
1969: PUSH
1970: LD_EXP 34
1974: PUSH
1975: LD_INT 0
1977: PUSH
1978: LD_INT 0
1980: PUSH
1981: EMPTY
1982: LIST
1983: LIST
1984: PUSH
1985: EMPTY
1986: LIST
1987: ADD
1988: ST_TO_ADDR
1989: GO 2032
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
1991: LD_ADDR_EXP 34
1995: PUSH
1996: LD_EXP 34
2000: PUSH
2001: LD_VAR 0 4
2005: PUSH
2006: LD_INT 1
2008: ARRAY
2009: PUSH
2010: EMPTY
2011: LIST
2012: ADD
2013: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
2014: LD_ADDR_VAR 0 4
2018: PUSH
2019: LD_VAR 0 4
2023: PPUSH
2024: LD_INT 1
2026: PPUSH
2027: CALL_OW 3
2031: ST_TO_ADDR
// end ;
2032: GO 1946
2034: POP
2035: POP
// end ;
2036: LD_VAR 0 1
2040: RET
// function set_attitudes ; var i , j ; begin
2041: LD_INT 0
2043: PPUSH
2044: PPUSH
2045: PPUSH
// if not Team_Game then
2046: LD_EXP 47
2050: NOT
2051: IFFALSE 2147
// begin for i = 1 to 8 do
2053: LD_ADDR_VAR 0 2
2057: PUSH
2058: DOUBLE
2059: LD_INT 1
2061: DEC
2062: ST_TO_ADDR
2063: LD_INT 8
2065: PUSH
2066: FOR_TO
2067: IFFALSE 2145
// for j = 1 to 8 do
2069: LD_ADDR_VAR 0 3
2073: PUSH
2074: DOUBLE
2075: LD_INT 1
2077: DEC
2078: ST_TO_ADDR
2079: LD_INT 8
2081: PUSH
2082: FOR_TO
2083: IFFALSE 2141
// if i <> j then
2085: LD_VAR 0 2
2089: PUSH
2090: LD_VAR 0 3
2094: NONEQUAL
2095: IFFALSE 2119
// SetAttitude ( i , j , att_neutral , true ) else
2097: LD_VAR 0 2
2101: PPUSH
2102: LD_VAR 0 3
2106: PPUSH
2107: LD_INT 0
2109: PPUSH
2110: LD_INT 1
2112: PPUSH
2113: CALL_OW 80
2117: GO 2139
// SetAttitude ( i , j , att_friend , true ) end ;
2119: LD_VAR 0 2
2123: PPUSH
2124: LD_VAR 0 3
2128: PPUSH
2129: LD_INT 1
2131: PPUSH
2132: LD_INT 1
2134: PPUSH
2135: CALL_OW 80
2139: GO 2082
2141: POP
2142: POP
2143: GO 2066
2145: POP
2146: POP
// end ;
2147: LD_VAR 0 1
2151: RET
// function create_sheherezade ( side ) ; var s ; begin
2152: LD_INT 0
2154: PPUSH
2155: PPUSH
// uc_side := side ;
2156: LD_ADDR_OWVAR 20
2160: PUSH
2161: LD_VAR 0 1
2165: ST_TO_ADDR
// uc_nation := nation_arabian ;
2166: LD_ADDR_OWVAR 21
2170: PUSH
2171: LD_INT 2
2173: ST_TO_ADDR
// hc_name = Sheherezade ;
2174: LD_ADDR_OWVAR 26
2178: PUSH
2179: LD_STRING Sheherezade
2181: ST_TO_ADDR
// hc_sex = sex_female ;
2182: LD_ADDR_OWVAR 27
2186: PUSH
2187: LD_INT 2
2189: ST_TO_ADDR
// hc_class = class_scientistic ;
2190: LD_ADDR_OWVAR 28
2194: PUSH
2195: LD_INT 4
2197: ST_TO_ADDR
// hc_basic_skills = shzd_skills ;
2198: LD_ADDR_OWVAR 30
2202: PUSH
2203: LD_EXP 19
2207: ST_TO_ADDR
// hc_skills = shzd_skills ;
2208: LD_ADDR_OWVAR 31
2212: PUSH
2213: LD_EXP 19
2217: ST_TO_ADDR
// hc_attr = [ shzd_stamina , shzd_speed ] ;
2218: LD_ADDR_OWVAR 29
2222: PUSH
2223: LD_EXP 18
2227: PUSH
2228: LD_EXP 17
2232: PUSH
2233: EMPTY
2234: LIST
2235: LIST
2236: ST_TO_ADDR
// hc_gallery = multi ;
2237: LD_ADDR_OWVAR 33
2241: PUSH
2242: LD_STRING multi
2244: ST_TO_ADDR
// hc_face_number = 18 ;
2245: LD_ADDR_OWVAR 34
2249: PUSH
2250: LD_INT 18
2252: ST_TO_ADDR
// hc_importance = 105 ;
2253: LD_ADDR_OWVAR 32
2257: PUSH
2258: LD_INT 105
2260: ST_TO_ADDR
// s = CreateHuman ;
2261: LD_ADDR_VAR 0 3
2265: PUSH
2266: CALL_OW 44
2270: ST_TO_ADDR
// PlaceUnitXYR ( s , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 1 , false ) ;
2271: LD_VAR 0 3
2275: PPUSH
2276: LD_EXP 34
2280: PUSH
2281: LD_VAR 0 1
2285: ARRAY
2286: PUSH
2287: LD_INT 1
2289: ARRAY
2290: PPUSH
2291: LD_EXP 34
2295: PUSH
2296: LD_VAR 0 1
2300: ARRAY
2301: PUSH
2302: LD_INT 2
2304: ARRAY
2305: PPUSH
2306: LD_INT 1
2308: PPUSH
2309: LD_INT 0
2311: PPUSH
2312: CALL_OW 50
// sheherezades = Replace ( sheherezades , side , s ) ;
2316: LD_ADDR_EXP 35
2320: PUSH
2321: LD_EXP 35
2325: PPUSH
2326: LD_VAR 0 1
2330: PPUSH
2331: LD_VAR 0 3
2335: PPUSH
2336: CALL_OW 1
2340: ST_TO_ADDR
// end ;
2341: LD_VAR 0 2
2345: RET
// function prepare_sides ; var i ; begin
2346: LD_INT 0
2348: PPUSH
2349: PPUSH
// for i := 1 to 8 do
2350: LD_ADDR_VAR 0 2
2354: PUSH
2355: DOUBLE
2356: LD_INT 1
2358: DEC
2359: ST_TO_ADDR
2360: LD_INT 8
2362: PUSH
2363: FOR_TO
2364: IFFALSE 2389
// if side_positions [ i ] then
2366: LD_EXP 43
2370: PUSH
2371: LD_VAR 0 2
2375: ARRAY
2376: IFFALSE 2387
// create_sheherezade ( i ) ;
2378: LD_VAR 0 2
2382: PPUSH
2383: CALL 2152 0 1
2387: GO 2363
2389: POP
2390: POP
// if prep_time = 0 then
2391: LD_EXP 32
2395: PUSH
2396: LD_INT 0
2398: EQUAL
2399: IFFALSE 2405
// sheherezade_start_the_fight ;
2401: CALL 3720 0 0
// end ;
2405: LD_VAR 0 1
2409: RET
// function prepare_side_to_the_fight ( side , materialization ) ; var x , y , i , sh , sol ; begin
2410: LD_INT 0
2412: PPUSH
2413: PPUSH
2414: PPUSH
2415: PPUSH
2416: PPUSH
2417: PPUSH
// SetTech ( tech_ApeLang , side , state_researched ) ;
2418: LD_INT 1
2420: PPUSH
2421: LD_VAR 0 1
2425: PPUSH
2426: LD_INT 2
2428: PPUSH
2429: CALL_OW 322
// x := GetX ( Sheherezades [ side ] ) ;
2433: LD_ADDR_VAR 0 4
2437: PUSH
2438: LD_EXP 35
2442: PUSH
2443: LD_VAR 0 1
2447: ARRAY
2448: PPUSH
2449: CALL_OW 250
2453: ST_TO_ADDR
// y := GetY ( Sheherezades [ side ] ) ;
2454: LD_ADDR_VAR 0 5
2458: PUSH
2459: LD_EXP 35
2463: PUSH
2464: LD_VAR 0 1
2468: ARRAY
2469: PPUSH
2470: CALL_OW 251
2474: ST_TO_ADDR
// coordinates := Replace ( coordinates , side , [ x , y ] ) ;
2475: LD_ADDR_EXP 34
2479: PUSH
2480: LD_EXP 34
2484: PPUSH
2485: LD_VAR 0 1
2489: PPUSH
2490: LD_VAR 0 4
2494: PUSH
2495: LD_VAR 0 5
2499: PUSH
2500: EMPTY
2501: LIST
2502: LIST
2503: PPUSH
2504: CALL_OW 1
2508: ST_TO_ADDR
// if flags then
2509: LD_EXP 33
2513: IFFALSE 2592
// begin SetBattleFlag ( side , x , y , [ [ bfo_defend_bonus_human , flags ] , [ bfo_defend_bonus_vehicle , flags ] , [ bfo_defend_bonus_building , flags ] , [ bfo_height , flags + 25 ] ] ) ;
2515: LD_VAR 0 1
2519: PPUSH
2520: LD_VAR 0 4
2524: PPUSH
2525: LD_VAR 0 5
2529: PPUSH
2530: LD_INT 1
2532: PUSH
2533: LD_EXP 33
2537: PUSH
2538: EMPTY
2539: LIST
2540: LIST
2541: PUSH
2542: LD_INT 2
2544: PUSH
2545: LD_EXP 33
2549: PUSH
2550: EMPTY
2551: LIST
2552: LIST
2553: PUSH
2554: LD_INT 3
2556: PUSH
2557: LD_EXP 33
2561: PUSH
2562: EMPTY
2563: LIST
2564: LIST
2565: PUSH
2566: LD_INT 20
2568: PUSH
2569: LD_EXP 33
2573: PUSH
2574: LD_INT 25
2576: PLUS
2577: PUSH
2578: EMPTY
2579: LIST
2580: LIST
2581: PUSH
2582: EMPTY
2583: LIST
2584: LIST
2585: LIST
2586: LIST
2587: PPUSH
2588: CALL_OW 418
// end ; uc_side := side ;
2592: LD_ADDR_OWVAR 20
2596: PUSH
2597: LD_VAR 0 1
2601: ST_TO_ADDR
// uc_nation := nation_arabian ;
2602: LD_ADDR_OWVAR 21
2606: PUSH
2607: LD_INT 2
2609: ST_TO_ADDR
// hc_name :=  ;
2610: LD_ADDR_OWVAR 26
2614: PUSH
2615: LD_STRING 
2617: ST_TO_ADDR
// hc_class := class_desert_warior ;
2618: LD_ADDR_OWVAR 28
2622: PUSH
2623: LD_INT 11
2625: ST_TO_ADDR
// hc_sex := sex_male ;
2626: LD_ADDR_OWVAR 27
2630: PUSH
2631: LD_INT 1
2633: ST_TO_ADDR
// hc_basic_skills := sh_skills ;
2634: LD_ADDR_OWVAR 30
2638: PUSH
2639: LD_EXP 21
2643: ST_TO_ADDR
// hc_skills := sh_skills ;
2644: LD_ADDR_OWVAR 31
2648: PUSH
2649: LD_EXP 21
2653: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2654: LD_ADDR_OWVAR 29
2658: PUSH
2659: LD_INT 10
2661: PUSH
2662: LD_INT 10
2664: PUSH
2665: EMPTY
2666: LIST
2667: LIST
2668: ST_TO_ADDR
// hc_importance := 0 ;
2669: LD_ADDR_OWVAR 32
2673: PUSH
2674: LD_INT 0
2676: ST_TO_ADDR
// hc_gallery :=  ;
2677: LD_ADDR_OWVAR 33
2681: PUSH
2682: LD_STRING 
2684: ST_TO_ADDR
// for i := 1 to nsol do
2685: LD_ADDR_VAR 0 6
2689: PUSH
2690: DOUBLE
2691: LD_INT 1
2693: DEC
2694: ST_TO_ADDR
2695: LD_EXP 22
2699: PUSH
2700: FOR_TO
2701: IFFALSE 2742
// begin sh := CreateHuman ;
2703: LD_ADDR_VAR 0 7
2707: PUSH
2708: CALL_OW 44
2712: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2713: LD_VAR 0 7
2717: PPUSH
2718: LD_VAR 0 4
2722: PPUSH
2723: LD_VAR 0 5
2727: PPUSH
2728: LD_INT 5
2730: PPUSH
2731: LD_VAR 0 2
2735: PPUSH
2736: CALL_OW 50
// end ;
2740: GO 2700
2742: POP
2743: POP
// hc_name :=  ;
2744: LD_ADDR_OWVAR 26
2748: PUSH
2749: LD_STRING 
2751: ST_TO_ADDR
// hc_class := class_soldier ;
2752: LD_ADDR_OWVAR 28
2756: PUSH
2757: LD_INT 1
2759: ST_TO_ADDR
// hc_sex := sex_male ;
2760: LD_ADDR_OWVAR 27
2764: PUSH
2765: LD_INT 1
2767: ST_TO_ADDR
// hc_basic_skills := sol_skills ;
2768: LD_ADDR_OWVAR 30
2772: PUSH
2773: LD_EXP 23
2777: ST_TO_ADDR
// hc_skills := sol_skills ;
2778: LD_ADDR_OWVAR 31
2782: PUSH
2783: LD_EXP 23
2787: ST_TO_ADDR
// hc_attr := [ 10 , 10 ] ;
2788: LD_ADDR_OWVAR 29
2792: PUSH
2793: LD_INT 10
2795: PUSH
2796: LD_INT 10
2798: PUSH
2799: EMPTY
2800: LIST
2801: LIST
2802: ST_TO_ADDR
// hc_importance := 0 ;
2803: LD_ADDR_OWVAR 32
2807: PUSH
2808: LD_INT 0
2810: ST_TO_ADDR
// hc_gallery :=  ;
2811: LD_ADDR_OWVAR 33
2815: PUSH
2816: LD_STRING 
2818: ST_TO_ADDR
// for i := 1 to nsh do
2819: LD_ADDR_VAR 0 6
2823: PUSH
2824: DOUBLE
2825: LD_INT 1
2827: DEC
2828: ST_TO_ADDR
2829: LD_EXP 20
2833: PUSH
2834: FOR_TO
2835: IFFALSE 2876
// begin sh := CreateHuman ;
2837: LD_ADDR_VAR 0 7
2841: PUSH
2842: CALL_OW 44
2846: ST_TO_ADDR
// PlaceUnitXYR ( sh , x , y , 5 , materialization ) ;
2847: LD_VAR 0 7
2851: PPUSH
2852: LD_VAR 0 4
2856: PPUSH
2857: LD_VAR 0 5
2861: PPUSH
2862: LD_INT 5
2864: PPUSH
2865: LD_VAR 0 2
2869: PPUSH
2870: CALL_OW 50
// end ;
2874: GO 2834
2876: POP
2877: POP
// end ;
2878: LD_VAR 0 3
2882: RET
// function find_hidden_hex ( ar ) ; var i , j , seen ; begin
2883: LD_INT 0
2885: PPUSH
2886: PPUSH
2887: PPUSH
2888: PPUSH
// for i := 1 to 100 do
2889: LD_ADDR_VAR 0 3
2893: PUSH
2894: DOUBLE
2895: LD_INT 1
2897: DEC
2898: ST_TO_ADDR
2899: LD_INT 100
2901: PUSH
2902: FOR_TO
2903: IFFALSE 3026
// begin repeat result := RandHexArea ( ar , false ) ;
2905: LD_ADDR_VAR 0 2
2909: PUSH
2910: LD_VAR 0 1
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 16
2922: ST_TO_ADDR
// until not HexInfo ( result [ 1 ] , result [ 2 ] ) ;
2923: LD_VAR 0 2
2927: PUSH
2928: LD_INT 1
2930: ARRAY
2931: PPUSH
2932: LD_VAR 0 2
2936: PUSH
2937: LD_INT 2
2939: ARRAY
2940: PPUSH
2941: CALL_OW 428
2945: NOT
2946: IFFALSE 2905
// seen := false ;
2948: LD_ADDR_VAR 0 5
2952: PUSH
2953: LD_INT 0
2955: ST_TO_ADDR
// for j := 1 to 8 do
2956: LD_ADDR_VAR 0 4
2960: PUSH
2961: DOUBLE
2962: LD_INT 1
2964: DEC
2965: ST_TO_ADDR
2966: LD_INT 8
2968: PUSH
2969: FOR_TO
2970: IFFALSE 3011
// if SeeXY ( j , result [ 1 ] , result [ 2 ] ) then
2972: LD_VAR 0 4
2976: PPUSH
2977: LD_VAR 0 2
2981: PUSH
2982: LD_INT 1
2984: ARRAY
2985: PPUSH
2986: LD_VAR 0 2
2990: PUSH
2991: LD_INT 2
2993: ARRAY
2994: PPUSH
2995: CALL_OW 293
2999: IFFALSE 3009
// seen := true ;
3001: LD_ADDR_VAR 0 5
3005: PUSH
3006: LD_INT 1
3008: ST_TO_ADDR
3009: GO 2969
3011: POP
3012: POP
// if not seen then
3013: LD_VAR 0 5
3017: NOT
3018: IFFALSE 3024
// exit ;
3020: POP
3021: POP
3022: GO 3036
// end ;
3024: GO 2902
3026: POP
3027: POP
// result := 0 ;
3028: LD_ADDR_VAR 0 2
3032: PUSH
3033: LD_INT 0
3035: ST_TO_ADDR
// end ;
3036: LD_VAR 0 2
3040: RET
// function create_ape ; var coord , i ; begin
3041: LD_INT 0
3043: PPUSH
3044: PPUSH
3045: PPUSH
// if lastunit >= 1999 then
3046: LD_EXP 36
3050: PUSH
3051: LD_INT 1999
3053: GREATEREQUAL
3054: IFFALSE 3058
// exit ;
3056: GO 3225
// uc_nation := nation_nature ;
3058: LD_ADDR_OWVAR 21
3062: PUSH
3063: LD_INT 0
3065: ST_TO_ADDR
// uc_side := 0 ;
3066: LD_ADDR_OWVAR 20
3070: PUSH
3071: LD_INT 0
3073: ST_TO_ADDR
// hc_name :=  ;
3074: LD_ADDR_OWVAR 26
3078: PUSH
3079: LD_STRING 
3081: ST_TO_ADDR
// hc_class := class_apeman ;
3082: LD_ADDR_OWVAR 28
3086: PUSH
3087: LD_INT 12
3089: ST_TO_ADDR
// hc_sex := 1 ;
3090: LD_ADDR_OWVAR 27
3094: PUSH
3095: LD_INT 1
3097: ST_TO_ADDR
// hc_basic_skills := ape_skills ;
3098: LD_ADDR_OWVAR 30
3102: PUSH
3103: LD_EXP 26
3107: ST_TO_ADDR
// hc_skills := ape_skills ;
3108: LD_ADDR_OWVAR 31
3112: PUSH
3113: LD_EXP 26
3117: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3118: LD_ADDR_OWVAR 29
3122: PUSH
3123: LD_INT 12
3125: PUSH
3126: LD_INT 12
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: ST_TO_ADDR
// hc_importance := 0 ;
3133: LD_ADDR_OWVAR 32
3137: PUSH
3138: LD_INT 0
3140: ST_TO_ADDR
// hc_gallery :=  ;
3141: LD_ADDR_OWVAR 33
3145: PUSH
3146: LD_STRING 
3148: ST_TO_ADDR
// hc_agressivity := Rand ( - 15 , 15 ) ;
3149: LD_ADDR_OWVAR 35
3153: PUSH
3154: LD_INT 15
3156: NEG
3157: PPUSH
3158: LD_INT 15
3160: PPUSH
3161: CALL_OW 12
3165: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3166: LD_ADDR_VAR 0 2
3170: PUSH
3171: LD_INT 4
3173: PPUSH
3174: CALL 2883 0 1
3178: ST_TO_ADDR
// if coord then
3179: LD_VAR 0 2
3183: IFFALSE 3225
// begin lastunit := CreateHuman ;
3185: LD_ADDR_EXP 36
3189: PUSH
3190: CALL_OW 44
3194: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3195: LD_EXP 36
3199: PPUSH
3200: LD_VAR 0 2
3204: PUSH
3205: LD_INT 1
3207: ARRAY
3208: PPUSH
3209: LD_VAR 0 2
3213: PUSH
3214: LD_INT 2
3216: ARRAY
3217: PPUSH
3218: LD_INT 0
3220: PPUSH
3221: CALL_OW 48
// end ; end ;
3225: LD_VAR 0 1
3229: RET
// function prepare_apes ; var i ; begin
3230: LD_INT 0
3232: PPUSH
3233: PPUSH
// for i := 1 to side_count * nstart_ape do
3234: LD_ADDR_VAR 0 2
3238: PUSH
3239: DOUBLE
3240: LD_INT 1
3242: DEC
3243: ST_TO_ADDR
3244: LD_EXP 37
3248: PUSH
3249: LD_EXP 24
3253: MUL
3254: PUSH
3255: FOR_TO
3256: IFFALSE 3264
// begin create_ape ;
3258: CALL 3041 0 0
// end ;
3262: GO 3255
3264: POP
3265: POP
// end ;
3266: LD_VAR 0 1
3270: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3271: LD_OWVAR 1
3275: PUSH
3276: LD_EXP 32
3280: GREATER
3281: IFFALSE 3365
3283: GO 3285
3285: DISABLE
3286: LD_INT 0
3288: PPUSH
// begin if not ape_respawning then
3289: LD_EXP 25
3293: NOT
3294: IFFALSE 3298
// exit ;
3296: GO 3365
// delay := ape_respawning div side_count ;
3298: LD_ADDR_VAR 0 1
3302: PUSH
3303: LD_EXP 25
3307: PUSH
3308: LD_EXP 37
3312: DIV
3313: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3314: LD_VAR 0 1
3318: PUSH
3319: LD_INT 50
3321: PPUSH
3322: LD_INT 150
3324: PPUSH
3325: CALL_OW 12
3329: MUL
3330: PUSH
3331: LD_INT 100
3333: DIV
3334: PPUSH
3335: CALL_OW 67
// delay := delay * 110 div 100 ;
3339: LD_ADDR_VAR 0 1
3343: PUSH
3344: LD_VAR 0 1
3348: PUSH
3349: LD_INT 110
3351: MUL
3352: PUSH
3353: LD_INT 100
3355: DIV
3356: ST_TO_ADDR
// create_ape ;
3357: CALL 3041 0 0
// until false ;
3361: LD_INT 0
3363: IFFALSE 3314
// end ;
3365: PPOPN 1
3367: END
// function create_tiger ; var coord , i ; begin
3368: LD_INT 0
3370: PPUSH
3371: PPUSH
3372: PPUSH
// if lastunit >= 1999 then
3373: LD_EXP 36
3377: PUSH
3378: LD_INT 1999
3380: GREATEREQUAL
3381: IFFALSE 3385
// exit ;
3383: GO 3577
// uc_nation := nation_nature ;
3385: LD_ADDR_OWVAR 21
3389: PUSH
3390: LD_INT 0
3392: ST_TO_ADDR
// uc_side := 0 ;
3393: LD_ADDR_OWVAR 20
3397: PUSH
3398: LD_INT 0
3400: ST_TO_ADDR
// hc_name :=  ;
3401: LD_ADDR_OWVAR 26
3405: PUSH
3406: LD_STRING 
3408: ST_TO_ADDR
// hc_class := class_tiger ;
3409: LD_ADDR_OWVAR 28
3413: PUSH
3414: LD_INT 14
3416: ST_TO_ADDR
// hc_sex := 1 ;
3417: LD_ADDR_OWVAR 27
3421: PUSH
3422: LD_INT 1
3424: ST_TO_ADDR
// hc_basic_skills := [ 2 , 2 , 2 , 2 ] ;
3425: LD_ADDR_OWVAR 30
3429: PUSH
3430: LD_INT 2
3432: PUSH
3433: LD_INT 2
3435: PUSH
3436: LD_INT 2
3438: PUSH
3439: LD_INT 2
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// hc_skills := [ 2 , 2 , 2 , 2 ] ;
3448: LD_ADDR_OWVAR 31
3452: PUSH
3453: LD_INT 2
3455: PUSH
3456: LD_INT 2
3458: PUSH
3459: LD_INT 2
3461: PUSH
3462: LD_INT 2
3464: PUSH
3465: EMPTY
3466: LIST
3467: LIST
3468: LIST
3469: LIST
3470: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
3471: LD_ADDR_OWVAR 29
3475: PUSH
3476: LD_INT 12
3478: PUSH
3479: LD_INT 12
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: ST_TO_ADDR
// hc_importance := 0 ;
3486: LD_ADDR_OWVAR 32
3490: PUSH
3491: LD_INT 0
3493: ST_TO_ADDR
// hc_gallery :=  ;
3494: LD_ADDR_OWVAR 33
3498: PUSH
3499: LD_STRING 
3501: ST_TO_ADDR
// hc_agressivity := Rand ( 30 , 50 ) ;
3502: LD_ADDR_OWVAR 35
3506: PUSH
3507: LD_INT 30
3509: PPUSH
3510: LD_INT 50
3512: PPUSH
3513: CALL_OW 12
3517: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3518: LD_ADDR_VAR 0 2
3522: PUSH
3523: LD_INT 4
3525: PPUSH
3526: CALL 2883 0 1
3530: ST_TO_ADDR
// if coord then
3531: LD_VAR 0 2
3535: IFFALSE 3577
// begin lastunit := CreateHuman ;
3537: LD_ADDR_EXP 36
3541: PUSH
3542: CALL_OW 44
3546: ST_TO_ADDR
// PlaceUnitXY ( lastunit , coord [ 1 ] , coord [ 2 ] , false ) ;
3547: LD_EXP 36
3551: PPUSH
3552: LD_VAR 0 2
3556: PUSH
3557: LD_INT 1
3559: ARRAY
3560: PPUSH
3561: LD_VAR 0 2
3565: PUSH
3566: LD_INT 2
3568: ARRAY
3569: PPUSH
3570: LD_INT 0
3572: PPUSH
3573: CALL_OW 48
// end ; end ;
3577: LD_VAR 0 1
3581: RET
// function prepare_tigers ; var i ; begin
3582: LD_INT 0
3584: PPUSH
3585: PPUSH
// for i := 1 to side_count * ntig do
3586: LD_ADDR_VAR 0 2
3590: PUSH
3591: DOUBLE
3592: LD_INT 1
3594: DEC
3595: ST_TO_ADDR
3596: LD_EXP 37
3600: PUSH
3601: LD_EXP 30
3605: MUL
3606: PUSH
3607: FOR_TO
3608: IFFALSE 3616
// begin create_tiger ;
3610: CALL 3368 0 0
// end ;
3614: GO 3607
3616: POP
3617: POP
// end ;
3618: LD_VAR 0 1
3622: RET
// every 0 0$1 trigger tick > prep_time marked 15 do var delay ;
3623: LD_OWVAR 1
3627: PUSH
3628: LD_EXP 32
3632: GREATER
3633: IFFALSE 3717
3635: GO 3637
3637: DISABLE
3638: LD_INT 0
3640: PPUSH
// begin if not tig_respawning then
3641: LD_EXP 31
3645: NOT
3646: IFFALSE 3650
// exit ;
3648: GO 3717
// delay := tig_respawning div side_count ;
3650: LD_ADDR_VAR 0 1
3654: PUSH
3655: LD_EXP 31
3659: PUSH
3660: LD_EXP 37
3664: DIV
3665: ST_TO_ADDR
// repeat wait ( delay * Rand ( 50 , 150 ) div 100 ) ;
3666: LD_VAR 0 1
3670: PUSH
3671: LD_INT 50
3673: PPUSH
3674: LD_INT 150
3676: PPUSH
3677: CALL_OW 12
3681: MUL
3682: PUSH
3683: LD_INT 100
3685: DIV
3686: PPUSH
3687: CALL_OW 67
// delay := delay * 110 div 100 ;
3691: LD_ADDR_VAR 0 1
3695: PUSH
3696: LD_VAR 0 1
3700: PUSH
3701: LD_INT 110
3703: MUL
3704: PUSH
3705: LD_INT 100
3707: DIV
3708: ST_TO_ADDR
// create_tiger ;
3709: CALL 3368 0 0
// until false ;
3713: LD_INT 0
3715: IFFALSE 3666
// end ;
3717: PPOPN 1
3719: END
// export function sheherezade_start_the_fight ; var i ; begin
3720: LD_INT 0
3722: PPUSH
3723: PPUSH
// for i := 1 to 8 do
3724: LD_ADDR_VAR 0 2
3728: PUSH
3729: DOUBLE
3730: LD_INT 1
3732: DEC
3733: ST_TO_ADDR
3734: LD_INT 8
3736: PUSH
3737: FOR_TO
3738: IFFALSE 3772
// if side_positions [ i ] then
3740: LD_EXP 43
3744: PUSH
3745: LD_VAR 0 2
3749: ARRAY
3750: IFFALSE 3770
// prepare_side_to_the_fight ( i , prep_time > 0 ) ;
3752: LD_VAR 0 2
3756: PPUSH
3757: LD_EXP 32
3761: PUSH
3762: LD_INT 0
3764: GREATER
3765: PPUSH
3766: CALL 2410 0 2
3770: GO 3737
3772: POP
3773: POP
// end ;
3774: LD_VAR 0 1
3778: RET
// function create_mastodon ; var coord , i ; begin
3779: LD_INT 0
3781: PPUSH
3782: PPUSH
3783: PPUSH
// if lastunit >= 1999 then
3784: LD_EXP 36
3788: PUSH
3789: LD_INT 1999
3791: GREATEREQUAL
3792: IFFALSE 3796
// exit ;
3794: GO 3882
// uc_nation := nation_nature ;
3796: LD_ADDR_OWVAR 21
3800: PUSH
3801: LD_INT 0
3803: ST_TO_ADDR
// uc_side := 0 ;
3804: LD_ADDR_OWVAR 20
3808: PUSH
3809: LD_INT 0
3811: ST_TO_ADDR
// vc_chassis := 31 ;
3812: LD_ADDR_OWVAR 37
3816: PUSH
3817: LD_INT 31
3819: ST_TO_ADDR
// coord := find_hidden_hex ( arstart ) ;
3820: LD_ADDR_VAR 0 2
3824: PUSH
3825: LD_INT 4
3827: PPUSH
3828: CALL 2883 0 1
3832: ST_TO_ADDR
// if coord then
3833: LD_VAR 0 2
3837: IFFALSE 3882
// begin lastunit := CreateVehicle ;
3839: LD_ADDR_EXP 36
3843: PUSH
3844: CALL_OW 45
3848: ST_TO_ADDR
// PlaceUnitXYR ( lastunit , coord [ 1 ] , coord [ 2 ] , 3 , false ) ;
3849: LD_EXP 36
3853: PPUSH
3854: LD_VAR 0 2
3858: PUSH
3859: LD_INT 1
3861: ARRAY
3862: PPUSH
3863: LD_VAR 0 2
3867: PUSH
3868: LD_INT 2
3870: ARRAY
3871: PPUSH
3872: LD_INT 3
3874: PPUSH
3875: LD_INT 0
3877: PPUSH
3878: CALL_OW 50
// end ; end ;
3882: LD_VAR 0 1
3886: RET
// function prepare_mastodons ; var i ; begin
3887: LD_INT 0
3889: PPUSH
3890: PPUSH
// for i := 1 to nmast1 + side_count * nmast2 + side_count * nsh * nmast3 div 100 do
3891: LD_ADDR_VAR 0 2
3895: PUSH
3896: DOUBLE
3897: LD_INT 1
3899: DEC
3900: ST_TO_ADDR
3901: LD_EXP 27
3905: PUSH
3906: LD_EXP 37
3910: PUSH
3911: LD_EXP 28
3915: MUL
3916: PLUS
3917: PUSH
3918: LD_EXP 37
3922: PUSH
3923: LD_EXP 20
3927: MUL
3928: PUSH
3929: LD_EXP 29
3933: MUL
3934: PUSH
3935: LD_INT 100
3937: DIV
3938: PLUS
3939: PUSH
3940: FOR_TO
3941: IFFALSE 3949
// begin create_mastodon ;
3943: CALL 3779 0 0
// end ;
3947: GO 3940
3949: POP
3950: POP
// end ;
3951: LD_VAR 0 1
3955: RET
// export function starting_sheherezad ; begin
3956: LD_INT 0
3958: PPUSH
// mp_selectmsg := true ;
3959: LD_ADDR_OWVAR 13
3963: PUSH
3964: LD_INT 1
3966: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
3967: CALL 111 0 0
// prepare_map_coordinates ;
3971: CALL 1596 0 0
// set_attitudes ;
3975: CALL 2041 0 0
// prepare_sides ;
3979: CALL 2346 0 0
// prepare_apes ;
3983: CALL 3230 0 0
// prepare_tigers ;
3987: CALL 3582 0 0
// prepare_mastodons ;
3991: CALL 3887 0 0
// your_side := Player_Side ;
3995: LD_ADDR_OWVAR 2
3999: PUSH
4000: LD_EXP 39
4004: ST_TO_ADDR
// ResetFog ;
4005: CALL_OW 335
// AnimateTrees ( true ) ;
4009: LD_INT 1
4011: PPUSH
4012: CALL_OW 573
// music_nat := nation_arabian ;
4016: LD_ADDR_OWVAR 71
4020: PUSH
4021: LD_INT 2
4023: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
4024: LD_EXP 34
4028: PUSH
4029: LD_OWVAR 2
4033: ARRAY
4034: PUSH
4035: LD_INT 1
4037: ARRAY
4038: PPUSH
4039: LD_EXP 34
4043: PUSH
4044: LD_OWVAR 2
4048: ARRAY
4049: PUSH
4050: LD_INT 2
4052: ARRAY
4053: PPUSH
4054: CALL_OW 86
// end ; end_of_file
4058: LD_VAR 0 1
4062: RET
// export def_victory_conditions , def_number_of_people , def_people_respawning , def_vehicles_at_start , def_vehicles_respawning , def_vehicles_nations , def_siberite_rocket , def_vehicles_durability ; export game_time , point_limit , vehresp , vehmax1 , vehmax2 , vehmax , startvehperc , startveh , vehdur , npeop , peopresp , vehnats , sibrock , to_resp ; function read_multiplayer_and_game_parameters ; var i ; begin
4063: LD_INT 0
4065: PPUSH
4066: PPUSH
// if MultiPlayer then
4067: LD_OWVAR 4
4071: IFFALSE 4135
// begin Player_Side = mp_player_side ;
4073: LD_ADDR_EXP 39
4077: PUSH
4078: LD_OWVAR 7
4082: ST_TO_ADDR
// Player_Team = mp_player_team ;
4083: LD_ADDR_EXP 40
4087: PUSH
4088: LD_OWVAR 8
4092: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
4093: LD_ADDR_EXP 43
4097: PUSH
4098: LD_OWVAR 17
4102: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
4103: LD_ADDR_EXP 41
4107: PUSH
4108: LD_OWVAR 15
4112: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
4113: LD_ADDR_EXP 44
4117: PUSH
4118: LD_OWVAR 16
4122: ST_TO_ADDR
// Teams = mp_teams ;
4123: LD_ADDR_EXP 42
4127: PUSH
4128: LD_OWVAR 12
4132: ST_TO_ADDR
// end else
4133: GO 4279
// begin randomize ;
4135: CALL_OW 10
// Player_Side = 1 ;
4139: LD_ADDR_EXP 39
4143: PUSH
4144: LD_INT 1
4146: ST_TO_ADDR
// Player_Team = 0 ;
4147: LD_ADDR_EXP 40
4151: PUSH
4152: LD_INT 0
4154: ST_TO_ADDR
// Side_Positions = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ;
4155: LD_ADDR_EXP 43
4159: PUSH
4160: LD_INT 1
4162: PUSH
4163: LD_INT 2
4165: PUSH
4166: LD_INT 3
4168: PUSH
4169: LD_INT 4
4171: PUSH
4172: LD_INT 5
4174: PUSH
4175: LD_INT 6
4177: PUSH
4178: LD_INT 7
4180: PUSH
4181: LD_INT 8
4183: PUSH
4184: EMPTY
4185: LIST
4186: LIST
4187: LIST
4188: LIST
4189: LIST
4190: LIST
4191: LIST
4192: LIST
4193: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
4194: LD_ADDR_EXP 41
4198: PUSH
4199: LD_INT 0
4201: PUSH
4202: LD_INT 0
4204: PUSH
4205: LD_INT 0
4207: PUSH
4208: LD_INT 0
4210: PUSH
4211: LD_INT 0
4213: PUSH
4214: LD_INT 0
4216: PUSH
4217: LD_INT 0
4219: PUSH
4220: LD_INT 0
4222: PUSH
4223: EMPTY
4224: LIST
4225: LIST
4226: LIST
4227: LIST
4228: LIST
4229: LIST
4230: LIST
4231: LIST
4232: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 3 , 2 , 1 , 2 ] ;
4233: LD_ADDR_EXP 44
4237: PUSH
4238: LD_INT 1
4240: PUSH
4241: LD_INT 3
4243: PUSH
4244: LD_INT 1
4246: PUSH
4247: LD_INT 2
4249: PUSH
4250: LD_INT 3
4252: PUSH
4253: LD_INT 2
4255: PUSH
4256: LD_INT 1
4258: PUSH
4259: LD_INT 2
4261: PUSH
4262: EMPTY
4263: LIST
4264: LIST
4265: LIST
4266: LIST
4267: LIST
4268: LIST
4269: LIST
4270: LIST
4271: ST_TO_ADDR
// Teams = [ ] ;
4272: LD_ADDR_EXP 42
4276: PUSH
4277: EMPTY
4278: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
4279: LD_ADDR_EXP 37
4283: PUSH
4284: LD_EXP 43
4288: PUSH
4289: LD_INT 0
4291: PUSH
4292: EMPTY
4293: LIST
4294: DIFF
4295: PUSH
4296: LD_INT 0
4298: PLUS
4299: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
4300: LD_ADDR_EXP 38
4304: PUSH
4305: LD_EXP 41
4309: PUSH
4310: LD_INT 0
4312: PUSH
4313: EMPTY
4314: LIST
4315: DIFF
4316: PUSH
4317: LD_INT 0
4319: PLUS
4320: ST_TO_ADDR
// if MultiPlayer then
4321: LD_OWVAR 4
4325: IFFALSE 4433
// begin def_victory_conditions = GetMultiplayerSetting ( 0 ) ;
4327: LD_ADDR_EXP 48
4331: PUSH
4332: LD_INT 0
4334: PPUSH
4335: CALL_OW 426
4339: ST_TO_ADDR
// def_number_of_people = GetMultiplayerSetting ( 1 ) ;
4340: LD_ADDR_EXP 49
4344: PUSH
4345: LD_INT 1
4347: PPUSH
4348: CALL_OW 426
4352: ST_TO_ADDR
// def_people_respawning = GetMultiplayerSetting ( 2 ) ;
4353: LD_ADDR_EXP 50
4357: PUSH
4358: LD_INT 2
4360: PPUSH
4361: CALL_OW 426
4365: ST_TO_ADDR
// def_vehicles_at_start = GetMultiplayerSetting ( 3 ) ;
4366: LD_ADDR_EXP 51
4370: PUSH
4371: LD_INT 3
4373: PPUSH
4374: CALL_OW 426
4378: ST_TO_ADDR
// def_vehicles_respawning = GetMultiplayerSetting ( 4 ) ;
4379: LD_ADDR_EXP 52
4383: PUSH
4384: LD_INT 4
4386: PPUSH
4387: CALL_OW 426
4391: ST_TO_ADDR
// def_vehicles_nations = GetMultiplayerSetting ( 5 ) ;
4392: LD_ADDR_EXP 53
4396: PUSH
4397: LD_INT 5
4399: PPUSH
4400: CALL_OW 426
4404: ST_TO_ADDR
// def_siberite_rocket = GetMultiplayerSetting ( 6 ) ;
4405: LD_ADDR_EXP 54
4409: PUSH
4410: LD_INT 6
4412: PPUSH
4413: CALL_OW 426
4417: ST_TO_ADDR
// def_vehicles_durability = GetMultiplayerSetting ( 7 ) ;
4418: LD_ADDR_EXP 55
4422: PUSH
4423: LD_INT 7
4425: PPUSH
4426: CALL_OW 426
4430: ST_TO_ADDR
// end else
4431: GO 4501
// begin randomize ;
4433: CALL_OW 10
// def_victory_conditions = 2 ;
4437: LD_ADDR_EXP 48
4441: PUSH
4442: LD_INT 2
4444: ST_TO_ADDR
// def_number_of_people = 1 ;
4445: LD_ADDR_EXP 49
4449: PUSH
4450: LD_INT 1
4452: ST_TO_ADDR
// def_people_respawning = 1 ;
4453: LD_ADDR_EXP 50
4457: PUSH
4458: LD_INT 1
4460: ST_TO_ADDR
// def_vehicles_at_start = 1 ;
4461: LD_ADDR_EXP 51
4465: PUSH
4466: LD_INT 1
4468: ST_TO_ADDR
// def_vehicles_respawning = 2 ;
4469: LD_ADDR_EXP 52
4473: PUSH
4474: LD_INT 2
4476: ST_TO_ADDR
// def_vehicles_nations = 0 ;
4477: LD_ADDR_EXP 53
4481: PUSH
4482: LD_INT 0
4484: ST_TO_ADDR
// def_siberite_rocket = 1 ;
4485: LD_ADDR_EXP 54
4489: PUSH
4490: LD_INT 1
4492: ST_TO_ADDR
// def_vehicles_durability = 1 ;
4493: LD_ADDR_EXP 55
4497: PUSH
4498: LD_INT 1
4500: ST_TO_ADDR
// end ; game_time = [ 5 5$0 , 10 10$0 , 15 15$0 , 20 20$0 , 30 30$0 , 0 , 0 , 0 , 0 , 0 , 0 ] [ def_victory_conditions + 1 ] ;
4501: LD_ADDR_EXP 56
4505: PUSH
4506: LD_INT 10500
4508: PUSH
4509: LD_INT 21000
4511: PUSH
4512: LD_INT 31500
4514: PUSH
4515: LD_INT 42000
4517: PUSH
4518: LD_INT 63000
4520: PUSH
4521: LD_INT 0
4523: PUSH
4524: LD_INT 0
4526: PUSH
4527: LD_INT 0
4529: PUSH
4530: LD_INT 0
4532: PUSH
4533: LD_INT 0
4535: PUSH
4536: LD_INT 0
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: LIST
4543: LIST
4544: LIST
4545: LIST
4546: LIST
4547: LIST
4548: LIST
4549: LIST
4550: LIST
4551: PUSH
4552: LD_EXP 48
4556: PUSH
4557: LD_INT 1
4559: PLUS
4560: ARRAY
4561: ST_TO_ADDR
// point_limit = [ 0 , 0 , 0 , 0 , 0 , 0 , 5 , 10 , 15 , 20 , 30 , 50 ] [ def_victory_conditions + 1 ] ;
4562: LD_ADDR_EXP 57
4566: PUSH
4567: LD_INT 0
4569: PUSH
4570: LD_INT 0
4572: PUSH
4573: LD_INT 0
4575: PUSH
4576: LD_INT 0
4578: PUSH
4579: LD_INT 0
4581: PUSH
4582: LD_INT 0
4584: PUSH
4585: LD_INT 5
4587: PUSH
4588: LD_INT 10
4590: PUSH
4591: LD_INT 15
4593: PUSH
4594: LD_INT 20
4596: PUSH
4597: LD_INT 30
4599: PUSH
4600: LD_INT 50
4602: PUSH
4603: EMPTY
4604: LIST
4605: LIST
4606: LIST
4607: LIST
4608: LIST
4609: LIST
4610: LIST
4611: LIST
4612: LIST
4613: LIST
4614: LIST
4615: LIST
4616: PUSH
4617: LD_EXP 48
4621: PUSH
4622: LD_INT 1
4624: PLUS
4625: ARRAY
4626: ST_TO_ADDR
// npeop = [ 4 , 6 , 8 , 10 ] [ def_number_of_people + 1 ] ;
4627: LD_ADDR_EXP 65
4631: PUSH
4632: LD_INT 4
4634: PUSH
4635: LD_INT 6
4637: PUSH
4638: LD_INT 8
4640: PUSH
4641: LD_INT 10
4643: PUSH
4644: EMPTY
4645: LIST
4646: LIST
4647: LIST
4648: LIST
4649: PUSH
4650: LD_EXP 49
4654: PUSH
4655: LD_INT 1
4657: PLUS
4658: ARRAY
4659: ST_TO_ADDR
// peopresp = [ false , [ 0 0$40 , 1 1$20 ] , [ 0 0$20 , 0 0$40 ] , [ 0 0$10 , 0 0$20 ] ] [ def_people_respawning + 1 ] ;
4660: LD_ADDR_EXP 66
4664: PUSH
4665: LD_INT 0
4667: PUSH
4668: LD_INT 1400
4670: PUSH
4671: LD_INT 2800
4673: PUSH
4674: EMPTY
4675: LIST
4676: LIST
4677: PUSH
4678: LD_INT 700
4680: PUSH
4681: LD_INT 1400
4683: PUSH
4684: EMPTY
4685: LIST
4686: LIST
4687: PUSH
4688: LD_INT 350
4690: PUSH
4691: LD_INT 700
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: LIST
4702: LIST
4703: PUSH
4704: LD_EXP 50
4708: PUSH
4709: LD_INT 1
4711: PLUS
4712: ARRAY
4713: ST_TO_ADDR
// vehmax1 = [ 3 , 6 , 9 ] [ def_vehicles_respawning + 1 ] ;
4714: LD_ADDR_EXP 59
4718: PUSH
4719: LD_INT 3
4721: PUSH
4722: LD_INT 6
4724: PUSH
4725: LD_INT 9
4727: PUSH
4728: EMPTY
4729: LIST
4730: LIST
4731: LIST
4732: PUSH
4733: LD_EXP 52
4737: PUSH
4738: LD_INT 1
4740: PLUS
4741: ARRAY
4742: ST_TO_ADDR
// vehmax2 = [ 2 , 4 , 6 ] [ def_vehicles_respawning + 1 ] ;
4743: LD_ADDR_EXP 60
4747: PUSH
4748: LD_INT 2
4750: PUSH
4751: LD_INT 4
4753: PUSH
4754: LD_INT 6
4756: PUSH
4757: EMPTY
4758: LIST
4759: LIST
4760: LIST
4761: PUSH
4762: LD_EXP 52
4766: PUSH
4767: LD_INT 1
4769: PLUS
4770: ARRAY
4771: ST_TO_ADDR
// vehmax = vehmax1 + side_count * vehmax2 ;
4772: LD_ADDR_EXP 61
4776: PUSH
4777: LD_EXP 59
4781: PUSH
4782: LD_EXP 37
4786: PUSH
4787: LD_EXP 60
4791: MUL
4792: PLUS
4793: ST_TO_ADDR
// vehdur = [ [ 25 , 50 ] , [ 45 , 90 ] , [ 75 , 150 ] ] [ def_vehicles_durability + 1 ] ;
4794: LD_ADDR_EXP 64
4798: PUSH
4799: LD_INT 25
4801: PUSH
4802: LD_INT 50
4804: PUSH
4805: EMPTY
4806: LIST
4807: LIST
4808: PUSH
4809: LD_INT 45
4811: PUSH
4812: LD_INT 90
4814: PUSH
4815: EMPTY
4816: LIST
4817: LIST
4818: PUSH
4819: LD_INT 75
4821: PUSH
4822: LD_INT 150
4824: PUSH
4825: EMPTY
4826: LIST
4827: LIST
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: LIST
4833: PUSH
4834: LD_EXP 55
4838: PUSH
4839: LD_INT 1
4841: PLUS
4842: ARRAY
4843: ST_TO_ADDR
// vehresp = [ [ 0 0$40 , 2 2$00 ] , [ 0 0$20 , 1 1$00 ] , [ 0 0$10 , 0 0$30 ] ] [ def_vehicles_respawning + 1 ] ;
4844: LD_ADDR_EXP 58
4848: PUSH
4849: LD_INT 1400
4851: PUSH
4852: LD_INT 4200
4854: PUSH
4855: EMPTY
4856: LIST
4857: LIST
4858: PUSH
4859: LD_INT 700
4861: PUSH
4862: LD_INT 2100
4864: PUSH
4865: EMPTY
4866: LIST
4867: LIST
4868: PUSH
4869: LD_INT 350
4871: PUSH
4872: LD_INT 1050
4874: PUSH
4875: EMPTY
4876: LIST
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: LIST
4883: PUSH
4884: LD_EXP 52
4888: PUSH
4889: LD_INT 1
4891: PLUS
4892: ARRAY
4893: ST_TO_ADDR
// startvehperc = [ 0 , 10 , 20 , 40 ] [ def_vehicles_at_start + 1 ] ;
4894: LD_ADDR_EXP 62
4898: PUSH
4899: LD_INT 0
4901: PUSH
4902: LD_INT 10
4904: PUSH
4905: LD_INT 20
4907: PUSH
4908: LD_INT 40
4910: PUSH
4911: EMPTY
4912: LIST
4913: LIST
4914: LIST
4915: LIST
4916: PUSH
4917: LD_EXP 51
4921: PUSH
4922: LD_INT 1
4924: PLUS
4925: ARRAY
4926: ST_TO_ADDR
// startveh = vehmax * startvehperc div 100 ;
4927: LD_ADDR_EXP 63
4931: PUSH
4932: LD_EXP 61
4936: PUSH
4937: LD_EXP 62
4941: MUL
4942: PUSH
4943: LD_INT 100
4945: DIV
4946: ST_TO_ADDR
// vehnats = [ [ 1 , 2 , 3 ] , [ 1 ] , [ 3 ] , [ 2 ] , [ 1 , 3 ] , [ 3 , 2 ] , [ 2 , 1 ] ] [ def_vehicles_nations + 1 ] ;
4947: LD_ADDR_EXP 67
4951: PUSH
4952: LD_INT 1
4954: PUSH
4955: LD_INT 2
4957: PUSH
4958: LD_INT 3
4960: PUSH
4961: EMPTY
4962: LIST
4963: LIST
4964: LIST
4965: PUSH
4966: LD_INT 1
4968: PUSH
4969: EMPTY
4970: LIST
4971: PUSH
4972: LD_INT 3
4974: PUSH
4975: EMPTY
4976: LIST
4977: PUSH
4978: LD_INT 2
4980: PUSH
4981: EMPTY
4982: LIST
4983: PUSH
4984: LD_INT 1
4986: PUSH
4987: LD_INT 3
4989: PUSH
4990: EMPTY
4991: LIST
4992: LIST
4993: PUSH
4994: LD_INT 3
4996: PUSH
4997: LD_INT 2
4999: PUSH
5000: EMPTY
5001: LIST
5002: LIST
5003: PUSH
5004: LD_INT 2
5006: PUSH
5007: LD_INT 1
5009: PUSH
5010: EMPTY
5011: LIST
5012: LIST
5013: PUSH
5014: EMPTY
5015: LIST
5016: LIST
5017: LIST
5018: LIST
5019: LIST
5020: LIST
5021: LIST
5022: PUSH
5023: LD_EXP 53
5027: PUSH
5028: LD_INT 1
5030: PLUS
5031: ARRAY
5032: ST_TO_ADDR
// sibrock = [ 0 , 3 , 7 ] [ def_siberite_rocket + 1 ] ;
5033: LD_ADDR_EXP 68
5037: PUSH
5038: LD_INT 0
5040: PUSH
5041: LD_INT 3
5043: PUSH
5044: LD_INT 7
5046: PUSH
5047: EMPTY
5048: LIST
5049: LIST
5050: LIST
5051: PUSH
5052: LD_EXP 54
5056: PUSH
5057: LD_INT 1
5059: PLUS
5060: ARRAY
5061: ST_TO_ADDR
// for i = 1 to 8 do
5062: LD_ADDR_VAR 0 2
5066: PUSH
5067: DOUBLE
5068: LD_INT 1
5070: DEC
5071: ST_TO_ADDR
5072: LD_INT 8
5074: PUSH
5075: FOR_TO
5076: IFFALSE 5108
// if Side_Positions [ i ] then
5078: LD_EXP 43
5082: PUSH
5083: LD_VAR 0 2
5087: ARRAY
5088: IFFALSE 5106
// to_resp := to_resp ^ i ;
5090: LD_ADDR_EXP 69
5094: PUSH
5095: LD_EXP 69
5099: PUSH
5100: LD_VAR 0 2
5104: ADD
5105: ST_TO_ADDR
5106: GO 5075
5108: POP
5109: POP
// end ;
5110: LD_VAR 0 1
5114: RET
// export chassis , weapons , areas_wheeled , areas_tracked ; function prepare_map_coordinates ; var best , c , bestc , minv , i , j , n ; begin
5115: LD_INT 0
5117: PPUSH
5118: PPUSH
5119: PPUSH
5120: PPUSH
5121: PPUSH
5122: PPUSH
5123: PPUSH
5124: PPUSH
// areas_wheeled = [ aw1 , aw2 , aw3 , aw4 ] ;
5125: LD_ADDR_EXP 72
5129: PUSH
5130: LD_INT 21
5132: PUSH
5133: LD_INT 19
5135: PUSH
5136: LD_INT 17
5138: PUSH
5139: LD_INT 15
5141: PUSH
5142: EMPTY
5143: LIST
5144: LIST
5145: LIST
5146: LIST
5147: ST_TO_ADDR
// areas_tracked = [ at1 , at2 , at3 , at4 ] ;
5148: LD_ADDR_EXP 73
5152: PUSH
5153: LD_INT 20
5155: PUSH
5156: LD_INT 18
5158: PUSH
5159: LD_INT 16
5161: PUSH
5162: LD_INT 14
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: ST_TO_ADDR
// best = 0 ;
5171: LD_ADDR_VAR 0 2
5175: PUSH
5176: LD_INT 0
5178: ST_TO_ADDR
// for n = 1 to 200 do
5179: LD_ADDR_VAR 0 8
5183: PUSH
5184: DOUBLE
5185: LD_INT 1
5187: DEC
5188: ST_TO_ADDR
5189: LD_INT 200
5191: PUSH
5192: FOR_TO
5193: IFFALSE 5489
// begin c = [ ] ;
5195: LD_ADDR_VAR 0 3
5199: PUSH
5200: EMPTY
5201: ST_TO_ADDR
// for i = 1 to side_count do
5202: LD_ADDR_VAR 0 6
5206: PUSH
5207: DOUBLE
5208: LD_INT 1
5210: DEC
5211: ST_TO_ADDR
5212: LD_EXP 37
5216: PUSH
5217: FOR_TO
5218: IFFALSE 5247
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
5220: LD_ADDR_VAR 0 3
5224: PUSH
5225: LD_VAR 0 3
5229: PUSH
5230: LD_INT 22
5232: PPUSH
5233: LD_INT 0
5235: PPUSH
5236: CALL_OW 16
5240: PUSH
5241: EMPTY
5242: LIST
5243: ADD
5244: ST_TO_ADDR
5245: GO 5217
5247: POP
5248: POP
// minv = 10000 ;
5249: LD_ADDR_VAR 0 5
5253: PUSH
5254: LD_INT 10000
5256: ST_TO_ADDR
// for i = 1 to side_count do
5257: LD_ADDR_VAR 0 6
5261: PUSH
5262: DOUBLE
5263: LD_INT 1
5265: DEC
5266: ST_TO_ADDR
5267: LD_EXP 37
5271: PUSH
5272: FOR_TO
5273: IFFALSE 5453
// for j = 1 to side_count do
5275: LD_ADDR_VAR 0 7
5279: PUSH
5280: DOUBLE
5281: LD_INT 1
5283: DEC
5284: ST_TO_ADDR
5285: LD_EXP 37
5289: PUSH
5290: FOR_TO
5291: IFFALSE 5449
// if i <> j then
5293: LD_VAR 0 6
5297: PUSH
5298: LD_VAR 0 7
5302: NONEQUAL
5303: IFFALSE 5447
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
5305: LD_VAR 0 3
5309: PUSH
5310: LD_VAR 0 6
5314: ARRAY
5315: PUSH
5316: LD_INT 1
5318: ARRAY
5319: PPUSH
5320: LD_VAR 0 3
5324: PUSH
5325: LD_VAR 0 6
5329: ARRAY
5330: PUSH
5331: LD_INT 2
5333: ARRAY
5334: PPUSH
5335: LD_VAR 0 3
5339: PUSH
5340: LD_VAR 0 7
5344: ARRAY
5345: PUSH
5346: LD_INT 1
5348: ARRAY
5349: PPUSH
5350: LD_VAR 0 3
5354: PUSH
5355: LD_VAR 0 7
5359: ARRAY
5360: PUSH
5361: LD_INT 2
5363: ARRAY
5364: PPUSH
5365: CALL_OW 298
5369: PUSH
5370: LD_VAR 0 5
5374: LESS
5375: IFFALSE 5447
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
5377: LD_ADDR_VAR 0 5
5381: PUSH
5382: LD_VAR 0 3
5386: PUSH
5387: LD_VAR 0 6
5391: ARRAY
5392: PUSH
5393: LD_INT 1
5395: ARRAY
5396: PPUSH
5397: LD_VAR 0 3
5401: PUSH
5402: LD_VAR 0 6
5406: ARRAY
5407: PUSH
5408: LD_INT 2
5410: ARRAY
5411: PPUSH
5412: LD_VAR 0 3
5416: PUSH
5417: LD_VAR 0 7
5421: ARRAY
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: LD_VAR 0 3
5431: PUSH
5432: LD_VAR 0 7
5436: ARRAY
5437: PUSH
5438: LD_INT 2
5440: ARRAY
5441: PPUSH
5442: CALL_OW 298
5446: ST_TO_ADDR
// end ;
5447: GO 5290
5449: POP
5450: POP
5451: GO 5272
5453: POP
5454: POP
// if minv > best then
5455: LD_VAR 0 5
5459: PUSH
5460: LD_VAR 0 2
5464: GREATER
5465: IFFALSE 5487
// begin best := minv ;
5467: LD_ADDR_VAR 0 2
5471: PUSH
5472: LD_VAR 0 5
5476: ST_TO_ADDR
// bestc := c ;
5477: LD_ADDR_VAR 0 4
5481: PUSH
5482: LD_VAR 0 3
5486: ST_TO_ADDR
// end ; end ;
5487: GO 5192
5489: POP
5490: POP
// coordinates := [ ] ;
5491: LD_ADDR_EXP 34
5495: PUSH
5496: EMPTY
5497: ST_TO_ADDR
// for i = 1 to 8 do
5498: LD_ADDR_VAR 0 6
5502: PUSH
5503: DOUBLE
5504: LD_INT 1
5506: DEC
5507: ST_TO_ADDR
5508: LD_INT 8
5510: PUSH
5511: FOR_TO
5512: IFFALSE 5599
// if side_positions [ i ] = 0 then
5514: LD_EXP 43
5518: PUSH
5519: LD_VAR 0 6
5523: ARRAY
5524: PUSH
5525: LD_INT 0
5527: EQUAL
5528: IFFALSE 5556
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
5530: LD_ADDR_EXP 34
5534: PUSH
5535: LD_EXP 34
5539: PUSH
5540: LD_INT 0
5542: PUSH
5543: LD_INT 0
5545: PUSH
5546: EMPTY
5547: LIST
5548: LIST
5549: PUSH
5550: EMPTY
5551: LIST
5552: ADD
5553: ST_TO_ADDR
5554: GO 5597
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
5556: LD_ADDR_EXP 34
5560: PUSH
5561: LD_EXP 34
5565: PUSH
5566: LD_VAR 0 4
5570: PUSH
5571: LD_INT 1
5573: ARRAY
5574: PUSH
5575: EMPTY
5576: LIST
5577: ADD
5578: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
5579: LD_ADDR_VAR 0 4
5583: PUSH
5584: LD_VAR 0 4
5588: PPUSH
5589: LD_INT 1
5591: PPUSH
5592: CALL_OW 3
5596: ST_TO_ADDR
// end ;
5597: GO 5511
5599: POP
5600: POP
// end ;
5601: LD_VAR 0 1
5605: RET
// function prepare_constants ; begin
5606: LD_INT 0
5608: PPUSH
// chassis = [ [ [ [ us_light_wheeled ] , [ ] ] , [ [ us_medium_wheeled ] , [ us_medium_tracked ] ] , [ [ ] , [ us_heavy_tracked , us_morphling ] ] ] , [ [ [ ar_light_trike , ar_hovercraft ] , [ ] ] , [ [ ar_medium_trike ] , [ ar_half_tracked ] ] , [ [ ] , [ ] ] ] , [ [ [ ] , [ ] ] , [ [ ru_medium_wheeled ] , [ ru_medium_tracked ] ] , [ [ ru_heavy_wheeled ] , [ ru_heavy_tracked ] ] ] ] ;
5609: LD_ADDR_EXP 70
5613: PUSH
5614: LD_INT 1
5616: PUSH
5617: EMPTY
5618: LIST
5619: PUSH
5620: EMPTY
5621: PUSH
5622: EMPTY
5623: LIST
5624: LIST
5625: PUSH
5626: LD_INT 2
5628: PUSH
5629: EMPTY
5630: LIST
5631: PUSH
5632: LD_INT 3
5634: PUSH
5635: EMPTY
5636: LIST
5637: PUSH
5638: EMPTY
5639: LIST
5640: LIST
5641: PUSH
5642: EMPTY
5643: PUSH
5644: LD_INT 4
5646: PUSH
5647: LD_INT 5
5649: PUSH
5650: EMPTY
5651: LIST
5652: LIST
5653: PUSH
5654: EMPTY
5655: LIST
5656: LIST
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: LIST
5662: PUSH
5663: LD_INT 12
5665: PUSH
5666: LD_INT 11
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: PUSH
5673: EMPTY
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: PUSH
5679: LD_INT 13
5681: PUSH
5682: EMPTY
5683: LIST
5684: PUSH
5685: LD_INT 14
5687: PUSH
5688: EMPTY
5689: LIST
5690: PUSH
5691: EMPTY
5692: LIST
5693: LIST
5694: PUSH
5695: EMPTY
5696: PUSH
5697: EMPTY
5698: PUSH
5699: EMPTY
5700: LIST
5701: LIST
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: LIST
5707: PUSH
5708: EMPTY
5709: PUSH
5710: EMPTY
5711: PUSH
5712: EMPTY
5713: LIST
5714: LIST
5715: PUSH
5716: LD_INT 21
5718: PUSH
5719: EMPTY
5720: LIST
5721: PUSH
5722: LD_INT 22
5724: PUSH
5725: EMPTY
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: PUSH
5732: LD_INT 23
5734: PUSH
5735: EMPTY
5736: LIST
5737: PUSH
5738: LD_INT 24
5740: PUSH
5741: EMPTY
5742: LIST
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: EMPTY
5749: LIST
5750: LIST
5751: LIST
5752: PUSH
5753: EMPTY
5754: LIST
5755: LIST
5756: LIST
5757: ST_TO_ADDR
// weapons = [ [ [ us_machine_gun , 1 , 100 ] , [ us_light_gun , 1 , 100 ] , [ us_radar , 1 , 100 ] , [ us_gatling_gun , 2 , 100 ] , [ us_double_gun , 2 , 100 ] , [ us_rocket_launcher , 2 , 100 ] , [ us_laser , 2 , 100 ] , [ us_heavy_gun , 3 , 100 ] , [ us_bulldozer , 3 , 100 ] , [ us_double_laser , 3 , 100 ] ] , [ [ ar_multimissile_ballista , 1 , 100 ] , [ ar_double_machine_gun , 1 , 100 ] , [ ar_light_gun , 1 , 100 ] , [ ar_radar , 1 , 100 ] , [ ar_gatling_gun , 2 , 100 ] , [ ar_gun , 2 , 100 ] , [ ar_rocket_launcher , 2 , 100 ] , [ ar_selfpropelled_bomb , 2 , 100 ] , [ ar_flame_thrower , 2 , 100 ] ] , [ [ ru_heavy_machine_gun , 2 , 100 ] , [ ru_gatling_gun , 2 , 100 ] , [ ru_gun , 2 , 100 ] , [ ru_rocket_launcher , 2 , 100 ] , [ ru_heavy_gun , 3 , 100 ] , [ ru_rocket , 3 , 100 ] , [ ru_bulldozer , 3 , 100 ] ] ] ;
5758: LD_ADDR_EXP 71
5762: PUSH
5763: LD_INT 2
5765: PUSH
5766: LD_INT 1
5768: PUSH
5769: LD_INT 100
5771: PUSH
5772: EMPTY
5773: LIST
5774: LIST
5775: LIST
5776: PUSH
5777: LD_INT 3
5779: PUSH
5780: LD_INT 1
5782: PUSH
5783: LD_INT 100
5785: PUSH
5786: EMPTY
5787: LIST
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 11
5793: PUSH
5794: LD_INT 1
5796: PUSH
5797: LD_INT 100
5799: PUSH
5800: EMPTY
5801: LIST
5802: LIST
5803: LIST
5804: PUSH
5805: LD_INT 4
5807: PUSH
5808: LD_INT 2
5810: PUSH
5811: LD_INT 100
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: PUSH
5819: LD_INT 5
5821: PUSH
5822: LD_INT 2
5824: PUSH
5825: LD_INT 100
5827: PUSH
5828: EMPTY
5829: LIST
5830: LIST
5831: LIST
5832: PUSH
5833: LD_INT 7
5835: PUSH
5836: LD_INT 2
5838: PUSH
5839: LD_INT 100
5841: PUSH
5842: EMPTY
5843: LIST
5844: LIST
5845: LIST
5846: PUSH
5847: LD_INT 9
5849: PUSH
5850: LD_INT 2
5852: PUSH
5853: LD_INT 100
5855: PUSH
5856: EMPTY
5857: LIST
5858: LIST
5859: LIST
5860: PUSH
5861: LD_INT 6
5863: PUSH
5864: LD_INT 3
5866: PUSH
5867: LD_INT 100
5869: PUSH
5870: EMPTY
5871: LIST
5872: LIST
5873: LIST
5874: PUSH
5875: LD_INT 14
5877: PUSH
5878: LD_INT 3
5880: PUSH
5881: LD_INT 100
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: LIST
5888: PUSH
5889: LD_INT 10
5891: PUSH
5892: LD_INT 3
5894: PUSH
5895: LD_INT 100
5897: PUSH
5898: EMPTY
5899: LIST
5900: LIST
5901: LIST
5902: PUSH
5903: EMPTY
5904: LIST
5905: LIST
5906: LIST
5907: LIST
5908: LIST
5909: LIST
5910: LIST
5911: LIST
5912: LIST
5913: LIST
5914: PUSH
5915: LD_INT 22
5917: PUSH
5918: LD_INT 1
5920: PUSH
5921: LD_INT 100
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: LIST
5928: PUSH
5929: LD_INT 24
5931: PUSH
5932: LD_INT 1
5934: PUSH
5935: LD_INT 100
5937: PUSH
5938: EMPTY
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 23
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 100
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: LIST
5956: PUSH
5957: LD_INT 30
5959: PUSH
5960: LD_INT 1
5962: PUSH
5963: LD_INT 100
5965: PUSH
5966: EMPTY
5967: LIST
5968: LIST
5969: LIST
5970: PUSH
5971: LD_INT 25
5973: PUSH
5974: LD_INT 2
5976: PUSH
5977: LD_INT 100
5979: PUSH
5980: EMPTY
5981: LIST
5982: LIST
5983: LIST
5984: PUSH
5985: LD_INT 27
5987: PUSH
5988: LD_INT 2
5990: PUSH
5991: LD_INT 100
5993: PUSH
5994: EMPTY
5995: LIST
5996: LIST
5997: LIST
5998: PUSH
5999: LD_INT 28
6001: PUSH
6002: LD_INT 2
6004: PUSH
6005: LD_INT 100
6007: PUSH
6008: EMPTY
6009: LIST
6010: LIST
6011: LIST
6012: PUSH
6013: LD_INT 29
6015: PUSH
6016: LD_INT 2
6018: PUSH
6019: LD_INT 100
6021: PUSH
6022: EMPTY
6023: LIST
6024: LIST
6025: LIST
6026: PUSH
6027: LD_INT 26
6029: PUSH
6030: LD_INT 2
6032: PUSH
6033: LD_INT 100
6035: PUSH
6036: EMPTY
6037: LIST
6038: LIST
6039: LIST
6040: PUSH
6041: EMPTY
6042: LIST
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: LIST
6048: LIST
6049: LIST
6050: LIST
6051: PUSH
6052: LD_INT 42
6054: PUSH
6055: LD_INT 2
6057: PUSH
6058: LD_INT 100
6060: PUSH
6061: EMPTY
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 43
6068: PUSH
6069: LD_INT 2
6071: PUSH
6072: LD_INT 100
6074: PUSH
6075: EMPTY
6076: LIST
6077: LIST
6078: LIST
6079: PUSH
6080: LD_INT 44
6082: PUSH
6083: LD_INT 2
6085: PUSH
6086: LD_INT 100
6088: PUSH
6089: EMPTY
6090: LIST
6091: LIST
6092: LIST
6093: PUSH
6094: LD_INT 45
6096: PUSH
6097: LD_INT 2
6099: PUSH
6100: LD_INT 100
6102: PUSH
6103: EMPTY
6104: LIST
6105: LIST
6106: LIST
6107: PUSH
6108: LD_INT 46
6110: PUSH
6111: LD_INT 3
6113: PUSH
6114: LD_INT 100
6116: PUSH
6117: EMPTY
6118: LIST
6119: LIST
6120: LIST
6121: PUSH
6122: LD_INT 47
6124: PUSH
6125: LD_INT 3
6127: PUSH
6128: LD_INT 100
6130: PUSH
6131: EMPTY
6132: LIST
6133: LIST
6134: LIST
6135: PUSH
6136: LD_INT 53
6138: PUSH
6139: LD_INT 3
6141: PUSH
6142: LD_INT 100
6144: PUSH
6145: EMPTY
6146: LIST
6147: LIST
6148: LIST
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: LIST
6156: LIST
6157: LIST
6158: PUSH
6159: EMPTY
6160: LIST
6161: LIST
6162: LIST
6163: ST_TO_ADDR
// end ;
6164: LD_VAR 0 1
6168: RET
// var is_tracked ; function random_vehicle ( sibrockprob ) ; var nat , wpset , suma , tmp , i , weap , wwght , wght , chs , trck ; begin
6169: LD_INT 0
6171: PPUSH
6172: PPUSH
6173: PPUSH
6174: PPUSH
6175: PPUSH
6176: PPUSH
6177: PPUSH
6178: PPUSH
6179: PPUSH
6180: PPUSH
6181: PPUSH
// nat := vehnats [ rand ( 1 , vehnats ) ] ;
6182: LD_ADDR_VAR 0 3
6186: PUSH
6187: LD_EXP 67
6191: PUSH
6192: LD_INT 1
6194: PPUSH
6195: LD_EXP 67
6199: PPUSH
6200: CALL_OW 12
6204: ARRAY
6205: ST_TO_ADDR
// if ( nat in [ nation_russian , nation_american ] ) and ( Rand ( 1 , 1000 ) <= sibrockprob ) then
6206: LD_VAR 0 3
6210: PUSH
6211: LD_INT 3
6213: PUSH
6214: LD_INT 1
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: IN
6221: PUSH
6222: LD_INT 1
6224: PPUSH
6225: LD_INT 1000
6227: PPUSH
6228: CALL_OW 12
6232: PUSH
6233: LD_VAR 0 1
6237: LESSEQUAL
6238: AND
6239: IFFALSE 6295
// begin wght := 3 ;
6241: LD_ADDR_VAR 0 10
6245: PUSH
6246: LD_INT 3
6248: ST_TO_ADDR
// case nat of nation_russian :
6249: LD_VAR 0 3
6253: PUSH
6254: LD_INT 3
6256: DOUBLE
6257: EQUAL
6258: IFTRUE 6262
6260: GO 6273
6262: POP
// weap := ru_siberium_rocket ; nation_american :
6263: LD_ADDR_VAR 0 8
6267: PUSH
6268: LD_INT 48
6270: ST_TO_ADDR
6271: GO 6293
6273: LD_INT 1
6275: DOUBLE
6276: EQUAL
6277: IFTRUE 6281
6279: GO 6292
6281: POP
// weap := us_siberium_rocket ; end ;
6282: LD_ADDR_VAR 0 8
6286: PUSH
6287: LD_INT 8
6289: ST_TO_ADDR
6290: GO 6293
6292: POP
// end else
6293: GO 6497
// begin wpset := weapons [ nat ] ;
6295: LD_ADDR_VAR 0 4
6299: PUSH
6300: LD_EXP 71
6304: PUSH
6305: LD_VAR 0 3
6309: ARRAY
6310: ST_TO_ADDR
// suma := 0 ;
6311: LD_ADDR_VAR 0 5
6315: PUSH
6316: LD_INT 0
6318: ST_TO_ADDR
// for i := 1 to wpset do
6319: LD_ADDR_VAR 0 7
6323: PUSH
6324: DOUBLE
6325: LD_INT 1
6327: DEC
6328: ST_TO_ADDR
6329: LD_VAR 0 4
6333: PUSH
6334: FOR_TO
6335: IFFALSE 6365
// suma := suma + wpset [ i ] [ 3 ] ;
6337: LD_ADDR_VAR 0 5
6341: PUSH
6342: LD_VAR 0 5
6346: PUSH
6347: LD_VAR 0 4
6351: PUSH
6352: LD_VAR 0 7
6356: ARRAY
6357: PUSH
6358: LD_INT 3
6360: ARRAY
6361: PLUS
6362: ST_TO_ADDR
6363: GO 6334
6365: POP
6366: POP
// tmp := rand ( 1 , suma ) ;
6367: LD_ADDR_VAR 0 6
6371: PUSH
6372: LD_INT 1
6374: PPUSH
6375: LD_VAR 0 5
6379: PPUSH
6380: CALL_OW 12
6384: ST_TO_ADDR
// i := 1 ;
6385: LD_ADDR_VAR 0 7
6389: PUSH
6390: LD_INT 1
6392: ST_TO_ADDR
// while wpset [ i ] [ 3 ] < tmp do
6393: LD_VAR 0 4
6397: PUSH
6398: LD_VAR 0 7
6402: ARRAY
6403: PUSH
6404: LD_INT 3
6406: ARRAY
6407: PUSH
6408: LD_VAR 0 6
6412: LESS
6413: IFFALSE 6457
// begin tmp := tmp - wpset [ i ] [ 3 ] ;
6415: LD_ADDR_VAR 0 6
6419: PUSH
6420: LD_VAR 0 6
6424: PUSH
6425: LD_VAR 0 4
6429: PUSH
6430: LD_VAR 0 7
6434: ARRAY
6435: PUSH
6436: LD_INT 3
6438: ARRAY
6439: MINUS
6440: ST_TO_ADDR
// i := i + 1 ;
6441: LD_ADDR_VAR 0 7
6445: PUSH
6446: LD_VAR 0 7
6450: PUSH
6451: LD_INT 1
6453: PLUS
6454: ST_TO_ADDR
// end ;
6455: GO 6393
// weap := wpset [ i ] [ 1 ] ;
6457: LD_ADDR_VAR 0 8
6461: PUSH
6462: LD_VAR 0 4
6466: PUSH
6467: LD_VAR 0 7
6471: ARRAY
6472: PUSH
6473: LD_INT 1
6475: ARRAY
6476: ST_TO_ADDR
// wwght := wpset [ i ] [ 2 ] ;
6477: LD_ADDR_VAR 0 9
6481: PUSH
6482: LD_VAR 0 4
6486: PUSH
6487: LD_VAR 0 7
6491: ARRAY
6492: PUSH
6493: LD_INT 2
6495: ARRAY
6496: ST_TO_ADDR
// end ; repeat trck := Rand ( 1 , 2 ) ;
6497: LD_ADDR_VAR 0 12
6501: PUSH
6502: LD_INT 1
6504: PPUSH
6505: LD_INT 2
6507: PPUSH
6508: CALL_OW 12
6512: ST_TO_ADDR
// case wwght of 3 :
6513: LD_VAR 0 9
6517: PUSH
6518: LD_INT 3
6520: DOUBLE
6521: EQUAL
6522: IFTRUE 6526
6524: GO 6537
6526: POP
// wght := 3 ; 2 :
6527: LD_ADDR_VAR 0 10
6531: PUSH
6532: LD_INT 3
6534: ST_TO_ADDR
6535: GO 6654
6537: LD_INT 2
6539: DOUBLE
6540: EQUAL
6541: IFTRUE 6545
6543: GO 6582
6545: POP
// if Rand ( 1 , 100 ) <= 80 then
6546: LD_INT 1
6548: PPUSH
6549: LD_INT 100
6551: PPUSH
6552: CALL_OW 12
6556: PUSH
6557: LD_INT 80
6559: LESSEQUAL
6560: IFFALSE 6572
// wght := 2 else
6562: LD_ADDR_VAR 0 10
6566: PUSH
6567: LD_INT 2
6569: ST_TO_ADDR
6570: GO 6580
// wght := 3 ; 1 :
6572: LD_ADDR_VAR 0 10
6576: PUSH
6577: LD_INT 3
6579: ST_TO_ADDR
6580: GO 6654
6582: LD_INT 1
6584: DOUBLE
6585: EQUAL
6586: IFTRUE 6590
6588: GO 6653
6590: POP
// if Rand ( 1 , 100 ) <= 80 then
6591: LD_INT 1
6593: PPUSH
6594: LD_INT 100
6596: PPUSH
6597: CALL_OW 12
6601: PUSH
6602: LD_INT 80
6604: LESSEQUAL
6605: IFFALSE 6617
// wght := 1 else
6607: LD_ADDR_VAR 0 10
6611: PUSH
6612: LD_INT 1
6614: ST_TO_ADDR
6615: GO 6651
// if Rand ( 1 , 100 ) <= 80 then
6617: LD_INT 1
6619: PPUSH
6620: LD_INT 100
6622: PPUSH
6623: CALL_OW 12
6627: PUSH
6628: LD_INT 80
6630: LESSEQUAL
6631: IFFALSE 6643
// wght := 2 else
6633: LD_ADDR_VAR 0 10
6637: PUSH
6638: LD_INT 2
6640: ST_TO_ADDR
6641: GO 6651
// wght := 3 ; end ;
6643: LD_ADDR_VAR 0 10
6647: PUSH
6648: LD_INT 3
6650: ST_TO_ADDR
6651: GO 6654
6653: POP
// if chassis [ nat ] [ wght ] [ trck ] then
6654: LD_EXP 70
6658: PUSH
6659: LD_VAR 0 3
6663: ARRAY
6664: PUSH
6665: LD_VAR 0 10
6669: ARRAY
6670: PUSH
6671: LD_VAR 0 12
6675: ARRAY
6676: IFFALSE 6740
// chs := chassis [ nat ] [ wght ] [ trck ] [ Rand ( 1 , chassis [ nat ] [ wght ] [ trck ] ) ] else
6678: LD_ADDR_VAR 0 11
6682: PUSH
6683: LD_EXP 70
6687: PUSH
6688: LD_VAR 0 3
6692: ARRAY
6693: PUSH
6694: LD_VAR 0 10
6698: ARRAY
6699: PUSH
6700: LD_VAR 0 12
6704: ARRAY
6705: PUSH
6706: LD_INT 1
6708: PPUSH
6709: LD_EXP 70
6713: PUSH
6714: LD_VAR 0 3
6718: ARRAY
6719: PUSH
6720: LD_VAR 0 10
6724: ARRAY
6725: PUSH
6726: LD_VAR 0 12
6730: ARRAY
6731: PPUSH
6732: CALL_OW 12
6736: ARRAY
6737: ST_TO_ADDR
6738: GO 6748
// chs := 0 ;
6740: LD_ADDR_VAR 0 11
6744: PUSH
6745: LD_INT 0
6747: ST_TO_ADDR
// until chs ;
6748: LD_VAR 0 11
6752: IFFALSE 6497
// uc_side := 0 ;
6754: LD_ADDR_OWVAR 20
6758: PUSH
6759: LD_INT 0
6761: ST_TO_ADDR
// uc_nation := nat ;
6762: LD_ADDR_OWVAR 21
6766: PUSH
6767: LD_VAR 0 3
6771: ST_TO_ADDR
// uc_direction := rand ( 0 , 5 ) ;
6772: LD_ADDR_OWVAR 24
6776: PUSH
6777: LD_INT 0
6779: PPUSH
6780: LD_INT 5
6782: PPUSH
6783: CALL_OW 12
6787: ST_TO_ADDR
// vc_chassis := chs ;
6788: LD_ADDR_OWVAR 37
6792: PUSH
6793: LD_VAR 0 11
6797: ST_TO_ADDR
// vc_weapon := weap ;
6798: LD_ADDR_OWVAR 40
6802: PUSH
6803: LD_VAR 0 8
6807: ST_TO_ADDR
// vc_control := control_manual ;
6808: LD_ADDR_OWVAR 38
6812: PUSH
6813: LD_INT 1
6815: ST_TO_ADDR
// case wght of 1 :
6816: LD_VAR 0 10
6820: PUSH
6821: LD_INT 1
6823: DOUBLE
6824: EQUAL
6825: IFTRUE 6829
6827: GO 6840
6829: POP
// vc_engine := engine_solar ; 2 , 3 :
6830: LD_ADDR_OWVAR 39
6834: PUSH
6835: LD_INT 2
6837: ST_TO_ADDR
6838: GO 6866
6840: LD_INT 2
6842: DOUBLE
6843: EQUAL
6844: IFTRUE 6854
6846: LD_INT 3
6848: DOUBLE
6849: EQUAL
6850: IFTRUE 6854
6852: GO 6865
6854: POP
// vc_engine := engine_siberite ; end ;
6855: LD_ADDR_OWVAR 39
6859: PUSH
6860: LD_INT 3
6862: ST_TO_ADDR
6863: GO 6866
6865: POP
// is_tracked := trck = 2 ;
6866: LD_ADDR_LOC 1
6870: PUSH
6871: LD_VAR 0 12
6875: PUSH
6876: LD_INT 2
6878: EQUAL
6879: ST_TO_ADDR
// end ;
6880: LD_VAR 0 2
6884: RET
// export function vehicles_create_vehicle ( atstart ) ; var v , ar ; begin
6885: LD_INT 0
6887: PPUSH
6888: PPUSH
6889: PPUSH
// if atstart then
6890: LD_VAR 0 1
6894: IFFALSE 6905
// random_vehicle ( 0 ) else
6896: LD_INT 0
6898: PPUSH
6899: CALL 6169 0 1
6903: GO 6914
// random_vehicle ( sibrock ) ;
6905: LD_EXP 68
6909: PPUSH
6910: CALL 6169 0 1
// v := CreateVehicle ;
6914: LD_ADDR_VAR 0 3
6918: PUSH
6919: CALL_OW 45
6923: ST_TO_ADDR
// if is_tracked then
6924: LD_LOC 1
6928: IFFALSE 6956
// ar := areas_tracked [ Rand ( 1 , areas_tracked ) ] else
6930: LD_ADDR_VAR 0 4
6934: PUSH
6935: LD_EXP 73
6939: PUSH
6940: LD_INT 1
6942: PPUSH
6943: LD_EXP 73
6947: PPUSH
6948: CALL_OW 12
6952: ARRAY
6953: ST_TO_ADDR
6954: GO 6980
// ar := areas_wheeled [ Rand ( 1 , areas_wheeled ) ] ;
6956: LD_ADDR_VAR 0 4
6960: PUSH
6961: LD_EXP 72
6965: PUSH
6966: LD_INT 1
6968: PPUSH
6969: LD_EXP 72
6973: PPUSH
6974: CALL_OW 12
6978: ARRAY
6979: ST_TO_ADDR
// PlaceUnitArea ( v , ar , not atstart ) ;
6980: LD_VAR 0 3
6984: PPUSH
6985: LD_VAR 0 4
6989: PPUSH
6990: LD_VAR 0 1
6994: NOT
6995: PPUSH
6996: CALL_OW 49
// end ;
7000: LD_VAR 0 2
7004: RET
// function prepare_vehicles ; var i ; begin
7005: LD_INT 0
7007: PPUSH
7008: PPUSH
// for i := 1 to startveh do
7009: LD_ADDR_VAR 0 2
7013: PUSH
7014: DOUBLE
7015: LD_INT 1
7017: DEC
7018: ST_TO_ADDR
7019: LD_EXP 63
7023: PUSH
7024: FOR_TO
7025: IFFALSE 7036
// begin vehicles_create_vehicle ( true ) ;
7027: LD_INT 1
7029: PPUSH
7030: CALL 6885 0 1
// end ;
7034: GO 7024
7036: POP
7037: POP
// end ;
7038: LD_VAR 0 1
7042: RET
// function set_attitudes ; var i , j ; begin
7043: LD_INT 0
7045: PPUSH
7046: PPUSH
7047: PPUSH
// if not Team_Game then
7048: LD_EXP 47
7052: NOT
7053: IFFALSE 7149
// begin for i = 1 to 8 do
7055: LD_ADDR_VAR 0 2
7059: PUSH
7060: DOUBLE
7061: LD_INT 1
7063: DEC
7064: ST_TO_ADDR
7065: LD_INT 8
7067: PUSH
7068: FOR_TO
7069: IFFALSE 7147
// for j = 1 to 8 do
7071: LD_ADDR_VAR 0 3
7075: PUSH
7076: DOUBLE
7077: LD_INT 1
7079: DEC
7080: ST_TO_ADDR
7081: LD_INT 8
7083: PUSH
7084: FOR_TO
7085: IFFALSE 7143
// if i <> j then
7087: LD_VAR 0 2
7091: PUSH
7092: LD_VAR 0 3
7096: NONEQUAL
7097: IFFALSE 7121
// SetAttitude ( i , j , att_enemy , true ) else
7099: LD_VAR 0 2
7103: PPUSH
7104: LD_VAR 0 3
7108: PPUSH
7109: LD_INT 2
7111: PPUSH
7112: LD_INT 1
7114: PPUSH
7115: CALL_OW 80
7119: GO 7141
// SetAttitude ( i , j , att_friend , true ) end ;
7121: LD_VAR 0 2
7125: PPUSH
7126: LD_VAR 0 3
7130: PPUSH
7131: LD_INT 1
7133: PPUSH
7134: LD_INT 1
7136: PPUSH
7137: CALL_OW 80
7141: GO 7084
7143: POP
7144: POP
7145: GO 7068
7147: POP
7148: POP
// end ;
7149: LD_VAR 0 1
7153: RET
// function prepare_side ( side ) ; var i ; begin
7154: LD_INT 0
7156: PPUSH
7157: PPUSH
// for i := 1 to npeop do
7158: LD_ADDR_VAR 0 3
7162: PUSH
7163: DOUBLE
7164: LD_INT 1
7166: DEC
7167: ST_TO_ADDR
7168: LD_EXP 65
7172: PUSH
7173: FOR_TO
7174: IFFALSE 7283
// begin uc_side := side ;
7176: LD_ADDR_OWVAR 20
7180: PUSH
7181: LD_VAR 0 1
7185: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
7186: LD_ADDR_OWVAR 21
7190: PUSH
7191: LD_EXP 44
7195: PUSH
7196: LD_VAR 0 1
7200: ARRAY
7201: ST_TO_ADDR
// hc_name :=  ;
7202: LD_ADDR_OWVAR 26
7206: PUSH
7207: LD_STRING 
7209: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
7210: LD_INT 0
7212: PPUSH
7213: LD_INT 4
7215: PPUSH
7216: CALL_OW 383
// hc_importance := 0 ;
7220: LD_ADDR_OWVAR 32
7224: PUSH
7225: LD_INT 0
7227: ST_TO_ADDR
// hc_gallery :=  ;
7228: LD_ADDR_OWVAR 33
7232: PUSH
7233: LD_STRING 
7235: ST_TO_ADDR
// PlaceUnitXYR ( CreateHuman , coordinates [ side ] [ 1 ] , coordinates [ side ] [ 2 ] , 4 , false ) ;
7236: CALL_OW 44
7240: PPUSH
7241: LD_EXP 34
7245: PUSH
7246: LD_VAR 0 1
7250: ARRAY
7251: PUSH
7252: LD_INT 1
7254: ARRAY
7255: PPUSH
7256: LD_EXP 34
7260: PUSH
7261: LD_VAR 0 1
7265: ARRAY
7266: PUSH
7267: LD_INT 2
7269: ARRAY
7270: PPUSH
7271: LD_INT 4
7273: PPUSH
7274: LD_INT 0
7276: PPUSH
7277: CALL_OW 50
// end ;
7281: GO 7173
7283: POP
7284: POP
// end ;
7285: LD_VAR 0 2
7289: RET
// function prepare_sides ; var i ; begin
7290: LD_INT 0
7292: PPUSH
7293: PPUSH
// for i := 1 to 8 do
7294: LD_ADDR_VAR 0 2
7298: PUSH
7299: DOUBLE
7300: LD_INT 1
7302: DEC
7303: ST_TO_ADDR
7304: LD_INT 8
7306: PUSH
7307: FOR_TO
7308: IFFALSE 7333
// if side_positions [ i ] then
7310: LD_EXP 43
7314: PUSH
7315: LD_VAR 0 2
7319: ARRAY
7320: IFFALSE 7331
// prepare_side ( i ) ;
7322: LD_VAR 0 2
7326: PPUSH
7327: CALL 7154 0 1
7331: GO 7307
7333: POP
7334: POP
// end ;
7335: LD_VAR 0 1
7339: RET
// export function starting_vehicles ; begin
7340: LD_INT 0
7342: PPUSH
// mp_with_score := true ;
7343: LD_ADDR_OWVAR 14
7347: PUSH
7348: LD_INT 1
7350: ST_TO_ADDR
// mp_selectmsg := true ;
7351: LD_ADDR_OWVAR 13
7355: PUSH
7356: LD_INT 1
7358: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
7359: CALL 4063 0 0
// prepare_map_coordinates ;
7363: CALL 5115 0 0
// prepare_constants ;
7367: CALL 5606 0 0
// set_attitudes ;
7371: CALL 7043 0 0
// prepare_sides ;
7375: CALL 7290 0 0
// prepare_vehicles ;
7379: CALL 7005 0 0
// SetAreaMapShow ( exitarea , 1 ) ;
7383: LD_INT 5
7385: PPUSH
7386: LD_INT 1
7388: PPUSH
7389: CALL_OW 424
// your_side := Player_Side ;
7393: LD_ADDR_OWVAR 2
7397: PUSH
7398: LD_EXP 39
7402: ST_TO_ADDR
// ResetFog ;
7403: CALL_OW 335
// AnimateTrees ( true ) ;
7407: LD_INT 1
7409: PPUSH
7410: CALL_OW 573
// music_nat := Side_Nations [ your_side ] ;
7414: LD_ADDR_OWVAR 71
7418: PUSH
7419: LD_EXP 44
7423: PUSH
7424: LD_OWVAR 2
7428: ARRAY
7429: ST_TO_ADDR
// CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
7430: LD_EXP 34
7434: PUSH
7435: LD_OWVAR 2
7439: ARRAY
7440: PUSH
7441: LD_INT 1
7443: ARRAY
7444: PPUSH
7445: LD_EXP 34
7449: PUSH
7450: LD_OWVAR 2
7454: ARRAY
7455: PUSH
7456: LD_INT 2
7458: ARRAY
7459: PPUSH
7460: CALL_OW 86
// end ; end_of_file
7464: LD_VAR 0 1
7468: RET
// every 0 0$0.5 + 2 marked 15 do var t , red ;
7469: GO 7471
7471: DISABLE
7472: LD_INT 0
7474: PPUSH
7475: PPUSH
// begin if not prep_time then
7476: LD_EXP 32
7480: NOT
7481: IFFALSE 7485
// exit ;
7483: GO 7607
// if tick >= prep_time then
7485: LD_OWVAR 1
7489: PUSH
7490: LD_EXP 32
7494: GREATEREQUAL
7495: IFFALSE 7510
// begin display_strings = [ ] ;
7497: LD_ADDR_OWVAR 47
7501: PUSH
7502: EMPTY
7503: ST_TO_ADDR
// sheherezade_start_the_fight ;
7504: CALL 3720 0 0
// end else
7508: GO 7607
// begin t = prep_time - tick ;
7510: LD_ADDR_VAR 0 1
7514: PUSH
7515: LD_EXP 32
7519: PUSH
7520: LD_OWVAR 1
7524: MINUS
7525: ST_TO_ADDR
// if t <= 0 0$5.5 then
7526: LD_VAR 0 1
7530: PUSH
7531: LD_INT 192
7533: LESSEQUAL
7534: IFFALSE 7556
// red := t mod 0 0$1 < 0 0$0.5 else
7536: LD_ADDR_VAR 0 2
7540: PUSH
7541: LD_VAR 0 1
7545: PUSH
7546: LD_INT 35
7548: MOD
7549: PUSH
7550: LD_INT 18
7552: LESS
7553: ST_TO_ADDR
7554: GO 7564
// red := false ;
7556: LD_ADDR_VAR 0 2
7560: PUSH
7561: LD_INT 0
7563: ST_TO_ADDR
// if red then
7564: LD_VAR 0 2
7568: IFFALSE 7589
// display_strings = [ #Sheherezade-Time2 , t ] else
7570: LD_ADDR_OWVAR 47
7574: PUSH
7575: LD_STRING #Sheherezade-Time2
7577: PUSH
7578: LD_VAR 0 1
7582: PUSH
7583: EMPTY
7584: LIST
7585: LIST
7586: ST_TO_ADDR
7587: GO 7606
// display_strings = [ #Sheherezade-Time1 , t ] ;
7589: LD_ADDR_OWVAR 47
7593: PUSH
7594: LD_STRING #Sheherezade-Time1
7596: PUSH
7597: LD_VAR 0 1
7601: PUSH
7602: EMPTY
7603: LIST
7604: LIST
7605: ST_TO_ADDR
// enable ;
7606: ENABLE
// end ; end ;
7607: PPOPN 2
7609: END
// every 4 marked 15 do
7610: GO 7612
7612: DISABLE
// begin if tick < prep_time then
7613: LD_OWVAR 1
7617: PUSH
7618: LD_EXP 32
7622: LESS
7623: IFFALSE 7638
// begin SetLives ( all_units , 1000 ) ;
7625: LD_OWVAR 3
7629: PPUSH
7630: LD_INT 1000
7632: PPUSH
7633: CALL_OW 234
// enable ;
7637: ENABLE
// end ; end ; end_of_file
7638: END
// on ApemanTamed ( ape , sci ) do begin if gametype = 15 then
7639: LD_EXP 1
7643: PUSH
7644: LD_INT 15
7646: EQUAL
7647: IFFALSE 7671
// begin if not def_apemen_abilities then
7649: LD_EXP 12
7653: NOT
7654: IFFALSE 7659
// disable else
7656: DISABLE
7657: GO 7671
// begin SetClass ( ape , class_apeman_soldier ) ;
7659: LD_VAR 0 1
7663: PPUSH
7664: LD_INT 15
7666: PPUSH
7667: CALL_OW 336
// end ; end ; end ;
7671: PPOPN 2
7673: END
// on UnitGoesToRed ( un ) do var killer , victim , near ;
7674: LD_INT 0
7676: PPUSH
7677: PPUSH
7678: PPUSH
// begin if gametype = 15 then
7679: LD_EXP 1
7683: PUSH
7684: LD_INT 15
7686: EQUAL
7687: IFFALSE 7912
// if un in sheherezades then
7689: LD_VAR 0 1
7693: PUSH
7694: LD_EXP 35
7698: IN
7699: IFFALSE 7912
// begin victim := GetSide ( un ) ;
7701: LD_ADDR_VAR 0 3
7705: PUSH
7706: LD_VAR 0 1
7710: PPUSH
7711: CALL_OW 255
7715: ST_TO_ADDR
// near := NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , victim ] , f_not , [ f_side , 0 ] ] ) , un ) ;
7716: LD_ADDR_VAR 0 4
7720: PUSH
7721: LD_INT 3
7723: PUSH
7724: LD_INT 22
7726: PUSH
7727: LD_VAR 0 3
7731: PUSH
7732: EMPTY
7733: LIST
7734: LIST
7735: PUSH
7736: LD_INT 3
7738: PUSH
7739: LD_INT 22
7741: PUSH
7742: LD_INT 0
7744: PUSH
7745: EMPTY
7746: LIST
7747: LIST
7748: PUSH
7749: EMPTY
7750: LIST
7751: LIST
7752: LIST
7753: LIST
7754: PPUSH
7755: CALL_OW 69
7759: PPUSH
7760: LD_VAR 0 1
7764: PPUSH
7765: CALL_OW 74
7769: ST_TO_ADDR
// killer := GetSide ( near ) ;
7770: LD_ADDR_VAR 0 2
7774: PUSH
7775: LD_VAR 0 4
7779: PPUSH
7780: CALL_OW 255
7784: ST_TO_ADDR
// if your_side and ( your_side = victim ) then
7785: LD_OWVAR 2
7789: PUSH
7790: LD_OWVAR 2
7794: PUSH
7795: LD_VAR 0 3
7799: EQUAL
7800: AND
7801: IFFALSE 7830
// begin wait ( 0 0$3 ) ;
7803: LD_INT 105
7805: PPUSH
7806: CALL_OW 67
// if not multiplayer then
7810: LD_OWVAR 4
7814: NOT
7815: IFFALSE 7826
// msg ( You Lost ) else
7817: LD_STRING You Lost
7819: PPUSH
7820: CALL_OW 100
7824: GO 7830
// YouLostInMultiplayer ;
7826: CALL_OW 107
// end ; sheherezades := Replace ( sheherezades , victim , 0 ) ;
7830: LD_ADDR_EXP 35
7834: PUSH
7835: LD_EXP 35
7839: PPUSH
7840: LD_VAR 0 3
7844: PPUSH
7845: LD_INT 0
7847: PPUSH
7848: CALL_OW 1
7852: ST_TO_ADDR
// SetSide ( FilterAllUnits ( [ f_side , victim ] ) , killer ) ;
7853: LD_INT 22
7855: PUSH
7856: LD_VAR 0 3
7860: PUSH
7861: EMPTY
7862: LIST
7863: LIST
7864: PPUSH
7865: CALL_OW 69
7869: PPUSH
7870: LD_VAR 0 2
7874: PPUSH
7875: CALL_OW 235
// ComStop ( FilterAllUnits ( [ f_side , killer ] ) ) ;
7879: LD_INT 22
7881: PUSH
7882: LD_VAR 0 2
7886: PUSH
7887: EMPTY
7888: LIST
7889: LIST
7890: PPUSH
7891: CALL_OW 69
7895: PPUSH
7896: CALL_OW 141
// SetLives ( un , 0 ) ;
7900: LD_VAR 0 1
7904: PPUSH
7905: LD_INT 0
7907: PPUSH
7908: CALL_OW 234
// end ; end ;
7912: PPOPN 4
7914: END
// on VehicleCaptured ( vehnew , vehold , origside , hum ) do begin if gametype = 25 then
7915: LD_EXP 1
7919: PUSH
7920: LD_INT 25
7922: EQUAL
7923: IFFALSE 8020
// begin if origside = 0 then
7925: LD_VAR 0 3
7929: PUSH
7930: LD_INT 0
7932: EQUAL
7933: IFFALSE 7973
// begin SetTag ( vehnew , Rand ( 30 , 75 ) ) ;
7935: LD_VAR 0 1
7939: PPUSH
7940: LD_INT 30
7942: PPUSH
7943: LD_INT 75
7945: PPUSH
7946: CALL_OW 12
7950: PPUSH
7951: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
7955: LD_ADDR_EXP 90
7959: PUSH
7960: LD_EXP 90
7964: PUSH
7965: LD_VAR 0 1
7969: ADD
7970: ST_TO_ADDR
// end else
7971: GO 8020
// begin SetUnitDisplayNumber ( vehnew , 0 ) ;
7973: LD_VAR 0 1
7977: PPUSH
7978: LD_INT 0
7980: PPUSH
7981: CALL_OW 505
// SetTag ( vehnew , GetTag ( vehold ) ) ;
7985: LD_VAR 0 1
7989: PPUSH
7990: LD_VAR 0 2
7994: PPUSH
7995: CALL_OW 110
7999: PPUSH
8000: CALL_OW 109
// to_be_countdowned := to_be_countdowned ^ vehnew ;
8004: LD_ADDR_EXP 90
8008: PUSH
8009: LD_EXP 90
8013: PUSH
8014: LD_VAR 0 1
8018: ADD
8019: ST_TO_ADDR
// end ; end end ; end_of_file
8020: PPOPN 4
8022: END
// every 0 0$1 marked 25 do var i , ends , best ;
8023: GO 8025
8025: DISABLE
8026: LD_INT 0
8028: PPUSH
8029: PPUSH
8030: PPUSH
// begin ends := false ;
8031: LD_ADDR_VAR 0 2
8035: PUSH
8036: LD_INT 0
8038: ST_TO_ADDR
// best := 0 ;
8039: LD_ADDR_VAR 0 3
8043: PUSH
8044: LD_INT 0
8046: ST_TO_ADDR
// for i := 1 to 8 do
8047: LD_ADDR_VAR 0 1
8051: PUSH
8052: DOUBLE
8053: LD_INT 1
8055: DEC
8056: ST_TO_ADDR
8057: LD_INT 8
8059: PUSH
8060: FOR_TO
8061: IFFALSE 8097
// if GetMultiScore ( i ) > best then
8063: LD_VAR 0 1
8067: PPUSH
8068: CALL_OW 507
8072: PUSH
8073: LD_VAR 0 3
8077: GREATER
8078: IFFALSE 8095
// best := GetMultiScore ( i ) ;
8080: LD_ADDR_VAR 0 3
8084: PUSH
8085: LD_VAR 0 1
8089: PPUSH
8090: CALL_OW 507
8094: ST_TO_ADDR
8095: GO 8060
8097: POP
8098: POP
// if point_limit then
8099: LD_EXP 57
8103: IFFALSE 8125
// if best > point_limit then
8105: LD_VAR 0 3
8109: PUSH
8110: LD_EXP 57
8114: GREATER
8115: IFFALSE 8125
// ends := true ;
8117: LD_ADDR_VAR 0 2
8121: PUSH
8122: LD_INT 1
8124: ST_TO_ADDR
// if game_time then
8125: LD_EXP 56
8129: IFFALSE 8151
// if game_time <= tick then
8131: LD_EXP 56
8135: PUSH
8136: LD_OWVAR 1
8140: LESSEQUAL
8141: IFFALSE 8151
// ends := true ;
8143: LD_ADDR_VAR 0 2
8147: PUSH
8148: LD_INT 1
8150: ST_TO_ADDR
// if ends then
8151: LD_VAR 0 2
8155: IFFALSE 8226
// begin if GetMultiScore ( your_side ) = best then
8157: LD_OWVAR 2
8161: PPUSH
8162: CALL_OW 507
8166: PUSH
8167: LD_VAR 0 3
8171: EQUAL
8172: IFFALSE 8200
// begin wait ( 0 0$1 ) ;
8174: LD_INT 35
8176: PPUSH
8177: CALL_OW 67
// if IAmServer then
8181: CALL_OW 518
8185: IFFALSE 8194
// wait ( 0 0$1 ) ;
8187: LD_INT 35
8189: PPUSH
8190: CALL_OW 67
// YouWinInMultiplayer ;
8194: CALL_OW 106
// end else
8198: GO 8224
// begin wait ( 0 0$1 ) ;
8200: LD_INT 35
8202: PPUSH
8203: CALL_OW 67
// if IAmServer then
8207: CALL_OW 518
8211: IFFALSE 8220
// wait ( 0 0$1 ) ;
8213: LD_INT 35
8215: PPUSH
8216: CALL_OW 67
// YouLostInMultiplayer ;
8220: CALL_OW 107
// end ; end else
8224: GO 8227
// enable ;
8226: ENABLE
// end ;
8227: PPOPN 3
8229: END
// every 0 0$3 marked 15 do var win , i ;
8230: GO 8232
8232: DISABLE
8233: LD_INT 0
8235: PPUSH
8236: PPUSH
// begin win := true ;
8237: LD_ADDR_VAR 0 1
8241: PUSH
8242: LD_INT 1
8244: ST_TO_ADDR
// for i = 1 to Side_Positions do
8245: LD_ADDR_VAR 0 2
8249: PUSH
8250: DOUBLE
8251: LD_INT 1
8253: DEC
8254: ST_TO_ADDR
8255: LD_EXP 43
8259: PUSH
8260: FOR_TO
8261: IFFALSE 8325
// if Side_Positions [ i ] and ( i <> your_side ) and MultiplayerSideAlive ( i ) then
8263: LD_EXP 43
8267: PUSH
8268: LD_VAR 0 2
8272: ARRAY
8273: PUSH
8274: LD_VAR 0 2
8278: PUSH
8279: LD_OWVAR 2
8283: NONEQUAL
8284: AND
8285: PUSH
8286: LD_VAR 0 2
8290: PPUSH
8291: CALL_OW 108
8295: AND
8296: IFFALSE 8323
// if not AlliedSides ( i , your_side ) then
8298: LD_VAR 0 2
8302: PPUSH
8303: LD_OWVAR 2
8307: PPUSH
8308: CALL 8363 0 2
8312: NOT
8313: IFFALSE 8323
// win := false ;
8315: LD_ADDR_VAR 0 1
8319: PUSH
8320: LD_INT 0
8322: ST_TO_ADDR
8323: GO 8260
8325: POP
8326: POP
// if win then
8327: LD_VAR 0 1
8331: IFFALSE 8359
// begin wait ( 0 0$3 ) ;
8333: LD_INT 105
8335: PPUSH
8336: CALL_OW 67
// YouWinInMultiplayer ;
8340: CALL_OW 106
// if IAmServer then
8344: CALL_OW 518
8348: IFFALSE 8357
// wait ( 0 0$1 ) ;
8350: LD_INT 35
8352: PPUSH
8353: CALL_OW 67
// exit ;
8357: GO 8360
// end ; enable ;
8359: ENABLE
// end ;
8360: PPOPN 2
8362: END
// function AlliedSides ( i , j ) ; var vysledek ; begin
8363: LD_INT 0
8365: PPUSH
8366: PPUSH
// vysledek := false ;
8367: LD_ADDR_VAR 0 4
8371: PUSH
8372: LD_INT 0
8374: ST_TO_ADDR
// if ( GetAttitude ( i , j ) = att_friend ) and ( GetAttitude ( j , i ) = att_friend ) and GetAlliedVictory ( i ) and GetAlliedVictory ( j ) then
8375: LD_VAR 0 1
8379: PPUSH
8380: LD_VAR 0 2
8384: PPUSH
8385: CALL_OW 81
8389: PUSH
8390: LD_INT 1
8392: EQUAL
8393: PUSH
8394: LD_VAR 0 2
8398: PPUSH
8399: LD_VAR 0 1
8403: PPUSH
8404: CALL_OW 81
8408: PUSH
8409: LD_INT 1
8411: EQUAL
8412: AND
8413: PUSH
8414: LD_VAR 0 1
8418: PPUSH
8419: CALL_OW 83
8423: AND
8424: PUSH
8425: LD_VAR 0 2
8429: PPUSH
8430: CALL_OW 83
8434: AND
8435: IFFALSE 8445
// vysledek := true ;
8437: LD_ADDR_VAR 0 4
8441: PUSH
8442: LD_INT 1
8444: ST_TO_ADDR
// result := vysledek ;
8445: LD_ADDR_VAR 0 3
8449: PUSH
8450: LD_VAR 0 4
8454: ST_TO_ADDR
// end ; end_of_file
8455: LD_VAR 0 3
8459: RET
// export def_hunters , def_hunt_size , def_hunt_balance , def_hunt_limit , def_doctors ; export one_hunter , hunt_limit , size_of_ape_team , size_of_hunt_team , doctors_in_team , hunter_level , ape_level , ape_stamina , to_be_alone , people , scorestring ; function read_multiplayer_and_game_parameters ; var i , p1 , p2 ; begin
8460: LD_INT 0
8462: PPUSH
8463: PPUSH
8464: PPUSH
8465: PPUSH
// if MultiPlayer then
8466: LD_OWVAR 4
8470: IFFALSE 8534
// begin Player_Side = mp_player_side ;
8472: LD_ADDR_EXP 39
8476: PUSH
8477: LD_OWVAR 7
8481: ST_TO_ADDR
// Player_Team = mp_player_team ;
8482: LD_ADDR_EXP 40
8486: PUSH
8487: LD_OWVAR 8
8491: ST_TO_ADDR
// Side_Positions = mp_sides_positions ;
8492: LD_ADDR_EXP 43
8496: PUSH
8497: LD_OWVAR 17
8501: ST_TO_ADDR
// Side_Teams = mp_sides_teams ;
8502: LD_ADDR_EXP 41
8506: PUSH
8507: LD_OWVAR 15
8511: ST_TO_ADDR
// Side_Nations = mp_sides_nations ;
8512: LD_ADDR_EXP 44
8516: PUSH
8517: LD_OWVAR 16
8521: ST_TO_ADDR
// Teams = mp_teams ;
8522: LD_ADDR_EXP 42
8526: PUSH
8527: LD_OWVAR 12
8531: ST_TO_ADDR
// end else
8532: GO 8678
// begin randomize ;
8534: CALL_OW 10
// Player_Side = 1 ;
8538: LD_ADDR_EXP 39
8542: PUSH
8543: LD_INT 1
8545: ST_TO_ADDR
// Player_Team = 0 ;
8546: LD_ADDR_EXP 40
8550: PUSH
8551: LD_INT 0
8553: ST_TO_ADDR
// Side_Positions = [ 1 , 3 , 6 , 0 , 0 , 0 , 0 , 7 ] ;
8554: LD_ADDR_EXP 43
8558: PUSH
8559: LD_INT 1
8561: PUSH
8562: LD_INT 3
8564: PUSH
8565: LD_INT 6
8567: PUSH
8568: LD_INT 0
8570: PUSH
8571: LD_INT 0
8573: PUSH
8574: LD_INT 0
8576: PUSH
8577: LD_INT 0
8579: PUSH
8580: LD_INT 7
8582: PUSH
8583: EMPTY
8584: LIST
8585: LIST
8586: LIST
8587: LIST
8588: LIST
8589: LIST
8590: LIST
8591: LIST
8592: ST_TO_ADDR
// Side_Teams = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ;
8593: LD_ADDR_EXP 41
8597: PUSH
8598: LD_INT 0
8600: PUSH
8601: LD_INT 0
8603: PUSH
8604: LD_INT 0
8606: PUSH
8607: LD_INT 0
8609: PUSH
8610: LD_INT 0
8612: PUSH
8613: LD_INT 0
8615: PUSH
8616: LD_INT 0
8618: PUSH
8619: LD_INT 0
8621: PUSH
8622: EMPTY
8623: LIST
8624: LIST
8625: LIST
8626: LIST
8627: LIST
8628: LIST
8629: LIST
8630: LIST
8631: ST_TO_ADDR
// Side_Nations = [ 1 , 3 , 1 , 2 , 2 , 2 , 2 , 2 ] ;
8632: LD_ADDR_EXP 44
8636: PUSH
8637: LD_INT 1
8639: PUSH
8640: LD_INT 3
8642: PUSH
8643: LD_INT 1
8645: PUSH
8646: LD_INT 2
8648: PUSH
8649: LD_INT 2
8651: PUSH
8652: LD_INT 2
8654: PUSH
8655: LD_INT 2
8657: PUSH
8658: LD_INT 2
8660: PUSH
8661: EMPTY
8662: LIST
8663: LIST
8664: LIST
8665: LIST
8666: LIST
8667: LIST
8668: LIST
8669: LIST
8670: ST_TO_ADDR
// Teams = [ ] ;
8671: LD_ADDR_EXP 42
8675: PUSH
8676: EMPTY
8677: ST_TO_ADDR
// end ; Side_Count = ( Side_Positions diff [ 0 ] ) + 0 ;
8678: LD_ADDR_EXP 37
8682: PUSH
8683: LD_EXP 43
8687: PUSH
8688: LD_INT 0
8690: PUSH
8691: EMPTY
8692: LIST
8693: DIFF
8694: PUSH
8695: LD_INT 0
8697: PLUS
8698: ST_TO_ADDR
// Team_Count = ( Side_Teams diff [ 0 ] ) + 0 ;
8699: LD_ADDR_EXP 38
8703: PUSH
8704: LD_EXP 41
8708: PUSH
8709: LD_INT 0
8711: PUSH
8712: EMPTY
8713: LIST
8714: DIFF
8715: PUSH
8716: LD_INT 0
8718: PLUS
8719: ST_TO_ADDR
// if MultiPlayer then
8720: LD_OWVAR 4
8724: IFFALSE 8780
// begin def_hunt_size = GetMultiplayerSetting ( 1 ) ;
8726: LD_ADDR_EXP 75
8730: PUSH
8731: LD_INT 1
8733: PPUSH
8734: CALL_OW 426
8738: ST_TO_ADDR
// def_hunt_balance = GetMultiplayerSetting ( 2 ) ;
8739: LD_ADDR_EXP 76
8743: PUSH
8744: LD_INT 2
8746: PPUSH
8747: CALL_OW 426
8751: ST_TO_ADDR
// def_hunt_limit = GetMultiplayerSetting ( 3 ) ;
8752: LD_ADDR_EXP 77
8756: PUSH
8757: LD_INT 3
8759: PPUSH
8760: CALL_OW 426
8764: ST_TO_ADDR
// def_doctors = GetMultiplayerSetting ( 4 ) ;
8765: LD_ADDR_EXP 78
8769: PUSH
8770: LD_INT 4
8772: PPUSH
8773: CALL_OW 426
8777: ST_TO_ADDR
// end else
8778: GO 8816
// begin randomize ;
8780: CALL_OW 10
// def_hunt_size = 1 ;
8784: LD_ADDR_EXP 75
8788: PUSH
8789: LD_INT 1
8791: ST_TO_ADDR
// def_hunt_balance = 1 ;
8792: LD_ADDR_EXP 76
8796: PUSH
8797: LD_INT 1
8799: ST_TO_ADDR
// def_hunt_limit = 1 ;
8800: LD_ADDR_EXP 77
8804: PUSH
8805: LD_INT 1
8807: ST_TO_ADDR
// def_doctors = 1 ;
8808: LD_ADDR_EXP 78
8812: PUSH
8813: LD_INT 1
8815: ST_TO_ADDR
// end ; one_hunter = gametype = 36 ;
8816: LD_ADDR_EXP 79
8820: PUSH
8821: LD_EXP 1
8825: PUSH
8826: LD_INT 36
8828: EQUAL
8829: ST_TO_ADDR
// if one_hunter then
8830: LD_EXP 79
8834: IFFALSE 9107
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
8836: LD_ADDR_EXP 80
8840: PUSH
8841: LD_INT 4200
8843: PUSH
8844: LD_INT 6300
8846: PUSH
8847: LD_INT 8400
8849: PUSH
8850: LD_INT 10500
8852: PUSH
8853: EMPTY
8854: LIST
8855: LIST
8856: LIST
8857: LIST
8858: PUSH
8859: LD_EXP 77
8863: PUSH
8864: LD_INT 1
8866: PLUS
8867: ARRAY
8868: ST_TO_ADDR
// p1 = [ 6 , 10 , 12 ] [ def_hunt_size + 1 ] ;
8869: LD_ADDR_VAR 0 3
8873: PUSH
8874: LD_INT 6
8876: PUSH
8877: LD_INT 10
8879: PUSH
8880: LD_INT 12
8882: PUSH
8883: EMPTY
8884: LIST
8885: LIST
8886: LIST
8887: PUSH
8888: LD_EXP 75
8892: PUSH
8893: LD_INT 1
8895: PLUS
8896: ARRAY
8897: ST_TO_ADDR
// p2 = [ 2 , 4 , 6 ] [ def_hunt_size + 1 ] ;
8898: LD_ADDR_VAR 0 4
8902: PUSH
8903: LD_INT 2
8905: PUSH
8906: LD_INT 4
8908: PUSH
8909: LD_INT 6
8911: PUSH
8912: EMPTY
8913: LIST
8914: LIST
8915: LIST
8916: PUSH
8917: LD_EXP 75
8921: PUSH
8922: LD_INT 1
8924: PLUS
8925: ARRAY
8926: ST_TO_ADDR
// size_of_ape_team = p1 div side_count + p2 ;
8927: LD_ADDR_EXP 81
8931: PUSH
8932: LD_VAR 0 3
8936: PUSH
8937: LD_EXP 37
8941: DIV
8942: PUSH
8943: LD_VAR 0 4
8947: PLUS
8948: ST_TO_ADDR
// size_of_hunt_team = size_of_ape_team * ( side_count - 1 ) ;
8949: LD_ADDR_EXP 82
8953: PUSH
8954: LD_EXP 81
8958: PUSH
8959: LD_EXP 37
8963: PUSH
8964: LD_INT 1
8966: MINUS
8967: MUL
8968: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
8969: LD_ADDR_EXP 83
8973: PUSH
8974: LD_INT 0
8976: PUSH
8977: LD_EXP 82
8981: PUSH
8982: LD_INT 5
8984: PLUS
8985: PUSH
8986: LD_INT 6
8988: DIV
8989: PUSH
8990: LD_EXP 82
8994: PUSH
8995: LD_INT 3
8997: PLUS
8998: PUSH
8999: LD_INT 4
9001: DIV
9002: PUSH
9003: EMPTY
9004: LIST
9005: LIST
9006: LIST
9007: PUSH
9008: LD_EXP 78
9012: PUSH
9013: LD_INT 1
9015: PLUS
9016: ARRAY
9017: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
9018: LD_ADDR_EXP 84
9022: PUSH
9023: LD_INT 5
9025: PUSH
9026: LD_INT 3
9028: PUSH
9029: LD_INT 1
9031: PUSH
9032: EMPTY
9033: LIST
9034: LIST
9035: LIST
9036: PUSH
9037: LD_EXP 76
9041: PUSH
9042: LD_INT 1
9044: PLUS
9045: ARRAY
9046: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9047: LD_ADDR_EXP 85
9051: PUSH
9052: LD_INT 1
9054: PUSH
9055: LD_INT 2
9057: PUSH
9058: LD_INT 3
9060: PUSH
9061: EMPTY
9062: LIST
9063: LIST
9064: LIST
9065: PUSH
9066: LD_EXP 76
9070: PUSH
9071: LD_INT 1
9073: PLUS
9074: ARRAY
9075: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9076: LD_ADDR_EXP 86
9080: PUSH
9081: LD_INT 6
9083: PUSH
9084: LD_INT 10
9086: PUSH
9087: LD_INT 13
9089: PUSH
9090: EMPTY
9091: LIST
9092: LIST
9093: LIST
9094: PUSH
9095: LD_EXP 76
9099: PUSH
9100: LD_INT 1
9102: PLUS
9103: ARRAY
9104: ST_TO_ADDR
// end else
9105: GO 9386
// begin hunt_limit = [ 2 2$0 , 3 3$0 , 4 4$0 , 5 5$0 ] [ def_hunt_limit + 1 ] ;
9107: LD_ADDR_EXP 80
9111: PUSH
9112: LD_INT 4200
9114: PUSH
9115: LD_INT 6300
9117: PUSH
9118: LD_INT 8400
9120: PUSH
9121: LD_INT 10500
9123: PUSH
9124: EMPTY
9125: LIST
9126: LIST
9127: LIST
9128: LIST
9129: PUSH
9130: LD_EXP 77
9134: PUSH
9135: LD_INT 1
9137: PLUS
9138: ARRAY
9139: ST_TO_ADDR
// p1 = [ 10 , 15 , 20 ] [ def_hunt_size + 1 ] ;
9140: LD_ADDR_VAR 0 3
9144: PUSH
9145: LD_INT 10
9147: PUSH
9148: LD_INT 15
9150: PUSH
9151: LD_INT 20
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: LIST
9158: PUSH
9159: LD_EXP 75
9163: PUSH
9164: LD_INT 1
9166: PLUS
9167: ARRAY
9168: ST_TO_ADDR
// p2 = [ 3 , 5 , 7 ] [ def_hunt_size + 1 ] ;
9169: LD_ADDR_VAR 0 4
9173: PUSH
9174: LD_INT 3
9176: PUSH
9177: LD_INT 5
9179: PUSH
9180: LD_INT 7
9182: PUSH
9183: EMPTY
9184: LIST
9185: LIST
9186: LIST
9187: PUSH
9188: LD_EXP 75
9192: PUSH
9193: LD_INT 1
9195: PLUS
9196: ARRAY
9197: ST_TO_ADDR
// size_of_hunt_team = p1 div side_count + p2 ;
9198: LD_ADDR_EXP 82
9202: PUSH
9203: LD_VAR 0 3
9207: PUSH
9208: LD_EXP 37
9212: DIV
9213: PUSH
9214: LD_VAR 0 4
9218: PLUS
9219: ST_TO_ADDR
// size_of_ape_team = ( size_of_hunt_team + size_of_hunt_team * ( side_count - 1 ) ) div 2 ;
9220: LD_ADDR_EXP 81
9224: PUSH
9225: LD_EXP 82
9229: PUSH
9230: LD_EXP 82
9234: PUSH
9235: LD_EXP 37
9239: PUSH
9240: LD_INT 1
9242: MINUS
9243: MUL
9244: PLUS
9245: PUSH
9246: LD_INT 2
9248: DIV
9249: ST_TO_ADDR
// doctors_in_team = [ 0 , ( size_of_hunt_team + 5 ) div 6 , ( size_of_hunt_team + 3 ) div 4 ] [ def_doctors + 1 ] ;
9250: LD_ADDR_EXP 83
9254: PUSH
9255: LD_INT 0
9257: PUSH
9258: LD_EXP 82
9262: PUSH
9263: LD_INT 5
9265: PLUS
9266: PUSH
9267: LD_INT 6
9269: DIV
9270: PUSH
9271: LD_EXP 82
9275: PUSH
9276: LD_INT 3
9278: PLUS
9279: PUSH
9280: LD_INT 4
9282: DIV
9283: PUSH
9284: EMPTY
9285: LIST
9286: LIST
9287: LIST
9288: PUSH
9289: LD_EXP 78
9293: PUSH
9294: LD_INT 1
9296: PLUS
9297: ARRAY
9298: ST_TO_ADDR
// hunter_level = [ 5 , 3 , 1 ] [ def_hunt_balance + 1 ] ;
9299: LD_ADDR_EXP 84
9303: PUSH
9304: LD_INT 5
9306: PUSH
9307: LD_INT 3
9309: PUSH
9310: LD_INT 1
9312: PUSH
9313: EMPTY
9314: LIST
9315: LIST
9316: LIST
9317: PUSH
9318: LD_EXP 76
9322: PUSH
9323: LD_INT 1
9325: PLUS
9326: ARRAY
9327: ST_TO_ADDR
// ape_level = [ 1 , 2 , 3 ] [ def_hunt_balance + 1 ] ;
9328: LD_ADDR_EXP 85
9332: PUSH
9333: LD_INT 1
9335: PUSH
9336: LD_INT 2
9338: PUSH
9339: LD_INT 3
9341: PUSH
9342: EMPTY
9343: LIST
9344: LIST
9345: LIST
9346: PUSH
9347: LD_EXP 76
9351: PUSH
9352: LD_INT 1
9354: PLUS
9355: ARRAY
9356: ST_TO_ADDR
// ape_stamina = [ 6 , 10 , 13 ] [ def_hunt_balance + 1 ] ;
9357: LD_ADDR_EXP 86
9361: PUSH
9362: LD_INT 6
9364: PUSH
9365: LD_INT 10
9367: PUSH
9368: LD_INT 13
9370: PUSH
9371: EMPTY
9372: LIST
9373: LIST
9374: LIST
9375: PUSH
9376: LD_EXP 76
9380: PUSH
9381: LD_INT 1
9383: PLUS
9384: ARRAY
9385: ST_TO_ADDR
// end ; for i = 1 to 8 do
9386: LD_ADDR_VAR 0 2
9390: PUSH
9391: DOUBLE
9392: LD_INT 1
9394: DEC
9395: ST_TO_ADDR
9396: LD_INT 8
9398: PUSH
9399: FOR_TO
9400: IFFALSE 9432
// if Side_Positions [ i ] then
9402: LD_EXP 43
9406: PUSH
9407: LD_VAR 0 2
9411: ARRAY
9412: IFFALSE 9430
// to_be_alone := to_be_alone ^ i ;
9414: LD_ADDR_EXP 87
9418: PUSH
9419: LD_EXP 87
9423: PUSH
9424: LD_VAR 0 2
9428: ADD
9429: ST_TO_ADDR
9430: GO 9399
9432: POP
9433: POP
// end ;
9434: LD_VAR 0 1
9438: RET
// function prepare_hunter_team ( side ) ; var i , team ; begin
9439: LD_INT 0
9441: PPUSH
9442: PPUSH
9443: PPUSH
// team := [ ] ;
9444: LD_ADDR_VAR 0 4
9448: PUSH
9449: EMPTY
9450: ST_TO_ADDR
// for i := 1 to size_of_hunt_team do
9451: LD_ADDR_VAR 0 3
9455: PUSH
9456: DOUBLE
9457: LD_INT 1
9459: DEC
9460: ST_TO_ADDR
9461: LD_EXP 82
9465: PUSH
9466: FOR_TO
9467: IFFALSE 9584
// begin uc_nation := side_nations [ side ] ;
9469: LD_ADDR_OWVAR 21
9473: PUSH
9474: LD_EXP 44
9478: PUSH
9479: LD_VAR 0 1
9483: ARRAY
9484: ST_TO_ADDR
// uc_side := side ;
9485: LD_ADDR_OWVAR 20
9489: PUSH
9490: LD_VAR 0 1
9494: ST_TO_ADDR
// hc_name :=  ;
9495: LD_ADDR_OWVAR 26
9499: PUSH
9500: LD_STRING 
9502: ST_TO_ADDR
// if i > size_of_hunt_team - doctors_in_team then
9503: LD_VAR 0 3
9507: PUSH
9508: LD_EXP 82
9512: PUSH
9513: LD_EXP 83
9517: MINUS
9518: GREATER
9519: IFFALSE 9535
// PrepareScientist ( 0 , hunter_level ) else
9521: LD_INT 0
9523: PPUSH
9524: LD_EXP 84
9528: PPUSH
9529: CALL_OW 384
9533: GO 9547
// PrepareSoldier ( 0 , hunter_level ) ;
9535: LD_INT 0
9537: PPUSH
9538: LD_EXP 84
9542: PPUSH
9543: CALL_OW 381
// hc_gallery :=  ;
9547: LD_ADDR_OWVAR 33
9551: PUSH
9552: LD_STRING 
9554: ST_TO_ADDR
// hc_importance := 0 ;
9555: LD_ADDR_OWVAR 32
9559: PUSH
9560: LD_INT 0
9562: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9563: LD_ADDR_VAR 0 4
9567: PUSH
9568: LD_VAR 0 4
9572: PUSH
9573: CALL_OW 44
9577: PUSH
9578: EMPTY
9579: LIST
9580: ADD
9581: ST_TO_ADDR
// end ;
9582: GO 9466
9584: POP
9585: POP
// people := Replace ( people , side , team ) ;
9586: LD_ADDR_EXP 88
9590: PUSH
9591: LD_EXP 88
9595: PPUSH
9596: LD_VAR 0 1
9600: PPUSH
9601: LD_VAR 0 4
9605: PPUSH
9606: CALL_OW 1
9610: ST_TO_ADDR
// end ;
9611: LD_VAR 0 2
9615: RET
// function prepare_ape_team ( side ) ; var i , team ; begin
9616: LD_INT 0
9618: PPUSH
9619: PPUSH
9620: PPUSH
// team := [ ] ;
9621: LD_ADDR_VAR 0 4
9625: PUSH
9626: EMPTY
9627: ST_TO_ADDR
// for i := 1 to size_of_ape_team do
9628: LD_ADDR_VAR 0 3
9632: PUSH
9633: DOUBLE
9634: LD_INT 1
9636: DEC
9637: ST_TO_ADDR
9638: LD_EXP 81
9642: PUSH
9643: FOR_TO
9644: IFFALSE 9767
// begin uc_nation := nation_nature ;
9646: LD_ADDR_OWVAR 21
9650: PUSH
9651: LD_INT 0
9653: ST_TO_ADDR
// uc_side := side ;
9654: LD_ADDR_OWVAR 20
9658: PUSH
9659: LD_VAR 0 1
9663: ST_TO_ADDR
// hc_name :=  ;
9664: LD_ADDR_OWVAR 26
9668: PUSH
9669: LD_STRING 
9671: ST_TO_ADDR
// hc_attr := [ ape_stamina , 14 ] ;
9672: LD_ADDR_OWVAR 29
9676: PUSH
9677: LD_EXP 86
9681: PUSH
9682: LD_INT 14
9684: PUSH
9685: EMPTY
9686: LIST
9687: LIST
9688: ST_TO_ADDR
// hc_skills := [ ape_level , 0 , 0 , 0 ] ;
9689: LD_ADDR_OWVAR 31
9693: PUSH
9694: LD_EXP 85
9698: PUSH
9699: LD_INT 0
9701: PUSH
9702: LD_INT 0
9704: PUSH
9705: LD_INT 0
9707: PUSH
9708: EMPTY
9709: LIST
9710: LIST
9711: LIST
9712: LIST
9713: ST_TO_ADDR
// hc_sex := sex_male ;
9714: LD_ADDR_OWVAR 27
9718: PUSH
9719: LD_INT 1
9721: ST_TO_ADDR
// hc_class := class_apeman ;
9722: LD_ADDR_OWVAR 28
9726: PUSH
9727: LD_INT 12
9729: ST_TO_ADDR
// hc_gallery :=  ;
9730: LD_ADDR_OWVAR 33
9734: PUSH
9735: LD_STRING 
9737: ST_TO_ADDR
// hc_importance := 0 ;
9738: LD_ADDR_OWVAR 32
9742: PUSH
9743: LD_INT 0
9745: ST_TO_ADDR
// team := team ^ [ CreateHuman ] ;
9746: LD_ADDR_VAR 0 4
9750: PUSH
9751: LD_VAR 0 4
9755: PUSH
9756: CALL_OW 44
9760: PUSH
9761: EMPTY
9762: LIST
9763: ADD
9764: ST_TO_ADDR
// end ;
9765: GO 9643
9767: POP
9768: POP
// people := Replace ( people , side , team ) ;
9769: LD_ADDR_EXP 88
9773: PUSH
9774: LD_EXP 88
9778: PPUSH
9779: LD_VAR 0 1
9783: PPUSH
9784: LD_VAR 0 4
9788: PPUSH
9789: CALL_OW 1
9793: ST_TO_ADDR
// end ;
9794: LD_VAR 0 2
9798: RET
// function display_score ( alone , t ) ; begin
9799: LD_INT 0
9801: PPUSH
// display_strings := scorestring ^  ;
9802: LD_ADDR_OWVAR 47
9806: PUSH
9807: LD_EXP 89
9811: PUSH
9812: LD_STRING 
9814: ADD
9815: ST_TO_ADDR
// if alone then
9816: LD_VAR 0 1
9820: IFFALSE 9900
// if one_hunter then
9822: LD_EXP 79
9826: IFFALSE 9865
// display_strings := display_strings ^ [ #Hunt-prepare2 , alone , alone , t ] else
9828: LD_ADDR_OWVAR 47
9832: PUSH
9833: LD_OWVAR 47
9837: PUSH
9838: LD_STRING #Hunt-prepare2
9840: PUSH
9841: LD_VAR 0 1
9845: PUSH
9846: LD_VAR 0 1
9850: PUSH
9851: LD_VAR 0 2
9855: PUSH
9856: EMPTY
9857: LIST
9858: LIST
9859: LIST
9860: LIST
9861: ADD
9862: ST_TO_ADDR
9863: GO 9900
// display_strings := display_strings ^ [ #Hunt-prepare1 , alone , alone , t ] ;
9865: LD_ADDR_OWVAR 47
9869: PUSH
9870: LD_OWVAR 47
9874: PUSH
9875: LD_STRING #Hunt-prepare1
9877: PUSH
9878: LD_VAR 0 1
9882: PUSH
9883: LD_VAR 0 1
9887: PUSH
9888: LD_VAR 0 2
9892: PUSH
9893: EMPTY
9894: LIST
9895: LIST
9896: LIST
9897: LIST
9898: ADD
9899: ST_TO_ADDR
// end ;
9900: LD_VAR 0 3
9904: RET
// function set_attitudes ( alone ) ; var i , j ; begin
9905: LD_INT 0
9907: PPUSH
9908: PPUSH
9909: PPUSH
// for i := 1 to 8 do
9910: LD_ADDR_VAR 0 3
9914: PUSH
9915: DOUBLE
9916: LD_INT 1
9918: DEC
9919: ST_TO_ADDR
9920: LD_INT 8
9922: PUSH
9923: FOR_TO
9924: IFFALSE 10014
// for j := 1 to 8 do
9926: LD_ADDR_VAR 0 4
9930: PUSH
9931: DOUBLE
9932: LD_INT 1
9934: DEC
9935: ST_TO_ADDR
9936: LD_INT 8
9938: PUSH
9939: FOR_TO
9940: IFFALSE 10010
// if ( i = alone ) = ( j = alone ) then
9942: LD_VAR 0 3
9946: PUSH
9947: LD_VAR 0 1
9951: EQUAL
9952: PUSH
9953: LD_VAR 0 4
9957: PUSH
9958: LD_VAR 0 1
9962: EQUAL
9963: EQUAL
9964: IFFALSE 9988
// SetAttitude ( i , j , att_friend , true ) else
9966: LD_VAR 0 3
9970: PPUSH
9971: LD_VAR 0 4
9975: PPUSH
9976: LD_INT 1
9978: PPUSH
9979: LD_INT 1
9981: PPUSH
9982: CALL_OW 80
9986: GO 10008
// SetAttitude ( i , j , att_enemy , true ) ;
9988: LD_VAR 0 3
9992: PPUSH
9993: LD_VAR 0 4
9997: PPUSH
9998: LD_INT 2
10000: PPUSH
10001: LD_INT 1
10003: PPUSH
10004: CALL_OW 80
10008: GO 9939
10010: POP
10011: POP
10012: GO 9923
10014: POP
10015: POP
// end ;
10016: LD_VAR 0 2
10020: RET
// function set_technologies ( alone ) ; var i ; begin
10021: LD_INT 0
10023: PPUSH
10024: PPUSH
// for i := 1 to 8 do
10025: LD_ADDR_VAR 0 3
10029: PUSH
10030: DOUBLE
10031: LD_INT 1
10033: DEC
10034: ST_TO_ADDR
10035: LD_INT 8
10037: PUSH
10038: FOR_TO
10039: IFFALSE 10228
// begin if ( alone = i ) = one_hunter then
10041: LD_VAR 0 1
10045: PUSH
10046: LD_VAR 0 3
10050: EQUAL
10051: PUSH
10052: LD_EXP 79
10056: EQUAL
10057: IFFALSE 10121
// begin SetTech ( tech_Opto1 , i , state_disabled ) ;
10059: LD_INT 60
10061: PPUSH
10062: LD_VAR 0 3
10066: PPUSH
10067: LD_INT 0
10069: PPUSH
10070: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_disabled ) ;
10074: LD_INT 61
10076: PPUSH
10077: LD_VAR 0 3
10081: PPUSH
10082: LD_INT 0
10084: PPUSH
10085: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_disabled ) ;
10089: LD_INT 62
10091: PPUSH
10092: LD_VAR 0 3
10096: PPUSH
10097: LD_INT 0
10099: PPUSH
10100: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_disabled ) ;
10104: LD_INT 5
10106: PPUSH
10107: LD_VAR 0 3
10111: PPUSH
10112: LD_INT 0
10114: PPUSH
10115: CALL_OW 322
// end else
10119: GO 10181
// begin SetTech ( tech_Opto1 , i , state_researched ) ;
10121: LD_INT 60
10123: PPUSH
10124: LD_VAR 0 3
10128: PPUSH
10129: LD_INT 2
10131: PPUSH
10132: CALL_OW 322
// SetTech ( tech_Opto2 , i , state_researched ) ;
10136: LD_INT 61
10138: PPUSH
10139: LD_VAR 0 3
10143: PPUSH
10144: LD_INT 2
10146: PPUSH
10147: CALL_OW 322
// SetTech ( tech_Opto3 , i , state_researched ) ;
10151: LD_INT 62
10153: PPUSH
10154: LD_VAR 0 3
10158: PPUSH
10159: LD_INT 2
10161: PPUSH
10162: CALL_OW 322
// SetTech ( tech_StimDrugs , i , state_researched ) ;
10166: LD_INT 5
10168: PPUSH
10169: LD_VAR 0 3
10173: PPUSH
10174: LD_INT 2
10176: PPUSH
10177: CALL_OW 322
// end ; SetTech ( tech_Weap1 , i , state_disabled ) ;
10181: LD_INT 51
10183: PPUSH
10184: LD_VAR 0 3
10188: PPUSH
10189: LD_INT 0
10191: PPUSH
10192: CALL_OW 322
// SetTech ( tech_Weap2 , i , state_disabled ) ;
10196: LD_INT 52
10198: PPUSH
10199: LD_VAR 0 3
10203: PPUSH
10204: LD_INT 0
10206: PPUSH
10207: CALL_OW 322
// SetTech ( tech_Weap3 , i , state_disabled ) ;
10211: LD_INT 53
10213: PPUSH
10214: LD_VAR 0 3
10218: PPUSH
10219: LD_INT 0
10221: PPUSH
10222: CALL_OW 322
// end ;
10226: GO 10038
10228: POP
10229: POP
// end ;
10230: LD_VAR 0 2
10234: RET
// function prepare_map_coordinates_more_hunters ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10235: LD_INT 0
10237: PPUSH
10238: PPUSH
10239: PPUSH
10240: PPUSH
10241: PPUSH
10242: PPUSH
10243: PPUSH
10244: PPUSH
// best = 0 ;
10245: LD_ADDR_VAR 0 3
10249: PUSH
10250: LD_INT 0
10252: ST_TO_ADDR
// for n = 1 to 40 do
10253: LD_ADDR_VAR 0 9
10257: PUSH
10258: DOUBLE
10259: LD_INT 1
10261: DEC
10262: ST_TO_ADDR
10263: LD_INT 40
10265: PUSH
10266: FOR_TO
10267: IFFALSE 10575
// begin c = [ ] ;
10269: LD_ADDR_VAR 0 4
10273: PUSH
10274: EMPTY
10275: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10276: LD_ADDR_VAR 0 7
10280: PUSH
10281: DOUBLE
10282: LD_INT 1
10284: DEC
10285: ST_TO_ADDR
10286: LD_EXP 37
10290: PUSH
10291: LD_INT 1
10293: MINUS
10294: PUSH
10295: FOR_TO
10296: IFFALSE 10325
// c := c ^ [ RandHexArea ( arstartveh , false ) ] ;
10298: LD_ADDR_VAR 0 4
10302: PUSH
10303: LD_VAR 0 4
10307: PUSH
10308: LD_INT 22
10310: PPUSH
10311: LD_INT 0
10313: PPUSH
10314: CALL_OW 16
10318: PUSH
10319: EMPTY
10320: LIST
10321: ADD
10322: ST_TO_ADDR
10323: GO 10295
10325: POP
10326: POP
// minv = 10000 ;
10327: LD_ADDR_VAR 0 6
10331: PUSH
10332: LD_INT 10000
10334: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10335: LD_ADDR_VAR 0 7
10339: PUSH
10340: DOUBLE
10341: LD_INT 1
10343: DEC
10344: ST_TO_ADDR
10345: LD_EXP 37
10349: PUSH
10350: LD_INT 1
10352: MINUS
10353: PUSH
10354: FOR_TO
10355: IFFALSE 10539
// for j = 1 to side_count - 1 do
10357: LD_ADDR_VAR 0 8
10361: PUSH
10362: DOUBLE
10363: LD_INT 1
10365: DEC
10366: ST_TO_ADDR
10367: LD_EXP 37
10371: PUSH
10372: LD_INT 1
10374: MINUS
10375: PUSH
10376: FOR_TO
10377: IFFALSE 10535
// if i <> j then
10379: LD_VAR 0 7
10383: PUSH
10384: LD_VAR 0 8
10388: NONEQUAL
10389: IFFALSE 10533
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10391: LD_VAR 0 4
10395: PUSH
10396: LD_VAR 0 7
10400: ARRAY
10401: PUSH
10402: LD_INT 1
10404: ARRAY
10405: PPUSH
10406: LD_VAR 0 4
10410: PUSH
10411: LD_VAR 0 7
10415: ARRAY
10416: PUSH
10417: LD_INT 2
10419: ARRAY
10420: PPUSH
10421: LD_VAR 0 4
10425: PUSH
10426: LD_VAR 0 8
10430: ARRAY
10431: PUSH
10432: LD_INT 1
10434: ARRAY
10435: PPUSH
10436: LD_VAR 0 4
10440: PUSH
10441: LD_VAR 0 8
10445: ARRAY
10446: PUSH
10447: LD_INT 2
10449: ARRAY
10450: PPUSH
10451: CALL_OW 298
10455: PUSH
10456: LD_VAR 0 6
10460: LESS
10461: IFFALSE 10533
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10463: LD_ADDR_VAR 0 6
10467: PUSH
10468: LD_VAR 0 4
10472: PUSH
10473: LD_VAR 0 7
10477: ARRAY
10478: PUSH
10479: LD_INT 1
10481: ARRAY
10482: PPUSH
10483: LD_VAR 0 4
10487: PUSH
10488: LD_VAR 0 7
10492: ARRAY
10493: PUSH
10494: LD_INT 2
10496: ARRAY
10497: PPUSH
10498: LD_VAR 0 4
10502: PUSH
10503: LD_VAR 0 8
10507: ARRAY
10508: PUSH
10509: LD_INT 1
10511: ARRAY
10512: PPUSH
10513: LD_VAR 0 4
10517: PUSH
10518: LD_VAR 0 8
10522: ARRAY
10523: PUSH
10524: LD_INT 2
10526: ARRAY
10527: PPUSH
10528: CALL_OW 298
10532: ST_TO_ADDR
// end ;
10533: GO 10376
10535: POP
10536: POP
10537: GO 10354
10539: POP
10540: POP
// if minv > best then
10541: LD_VAR 0 6
10545: PUSH
10546: LD_VAR 0 3
10550: GREATER
10551: IFFALSE 10573
// begin best := minv ;
10553: LD_ADDR_VAR 0 3
10557: PUSH
10558: LD_VAR 0 6
10562: ST_TO_ADDR
// bestc := c ;
10563: LD_ADDR_VAR 0 5
10567: PUSH
10568: LD_VAR 0 4
10572: ST_TO_ADDR
// end ; end ;
10573: GO 10266
10575: POP
10576: POP
// coordinates := [ ] ;
10577: LD_ADDR_EXP 34
10581: PUSH
10582: EMPTY
10583: ST_TO_ADDR
// for i = 1 to 8 do
10584: LD_ADDR_VAR 0 7
10588: PUSH
10589: DOUBLE
10590: LD_INT 1
10592: DEC
10593: ST_TO_ADDR
10594: LD_INT 8
10596: PUSH
10597: FOR_TO
10598: IFFALSE 10723
// if i = alone then
10600: LD_VAR 0 7
10604: PUSH
10605: LD_VAR 0 1
10609: EQUAL
10610: IFFALSE 10638
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
10612: LD_ADDR_EXP 34
10616: PUSH
10617: LD_EXP 34
10621: PUSH
10622: LD_INT 81
10624: PUSH
10625: LD_INT 57
10627: PUSH
10628: EMPTY
10629: LIST
10630: LIST
10631: PUSH
10632: EMPTY
10633: LIST
10634: ADD
10635: ST_TO_ADDR
10636: GO 10721
// if ( side_positions [ i ] = 0 ) then
10638: LD_EXP 43
10642: PUSH
10643: LD_VAR 0 7
10647: ARRAY
10648: PUSH
10649: LD_INT 0
10651: EQUAL
10652: IFFALSE 10680
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
10654: LD_ADDR_EXP 34
10658: PUSH
10659: LD_EXP 34
10663: PUSH
10664: LD_INT 0
10666: PUSH
10667: LD_INT 0
10669: PUSH
10670: EMPTY
10671: LIST
10672: LIST
10673: PUSH
10674: EMPTY
10675: LIST
10676: ADD
10677: ST_TO_ADDR
10678: GO 10721
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
10680: LD_ADDR_EXP 34
10684: PUSH
10685: LD_EXP 34
10689: PUSH
10690: LD_VAR 0 5
10694: PUSH
10695: LD_INT 1
10697: ARRAY
10698: PUSH
10699: EMPTY
10700: LIST
10701: ADD
10702: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
10703: LD_ADDR_VAR 0 5
10707: PUSH
10708: LD_VAR 0 5
10712: PPUSH
10713: LD_INT 1
10715: PPUSH
10716: CALL_OW 3
10720: ST_TO_ADDR
// end ;
10721: GO 10597
10723: POP
10724: POP
// end ;
10725: LD_VAR 0 2
10729: RET
// function prepare_map_coordinates_one_hunter ( alone ) ; var best , c , bestc , minv , i , j , n ; begin
10730: LD_INT 0
10732: PPUSH
10733: PPUSH
10734: PPUSH
10735: PPUSH
10736: PPUSH
10737: PPUSH
10738: PPUSH
10739: PPUSH
// best = 0 ;
10740: LD_ADDR_VAR 0 3
10744: PUSH
10745: LD_INT 0
10747: ST_TO_ADDR
// for n = 1 to 40 do
10748: LD_ADDR_VAR 0 9
10752: PUSH
10753: DOUBLE
10754: LD_INT 1
10756: DEC
10757: ST_TO_ADDR
10758: LD_INT 40
10760: PUSH
10761: FOR_TO
10762: IFFALSE 11070
// begin c = [ ] ;
10764: LD_ADDR_VAR 0 4
10768: PUSH
10769: EMPTY
10770: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10771: LD_ADDR_VAR 0 7
10775: PUSH
10776: DOUBLE
10777: LD_INT 1
10779: DEC
10780: ST_TO_ADDR
10781: LD_EXP 37
10785: PUSH
10786: LD_INT 1
10788: MINUS
10789: PUSH
10790: FOR_TO
10791: IFFALSE 10820
// c := c ^ [ RandHexArea ( arapestart , false ) ] ;
10793: LD_ADDR_VAR 0 4
10797: PUSH
10798: LD_VAR 0 4
10802: PUSH
10803: LD_INT 24
10805: PPUSH
10806: LD_INT 0
10808: PPUSH
10809: CALL_OW 16
10813: PUSH
10814: EMPTY
10815: LIST
10816: ADD
10817: ST_TO_ADDR
10818: GO 10790
10820: POP
10821: POP
// minv = 10000 ;
10822: LD_ADDR_VAR 0 6
10826: PUSH
10827: LD_INT 10000
10829: ST_TO_ADDR
// for i = 1 to side_count - 1 do
10830: LD_ADDR_VAR 0 7
10834: PUSH
10835: DOUBLE
10836: LD_INT 1
10838: DEC
10839: ST_TO_ADDR
10840: LD_EXP 37
10844: PUSH
10845: LD_INT 1
10847: MINUS
10848: PUSH
10849: FOR_TO
10850: IFFALSE 11034
// for j = 1 to side_count - 1 do
10852: LD_ADDR_VAR 0 8
10856: PUSH
10857: DOUBLE
10858: LD_INT 1
10860: DEC
10861: ST_TO_ADDR
10862: LD_EXP 37
10866: PUSH
10867: LD_INT 1
10869: MINUS
10870: PUSH
10871: FOR_TO
10872: IFFALSE 11030
// if i <> j then
10874: LD_VAR 0 7
10878: PUSH
10879: LD_VAR 0 8
10883: NONEQUAL
10884: IFFALSE 11028
// begin if GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) < minv then
10886: LD_VAR 0 4
10890: PUSH
10891: LD_VAR 0 7
10895: ARRAY
10896: PUSH
10897: LD_INT 1
10899: ARRAY
10900: PPUSH
10901: LD_VAR 0 4
10905: PUSH
10906: LD_VAR 0 7
10910: ARRAY
10911: PUSH
10912: LD_INT 2
10914: ARRAY
10915: PPUSH
10916: LD_VAR 0 4
10920: PUSH
10921: LD_VAR 0 8
10925: ARRAY
10926: PUSH
10927: LD_INT 1
10929: ARRAY
10930: PPUSH
10931: LD_VAR 0 4
10935: PUSH
10936: LD_VAR 0 8
10940: ARRAY
10941: PUSH
10942: LD_INT 2
10944: ARRAY
10945: PPUSH
10946: CALL_OW 298
10950: PUSH
10951: LD_VAR 0 6
10955: LESS
10956: IFFALSE 11028
// minv := GetDistXY ( c [ i ] [ 1 ] , c [ i ] [ 2 ] , c [ j ] [ 1 ] , c [ j ] [ 2 ] ) ;
10958: LD_ADDR_VAR 0 6
10962: PUSH
10963: LD_VAR 0 4
10967: PUSH
10968: LD_VAR 0 7
10972: ARRAY
10973: PUSH
10974: LD_INT 1
10976: ARRAY
10977: PPUSH
10978: LD_VAR 0 4
10982: PUSH
10983: LD_VAR 0 7
10987: ARRAY
10988: PUSH
10989: LD_INT 2
10991: ARRAY
10992: PPUSH
10993: LD_VAR 0 4
10997: PUSH
10998: LD_VAR 0 8
11002: ARRAY
11003: PUSH
11004: LD_INT 1
11006: ARRAY
11007: PPUSH
11008: LD_VAR 0 4
11012: PUSH
11013: LD_VAR 0 8
11017: ARRAY
11018: PUSH
11019: LD_INT 2
11021: ARRAY
11022: PPUSH
11023: CALL_OW 298
11027: ST_TO_ADDR
// end ;
11028: GO 10871
11030: POP
11031: POP
11032: GO 10849
11034: POP
11035: POP
// if minv > best then
11036: LD_VAR 0 6
11040: PUSH
11041: LD_VAR 0 3
11045: GREATER
11046: IFFALSE 11068
// begin best := minv ;
11048: LD_ADDR_VAR 0 3
11052: PUSH
11053: LD_VAR 0 6
11057: ST_TO_ADDR
// bestc := c ;
11058: LD_ADDR_VAR 0 5
11062: PUSH
11063: LD_VAR 0 4
11067: ST_TO_ADDR
// end ; end ;
11068: GO 10761
11070: POP
11071: POP
// coordinates := [ ] ;
11072: LD_ADDR_EXP 34
11076: PUSH
11077: EMPTY
11078: ST_TO_ADDR
// for i = 1 to 8 do
11079: LD_ADDR_VAR 0 7
11083: PUSH
11084: DOUBLE
11085: LD_INT 1
11087: DEC
11088: ST_TO_ADDR
11089: LD_INT 8
11091: PUSH
11092: FOR_TO
11093: IFFALSE 11218
// if i = alone then
11095: LD_VAR 0 7
11099: PUSH
11100: LD_VAR 0 1
11104: EQUAL
11105: IFFALSE 11133
// coordinates := coordinates ^ [ [ 81 , 57 ] ] else
11107: LD_ADDR_EXP 34
11111: PUSH
11112: LD_EXP 34
11116: PUSH
11117: LD_INT 81
11119: PUSH
11120: LD_INT 57
11122: PUSH
11123: EMPTY
11124: LIST
11125: LIST
11126: PUSH
11127: EMPTY
11128: LIST
11129: ADD
11130: ST_TO_ADDR
11131: GO 11216
// if ( side_positions [ i ] = 0 ) then
11133: LD_EXP 43
11137: PUSH
11138: LD_VAR 0 7
11142: ARRAY
11143: PUSH
11144: LD_INT 0
11146: EQUAL
11147: IFFALSE 11175
// coordinates := coordinates ^ [ [ 0 , 0 ] ] else
11149: LD_ADDR_EXP 34
11153: PUSH
11154: LD_EXP 34
11158: PUSH
11159: LD_INT 0
11161: PUSH
11162: LD_INT 0
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: ADD
11172: ST_TO_ADDR
11173: GO 11216
// begin coordinates := coordinates ^ [ bestc [ 1 ] ] ;
11175: LD_ADDR_EXP 34
11179: PUSH
11180: LD_EXP 34
11184: PUSH
11185: LD_VAR 0 5
11189: PUSH
11190: LD_INT 1
11192: ARRAY
11193: PUSH
11194: EMPTY
11195: LIST
11196: ADD
11197: ST_TO_ADDR
// bestc := delete ( bestc , 1 ) ;
11198: LD_ADDR_VAR 0 5
11202: PUSH
11203: LD_VAR 0 5
11207: PPUSH
11208: LD_INT 1
11210: PPUSH
11211: CALL_OW 3
11215: ST_TO_ADDR
// end ;
11216: GO 11092
11218: POP
11219: POP
// end ;
11220: LD_VAR 0 2
11224: RET
// function prepare_game ( alone ) ; var i , t ; begin
11225: LD_INT 0
11227: PPUSH
11228: PPUSH
11229: PPUSH
// ResetFog ;
11230: CALL_OW 335
// AnimateTrees ( true ) ;
11234: LD_INT 1
11236: PPUSH
11237: CALL_OW 573
// for i := 1 to 8 do
11241: LD_ADDR_VAR 0 3
11245: PUSH
11246: DOUBLE
11247: LD_INT 1
11249: DEC
11250: ST_TO_ADDR
11251: LD_INT 8
11253: PUSH
11254: FOR_TO
11255: IFFALSE 11309
// if Side_Positions [ i ] then
11257: LD_EXP 43
11261: PUSH
11262: LD_VAR 0 3
11266: ARRAY
11267: IFFALSE 11307
// if i = alone then
11269: LD_VAR 0 3
11273: PUSH
11274: LD_VAR 0 1
11278: EQUAL
11279: IFFALSE 11295
// ChangeSideFog ( i , 1 ) else
11281: LD_VAR 0 3
11285: PPUSH
11286: LD_INT 1
11288: PPUSH
11289: CALL_OW 343
11293: GO 11307
// ChangeSideFog ( i , 2 ) ;
11295: LD_VAR 0 3
11299: PPUSH
11300: LD_INT 2
11302: PPUSH
11303: CALL_OW 343
11307: GO 11254
11309: POP
11310: POP
// set_attitudes ( alone ) ;
11311: LD_VAR 0 1
11315: PPUSH
11316: CALL 9905 0 1
// set_technologies ( alone ) ;
11320: LD_VAR 0 1
11324: PPUSH
11325: CALL 10021 0 1
// display_score ( alone , 0 0$8 ) ;
11329: LD_VAR 0 1
11333: PPUSH
11334: LD_INT 280
11336: PPUSH
11337: CALL 9799 0 2
// for i := 1 to 8 do
11341: LD_ADDR_VAR 0 3
11345: PUSH
11346: DOUBLE
11347: LD_INT 1
11349: DEC
11350: ST_TO_ADDR
11351: LD_INT 8
11353: PUSH
11354: FOR_TO
11355: IFFALSE 11409
// if Side_Positions [ i ] then
11357: LD_EXP 43
11361: PUSH
11362: LD_VAR 0 3
11366: ARRAY
11367: IFFALSE 11407
// if ( i = alone ) = ( one_hunter ) then
11369: LD_VAR 0 3
11373: PUSH
11374: LD_VAR 0 1
11378: EQUAL
11379: PUSH
11380: LD_EXP 79
11384: EQUAL
11385: IFFALSE 11398
// prepare_hunter_team ( i ) else
11387: LD_VAR 0 3
11391: PPUSH
11392: CALL 9439 0 1
11396: GO 11407
// prepare_ape_team ( i ) ;
11398: LD_VAR 0 3
11402: PPUSH
11403: CALL 9616 0 1
11407: GO 11354
11409: POP
11410: POP
// t := 8 ;
11411: LD_ADDR_VAR 0 4
11415: PUSH
11416: LD_INT 8
11418: ST_TO_ADDR
// repeat t := t - 1 ;
11419: LD_ADDR_VAR 0 4
11423: PUSH
11424: LD_VAR 0 4
11428: PUSH
11429: LD_INT 1
11431: MINUS
11432: ST_TO_ADDR
// display_score ( alone , t * 0 0$1 ) ;
11433: LD_VAR 0 1
11437: PPUSH
11438: LD_VAR 0 4
11442: PUSH
11443: LD_INT 35
11445: MUL
11446: PPUSH
11447: CALL 9799 0 2
// wait ( 0 0$1 ) ;
11451: LD_INT 35
11453: PPUSH
11454: CALL_OW 67
// until t = 0 ;
11458: LD_VAR 0 4
11462: PUSH
11463: LD_INT 0
11465: EQUAL
11466: IFFALSE 11419
// end ;
11468: LD_VAR 0 2
11472: RET
// function run_game ( alone ) ; var i , un , ape , time , alive , dead , aktsc ; begin
11473: LD_INT 0
11475: PPUSH
11476: PPUSH
11477: PPUSH
11478: PPUSH
11479: PPUSH
11480: PPUSH
11481: PPUSH
11482: PPUSH
// if ( your_side = alone ) <> one_hunter then
11483: LD_OWVAR 2
11487: PUSH
11488: LD_VAR 0 1
11492: EQUAL
11493: PUSH
11494: LD_EXP 79
11498: NONEQUAL
11499: IFFALSE 11511
// music_nat := nation_arabian else
11501: LD_ADDR_OWVAR 71
11505: PUSH
11506: LD_INT 2
11508: ST_TO_ADDR
11509: GO 11527
// music_nat := Side_Nations [ your_side ] ;
11511: LD_ADDR_OWVAR 71
11515: PUSH
11516: LD_EXP 44
11520: PUSH
11521: LD_OWVAR 2
11525: ARRAY
11526: ST_TO_ADDR
// if one_hunter then
11527: LD_EXP 79
11531: IFFALSE 11696
// begin prepare_map_coordinates_one_hunter ( alone ) ;
11533: LD_VAR 0 1
11537: PPUSH
11538: CALL 10730 0 1
// for i := 1 to 8 do
11542: LD_ADDR_VAR 0 3
11546: PUSH
11547: DOUBLE
11548: LD_INT 1
11550: DEC
11551: ST_TO_ADDR
11552: LD_INT 8
11554: PUSH
11555: FOR_TO
11556: IFFALSE 11692
// if side_positions [ i ] then
11558: LD_EXP 43
11562: PUSH
11563: LD_VAR 0 3
11567: ARRAY
11568: IFFALSE 11690
// if i = alone then
11570: LD_VAR 0 3
11574: PUSH
11575: LD_VAR 0 1
11579: EQUAL
11580: IFFALSE 11622
// for un in people [ i ] do
11582: LD_ADDR_VAR 0 4
11586: PUSH
11587: LD_EXP 88
11591: PUSH
11592: LD_VAR 0 3
11596: ARRAY
11597: PUSH
11598: FOR_IN
11599: IFFALSE 11618
// PlaceUnitArea ( un , arstartveh , false ) else
11601: LD_VAR 0 4
11605: PPUSH
11606: LD_INT 22
11608: PPUSH
11609: LD_INT 0
11611: PPUSH
11612: CALL_OW 49
11616: GO 11598
11618: POP
11619: POP
11620: GO 11690
// for un in people [ i ] do
11622: LD_ADDR_VAR 0 4
11626: PUSH
11627: LD_EXP 88
11631: PUSH
11632: LD_VAR 0 3
11636: ARRAY
11637: PUSH
11638: FOR_IN
11639: IFFALSE 11688
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 15 , false ) ;
11641: LD_VAR 0 4
11645: PPUSH
11646: LD_EXP 34
11650: PUSH
11651: LD_VAR 0 3
11655: ARRAY
11656: PUSH
11657: LD_INT 1
11659: ARRAY
11660: PPUSH
11661: LD_EXP 34
11665: PUSH
11666: LD_VAR 0 3
11670: ARRAY
11671: PUSH
11672: LD_INT 2
11674: ARRAY
11675: PPUSH
11676: LD_INT 15
11678: PPUSH
11679: LD_INT 0
11681: PPUSH
11682: CALL_OW 50
11686: GO 11638
11688: POP
11689: POP
11690: GO 11555
11692: POP
11693: POP
// end else
11694: GO 11857
// begin prepare_map_coordinates_more_hunters ( alone ) ;
11696: LD_VAR 0 1
11700: PPUSH
11701: CALL 10235 0 1
// for i := 1 to 8 do
11705: LD_ADDR_VAR 0 3
11709: PUSH
11710: DOUBLE
11711: LD_INT 1
11713: DEC
11714: ST_TO_ADDR
11715: LD_INT 8
11717: PUSH
11718: FOR_TO
11719: IFFALSE 11855
// if side_positions [ i ] then
11721: LD_EXP 43
11725: PUSH
11726: LD_VAR 0 3
11730: ARRAY
11731: IFFALSE 11853
// if i = alone then
11733: LD_VAR 0 3
11737: PUSH
11738: LD_VAR 0 1
11742: EQUAL
11743: IFFALSE 11785
// for un in people [ i ] do
11745: LD_ADDR_VAR 0 4
11749: PUSH
11750: LD_EXP 88
11754: PUSH
11755: LD_VAR 0 3
11759: ARRAY
11760: PUSH
11761: FOR_IN
11762: IFFALSE 11781
// PlaceUnitArea ( un , arapes , false ) else
11764: LD_VAR 0 4
11768: PPUSH
11769: LD_INT 23
11771: PPUSH
11772: LD_INT 0
11774: PPUSH
11775: CALL_OW 49
11779: GO 11761
11781: POP
11782: POP
11783: GO 11853
// for un in people [ i ] do
11785: LD_ADDR_VAR 0 4
11789: PUSH
11790: LD_EXP 88
11794: PUSH
11795: LD_VAR 0 3
11799: ARRAY
11800: PUSH
11801: FOR_IN
11802: IFFALSE 11851
// PlaceUnitXYR ( un , coordinates [ i ] [ 1 ] , coordinates [ i ] [ 2 ] , 4 , false ) ;
11804: LD_VAR 0 4
11808: PPUSH
11809: LD_EXP 34
11813: PUSH
11814: LD_VAR 0 3
11818: ARRAY
11819: PUSH
11820: LD_INT 1
11822: ARRAY
11823: PPUSH
11824: LD_EXP 34
11828: PUSH
11829: LD_VAR 0 3
11833: ARRAY
11834: PUSH
11835: LD_INT 2
11837: ARRAY
11838: PPUSH
11839: LD_INT 4
11841: PPUSH
11842: LD_INT 0
11844: PPUSH
11845: CALL_OW 50
11849: GO 11801
11851: POP
11852: POP
11853: GO 11718
11855: POP
11856: POP
// end ; CenterNowOnXY ( coordinates [ your_side ] [ 1 ] , coordinates [ your_side ] [ 2 ] ) ;
11857: LD_EXP 34
11861: PUSH
11862: LD_OWVAR 2
11866: ARRAY
11867: PUSH
11868: LD_INT 1
11870: ARRAY
11871: PPUSH
11872: LD_EXP 34
11876: PUSH
11877: LD_OWVAR 2
11881: ARRAY
11882: PUSH
11883: LD_INT 2
11885: ARRAY
11886: PPUSH
11887: CALL_OW 86
// display_score ( 0 , 0 ) ;
11891: LD_INT 0
11893: PPUSH
11894: LD_INT 0
11896: PPUSH
11897: CALL 9799 0 2
// time := hunt_limit div 0 0$1 ;
11901: LD_ADDR_VAR 0 6
11905: PUSH
11906: LD_EXP 80
11910: PUSH
11911: LD_INT 35
11913: DIV
11914: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11915: LD_INT 35
11917: PPUSH
11918: CALL_OW 67
// ape := FilterAllUnits ( [ f_class , class_apeman ] ) + 0 ;
11922: LD_ADDR_VAR 0 5
11926: PUSH
11927: LD_INT 25
11929: PUSH
11930: LD_INT 12
11932: PUSH
11933: EMPTY
11934: LIST
11935: LIST
11936: PPUSH
11937: CALL_OW 69
11941: PUSH
11942: LD_INT 0
11944: PLUS
11945: ST_TO_ADDR
// time := time - 1 ;
11946: LD_ADDR_VAR 0 6
11950: PUSH
11951: LD_VAR 0 6
11955: PUSH
11956: LD_INT 1
11958: MINUS
11959: ST_TO_ADDR
// display_strings := [ #Hunt-Apes , alone , ape , #Hunt-Limit , alone , time * 0 0$1 ] ;
11960: LD_ADDR_OWVAR 47
11964: PUSH
11965: LD_STRING #Hunt-Apes
11967: PUSH
11968: LD_VAR 0 1
11972: PUSH
11973: LD_VAR 0 5
11977: PUSH
11978: LD_STRING #Hunt-Limit
11980: PUSH
11981: LD_VAR 0 1
11985: PUSH
11986: LD_VAR 0 6
11990: PUSH
11991: LD_INT 35
11993: MUL
11994: PUSH
11995: EMPTY
11996: LIST
11997: LIST
11998: LIST
11999: LIST
12000: LIST
12001: LIST
12002: ST_TO_ADDR
// until ( ape = 0 ) or ( time = 0 ) ;
12003: LD_VAR 0 5
12007: PUSH
12008: LD_INT 0
12010: EQUAL
12011: PUSH
12012: LD_VAR 0 6
12016: PUSH
12017: LD_INT 0
12019: EQUAL
12020: OR
12021: IFFALSE 11915
// alive := FilterAllUnits ( [ f_or , [ f_class , class_soldier ] , [ f_class , class_scientistic ] ] ) + 0 ;
12023: LD_ADDR_VAR 0 7
12027: PUSH
12028: LD_INT 2
12030: PUSH
12031: LD_INT 25
12033: PUSH
12034: LD_INT 1
12036: PUSH
12037: EMPTY
12038: LIST
12039: LIST
12040: PUSH
12041: LD_INT 25
12043: PUSH
12044: LD_INT 4
12046: PUSH
12047: EMPTY
12048: LIST
12049: LIST
12050: PUSH
12051: EMPTY
12052: LIST
12053: LIST
12054: LIST
12055: PPUSH
12056: CALL_OW 69
12060: PUSH
12061: LD_INT 0
12063: PLUS
12064: ST_TO_ADDR
// if one_hunter then
12065: LD_EXP 79
12069: IFFALSE 12220
// begin dead := size_of_hunt_team - alive ;
12071: LD_ADDR_VAR 0 8
12075: PUSH
12076: LD_EXP 82
12080: PUSH
12081: LD_VAR 0 7
12085: MINUS
12086: ST_TO_ADDR
// ape := size_of_ape_team * ( side_count - 1 ) - ape ;
12087: LD_ADDR_VAR 0 5
12091: PUSH
12092: LD_EXP 81
12096: PUSH
12097: LD_EXP 37
12101: PUSH
12102: LD_INT 1
12104: MINUS
12105: MUL
12106: PUSH
12107: LD_VAR 0 5
12111: MINUS
12112: ST_TO_ADDR
// aktsc := time + ape * 30 - dead * 20 ;
12113: LD_ADDR_VAR 0 9
12117: PUSH
12118: LD_VAR 0 6
12122: PUSH
12123: LD_VAR 0 5
12127: PUSH
12128: LD_INT 30
12130: MUL
12131: PLUS
12132: PUSH
12133: LD_VAR 0 8
12137: PUSH
12138: LD_INT 20
12140: MUL
12141: MINUS
12142: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score2 , alone , alone , time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12143: LD_ADDR_EXP 89
12147: PUSH
12148: LD_EXP 89
12152: PUSH
12153: LD_STRING #Hunt-score2
12155: PUSH
12156: LD_VAR 0 1
12160: PUSH
12161: LD_VAR 0 1
12165: PUSH
12166: LD_VAR 0 6
12170: PUSH
12171: LD_INT 35
12173: MUL
12174: PUSH
12175: LD_VAR 0 5
12179: PUSH
12180: LD_VAR 0 8
12184: PUSH
12185: LD_INT 0
12187: PUSH
12188: LD_VAR 0 9
12192: PUSH
12193: EMPTY
12194: LIST
12195: LIST
12196: LIST
12197: LIST
12198: LIST
12199: LIST
12200: LIST
12201: LIST
12202: ADD
12203: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12204: LD_VAR 0 1
12208: PPUSH
12209: LD_VAR 0 9
12213: PPUSH
12214: CALL_OW 506
// end else
12218: GO 12367
// begin dead := size_of_hunt_team * ( side_count - 1 ) - alive ;
12220: LD_ADDR_VAR 0 8
12224: PUSH
12225: LD_EXP 82
12229: PUSH
12230: LD_EXP 37
12234: PUSH
12235: LD_INT 1
12237: MINUS
12238: MUL
12239: PUSH
12240: LD_VAR 0 7
12244: MINUS
12245: ST_TO_ADDR
// aktsc := hunt_limit div 0 0$1 - time + ape * 30 + dead * 20 ;
12246: LD_ADDR_VAR 0 9
12250: PUSH
12251: LD_EXP 80
12255: PUSH
12256: LD_INT 35
12258: DIV
12259: PUSH
12260: LD_VAR 0 6
12264: MINUS
12265: PUSH
12266: LD_VAR 0 5
12270: PUSH
12271: LD_INT 30
12273: MUL
12274: PLUS
12275: PUSH
12276: LD_VAR 0 8
12280: PUSH
12281: LD_INT 20
12283: MUL
12284: PLUS
12285: ST_TO_ADDR
// scorestring := scorestring ^ [ #Hunt-score1 , alone , alone , hunt_limit - time * 0 0$1 , ape , dead , 0 , aktsc ] ;
12286: LD_ADDR_EXP 89
12290: PUSH
12291: LD_EXP 89
12295: PUSH
12296: LD_STRING #Hunt-score1
12298: PUSH
12299: LD_VAR 0 1
12303: PUSH
12304: LD_VAR 0 1
12308: PUSH
12309: LD_EXP 80
12313: PUSH
12314: LD_VAR 0 6
12318: PUSH
12319: LD_INT 35
12321: MUL
12322: MINUS
12323: PUSH
12324: LD_VAR 0 5
12328: PUSH
12329: LD_VAR 0 8
12333: PUSH
12334: LD_INT 0
12336: PUSH
12337: LD_VAR 0 9
12341: PUSH
12342: EMPTY
12343: LIST
12344: LIST
12345: LIST
12346: LIST
12347: LIST
12348: LIST
12349: LIST
12350: LIST
12351: ADD
12352: ST_TO_ADDR
// SetMultiScore ( alone , aktsc ) ;
12353: LD_VAR 0 1
12357: PPUSH
12358: LD_VAR 0 9
12362: PPUSH
12363: CALL_OW 506
// end ; end ;
12367: LD_VAR 0 2
12371: RET
// function close_game ( alone ) ; var un ; begin
12372: LD_INT 0
12374: PPUSH
12375: PPUSH
// for un in all_units do
12376: LD_ADDR_VAR 0 3
12380: PUSH
12381: LD_OWVAR 3
12385: PUSH
12386: FOR_IN
12387: IFFALSE 12400
// DestroyUnit ( un ) ;
12389: LD_VAR 0 3
12393: PPUSH
12394: CALL_OW 65
12398: GO 12386
12400: POP
12401: POP
// ResetFog ;
12402: CALL_OW 335
// end ;
12406: LD_VAR 0 2
12410: RET
// export function starting_hunt ; var alone , win , i ; begin
12411: LD_INT 0
12413: PPUSH
12414: PPUSH
12415: PPUSH
12416: PPUSH
// mp_selectmsg := true ;
12417: LD_ADDR_OWVAR 13
12421: PUSH
12422: LD_INT 1
12424: ST_TO_ADDR
// mp_with_score := true ;
12425: LD_ADDR_OWVAR 14
12429: PUSH
12430: LD_INT 1
12432: ST_TO_ADDR
// read_multiplayer_and_game_parameters ;
12433: CALL 8460 0 0
// your_side := Player_Side ;
12437: LD_ADDR_OWVAR 2
12441: PUSH
12442: LD_EXP 39
12446: ST_TO_ADDR
// while to_be_alone do
12447: LD_EXP 87
12451: IFFALSE 12522
// begin alone := to_be_alone [ Rand ( 1 , to_be_alone ) ] ;
12453: LD_ADDR_VAR 0 2
12457: PUSH
12458: LD_EXP 87
12462: PUSH
12463: LD_INT 1
12465: PPUSH
12466: LD_EXP 87
12470: PPUSH
12471: CALL_OW 12
12475: ARRAY
12476: ST_TO_ADDR
// to_be_alone := to_be_alone diff alone ;
12477: LD_ADDR_EXP 87
12481: PUSH
12482: LD_EXP 87
12486: PUSH
12487: LD_VAR 0 2
12491: DIFF
12492: ST_TO_ADDR
// prepare_game ( alone ) ;
12493: LD_VAR 0 2
12497: PPUSH
12498: CALL 11225 0 1
// run_game ( alone ) ;
12502: LD_VAR 0 2
12506: PPUSH
12507: CALL 11473 0 1
// close_game ( alone ) ;
12511: LD_VAR 0 2
12515: PPUSH
12516: CALL 12372 0 1
// end ;
12520: GO 12447
// display_score ( 0 , 0 ) ;
12522: LD_INT 0
12524: PPUSH
12525: LD_INT 0
12527: PPUSH
12528: CALL 9799 0 2
// wait ( 0 0$5 ) ;
12532: LD_INT 175
12534: PPUSH
12535: CALL_OW 67
// win := true ;
12539: LD_ADDR_VAR 0 3
12543: PUSH
12544: LD_INT 1
12546: ST_TO_ADDR
// for i := 1 to 8 do
12547: LD_ADDR_VAR 0 4
12551: PUSH
12552: DOUBLE
12553: LD_INT 1
12555: DEC
12556: ST_TO_ADDR
12557: LD_INT 8
12559: PUSH
12560: FOR_TO
12561: IFFALSE 12595
// if GetMultiScore ( i ) > GetMultiScore ( your_side ) then
12563: LD_VAR 0 4
12567: PPUSH
12568: CALL_OW 507
12572: PUSH
12573: LD_OWVAR 2
12577: PPUSH
12578: CALL_OW 507
12582: GREATER
12583: IFFALSE 12593
// win := false ;
12585: LD_ADDR_VAR 0 3
12589: PUSH
12590: LD_INT 0
12592: ST_TO_ADDR
12593: GO 12560
12595: POP
12596: POP
// if win then
12597: LD_VAR 0 3
12601: IFFALSE 12609
// YouWinInMultiplayer else
12603: CALL_OW 106
12607: GO 12613
// YouLostInMultiplayer ;
12609: CALL_OW 107
// end ; end_of_file
12613: LD_VAR 0 1
12617: RET
// export to_be_countdowned ; every 0 0$0.2 trigger to_be_countdowned marked 25 do var who , timer ;
12618: LD_EXP 90
12622: IFFALSE 12793
12624: GO 12626
12626: DISABLE
12627: LD_INT 0
12629: PPUSH
12630: PPUSH
// begin enable ;
12631: ENABLE
// who := to_be_countdowned [ 1 ] ;
12632: LD_ADDR_VAR 0 1
12636: PUSH
12637: LD_EXP 90
12641: PUSH
12642: LD_INT 1
12644: ARRAY
12645: ST_TO_ADDR
// to_be_countdowned := Delete ( to_be_countdowned , 1 ) ;
12646: LD_ADDR_EXP 90
12650: PUSH
12651: LD_EXP 90
12655: PPUSH
12656: LD_INT 1
12658: PPUSH
12659: CALL_OW 3
12663: ST_TO_ADDR
// repeat timer := GetTag ( who ) ;
12664: LD_ADDR_VAR 0 2
12668: PUSH
12669: LD_VAR 0 1
12673: PPUSH
12674: CALL_OW 110
12678: ST_TO_ADDR
// if GetSide ( who ) = your_side then
12679: LD_VAR 0 1
12683: PPUSH
12684: CALL_OW 255
12688: PUSH
12689: LD_OWVAR 2
12693: EQUAL
12694: IFFALSE 12710
// SetUnitDisplayNumber ( who , timer ) ;
12696: LD_VAR 0 1
12700: PPUSH
12701: LD_VAR 0 2
12705: PPUSH
12706: CALL_OW 505
// timer := timer - 1 ;
12710: LD_ADDR_VAR 0 2
12714: PUSH
12715: LD_VAR 0 2
12719: PUSH
12720: LD_INT 1
12722: MINUS
12723: ST_TO_ADDR
// SetTag ( who , timer ) ;
12724: LD_VAR 0 1
12728: PPUSH
12729: LD_VAR 0 2
12733: PPUSH
12734: CALL_OW 109
// wait ( 0 0$1 ) ;
12738: LD_INT 35
12740: PPUSH
12741: CALL_OW 67
// until not IsLive ( who ) or not GetTag ( who ) ;
12745: LD_VAR 0 1
12749: PPUSH
12750: CALL_OW 300
12754: NOT
12755: PUSH
12756: LD_VAR 0 1
12760: PPUSH
12761: CALL_OW 110
12765: NOT
12766: OR
12767: IFFALSE 12664
// if not GetTag ( who ) then
12769: LD_VAR 0 1
12773: PPUSH
12774: CALL_OW 110
12778: NOT
12779: IFFALSE 12793
// SetLives ( who , 0 ) ;
12781: LD_VAR 0 1
12785: PPUSH
12786: LD_INT 0
12788: PPUSH
12789: CALL_OW 234
// end ;
12793: PPOPN 2
12795: END
// every 0 0$0.5 + 0 0$0.05 marked 25 do var un , veh ;
12796: GO 12798
12798: DISABLE
12799: LD_INT 0
12801: PPUSH
12802: PPUSH
// begin veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , f_not , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12803: LD_ADDR_VAR 0 2
12807: PUSH
12808: LD_INT 5
12810: PPUSH
12811: LD_INT 21
12813: PUSH
12814: LD_INT 2
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: PUSH
12821: LD_INT 3
12823: PUSH
12824: LD_INT 58
12826: PUSH
12827: EMPTY
12828: LIST
12829: PUSH
12830: LD_INT 3
12832: PUSH
12833: LD_INT 22
12835: PUSH
12836: LD_INT 0
12838: PUSH
12839: EMPTY
12840: LIST
12841: LIST
12842: PUSH
12843: EMPTY
12844: LIST
12845: LIST
12846: LIST
12847: LIST
12848: LIST
12849: PPUSH
12850: CALL_OW 70
12854: ST_TO_ADDR
// for un in veh do
12855: LD_ADDR_VAR 0 1
12859: PUSH
12860: LD_VAR 0 2
12864: PUSH
12865: FOR_IN
12866: IFFALSE 12879
// ComExitVehicle ( veh ) ;
12868: LD_VAR 0 2
12872: PPUSH
12873: CALL_OW 121
12877: GO 12865
12879: POP
12880: POP
// veh := FilterUnitsInArea ( exitarea , [ [ f_type , unit_vehicle ] , [ f_empty ] , f_not , [ f_side , 0 ] ] ) ;
12881: LD_ADDR_VAR 0 2
12885: PUSH
12886: LD_INT 5
12888: PPUSH
12889: LD_INT 21
12891: PUSH
12892: LD_INT 2
12894: PUSH
12895: EMPTY
12896: LIST
12897: LIST
12898: PUSH
12899: LD_INT 58
12901: PUSH
12902: EMPTY
12903: LIST
12904: PUSH
12905: LD_INT 3
12907: PUSH
12908: LD_INT 22
12910: PUSH
12911: LD_INT 0
12913: PUSH
12914: EMPTY
12915: LIST
12916: LIST
12917: PUSH
12918: EMPTY
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: PPUSH
12924: CALL_OW 70
12928: ST_TO_ADDR
// for un in veh do
12929: LD_ADDR_VAR 0 1
12933: PUSH
12934: LD_VAR 0 2
12938: PUSH
12939: FOR_IN
12940: IFFALSE 12995
// begin SetMultiScore ( GetSide ( un ) , GetMultiScore ( GetSide ( un ) ) + 1 ) ;
12942: LD_VAR 0 1
12946: PPUSH
12947: CALL_OW 255
12951: PPUSH
12952: LD_VAR 0 1
12956: PPUSH
12957: CALL_OW 255
12961: PPUSH
12962: CALL_OW 507
12966: PUSH
12967: LD_INT 1
12969: PLUS
12970: PPUSH
12971: CALL_OW 506
// RemoveUnit ( un ) ;
12975: LD_VAR 0 1
12979: PPUSH
12980: CALL_OW 64
// DestroyUnit ( un ) ;
12984: LD_VAR 0 1
12988: PPUSH
12989: CALL_OW 65
// end ;
12993: GO 12939
12995: POP
12996: POP
// enable ;
12997: ENABLE
// end ;
12998: PPOPN 2
13000: END
// every 0 0$1 + 0 0$0.1 marked 25 do var i , best , nbest , lastbest , s , first , n ;
13001: GO 13003
13003: DISABLE
13004: LD_INT 0
13006: PPUSH
13007: PPUSH
13008: PPUSH
13009: PPUSH
13010: PPUSH
13011: PPUSH
13012: PPUSH
// begin lastbest := 99999 ;
13013: LD_ADDR_VAR 0 4
13017: PUSH
13018: LD_INT 99999
13020: ST_TO_ADDR
// s := [ ] ;
13021: LD_ADDR_VAR 0 5
13025: PUSH
13026: EMPTY
13027: ST_TO_ADDR
// n := 1 ;
13028: LD_ADDR_VAR 0 7
13032: PUSH
13033: LD_INT 1
13035: ST_TO_ADDR
// repeat best := - 99999 ;
13036: LD_ADDR_VAR 0 2
13040: PUSH
13041: LD_INT 99999
13043: NEG
13044: ST_TO_ADDR
// nbest := 0 ;
13045: LD_ADDR_VAR 0 3
13049: PUSH
13050: LD_INT 0
13052: ST_TO_ADDR
// for i := 1 to 8 do
13053: LD_ADDR_VAR 0 1
13057: PUSH
13058: DOUBLE
13059: LD_INT 1
13061: DEC
13062: ST_TO_ADDR
13063: LD_INT 8
13065: PUSH
13066: FOR_TO
13067: IFFALSE 13173
// if Side_Positions [ i ] then
13069: LD_EXP 43
13073: PUSH
13074: LD_VAR 0 1
13078: ARRAY
13079: IFFALSE 13171
// begin if ( GetMultiScore ( i ) > best ) and ( GetMultiScore ( i ) < lastbest ) then
13081: LD_VAR 0 1
13085: PPUSH
13086: CALL_OW 507
13090: PUSH
13091: LD_VAR 0 2
13095: GREATER
13096: PUSH
13097: LD_VAR 0 1
13101: PPUSH
13102: CALL_OW 507
13106: PUSH
13107: LD_VAR 0 4
13111: LESS
13112: AND
13113: IFFALSE 13140
// begin best := GetMultiScore ( i ) ;
13115: LD_ADDR_VAR 0 2
13119: PUSH
13120: LD_VAR 0 1
13124: PPUSH
13125: CALL_OW 507
13129: ST_TO_ADDR
// nbest := 1 ;
13130: LD_ADDR_VAR 0 3
13134: PUSH
13135: LD_INT 1
13137: ST_TO_ADDR
// end else
13138: GO 13171
// if GetMultiScore ( i ) = best then
13140: LD_VAR 0 1
13144: PPUSH
13145: CALL_OW 507
13149: PUSH
13150: LD_VAR 0 2
13154: EQUAL
13155: IFFALSE 13171
// begin nbest := nbest + 1 ;
13157: LD_ADDR_VAR 0 3
13161: PUSH
13162: LD_VAR 0 3
13166: PUSH
13167: LD_INT 1
13169: PLUS
13170: ST_TO_ADDR
// end ; end ;
13171: GO 13066
13173: POP
13174: POP
// first := true ;
13175: LD_ADDR_VAR 0 6
13179: PUSH
13180: LD_INT 1
13182: ST_TO_ADDR
// if nbest > 0 then
13183: LD_VAR 0 3
13187: PUSH
13188: LD_INT 0
13190: GREATER
13191: IFFALSE 13364
// for i := 1 to 8 do
13193: LD_ADDR_VAR 0 1
13197: PUSH
13198: DOUBLE
13199: LD_INT 1
13201: DEC
13202: ST_TO_ADDR
13203: LD_INT 8
13205: PUSH
13206: FOR_TO
13207: IFFALSE 13362
// if Side_Positions [ i ] then
13209: LD_EXP 43
13213: PUSH
13214: LD_VAR 0 1
13218: ARRAY
13219: IFFALSE 13360
// if GetMultiScore ( i ) = best then
13221: LD_VAR 0 1
13225: PPUSH
13226: CALL_OW 507
13230: PUSH
13231: LD_VAR 0 2
13235: EQUAL
13236: IFFALSE 13360
// if nbest = 1 then
13238: LD_VAR 0 3
13242: PUSH
13243: LD_INT 1
13245: EQUAL
13246: IFFALSE 13297
// s := s ^ [ #Multi-score , n , i , i , i , best ] else
13248: LD_ADDR_VAR 0 5
13252: PUSH
13253: LD_VAR 0 5
13257: PUSH
13258: LD_STRING #Multi-score
13260: PUSH
13261: LD_VAR 0 7
13265: PUSH
13266: LD_VAR 0 1
13270: PUSH
13271: LD_VAR 0 1
13275: PUSH
13276: LD_VAR 0 1
13280: PUSH
13281: LD_VAR 0 2
13285: PUSH
13286: EMPTY
13287: LIST
13288: LIST
13289: LIST
13290: LIST
13291: LIST
13292: LIST
13293: ADD
13294: ST_TO_ADDR
13295: GO 13360
// s := s ^ [ #Multi-score-range , n , n + nbest - 1 , i , i , i , best ] ;
13297: LD_ADDR_VAR 0 5
13301: PUSH
13302: LD_VAR 0 5
13306: PUSH
13307: LD_STRING #Multi-score-range
13309: PUSH
13310: LD_VAR 0 7
13314: PUSH
13315: LD_VAR 0 7
13319: PUSH
13320: LD_VAR 0 3
13324: PLUS
13325: PUSH
13326: LD_INT 1
13328: MINUS
13329: PUSH
13330: LD_VAR 0 1
13334: PUSH
13335: LD_VAR 0 1
13339: PUSH
13340: LD_VAR 0 1
13344: PUSH
13345: LD_VAR 0 2
13349: PUSH
13350: EMPTY
13351: LIST
13352: LIST
13353: LIST
13354: LIST
13355: LIST
13356: LIST
13357: LIST
13358: ADD
13359: ST_TO_ADDR
13360: GO 13206
13362: POP
13363: POP
// n := n + nbest ;
13364: LD_ADDR_VAR 0 7
13368: PUSH
13369: LD_VAR 0 7
13373: PUSH
13374: LD_VAR 0 3
13378: PLUS
13379: ST_TO_ADDR
// lastbest := best ;
13380: LD_ADDR_VAR 0 4
13384: PUSH
13385: LD_VAR 0 2
13389: ST_TO_ADDR
// until nbest = 0 ;
13390: LD_VAR 0 3
13394: PUSH
13395: LD_INT 0
13397: EQUAL
13398: IFFALSE 13036
// if game_time then
13400: LD_EXP 56
13404: IFFALSE 13439
// s := [ #Hunt-Limit , 0 , game_time - tick ] ^ s ;
13406: LD_ADDR_VAR 0 5
13410: PUSH
13411: LD_STRING #Hunt-Limit
13413: PUSH
13414: LD_INT 0
13416: PUSH
13417: LD_EXP 56
13421: PUSH
13422: LD_OWVAR 1
13426: MINUS
13427: PUSH
13428: EMPTY
13429: LIST
13430: LIST
13431: LIST
13432: PUSH
13433: LD_VAR 0 5
13437: ADD
13438: ST_TO_ADDR
// display_strings := s ;
13439: LD_ADDR_OWVAR 47
13443: PUSH
13444: LD_VAR 0 5
13448: ST_TO_ADDR
// enable ;
13449: ENABLE
// end ;
13450: PPOPN 7
13452: END
// every 0 0$1 marked 25 do var veh ;
13453: GO 13455
13455: DISABLE
13456: LD_INT 0
13458: PPUSH
// begin repeat repeat veh := FilterAllUnits ( [ f_type , unit_vehicle ] ) ;
13459: LD_ADDR_VAR 0 1
13463: PUSH
13464: LD_INT 21
13466: PUSH
13467: LD_INT 2
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PPUSH
13474: CALL_OW 69
13478: ST_TO_ADDR
// wait ( 0 0$3 ) ;
13479: LD_INT 105
13481: PPUSH
13482: CALL_OW 67
// until veh < vehmax ;
13486: LD_VAR 0 1
13490: PUSH
13491: LD_EXP 61
13495: LESS
13496: IFFALSE 13459
// wait ( Rand ( vehresp [ 1 ] div side_count , vehresp [ 2 ] div side_count ) ) ;
13498: LD_EXP 58
13502: PUSH
13503: LD_INT 1
13505: ARRAY
13506: PUSH
13507: LD_EXP 37
13511: DIV
13512: PPUSH
13513: LD_EXP 58
13517: PUSH
13518: LD_INT 2
13520: ARRAY
13521: PUSH
13522: LD_EXP 37
13526: DIV
13527: PPUSH
13528: CALL_OW 12
13532: PPUSH
13533: CALL_OW 67
// vehicles_create_vehicle ( false ) ;
13537: LD_INT 0
13539: PPUSH
13540: CALL 6885 0 1
// until false ;
13544: LD_INT 0
13546: IFFALSE 13459
// end ;
13548: PPOPN 1
13550: END
// every 3 marked 25 do var side , peop ;
13551: GO 13553
13553: DISABLE
13554: LD_INT 0
13556: PPUSH
13557: PPUSH
// begin if not to_resp then
13558: LD_EXP 69
13562: NOT
13563: IFFALSE 13567
// exit ;
13565: GO 13768
// enable ;
13567: ENABLE
// side := to_resp [ 1 ] ;
13568: LD_ADDR_VAR 0 1
13572: PUSH
13573: LD_EXP 69
13577: PUSH
13578: LD_INT 1
13580: ARRAY
13581: ST_TO_ADDR
// to_resp := Delete ( to_resp , 1 ) ;
13582: LD_ADDR_EXP 69
13586: PUSH
13587: LD_EXP 69
13591: PPUSH
13592: LD_INT 1
13594: PPUSH
13595: CALL_OW 3
13599: ST_TO_ADDR
// repeat repeat peop := FilterAllUnits ( [ [ f_type , unit_human ] , [ f_side , side ] , [ f_ok ] ] ) ;
13600: LD_ADDR_VAR 0 2
13604: PUSH
13605: LD_INT 21
13607: PUSH
13608: LD_INT 1
13610: PUSH
13611: EMPTY
13612: LIST
13613: LIST
13614: PUSH
13615: LD_INT 22
13617: PUSH
13618: LD_VAR 0 1
13622: PUSH
13623: EMPTY
13624: LIST
13625: LIST
13626: PUSH
13627: LD_INT 50
13629: PUSH
13630: EMPTY
13631: LIST
13632: PUSH
13633: EMPTY
13634: LIST
13635: LIST
13636: LIST
13637: PPUSH
13638: CALL_OW 69
13642: ST_TO_ADDR
// wait ( 0 0$5 ) ;
13643: LD_INT 175
13645: PPUSH
13646: CALL_OW 67
// until peop < npeop ;
13650: LD_VAR 0 2
13654: PUSH
13655: LD_EXP 65
13659: LESS
13660: IFFALSE 13600
// wait ( Rand ( peopresp [ 1 ] , peopresp [ 2 ] ) ) ;
13662: LD_EXP 66
13666: PUSH
13667: LD_INT 1
13669: ARRAY
13670: PPUSH
13671: LD_EXP 66
13675: PUSH
13676: LD_INT 2
13678: ARRAY
13679: PPUSH
13680: CALL_OW 12
13684: PPUSH
13685: CALL_OW 67
// uc_side := side ;
13689: LD_ADDR_OWVAR 20
13693: PUSH
13694: LD_VAR 0 1
13698: ST_TO_ADDR
// uc_nation := side_nations [ side ] ;
13699: LD_ADDR_OWVAR 21
13703: PUSH
13704: LD_EXP 44
13708: PUSH
13709: LD_VAR 0 1
13713: ARRAY
13714: ST_TO_ADDR
// hc_name :=  ;
13715: LD_ADDR_OWVAR 26
13719: PUSH
13720: LD_STRING 
13722: ST_TO_ADDR
// PrepareMechanic ( 0 , 4 ) ;
13723: LD_INT 0
13725: PPUSH
13726: LD_INT 4
13728: PPUSH
13729: CALL_OW 383
// hc_importance := 0 ;
13733: LD_ADDR_OWVAR 32
13737: PUSH
13738: LD_INT 0
13740: ST_TO_ADDR
// hc_gallery :=  ;
13741: LD_ADDR_OWVAR 33
13745: PUSH
13746: LD_STRING 
13748: ST_TO_ADDR
// PlaceUnitArea ( CreateHuman , arstartveh , true ) ;
13749: CALL_OW 44
13753: PPUSH
13754: LD_INT 22
13756: PPUSH
13757: LD_INT 1
13759: PPUSH
13760: CALL_OW 49
// until false ;
13764: LD_INT 0
13766: IFFALSE 13600
// end ;
13768: PPOPN 2
13770: END
// on siberiterocketexploded ( un , x , y ) do SA_OnSiberiteRocketExploded ( un , x , y , Your_Side ) ; end_of_file
13771: LD_VAR 0 1
13775: PPUSH
13776: LD_VAR 0 2
13780: PPUSH
13781: LD_VAR 0 3
13785: PPUSH
13786: LD_OWVAR 2
13790: PPUSH
13791: CALL 14748 0 4
13795: PPOPN 3
13797: END
// export Side_Comps ; export nonCombat , siberite_rocket ; every 1 do
13798: GO 13800
13800: DISABLE
// begin if GetMultiplayerSetting ( 49 ) or iseditor then
13801: LD_INT 49
13803: PPUSH
13804: CALL_OW 426
13808: PUSH
13809: LD_OWVAR 84
13813: OR
13814: IFFALSE 13823
// fogoff ( true ) ;
13816: LD_INT 1
13818: PPUSH
13819: CALL_OW 344
// disable ( 125 ) ;
13823: LD_INT 125
13825: DISABLE_MARKED
// Start_VehicleAI ;
13826: CALL 13831 0 0
// end ;
13830: END
// function Start_VehicleAI ; var i , k ; begin
13831: LD_INT 0
13833: PPUSH
13834: PPUSH
13835: PPUSH
// if multiplayer then
13836: LD_OWVAR 4
13840: IFFALSE 13854
// Side_Comps = mp_sides_comps else
13842: LD_ADDR_EXP 91
13846: PUSH
13847: CALL 13996 0 0
13851: ST_TO_ADDR
13852: GO 13893
// side_comps = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ;
13854: LD_ADDR_EXP 91
13858: PUSH
13859: LD_INT 1
13861: PUSH
13862: LD_INT 1
13864: PUSH
13865: LD_INT 1
13867: PUSH
13868: LD_INT 1
13870: PUSH
13871: LD_INT 1
13873: PUSH
13874: LD_INT 1
13876: PUSH
13877: LD_INT 1
13879: PUSH
13880: LD_INT 1
13882: PUSH
13883: EMPTY
13884: LIST
13885: LIST
13886: LIST
13887: LIST
13888: LIST
13889: LIST
13890: LIST
13891: LIST
13892: ST_TO_ADDR
// k = false ;
13893: LD_ADDR_VAR 0 3
13897: PUSH
13898: LD_INT 0
13900: ST_TO_ADDR
// for i in side_comps do
13901: LD_ADDR_VAR 0 2
13905: PUSH
13906: LD_EXP 91
13910: PUSH
13911: FOR_IN
13912: IFFALSE 13930
// if i then
13914: LD_VAR 0 2
13918: IFFALSE 13928
// k = true ;
13920: LD_ADDR_VAR 0 3
13924: PUSH
13925: LD_INT 1
13927: ST_TO_ADDR
13928: GO 13911
13930: POP
13931: POP
// nonCombat = [ us_radar , us_bulldozer , us_siberium_rocket_remainder , ar_radar , ar_selfpropelled_bomb , ru_bulldozer , ru_siberium_rocket_remainder ] ;
13932: LD_ADDR_EXP 92
13936: PUSH
13937: LD_INT 11
13939: PUSH
13940: LD_INT 14
13942: PUSH
13943: LD_INT 15
13945: PUSH
13946: LD_INT 30
13948: PUSH
13949: LD_INT 29
13951: PUSH
13952: LD_INT 53
13954: PUSH
13955: LD_INT 55
13957: PUSH
13958: EMPTY
13959: LIST
13960: LIST
13961: LIST
13962: LIST
13963: LIST
13964: LIST
13965: LIST
13966: ST_TO_ADDR
// Siberite_Rocket = [ us_siberium_rocket , ru_siberium_rocket ] ;
13967: LD_ADDR_EXP 93
13971: PUSH
13972: LD_INT 8
13974: PUSH
13975: LD_INT 48
13977: PUSH
13978: EMPTY
13979: LIST
13980: LIST
13981: ST_TO_ADDR
// if k then
13982: LD_VAR 0 3
13986: IFFALSE 13991
// enable ( 125 ) ;
13988: LD_INT 125
13990: ENABLE_MARKED
// end ;
13991: LD_VAR 0 1
13995: RET
// function mp_sides_comps ; var c , i ; begin
13996: LD_INT 0
13998: PPUSH
13999: PPUSH
14000: PPUSH
// c = [ ] ;
14001: LD_ADDR_VAR 0 2
14005: PUSH
14006: EMPTY
14007: ST_TO_ADDR
// for i = 1 to 8 do
14008: LD_ADDR_VAR 0 3
14012: PUSH
14013: DOUBLE
14014: LD_INT 1
14016: DEC
14017: ST_TO_ADDR
14018: LD_INT 8
14020: PUSH
14021: FOR_TO
14022: IFFALSE 14047
// c = c ^ Multiplayer_GetPlayerIsComp ( i ) ;
14024: LD_ADDR_VAR 0 2
14028: PUSH
14029: LD_VAR 0 2
14033: PUSH
14034: LD_VAR 0 3
14038: PPUSH
14039: CALL_OW 532
14043: ADD
14044: ST_TO_ADDR
14045: GO 14021
14047: POP
14048: POP
// result = c ;
14049: LD_ADDR_VAR 0 1
14053: PUSH
14054: LD_VAR 0 2
14058: ST_TO_ADDR
// end ;
14059: LD_VAR 0 1
14063: RET
// every 0 0$1 marked 125 do var units , u , veh , k , c , i , hex ;
14064: GO 14066
14066: DISABLE
14067: LD_INT 0
14069: PPUSH
14070: PPUSH
14071: PPUSH
14072: PPUSH
14073: PPUSH
14074: PPUSH
14075: PPUSH
// begin units = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_human ] ] ) ;
14076: LD_ADDR_VAR 0 1
14080: PUSH
14081: LD_INT 52
14083: PUSH
14084: EMPTY
14085: LIST
14086: PUSH
14087: LD_INT 50
14089: PUSH
14090: EMPTY
14091: LIST
14092: PUSH
14093: LD_INT 21
14095: PUSH
14096: LD_INT 1
14098: PUSH
14099: EMPTY
14100: LIST
14101: LIST
14102: PUSH
14103: EMPTY
14104: LIST
14105: LIST
14106: LIST
14107: PPUSH
14108: CALL_OW 69
14112: ST_TO_ADDR
// k = filterallunits ( [ [ f_placed ] , [ f_ok ] , [ f_type , unit_vehicle ] , [ f_empty ] ] ) ;
14113: LD_ADDR_VAR 0 4
14117: PUSH
14118: LD_INT 52
14120: PUSH
14121: EMPTY
14122: LIST
14123: PUSH
14124: LD_INT 50
14126: PUSH
14127: EMPTY
14128: LIST
14129: PUSH
14130: LD_INT 21
14132: PUSH
14133: LD_INT 2
14135: PUSH
14136: EMPTY
14137: LIST
14138: LIST
14139: PUSH
14140: LD_INT 58
14142: PUSH
14143: EMPTY
14144: LIST
14145: PUSH
14146: EMPTY
14147: LIST
14148: LIST
14149: LIST
14150: LIST
14151: PPUSH
14152: CALL_OW 69
14156: ST_TO_ADDR
// for u in units do
14157: LD_ADDR_VAR 0 2
14161: PUSH
14162: LD_VAR 0 1
14166: PUSH
14167: FOR_IN
14168: IFFALSE 14239
// if getSide ( u ) = 0 then
14170: LD_VAR 0 2
14174: PPUSH
14175: CALL_OW 255
14179: PUSH
14180: LD_INT 0
14182: EQUAL
14183: IFFALSE 14203
// units = units diff u else
14185: LD_ADDR_VAR 0 1
14189: PUSH
14190: LD_VAR 0 1
14194: PUSH
14195: LD_VAR 0 2
14199: DIFF
14200: ST_TO_ADDR
14201: GO 14237
// if not Side_Comps [ getSide ( u ) ] then
14203: LD_EXP 91
14207: PUSH
14208: LD_VAR 0 2
14212: PPUSH
14213: CALL_OW 255
14217: ARRAY
14218: NOT
14219: IFFALSE 14237
// units = units diff u ;
14221: LD_ADDR_VAR 0 1
14225: PUSH
14226: LD_VAR 0 1
14230: PUSH
14231: LD_VAR 0 2
14235: DIFF
14236: ST_TO_ADDR
14237: GO 14167
14239: POP
14240: POP
// for u in units do
14241: LD_ADDR_VAR 0 2
14245: PUSH
14246: LD_VAR 0 1
14250: PUSH
14251: FOR_IN
14252: IFFALSE 14672
// begin if isinunit ( u ) then
14254: LD_VAR 0 2
14258: PPUSH
14259: CALL_OW 310
14263: IFFALSE 14480
// begin veh = isinunit ( u ) ;
14265: LD_ADDR_VAR 0 3
14269: PUSH
14270: LD_VAR 0 2
14274: PPUSH
14275: CALL_OW 310
14279: ST_TO_ADDR
// if not HasTask ( veh ) then
14280: LD_VAR 0 3
14284: PPUSH
14285: CALL_OW 314
14289: NOT
14290: IFFALSE 14478
// begin if getWeapon ( veh ) in nonCombat then
14292: LD_VAR 0 3
14296: PPUSH
14297: CALL_OW 264
14301: PUSH
14302: LD_EXP 92
14306: IN
14307: IFFALSE 14323
// comMoveToArea ( veh , exitarea ) else
14309: LD_VAR 0 3
14313: PPUSH
14314: LD_INT 5
14316: PPUSH
14317: CALL_OW 113
14321: GO 14478
// if getWeapon ( veh ) in Siberite_Rocket then
14323: LD_VAR 0 3
14327: PPUSH
14328: CALL_OW 264
14332: PUSH
14333: LD_EXP 93
14337: IN
14338: IFFALSE 14394
// begin hex = RandHex ( false ) ;
14340: LD_ADDR_VAR 0 7
14344: PUSH
14345: LD_INT 0
14347: PPUSH
14348: CALL_OW 15
14352: ST_TO_ADDR
// ComAttackPlace ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14353: LD_VAR 0 3
14357: PPUSH
14358: LD_VAR 0 7
14362: PUSH
14363: LD_INT 1
14365: ARRAY
14366: PPUSH
14367: LD_VAR 0 7
14371: PUSH
14372: LD_INT 2
14374: ARRAY
14375: PPUSH
14376: CALL_OW 116
// AddComMoveToArea ( veh , exitarea ) ;
14380: LD_VAR 0 3
14384: PPUSH
14385: LD_INT 5
14387: PPUSH
14388: CALL_OW 173
// end else
14392: GO 14478
// if getLives ( veh ) <= hranice_zraneni then
14394: LD_VAR 0 3
14398: PPUSH
14399: CALL_OW 256
14403: PUSH
14404: LD_INT 500
14406: LESSEQUAL
14407: IFFALSE 14423
// comMoveToArea ( veh , exitarea ) else
14409: LD_VAR 0 3
14413: PPUSH
14414: LD_INT 5
14416: PPUSH
14417: CALL_OW 113
14421: GO 14478
// begin hex = RandHexArea ( exitarea , false ) ;
14423: LD_ADDR_VAR 0 7
14427: PUSH
14428: LD_INT 5
14430: PPUSH
14431: LD_INT 0
14433: PPUSH
14434: CALL_OW 16
14438: ST_TO_ADDR
// comAgressiveMove ( veh , hex [ 1 ] , hex [ 2 ] ) ;
14439: LD_VAR 0 3
14443: PPUSH
14444: LD_VAR 0 7
14448: PUSH
14449: LD_INT 1
14451: ARRAY
14452: PPUSH
14453: LD_VAR 0 7
14457: PUSH
14458: LD_INT 2
14460: ARRAY
14461: PPUSH
14462: CALL_OW 114
// AddComMoveToArea ( veh , exitarea ) ;
14466: LD_VAR 0 3
14470: PPUSH
14471: LD_INT 5
14473: PPUSH
14474: CALL_OW 173
// end ; end ; end else
14478: GO 14663
// begin if not HasTask ( u ) then
14480: LD_VAR 0 2
14484: PPUSH
14485: CALL_OW 314
14489: NOT
14490: IFFALSE 14534
// begin hex = RandHex ( false ) ;
14492: LD_ADDR_VAR 0 7
14496: PUSH
14497: LD_INT 0
14499: PPUSH
14500: CALL_OW 15
14504: ST_TO_ADDR
// ComMoveXY ( u , hex [ 1 ] , hex [ 2 ] ) ;
14505: LD_VAR 0 2
14509: PPUSH
14510: LD_VAR 0 7
14514: PUSH
14515: LD_INT 1
14517: ARRAY
14518: PPUSH
14519: LD_VAR 0 7
14523: PUSH
14524: LD_INT 2
14526: ARRAY
14527: PPUSH
14528: CALL_OW 111
// end else
14532: GO 14663
// begin c = [ ] ;
14534: LD_ADDR_VAR 0 5
14538: PUSH
14539: EMPTY
14540: ST_TO_ADDR
// for i in k do
14541: LD_ADDR_VAR 0 6
14545: PUSH
14546: LD_VAR 0 4
14550: PUSH
14551: FOR_IN
14552: IFFALSE 14593
// if See ( getSide ( u ) , i ) then
14554: LD_VAR 0 2
14558: PPUSH
14559: CALL_OW 255
14563: PPUSH
14564: LD_VAR 0 6
14568: PPUSH
14569: CALL_OW 292
14573: IFFALSE 14591
// c = c ^ i ;
14575: LD_ADDR_VAR 0 5
14579: PUSH
14580: LD_VAR 0 5
14584: PUSH
14585: LD_VAR 0 6
14589: ADD
14590: ST_TO_ADDR
14591: GO 14551
14593: POP
14594: POP
// if c + 0 > 0 then
14595: LD_VAR 0 5
14599: PUSH
14600: LD_INT 0
14602: PLUS
14603: PUSH
14604: LD_INT 0
14606: GREATER
14607: IFFALSE 14663
// begin c = NearestUnitToUnit ( c , u ) ;
14609: LD_ADDR_VAR 0 5
14613: PUSH
14614: LD_VAR 0 5
14618: PPUSH
14619: LD_VAR 0 2
14623: PPUSH
14624: CALL_OW 74
14628: ST_TO_ADDR
// if GetDistUnits ( u , c ) < 10 then
14629: LD_VAR 0 2
14633: PPUSH
14634: LD_VAR 0 5
14638: PPUSH
14639: CALL_OW 296
14643: PUSH
14644: LD_INT 10
14646: LESS
14647: IFFALSE 14663
// comEnterUnit ( u , c ) ;
14649: LD_VAR 0 2
14653: PPUSH
14654: LD_VAR 0 5
14658: PPUSH
14659: CALL_OW 120
// end ; end ; end ; wait ( 1 ) ;
14663: LD_INT 1
14665: PPUSH
14666: CALL_OW 67
// end ;
14670: GO 14251
14672: POP
14673: POP
// enable ;
14674: ENABLE
// end ; end_of_file
14675: PPOPN 7
14677: END
// every 10 do
14678: GO 14680
14680: DISABLE
// begin if not multiplayer then
14681: LD_OWVAR 4
14685: NOT
14686: IFFALSE 14690
// exit ;
14688: GO 14747
// if ( tick >= 100 ) then
14690: LD_OWVAR 1
14694: PUSH
14695: LD_INT 100
14697: GREATEREQUAL
14698: IFFALSE 14718
// if tick mod 20 = 0 then
14700: LD_OWVAR 1
14704: PUSH
14705: LD_INT 20
14707: MOD
14708: PUSH
14709: LD_INT 0
14711: EQUAL
14712: IFFALSE 14718
// MultiplayerCRC ;
14714: CALL_OW 361
// if ( tick >= 100 ) then
14718: LD_OWVAR 1
14722: PUSH
14723: LD_INT 100
14725: GREATEREQUAL
14726: IFFALSE 14746
// if tick mod 30 = 0 then
14728: LD_OWVAR 1
14732: PUSH
14733: LD_INT 30
14735: MOD
14736: PUSH
14737: LD_INT 0
14739: EQUAL
14740: IFFALSE 14746
// DebugLogAll ;
14742: CALL_OW 360
// enable ;
14746: ENABLE
// end ; end_of_file
14747: END
// export function SA_OnSiberiteRocketExploded ( siberite_rocket_vehicle , target_x , target_y , requestSide ) ; begin
14748: LD_INT 0
14750: PPUSH
// if GetSide ( siberite_rocket_vehicle ) = requestSide then
14751: LD_VAR 0 1
14755: PPUSH
14756: CALL_OW 255
14760: PUSH
14761: LD_VAR 0 4
14765: EQUAL
14766: IFFALSE 14785
// begin SetAchievement ( ACH_RAD ) ;
14768: LD_STRING ACH_RAD
14770: PPUSH
14771: CALL_OW 543
// SetAchievementEx ( ACH_NL , 1 ) ;
14775: LD_STRING ACH_NL
14777: PPUSH
14778: LD_INT 1
14780: PPUSH
14781: CALL_OW 564
// end end ;
14785: LD_VAR 0 5
14789: RET
// export function SA_Win ( side ) ; begin
14790: LD_INT 0
14792: PPUSH
// case side of 1 :
14793: LD_VAR 0 1
14797: PUSH
14798: LD_INT 1
14800: DOUBLE
14801: EQUAL
14802: IFTRUE 14806
14804: GO 14819
14806: POP
// SetAchievementEx ( ACH_AH , 1 ) ; 2 :
14807: LD_STRING ACH_AH
14809: PPUSH
14810: LD_INT 1
14812: PPUSH
14813: CALL_OW 564
14817: GO 14982
14819: LD_INT 2
14821: DOUBLE
14822: EQUAL
14823: IFTRUE 14827
14825: GO 14840
14827: POP
// SetAchievementEx ( ACH_E , 1 ) ; 3 :
14828: LD_STRING ACH_E
14830: PPUSH
14831: LD_INT 1
14833: PPUSH
14834: CALL_OW 564
14838: GO 14982
14840: LD_INT 3
14842: DOUBLE
14843: EQUAL
14844: IFTRUE 14848
14846: GO 14861
14848: POP
// SetAchievementEx ( ACH_OOL , 1 ) ; [ 1 , 2 ] :
14849: LD_STRING ACH_OOL
14851: PPUSH
14852: LD_INT 1
14854: PPUSH
14855: CALL_OW 564
14859: GO 14982
14861: LD_INT 1
14863: PUSH
14864: LD_INT 2
14866: PUSH
14867: EMPTY
14868: LIST
14869: LIST
14870: DOUBLE
14871: EQUAL
14872: IFTRUE 14876
14874: GO 14901
14876: POP
// begin SetAchievementEx ( ACH_AH , 0.5 ) ;
14877: LD_STRING ACH_AH
14879: PPUSH
14880: LD_REAL  5.00000000000000E-0001
14883: PPUSH
14884: CALL_OW 564
// SetAchievementEx ( ACH_E , 0.5 ) ;
14888: LD_STRING ACH_E
14890: PPUSH
14891: LD_REAL  5.00000000000000E-0001
14894: PPUSH
14895: CALL_OW 564
// end ; [ 2 , 3 ] :
14899: GO 14982
14901: LD_INT 2
14903: PUSH
14904: LD_INT 3
14906: PUSH
14907: EMPTY
14908: LIST
14909: LIST
14910: DOUBLE
14911: EQUAL
14912: IFTRUE 14916
14914: GO 14941
14916: POP
// begin SetAchievementEx ( ACH_OOL , 0.5 ) ;
14917: LD_STRING ACH_OOL
14919: PPUSH
14920: LD_REAL  5.00000000000000E-0001
14923: PPUSH
14924: CALL_OW 564
// SetAchievementEx ( ACH_E , 0.5 ) ;
14928: LD_STRING ACH_E
14930: PPUSH
14931: LD_REAL  5.00000000000000E-0001
14934: PPUSH
14935: CALL_OW 564
// end ; [ 3 , 1 ] :
14939: GO 14982
14941: LD_INT 3
14943: PUSH
14944: LD_INT 1
14946: PUSH
14947: EMPTY
14948: LIST
14949: LIST
14950: DOUBLE
14951: EQUAL
14952: IFTRUE 14956
14954: GO 14981
14956: POP
// begin SetAchievementEx ( ACH_AH , 0.5 ) ;
14957: LD_STRING ACH_AH
14959: PPUSH
14960: LD_REAL  5.00000000000000E-0001
14963: PPUSH
14964: CALL_OW 564
// SetAchievementEx ( ACH_OOL , 0.5 ) ;
14968: LD_STRING ACH_OOL
14970: PPUSH
14971: LD_REAL  5.00000000000000E-0001
14974: PPUSH
14975: CALL_OW 564
// end ; end ;
14979: GO 14982
14981: POP
// end ;
14982: LD_VAR 0 2
14986: RET
